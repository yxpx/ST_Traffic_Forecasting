"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@observablehq";
exports.ids = ["vendor-chunks/@observablehq"];
exports.modules = {

/***/ "(ssr)/./node_modules/@observablehq/plot/src/axes.js":
/*!*****************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/axes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inferFontVariant: () => (/* binding */ inferFontVariant)\n/* harmony export */ });\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n\n\nfunction inferFontVariant(scale) {\n  return (0,_scales_js__WEBPACK_IMPORTED_MODULE_0__.isOrdinalScale)(scale) && scale.interval === undefined ? undefined : \"tabular-nums\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9heGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJDOztBQUVwQztBQUNQLFNBQVMsMERBQWM7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL2F4ZXMuanM/NGY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2lzT3JkaW5hbFNjYWxlfSBmcm9tIFwiLi9zY2FsZXMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluZmVyRm9udFZhcmlhbnQoc2NhbGUpIHtcbiAgcmV0dXJuIGlzT3JkaW5hbFNjYWxlKHNjYWxlKSAmJiBzY2FsZS5pbnRlcnZhbCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogXCJ0YWJ1bGFyLW51bXNcIjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/axes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/channel.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/channel.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   channelDomain: () => (/* binding */ channelDomain),\n/* harmony export */   createChannel: () => (/* binding */ createChannel),\n/* harmony export */   createChannels: () => (/* binding */ createChannels),\n/* harmony export */   getSource: () => (/* binding */ getSource),\n/* harmony export */   inferChannelScale: () => (/* binding */ inferChannelScale),\n/* harmony export */   valueObject: () => (/* binding */ valueObject)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scales/index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _transforms_group_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transforms/group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n\n\n\n\n\n\n\nfunction createChannel(data, {scale, type, value, filter, hint, label = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.labelof)(value)}, name) {\n  if (hint === undefined && typeof value?.transform === \"function\") hint = value.hint;\n  return inferChannelScale(name, {\n    scale,\n    type,\n    value: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, value),\n    label,\n    filter,\n    hint\n  });\n}\n\nfunction createChannels(channels, data) {\n  return Object.fromEntries(\n    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])\n  );\n}\n\n// TODO Use Float64Array for scales with numeric ranges, e.g. position?\nfunction valueObject(channels, scales) {\n  const values = Object.fromEntries(\n    Object.entries(channels).map(([name, {scale: scaleName, value}]) => {\n      const scale = scaleName == null ? null : scales[scaleName];\n      return [name, scale == null ? value : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.map)(value, scale)];\n    })\n  );\n  values.channels = channels; // expose channel state for advanced usage\n  return values;\n}\n\n// If the channel uses the \"auto\" scale (or equivalently true), infer the scale\n// from the channel name and the provided values. For color and symbol channels,\n// no scale is applied if the values are literal; however for symbols, we must\n// promote symbol names (e.g., \"plus\") to symbol implementations (symbolPlus).\n// Note: mutates channel!\nfunction inferChannelScale(name, channel) {\n  const {scale, value} = channel;\n  if (scale === true || scale === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = scale !== true && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isEvery)(value, _options_js__WEBPACK_IMPORTED_MODULE_1__.isColor) ? null : \"color\";\n        channel.defaultScale = \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n      case \"opacity\":\n        channel.scale = scale !== true && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isEvery)(value, _options_js__WEBPACK_IMPORTED_MODULE_1__.isOpacity) ? null : \"opacity\";\n        channel.defaultScale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (scale !== true && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isEvery)(value, _symbol_js__WEBPACK_IMPORTED_MODULE_2__.isSymbol)) {\n          channel.scale = null;\n          channel.value = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.map)(value, _symbol_js__WEBPACK_IMPORTED_MODULE_2__.maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        channel.defaultScale = \"symbol\";\n        break;\n      default:\n        channel.scale = _scales_index_js__WEBPACK_IMPORTED_MODULE_3__.registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale === false) {\n    channel.scale = null;\n  } else if (scale != null && !_scales_index_js__WEBPACK_IMPORTED_MODULE_3__.registry.has(scale)) {\n    throw new Error(`unknown scale: ${scale}`);\n  }\n  return channel;\n}\n\n// Note: mutates channel.domain! This is set to a function so that it is lazily\n// computed; i.e., if the scale’s domain is set explicitly, that takes priority\n// over the sort option, and we don’t need to do additional work.\nfunction channelDomain(data, facets, channels, facetChannels, options) {\n  const {order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit} = options;\n  for (const x in options) {\n    if (!_scales_index_js__WEBPACK_IMPORTED_MODULE_3__.registry.has(x)) continue; // ignore unknown scale keys (including generic options)\n    let {value: y, order = defaultOrder, reverse = defaultReverse, reduce = defaultReduce, limit = defaultLimit} = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeValue)(options[x]); // prettier-ignore\n    const negate = y?.startsWith(\"-\");\n    if (negate) y = y.slice(1);\n    order = order === undefined ? negate !== (y === \"width\" || y === \"height\") ? descendingGroup : ascendingGroup : maybeOrder(order); // prettier-ignore\n    if (reduce == null || reduce === false) continue; // disabled reducer\n    const X = x === \"fx\" || x === \"fy\" ? reindexFacetChannel(facets, facetChannels[x]) : findScaleChannel(channels, x);\n    if (!X) throw new Error(`missing channel for scale: ${x}`);\n    const XV = X.value;\n    const [lo = 0, hi = Infinity] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isIterable)(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y == null) {\n      X.domain = () => {\n        let domain = Array.from(new d3__WEBPACK_IMPORTED_MODULE_0__.InternSet(XV)); // remove any duplicates\n        if (reverse) domain = domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV =\n        y === \"data\"\n          ? data\n          : y === \"height\"\n          ? difference(channels, \"y1\", \"y2\")\n          : y === \"width\"\n          ? difference(channels, \"x1\", \"x2\")\n          : values(channels, y, y === \"y\" ? \"y2\" : y === \"x\" ? \"x2\" : undefined);\n      const reducer = (0,_transforms_group_js__WEBPACK_IMPORTED_MODULE_4__.maybeReduce)(reduce === true ? \"max\" : reduce, YV);\n      X.domain = () => {\n        let domain = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollups)(\n          (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(XV),\n          (I) => reducer.reduceIndex(I, YV),\n          (i) => XV[i]\n        );\n        if (order) domain.sort(order);\n        if (reverse) domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain.map(_options_js__WEBPACK_IMPORTED_MODULE_1__.first);\n      };\n    }\n  }\n}\n\nfunction findScaleChannel(channels, scale) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale) return channel;\n  }\n}\n\n// Facet channels are not affected by transforms; so, to compute the domain of a\n// facet scale, we must first re-index the facet channel according to the\n// transformed mark index. Note: mutates channel, but that should be safe here?\nfunction reindexFacetChannel(facets, channel) {\n  const originalFacets = facets.original;\n  if (originalFacets === facets) return channel; // not transformed\n  const V1 = channel.value;\n  const V2 = (channel.value = []); // mutates channel!\n  for (let i = 0; i < originalFacets.length; ++i) {\n    const vi = V1[originalFacets[i][0]];\n    for (const j of facets[i]) V2[j] = vi;\n  }\n  return channel;\n}\n\nfunction difference(channels, k1, k2) {\n  const X1 = values(channels, k1);\n  const X2 = values(channels, k2);\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.map)(X2, (x2, i) => Math.abs(x2 - X1[i]), Float64Array);\n}\n\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== undefined) channel = channels[alias];\n  if (channel) return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\n\nfunction maybeOrder(order) {\n  if (order == null || typeof order === \"function\") return order;\n  switch (`${order}`.toLowerCase()) {\n    case \"ascending\":\n      return ascendingGroup;\n    case \"descending\":\n      return descendingGroup;\n  }\n  throw new Error(`invalid order: ${order}`);\n}\n\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined)(av, bv) || (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined)(ak, bk);\n}\n\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.descendingDefined)(av, bv) || (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined)(ak, bk);\n}\n\nfunction getSource(channels, key) {\n  let channel = channels[key];\n  if (!channel) return;\n  while (channel.source) channel = channel.source;\n  return channel.source === null ? null : channel;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9jaGFubmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUMyQjtBQUNxRDtBQUMzRTtBQUNPO0FBQ0E7O0FBRTNDLDhCQUE4QiwwQ0FBMEMsb0RBQU8sUUFBUTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBLDRDQUE0QyxnREFBRztBQUMvQyxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDTztBQUNQLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFPLFFBQVEsZ0RBQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBTyxRQUFRLGtEQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvREFBTyxRQUFRLGdEQUFRO0FBQ3JEO0FBQ0EsMEJBQTBCLGdEQUFHLFFBQVEsbURBQVc7QUFDaEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVE7QUFDaEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUksMkJBQTJCLHNEQUFRO0FBQ3ZDLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsU0FBUyxpR0FBaUc7QUFDMUc7QUFDQSxTQUFTLHNEQUFRLG1CQUFtQjtBQUNwQyxTQUFTLHdHQUF3RyxFQUFFLHVEQUFVLGNBQWM7QUFDM0k7QUFDQTtBQUNBLHVJQUF1STtBQUN2SSxzREFBc0Q7QUFDdEQ7QUFDQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBLG9DQUFvQyx1REFBVTtBQUM5QztBQUNBO0FBQ0Esb0NBQW9DLHlDQUFTLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBVztBQUNqQztBQUNBLHFCQUFxQiwyQ0FBTztBQUM1QixVQUFVLGtEQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQUc7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDOztBQUVBO0FBQ0EsU0FBUyw2REFBZ0IsWUFBWSw2REFBZ0I7QUFDckQ7O0FBRUE7QUFDQSxTQUFTLDhEQUFpQixZQUFZLDZEQUFnQjtBQUN0RDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL2NoYW5uZWwuanM/MzVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ludGVyblNldCwgcm9sbHVwc30gZnJvbSBcImQzXCI7XG5pbXBvcnQge2FzY2VuZGluZ0RlZmluZWQsIGRlc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge2ZpcnN0LCBpc0NvbG9yLCBpc0V2ZXJ5LCBpc0l0ZXJhYmxlLCBpc09wYWNpdHksIGxhYmVsb2YsIG1hcCwgbWF5YmVWYWx1ZSwgcmFuZ2UsIHZhbHVlb2Z9IGZyb20gXCIuL29wdGlvbnMuanNcIjtcbmltcG9ydCB7cmVnaXN0cnl9IGZyb20gXCIuL3NjYWxlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtpc1N5bWJvbCwgbWF5YmVTeW1ib2x9IGZyb20gXCIuL3N5bWJvbC5qc1wiO1xuaW1wb3J0IHttYXliZVJlZHVjZX0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9ncm91cC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbChkYXRhLCB7c2NhbGUsIHR5cGUsIHZhbHVlLCBmaWx0ZXIsIGhpbnQsIGxhYmVsID0gbGFiZWxvZih2YWx1ZSl9LCBuYW1lKSB7XG4gIGlmIChoaW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlPy50cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIikgaGludCA9IHZhbHVlLmhpbnQ7XG4gIHJldHVybiBpbmZlckNoYW5uZWxTY2FsZShuYW1lLCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZSxcbiAgICB2YWx1ZTogdmFsdWVvZihkYXRhLCB2YWx1ZSksXG4gICAgbGFiZWwsXG4gICAgZmlsdGVyLFxuICAgIGhpbnRcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGFubmVscyhjaGFubmVscywgZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGNoYW5uZWxzKS5tYXAoKFtuYW1lLCBjaGFubmVsXSkgPT4gW25hbWUsIGNyZWF0ZUNoYW5uZWwoZGF0YSwgY2hhbm5lbCwgbmFtZSldKVxuICApO1xufVxuXG4vLyBUT0RPIFVzZSBGbG9hdDY0QXJyYXkgZm9yIHNjYWxlcyB3aXRoIG51bWVyaWMgcmFuZ2VzLCBlLmcuIHBvc2l0aW9uP1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlT2JqZWN0KGNoYW5uZWxzLCBzY2FsZXMpIHtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGNoYW5uZWxzKS5tYXAoKFtuYW1lLCB7c2NhbGU6IHNjYWxlTmFtZSwgdmFsdWV9XSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZU5hbWUgPT0gbnVsbCA/IG51bGwgOiBzY2FsZXNbc2NhbGVOYW1lXTtcbiAgICAgIHJldHVybiBbbmFtZSwgc2NhbGUgPT0gbnVsbCA/IHZhbHVlIDogbWFwKHZhbHVlLCBzY2FsZSldO1xuICAgIH0pXG4gICk7XG4gIHZhbHVlcy5jaGFubmVscyA9IGNoYW5uZWxzOyAvLyBleHBvc2UgY2hhbm5lbCBzdGF0ZSBmb3IgYWR2YW5jZWQgdXNhZ2VcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gSWYgdGhlIGNoYW5uZWwgdXNlcyB0aGUgXCJhdXRvXCIgc2NhbGUgKG9yIGVxdWl2YWxlbnRseSB0cnVlKSwgaW5mZXIgdGhlIHNjYWxlXG4vLyBmcm9tIHRoZSBjaGFubmVsIG5hbWUgYW5kIHRoZSBwcm92aWRlZCB2YWx1ZXMuIEZvciBjb2xvciBhbmQgc3ltYm9sIGNoYW5uZWxzLFxuLy8gbm8gc2NhbGUgaXMgYXBwbGllZCBpZiB0aGUgdmFsdWVzIGFyZSBsaXRlcmFsOyBob3dldmVyIGZvciBzeW1ib2xzLCB3ZSBtdXN0XG4vLyBwcm9tb3RlIHN5bWJvbCBuYW1lcyAoZS5nLiwgXCJwbHVzXCIpIHRvIHN5bWJvbCBpbXBsZW1lbnRhdGlvbnMgKHN5bWJvbFBsdXMpLlxuLy8gTm90ZTogbXV0YXRlcyBjaGFubmVsIVxuZXhwb3J0IGZ1bmN0aW9uIGluZmVyQ2hhbm5lbFNjYWxlKG5hbWUsIGNoYW5uZWwpIHtcbiAgY29uc3Qge3NjYWxlLCB2YWx1ZX0gPSBjaGFubmVsO1xuICBpZiAoc2NhbGUgPT09IHRydWUgfHwgc2NhbGUgPT09IFwiYXV0b1wiKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgY2FzZSBcInN0cm9rZVwiOlxuICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgIGNoYW5uZWwuc2NhbGUgPSBzY2FsZSAhPT0gdHJ1ZSAmJiBpc0V2ZXJ5KHZhbHVlLCBpc0NvbG9yKSA/IG51bGwgOiBcImNvbG9yXCI7XG4gICAgICAgIGNoYW5uZWwuZGVmYXVsdFNjYWxlID0gXCJjb2xvclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmaWxsT3BhY2l0eVwiOlxuICAgICAgY2FzZSBcInN0cm9rZU9wYWNpdHlcIjpcbiAgICAgIGNhc2UgXCJvcGFjaXR5XCI6XG4gICAgICAgIGNoYW5uZWwuc2NhbGUgPSBzY2FsZSAhPT0gdHJ1ZSAmJiBpc0V2ZXJ5KHZhbHVlLCBpc09wYWNpdHkpID8gbnVsbCA6IFwib3BhY2l0eVwiO1xuICAgICAgICBjaGFubmVsLmRlZmF1bHRTY2FsZSA9IFwib3BhY2l0eVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgaWYgKHNjYWxlICE9PSB0cnVlICYmIGlzRXZlcnkodmFsdWUsIGlzU3ltYm9sKSkge1xuICAgICAgICAgIGNoYW5uZWwuc2NhbGUgPSBudWxsO1xuICAgICAgICAgIGNoYW5uZWwudmFsdWUgPSBtYXAodmFsdWUsIG1heWJlU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFubmVsLnNjYWxlID0gXCJzeW1ib2xcIjtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsLmRlZmF1bHRTY2FsZSA9IFwic3ltYm9sXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hhbm5lbC5zY2FsZSA9IHJlZ2lzdHJ5LmhhcyhuYW1lKSA/IG5hbWUgOiBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NhbGUgPT09IGZhbHNlKSB7XG4gICAgY2hhbm5lbC5zY2FsZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoc2NhbGUgIT0gbnVsbCAmJiAhcmVnaXN0cnkuaGFzKHNjYWxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzY2FsZTogJHtzY2FsZX1gKTtcbiAgfVxuICByZXR1cm4gY2hhbm5lbDtcbn1cblxuLy8gTm90ZTogbXV0YXRlcyBjaGFubmVsLmRvbWFpbiEgVGhpcyBpcyBzZXQgdG8gYSBmdW5jdGlvbiBzbyB0aGF0IGl0IGlzIGxhemlseVxuLy8gY29tcHV0ZWQ7IGkuZS4sIGlmIHRoZSBzY2FsZeKAmXMgZG9tYWluIGlzIHNldCBleHBsaWNpdGx5LCB0aGF0IHRha2VzIHByaW9yaXR5XG4vLyBvdmVyIHRoZSBzb3J0IG9wdGlvbiwgYW5kIHdlIGRvbuKAmXQgbmVlZCB0byBkbyBhZGRpdGlvbmFsIHdvcmsuXG5leHBvcnQgZnVuY3Rpb24gY2hhbm5lbERvbWFpbihkYXRhLCBmYWNldHMsIGNoYW5uZWxzLCBmYWNldENoYW5uZWxzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtvcmRlcjogZGVmYXVsdE9yZGVyLCByZXZlcnNlOiBkZWZhdWx0UmV2ZXJzZSwgcmVkdWNlOiBkZWZhdWx0UmVkdWNlID0gdHJ1ZSwgbGltaXQ6IGRlZmF1bHRMaW1pdH0gPSBvcHRpb25zO1xuICBmb3IgKGNvbnN0IHggaW4gb3B0aW9ucykge1xuICAgIGlmICghcmVnaXN0cnkuaGFzKHgpKSBjb250aW51ZTsgLy8gaWdub3JlIHVua25vd24gc2NhbGUga2V5cyAoaW5jbHVkaW5nIGdlbmVyaWMgb3B0aW9ucylcbiAgICBsZXQge3ZhbHVlOiB5LCBvcmRlciA9IGRlZmF1bHRPcmRlciwgcmV2ZXJzZSA9IGRlZmF1bHRSZXZlcnNlLCByZWR1Y2UgPSBkZWZhdWx0UmVkdWNlLCBsaW1pdCA9IGRlZmF1bHRMaW1pdH0gPSBtYXliZVZhbHVlKG9wdGlvbnNbeF0pOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBuZWdhdGUgPSB5Py5zdGFydHNXaXRoKFwiLVwiKTtcbiAgICBpZiAobmVnYXRlKSB5ID0geS5zbGljZSgxKTtcbiAgICBvcmRlciA9IG9yZGVyID09PSB1bmRlZmluZWQgPyBuZWdhdGUgIT09ICh5ID09PSBcIndpZHRoXCIgfHwgeSA9PT0gXCJoZWlnaHRcIikgPyBkZXNjZW5kaW5nR3JvdXAgOiBhc2NlbmRpbmdHcm91cCA6IG1heWJlT3JkZXIob3JkZXIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBpZiAocmVkdWNlID09IG51bGwgfHwgcmVkdWNlID09PSBmYWxzZSkgY29udGludWU7IC8vIGRpc2FibGVkIHJlZHVjZXJcbiAgICBjb25zdCBYID0geCA9PT0gXCJmeFwiIHx8IHggPT09IFwiZnlcIiA/IHJlaW5kZXhGYWNldENoYW5uZWwoZmFjZXRzLCBmYWNldENoYW5uZWxzW3hdKSA6IGZpbmRTY2FsZUNoYW5uZWwoY2hhbm5lbHMsIHgpO1xuICAgIGlmICghWCkgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGNoYW5uZWwgZm9yIHNjYWxlOiAke3h9YCk7XG4gICAgY29uc3QgWFYgPSBYLnZhbHVlO1xuICAgIGNvbnN0IFtsbyA9IDAsIGhpID0gSW5maW5pdHldID0gaXNJdGVyYWJsZShsaW1pdCkgPyBsaW1pdCA6IGxpbWl0IDwgMCA/IFtsaW1pdF0gOiBbMCwgbGltaXRdO1xuICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgIFguZG9tYWluID0gKCkgPT4ge1xuICAgICAgICBsZXQgZG9tYWluID0gQXJyYXkuZnJvbShuZXcgSW50ZXJuU2V0KFhWKSk7IC8vIHJlbW92ZSBhbnkgZHVwbGljYXRlc1xuICAgICAgICBpZiAocmV2ZXJzZSkgZG9tYWluID0gZG9tYWluLnJldmVyc2UoKTtcbiAgICAgICAgaWYgKGxvICE9PSAwIHx8IGhpICE9PSBJbmZpbml0eSkgZG9tYWluID0gZG9tYWluLnNsaWNlKGxvLCBoaSk7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBZViA9XG4gICAgICAgIHkgPT09IFwiZGF0YVwiXG4gICAgICAgICAgPyBkYXRhXG4gICAgICAgICAgOiB5ID09PSBcImhlaWdodFwiXG4gICAgICAgICAgPyBkaWZmZXJlbmNlKGNoYW5uZWxzLCBcInkxXCIsIFwieTJcIilcbiAgICAgICAgICA6IHkgPT09IFwid2lkdGhcIlxuICAgICAgICAgID8gZGlmZmVyZW5jZShjaGFubmVscywgXCJ4MVwiLCBcIngyXCIpXG4gICAgICAgICAgOiB2YWx1ZXMoY2hhbm5lbHMsIHksIHkgPT09IFwieVwiID8gXCJ5MlwiIDogeSA9PT0gXCJ4XCIgPyBcIngyXCIgOiB1bmRlZmluZWQpO1xuICAgICAgY29uc3QgcmVkdWNlciA9IG1heWJlUmVkdWNlKHJlZHVjZSA9PT0gdHJ1ZSA/IFwibWF4XCIgOiByZWR1Y2UsIFlWKTtcbiAgICAgIFguZG9tYWluID0gKCkgPT4ge1xuICAgICAgICBsZXQgZG9tYWluID0gcm9sbHVwcyhcbiAgICAgICAgICByYW5nZShYViksXG4gICAgICAgICAgKEkpID0+IHJlZHVjZXIucmVkdWNlSW5kZXgoSSwgWVYpLFxuICAgICAgICAgIChpKSA9PiBYVltpXVxuICAgICAgICApO1xuICAgICAgICBpZiAob3JkZXIpIGRvbWFpbi5zb3J0KG9yZGVyKTtcbiAgICAgICAgaWYgKHJldmVyc2UpIGRvbWFpbi5yZXZlcnNlKCk7XG4gICAgICAgIGlmIChsbyAhPT0gMCB8fCBoaSAhPT0gSW5maW5pdHkpIGRvbWFpbiA9IGRvbWFpbi5zbGljZShsbywgaGkpO1xuICAgICAgICByZXR1cm4gZG9tYWluLm1hcChmaXJzdCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU2NhbGVDaGFubmVsKGNoYW5uZWxzLCBzY2FsZSkge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIHtcbiAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbbmFtZV07XG4gICAgaWYgKGNoYW5uZWwuc2NhbGUgPT09IHNjYWxlKSByZXR1cm4gY2hhbm5lbDtcbiAgfVxufVxuXG4vLyBGYWNldCBjaGFubmVscyBhcmUgbm90IGFmZmVjdGVkIGJ5IHRyYW5zZm9ybXM7IHNvLCB0byBjb21wdXRlIHRoZSBkb21haW4gb2YgYVxuLy8gZmFjZXQgc2NhbGUsIHdlIG11c3QgZmlyc3QgcmUtaW5kZXggdGhlIGZhY2V0IGNoYW5uZWwgYWNjb3JkaW5nIHRvIHRoZVxuLy8gdHJhbnNmb3JtZWQgbWFyayBpbmRleC4gTm90ZTogbXV0YXRlcyBjaGFubmVsLCBidXQgdGhhdCBzaG91bGQgYmUgc2FmZSBoZXJlP1xuZnVuY3Rpb24gcmVpbmRleEZhY2V0Q2hhbm5lbChmYWNldHMsIGNoYW5uZWwpIHtcbiAgY29uc3Qgb3JpZ2luYWxGYWNldHMgPSBmYWNldHMub3JpZ2luYWw7XG4gIGlmIChvcmlnaW5hbEZhY2V0cyA9PT0gZmFjZXRzKSByZXR1cm4gY2hhbm5lbDsgLy8gbm90IHRyYW5zZm9ybWVkXG4gIGNvbnN0IFYxID0gY2hhbm5lbC52YWx1ZTtcbiAgY29uc3QgVjIgPSAoY2hhbm5lbC52YWx1ZSA9IFtdKTsgLy8gbXV0YXRlcyBjaGFubmVsIVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsRmFjZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdmkgPSBWMVtvcmlnaW5hbEZhY2V0c1tpXVswXV07XG4gICAgZm9yIChjb25zdCBqIG9mIGZhY2V0c1tpXSkgVjJbal0gPSB2aTtcbiAgfVxuICByZXR1cm4gY2hhbm5lbDtcbn1cblxuZnVuY3Rpb24gZGlmZmVyZW5jZShjaGFubmVscywgazEsIGsyKSB7XG4gIGNvbnN0IFgxID0gdmFsdWVzKGNoYW5uZWxzLCBrMSk7XG4gIGNvbnN0IFgyID0gdmFsdWVzKGNoYW5uZWxzLCBrMik7XG4gIHJldHVybiBtYXAoWDIsICh4MiwgaSkgPT4gTWF0aC5hYnMoeDIgLSBYMVtpXSksIEZsb2F0NjRBcnJheSk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlcyhjaGFubmVscywgbmFtZSwgYWxpYXMpIHtcbiAgbGV0IGNoYW5uZWwgPSBjaGFubmVsc1tuYW1lXTtcbiAgaWYgKCFjaGFubmVsICYmIGFsaWFzICE9PSB1bmRlZmluZWQpIGNoYW5uZWwgPSBjaGFubmVsc1thbGlhc107XG4gIGlmIChjaGFubmVsKSByZXR1cm4gY2hhbm5lbC52YWx1ZTtcbiAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGNoYW5uZWw6ICR7bmFtZX1gKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVPcmRlcihvcmRlcikge1xuICBpZiAob3JkZXIgPT0gbnVsbCB8fCB0eXBlb2Ygb3JkZXIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9yZGVyO1xuICBzd2l0Y2ggKGAke29yZGVyfWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJhc2NlbmRpbmdcIjpcbiAgICAgIHJldHVybiBhc2NlbmRpbmdHcm91cDtcbiAgICBjYXNlIFwiZGVzY2VuZGluZ1wiOlxuICAgICAgcmV0dXJuIGRlc2NlbmRpbmdHcm91cDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3JkZXI6ICR7b3JkZXJ9YCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0dyb3VwKFthaywgYXZdLCBbYmssIGJ2XSkge1xuICByZXR1cm4gYXNjZW5kaW5nRGVmaW5lZChhdiwgYnYpIHx8IGFzY2VuZGluZ0RlZmluZWQoYWssIGJrKTtcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZ0dyb3VwKFthaywgYXZdLCBbYmssIGJ2XSkge1xuICByZXR1cm4gZGVzY2VuZGluZ0RlZmluZWQoYXYsIGJ2KSB8fCBhc2NlbmRpbmdEZWZpbmVkKGFrLCBiayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2UoY2hhbm5lbHMsIGtleSkge1xuICBsZXQgY2hhbm5lbCA9IGNoYW5uZWxzW2tleV07XG4gIGlmICghY2hhbm5lbCkgcmV0dXJuO1xuICB3aGlsZSAoY2hhbm5lbC5zb3VyY2UpIGNoYW5uZWwgPSBjaGFubmVsLnNvdXJjZTtcbiAgcmV0dXJuIGNoYW5uZWwuc291cmNlID09PSBudWxsID8gbnVsbCA6IGNoYW5uZWw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/context.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/context.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createContext: () => (/* binding */ createContext)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n\n\n\nfunction createContext(options = {}) {\n  const {document = typeof window !== \"undefined\" ? window.document : undefined, clip} = options;\n  return {document, clip: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeClip)(clip)};\n}\n\nfunction create(name, {document}) {\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)((0,d3__WEBPACK_IMPORTED_MODULE_0__.creator)(name).call(document.documentElement));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUM7QUFDSTs7QUFFaEMsbUNBQW1DO0FBQzFDLFNBQVMsOEVBQThFO0FBQ3ZGLFVBQVUsZ0JBQWdCLHNEQUFTO0FBQ25DOztBQUVPLHVCQUF1QixTQUFTO0FBQ3ZDLFNBQVMsMENBQU0sQ0FBQywyQ0FBTztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvY29udGV4dC5qcz9hNDQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRvciwgc2VsZWN0fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7bWF5YmVDbGlwfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7ZG9jdW1lbnQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmRvY3VtZW50IDogdW5kZWZpbmVkLCBjbGlwfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7ZG9jdW1lbnQsIGNsaXA6IG1heWJlQ2xpcChjbGlwKX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUobmFtZSwge2RvY3VtZW50fSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/curve.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/curve.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curveAuto: () => (/* binding */ curveAuto),\n/* harmony export */   maybeCurve: () => (/* binding */ maybeCurve),\n/* harmony export */   maybeCurveAuto: () => (/* binding */ maybeCurveAuto)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n\n\nconst curves = new Map([\n  [\"basis\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBasis],\n  [\"basis-closed\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBasisClosed],\n  [\"basis-open\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBasisOpen],\n  [\"bundle\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBundle],\n  [\"bump-x\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBumpX],\n  [\"bump-y\", d3__WEBPACK_IMPORTED_MODULE_0__.curveBumpY],\n  [\"cardinal\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCardinal],\n  [\"cardinal-closed\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCardinalClosed],\n  [\"cardinal-open\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCardinalOpen],\n  [\"catmull-rom\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCatmullRom],\n  [\"catmull-rom-closed\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCatmullRomClosed],\n  [\"catmull-rom-open\", d3__WEBPACK_IMPORTED_MODULE_0__.curveCatmullRomOpen],\n  [\"linear\", d3__WEBPACK_IMPORTED_MODULE_0__.curveLinear],\n  [\"linear-closed\", d3__WEBPACK_IMPORTED_MODULE_0__.curveLinearClosed],\n  [\"monotone-x\", d3__WEBPACK_IMPORTED_MODULE_0__.curveMonotoneX],\n  [\"monotone-y\", d3__WEBPACK_IMPORTED_MODULE_0__.curveMonotoneY],\n  [\"natural\", d3__WEBPACK_IMPORTED_MODULE_0__.curveNatural],\n  [\"step\", d3__WEBPACK_IMPORTED_MODULE_0__.curveStep],\n  [\"step-after\", d3__WEBPACK_IMPORTED_MODULE_0__.curveStepAfter],\n  [\"step-before\", d3__WEBPACK_IMPORTED_MODULE_0__.curveStepBefore]\n]);\n\nfunction maybeCurve(curve = d3__WEBPACK_IMPORTED_MODULE_0__.curveLinear, tension) {\n  if (typeof curve === \"function\") return curve; // custom curve\n  const c = curves.get(`${curve}`.toLowerCase());\n  if (!c) throw new Error(`unknown curve: ${curve}`);\n  if (tension !== undefined) {\n    if (\"beta\" in c) {\n      return c.beta(tension);\n    } else if (\"tension\" in c) {\n      return c.tension(tension);\n    } else if (\"alpha\" in c) {\n      return c.alpha(tension);\n    }\n  }\n  return c;\n}\n\n// For the “auto” curve, return a symbol instead of a curve implementation;\n// we’ll use d3.geoPath to render if there’s a projection.\nfunction maybeCurveAuto(curve = curveAuto, tension) {\n  return typeof curve !== \"function\" && `${curve}`.toLowerCase() === \"auto\" ? curveAuto : maybeCurve(curve, tension);\n}\n\n// This is a special built-in curve that will use d3.geoPath when there is a\n// projection, and the linear curve when there is not. You can explicitly\n// opt-out of d3.geoPath and instead use d3.line with the \"linear\" curve.\nfunction curveAuto(context) {\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.curveLinear)(context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBcUJZOztBQUVaO0FBQ0EsWUFBWSwwQ0FBVTtBQUN0QixtQkFBbUIsZ0RBQWdCO0FBQ25DLGlCQUFpQiw4Q0FBYztBQUMvQixhQUFhLDJDQUFXO0FBQ3hCLGFBQWEsMENBQVU7QUFDdkIsYUFBYSwwQ0FBVTtBQUN2QixlQUFlLDZDQUFhO0FBQzVCLHNCQUFzQixtREFBbUI7QUFDekMsb0JBQW9CLGlEQUFpQjtBQUNyQyxrQkFBa0IsK0NBQWU7QUFDakMseUJBQXlCLHFEQUFxQjtBQUM5Qyx1QkFBdUIsbURBQW1CO0FBQzFDLGFBQWEsMkNBQVc7QUFDeEIsb0JBQW9CLGlEQUFpQjtBQUNyQyxpQkFBaUIsOENBQWM7QUFDL0IsaUJBQWlCLDhDQUFjO0FBQy9CLGNBQWMsNENBQVk7QUFDMUIsV0FBVyx5Q0FBUztBQUNwQixpQkFBaUIsOENBQWM7QUFDL0Isa0JBQWtCLCtDQUFlO0FBQ2pDOztBQUVPLDRCQUE0QiwyQ0FBVztBQUM5QyxpREFBaUQ7QUFDakQsMEJBQTBCLE1BQU07QUFDaEMsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1AsMkNBQTJDLE1BQU07QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLCtDQUFXO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9jdXJ2ZS5qcz9kZjdjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGN1cnZlQmFzaXMsXG4gIGN1cnZlQmFzaXNDbG9zZWQsXG4gIGN1cnZlQmFzaXNPcGVuLFxuICBjdXJ2ZUJ1bmRsZSxcbiAgY3VydmVCdW1wWCxcbiAgY3VydmVCdW1wWSxcbiAgY3VydmVDYXJkaW5hbCxcbiAgY3VydmVDYXJkaW5hbENsb3NlZCxcbiAgY3VydmVDYXJkaW5hbE9wZW4sXG4gIGN1cnZlQ2F0bXVsbFJvbSxcbiAgY3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxuICBjdXJ2ZUNhdG11bGxSb21PcGVuLFxuICBjdXJ2ZUxpbmVhcixcbiAgY3VydmVMaW5lYXJDbG9zZWQsXG4gIGN1cnZlTW9ub3RvbmVYLFxuICBjdXJ2ZU1vbm90b25lWSxcbiAgY3VydmVOYXR1cmFsLFxuICBjdXJ2ZVN0ZXAsXG4gIGN1cnZlU3RlcEFmdGVyLFxuICBjdXJ2ZVN0ZXBCZWZvcmVcbn0gZnJvbSBcImQzXCI7XG5cbmNvbnN0IGN1cnZlcyA9IG5ldyBNYXAoW1xuICBbXCJiYXNpc1wiLCBjdXJ2ZUJhc2lzXSxcbiAgW1wiYmFzaXMtY2xvc2VkXCIsIGN1cnZlQmFzaXNDbG9zZWRdLFxuICBbXCJiYXNpcy1vcGVuXCIsIGN1cnZlQmFzaXNPcGVuXSxcbiAgW1wiYnVuZGxlXCIsIGN1cnZlQnVuZGxlXSxcbiAgW1wiYnVtcC14XCIsIGN1cnZlQnVtcFhdLFxuICBbXCJidW1wLXlcIiwgY3VydmVCdW1wWV0sXG4gIFtcImNhcmRpbmFsXCIsIGN1cnZlQ2FyZGluYWxdLFxuICBbXCJjYXJkaW5hbC1jbG9zZWRcIiwgY3VydmVDYXJkaW5hbENsb3NlZF0sXG4gIFtcImNhcmRpbmFsLW9wZW5cIiwgY3VydmVDYXJkaW5hbE9wZW5dLFxuICBbXCJjYXRtdWxsLXJvbVwiLCBjdXJ2ZUNhdG11bGxSb21dLFxuICBbXCJjYXRtdWxsLXJvbS1jbG9zZWRcIiwgY3VydmVDYXRtdWxsUm9tQ2xvc2VkXSxcbiAgW1wiY2F0bXVsbC1yb20tb3BlblwiLCBjdXJ2ZUNhdG11bGxSb21PcGVuXSxcbiAgW1wibGluZWFyXCIsIGN1cnZlTGluZWFyXSxcbiAgW1wibGluZWFyLWNsb3NlZFwiLCBjdXJ2ZUxpbmVhckNsb3NlZF0sXG4gIFtcIm1vbm90b25lLXhcIiwgY3VydmVNb25vdG9uZVhdLFxuICBbXCJtb25vdG9uZS15XCIsIGN1cnZlTW9ub3RvbmVZXSxcbiAgW1wibmF0dXJhbFwiLCBjdXJ2ZU5hdHVyYWxdLFxuICBbXCJzdGVwXCIsIGN1cnZlU3RlcF0sXG4gIFtcInN0ZXAtYWZ0ZXJcIiwgY3VydmVTdGVwQWZ0ZXJdLFxuICBbXCJzdGVwLWJlZm9yZVwiLCBjdXJ2ZVN0ZXBCZWZvcmVdXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQ3VydmUoY3VydmUgPSBjdXJ2ZUxpbmVhciwgdGVuc2lvbikge1xuICBpZiAodHlwZW9mIGN1cnZlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjdXJ2ZTsgLy8gY3VzdG9tIGN1cnZlXG4gIGNvbnN0IGMgPSBjdXJ2ZXMuZ2V0KGAke2N1cnZlfWAudG9Mb3dlckNhc2UoKSk7XG4gIGlmICghYykgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGN1cnZlOiAke2N1cnZlfWApO1xuICBpZiAodGVuc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKFwiYmV0YVwiIGluIGMpIHtcbiAgICAgIHJldHVybiBjLmJldGEodGVuc2lvbik7XG4gICAgfSBlbHNlIGlmIChcInRlbnNpb25cIiBpbiBjKSB7XG4gICAgICByZXR1cm4gYy50ZW5zaW9uKHRlbnNpb24pO1xuICAgIH0gZWxzZSBpZiAoXCJhbHBoYVwiIGluIGMpIHtcbiAgICAgIHJldHVybiBjLmFscGhhKHRlbnNpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn1cblxuLy8gRm9yIHRoZSDigJxhdXRv4oCdIGN1cnZlLCByZXR1cm4gYSBzeW1ib2wgaW5zdGVhZCBvZiBhIGN1cnZlIGltcGxlbWVudGF0aW9uO1xuLy8gd2XigJlsbCB1c2UgZDMuZ2VvUGF0aCB0byByZW5kZXIgaWYgdGhlcmXigJlzIGEgcHJvamVjdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUN1cnZlQXV0byhjdXJ2ZSA9IGN1cnZlQXV0bywgdGVuc2lvbikge1xuICByZXR1cm4gdHlwZW9mIGN1cnZlICE9PSBcImZ1bmN0aW9uXCIgJiYgYCR7Y3VydmV9YC50b0xvd2VyQ2FzZSgpID09PSBcImF1dG9cIiA/IGN1cnZlQXV0byA6IG1heWJlQ3VydmUoY3VydmUsIHRlbnNpb24pO1xufVxuXG4vLyBUaGlzIGlzIGEgc3BlY2lhbCBidWlsdC1pbiBjdXJ2ZSB0aGF0IHdpbGwgdXNlIGQzLmdlb1BhdGggd2hlbiB0aGVyZSBpcyBhXG4vLyBwcm9qZWN0aW9uLCBhbmQgdGhlIGxpbmVhciBjdXJ2ZSB3aGVuIHRoZXJlIGlzIG5vdC4gWW91IGNhbiBleHBsaWNpdGx5XG4vLyBvcHQtb3V0IG9mIGQzLmdlb1BhdGggYW5kIGluc3RlYWQgdXNlIGQzLmxpbmUgd2l0aCB0aGUgXCJsaW5lYXJcIiBjdXJ2ZS5cbmV4cG9ydCBmdW5jdGlvbiBjdXJ2ZUF1dG8oY29udGV4dCkge1xuICByZXR1cm4gY3VydmVMaW5lYXIoY29udGV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/defined.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/defined.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),\n/* harmony export */   defined: () => (/* binding */ defined),\n/* harmony export */   descendingDefined: () => (/* binding */ descendingDefined),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   negative: () => (/* binding */ negative),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   positive: () => (/* binding */ positive)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n\n\nfunction defined(x) {\n  return x != null && !Number.isNaN(x);\n}\n\nfunction ascendingDefined(a, b) {\n  return +defined(b) - +defined(a) || (0,d3__WEBPACK_IMPORTED_MODULE_0__.ascending)(a, b);\n}\n\nfunction descendingDefined(a, b) {\n  return +defined(b) - +defined(a) || (0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(a, b);\n}\n\nfunction nonempty(x) {\n  return x != null && `${x}` !== \"\";\n}\n\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n\nfunction positive(x) {\n  return x > 0 && isFinite(x) ? x : NaN;\n}\n\nfunction negative(x) {\n  return x < 0 && isFinite(x) ? x : NaN;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9kZWZpbmVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlDOztBQUVsQztBQUNQO0FBQ0E7O0FBRU87QUFDUCxzQ0FBc0MsNkNBQVM7QUFDL0M7O0FBRU87QUFDUCxzQ0FBc0MsOENBQVU7QUFDaEQ7O0FBRU87QUFDUCx5QkFBeUIsRUFBRTtBQUMzQjs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvZGVmaW5lZC5qcz85MTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXNjZW5kaW5nLCBkZXNjZW5kaW5nfSBmcm9tIFwiZDNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZWQoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmICFOdW1iZXIuaXNOYU4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRpbmdEZWZpbmVkKGEsIGIpIHtcbiAgcmV0dXJuICtkZWZpbmVkKGIpIC0gK2RlZmluZWQoYSkgfHwgYXNjZW5kaW5nKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzY2VuZGluZ0RlZmluZWQoYSwgYikge1xuICByZXR1cm4gK2RlZmluZWQoYikgLSArZGVmaW5lZChhKSB8fCBkZXNjZW5kaW5nKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9uZW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIGAke3h9YCAhPT0gXCJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbml0ZSh4KSB7XG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/IHggOiBOYU47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NpdGl2ZSh4KSB7XG4gIHJldHVybiB4ID4gMCAmJiBpc0Zpbml0ZSh4KSA/IHggOiBOYU47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGl2ZSh4KSB7XG4gIHJldHVybiB4IDwgMCAmJiBpc0Zpbml0ZSh4KSA/IHggOiBOYU47XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/defined.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/dimensions.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/dimensions.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDimensions: () => (/* binding */ createDimensions)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\n\n\n\nfunction createDimensions(scales, marks, options = {}) {\n  // Compute the default margins: the maximum of the marks’ margins. While not\n  // always used, they may be needed to compute the default height of the plot.\n  let marginTopDefault = 0.5 - _style_js__WEBPACK_IMPORTED_MODULE_1__.offset,\n    marginRightDefault = 0.5 + _style_js__WEBPACK_IMPORTED_MODULE_1__.offset,\n    marginBottomDefault = 0.5 + _style_js__WEBPACK_IMPORTED_MODULE_1__.offset,\n    marginLeftDefault = 0.5 - _style_js__WEBPACK_IMPORTED_MODULE_1__.offset;\n\n  for (const {marginTop, marginRight, marginBottom, marginLeft} of marks) {\n    if (marginTop > marginTopDefault) marginTopDefault = marginTop;\n    if (marginRight > marginRightDefault) marginRightDefault = marginRight;\n    if (marginBottom > marginBottomDefault) marginBottomDefault = marginBottom;\n    if (marginLeft > marginLeftDefault) marginLeftDefault = marginLeft;\n  }\n\n  // Compute the actual margins. The order of precedence is: the side-specific\n  // margin options, then the global margin option, then the defaults.\n  let {\n    margin,\n    marginTop = margin !== undefined ? margin : marginTopDefault,\n    marginRight = margin !== undefined ? margin : marginRightDefault,\n    marginBottom = margin !== undefined ? margin : marginBottomDefault,\n    marginLeft = margin !== undefined ? margin : marginLeftDefault\n  } = options;\n\n  // Coerce the margin options to numbers.\n  marginTop = +marginTop;\n  marginRight = +marginRight;\n  marginBottom = +marginBottom;\n  marginLeft = +marginLeft;\n\n  // Compute the outer dimensions of the plot. If the top and bottom margins are\n  // specified explicitly, adjust the automatic height accordingly.\n  let {\n    width = 640,\n    height = autoHeight(scales, options, {\n      width,\n      marginTopDefault,\n      marginRightDefault,\n      marginBottomDefault,\n      marginLeftDefault\n    }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)\n  } = options;\n\n  // Coerce the width and height.\n  width = +width;\n  height = +height;\n\n  const dimensions = {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n\n  // Compute the facet margins.\n  if (scales.fx || scales.fy) {\n    let {\n      margin: facetMargin,\n      marginTop: facetMarginTop = facetMargin !== undefined ? facetMargin : marginTop,\n      marginRight: facetMarginRight = facetMargin !== undefined ? facetMargin : marginRight,\n      marginBottom: facetMarginBottom = facetMargin !== undefined ? facetMargin : marginBottom,\n      marginLeft: facetMarginLeft = facetMargin !== undefined ? facetMargin : marginLeft\n    } = options.facet ?? {};\n\n    // Coerce the facet margin options to numbers.\n    facetMarginTop = +facetMarginTop;\n    facetMarginRight = +facetMarginRight;\n    facetMarginBottom = +facetMarginBottom;\n    facetMarginLeft = +facetMarginLeft;\n\n    dimensions.facet = {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    };\n  }\n\n  return dimensions;\n}\n\nfunction autoHeight(\n  {x, y, fy, fx},\n  {projection, aspectRatio},\n  {width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault}\n) {\n  const nfy = fy ? fy.scale.domain().length || 1 : 1;\n\n  // If a projection is specified, compute an aspect ratio based on the domain,\n  // defaulting to the projection’s natural aspect ratio (if known).\n  const ar = (0,_projection_js__WEBPACK_IMPORTED_MODULE_2__.projectionAspectRatio)(projection);\n  if (ar) {\n    const nfx = fx ? fx.scale.domain().length : 1;\n    const far = ((1.1 * nfy - 0.1) / (1.1 * nfx - 0.1)) * ar; // 0.1 is default facet padding\n    const lar = Math.max(0.1, Math.min(10, far)); // clamp the aspect ratio to a “reasonable” value\n    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);\n  }\n  const ny = y ? ((0,_scales_js__WEBPACK_IMPORTED_MODULE_3__.isOrdinalScale)(y) ? y.scale.domain().length || 1 : Math.max(7, 17 / nfy)) : 1;\n\n  // If a desired aspect ratio is given, compute a default height to match.\n  if (aspectRatio != null) {\n    aspectRatio = +aspectRatio;\n    if (!(isFinite(aspectRatio) && aspectRatio > 0)) throw new Error(`invalid aspectRatio: ${aspectRatio}`);\n    const ratio = aspectRatioLength(\"y\", y) / (aspectRatioLength(\"x\", x) * aspectRatio);\n    const fxb = fx ? fx.scale.bandwidth() : 1;\n    const fyb = fy ? fy.scale.bandwidth() : 1;\n    const w = fxb * (width - marginLeftDefault - marginRightDefault) - x.insetLeft - x.insetRight;\n    return (ratio * w + y.insetTop + y.insetBottom) / fyb + marginTopDefault + marginBottomDefault;\n  }\n\n  return !!(y || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;\n}\n\nfunction aspectRatioLength(k, scale) {\n  if (!scale) throw new Error(`aspectRatio requires ${k} scale`);\n  const {type, domain} = scale;\n  let transform;\n  switch (type) {\n    case \"linear\":\n    case \"utc\":\n    case \"time\":\n      transform = Number;\n      break;\n    case \"pow\": {\n      const exponent = scale.scale.exponent();\n      transform = (x) => Math.pow(x, exponent);\n      break;\n    }\n    case \"log\":\n      transform = Math.log;\n      break;\n    case \"point\":\n    case \"band\":\n      return domain.length;\n    default:\n      throw new Error(`unsupported ${k} scale for aspectRatio: ${type}`);\n  }\n  const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain);\n  return Math.abs(transform(max) - transform(min));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9kaW1lbnNpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBCO0FBQzRCO0FBQ1g7QUFDVDs7QUFFM0IscURBQXFEO0FBQzVEO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQU07QUFDckMsK0JBQStCLDZDQUFNO0FBQ3JDLGdDQUFnQyw2Q0FBTTtBQUN0Qyw4QkFBOEIsNkNBQU07O0FBRXBDLGNBQWMsa0RBQWtEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUcsYUFBYTtBQUNoQixHQUFHLHdCQUF3QjtBQUMzQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxxRUFBcUI7QUFDbEM7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGtCQUFrQiwwREFBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLFlBQVk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsR0FBRztBQUN6RCxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRyx5QkFBeUIsS0FBSztBQUN0RTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9kaW1lbnNpb25zLmpzPzRiN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtleHRlbnR9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtwcm9qZWN0aW9uQXNwZWN0UmF0aW99IGZyb20gXCIuL3Byb2plY3Rpb24uanNcIjtcbmltcG9ydCB7aXNPcmRpbmFsU2NhbGV9IGZyb20gXCIuL3NjYWxlcy5qc1wiO1xuaW1wb3J0IHtvZmZzZXR9IGZyb20gXCIuL3N0eWxlLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaW1lbnNpb25zKHNjYWxlcywgbWFya3MsIG9wdGlvbnMgPSB7fSkge1xuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IG1hcmdpbnM6IHRoZSBtYXhpbXVtIG9mIHRoZSBtYXJrc+KAmSBtYXJnaW5zLiBXaGlsZSBub3RcbiAgLy8gYWx3YXlzIHVzZWQsIHRoZXkgbWF5IGJlIG5lZWRlZCB0byBjb21wdXRlIHRoZSBkZWZhdWx0IGhlaWdodCBvZiB0aGUgcGxvdC5cbiAgbGV0IG1hcmdpblRvcERlZmF1bHQgPSAwLjUgLSBvZmZzZXQsXG4gICAgbWFyZ2luUmlnaHREZWZhdWx0ID0gMC41ICsgb2Zmc2V0LFxuICAgIG1hcmdpbkJvdHRvbURlZmF1bHQgPSAwLjUgKyBvZmZzZXQsXG4gICAgbWFyZ2luTGVmdERlZmF1bHQgPSAwLjUgLSBvZmZzZXQ7XG5cbiAgZm9yIChjb25zdCB7bWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0fSBvZiBtYXJrcykge1xuICAgIGlmIChtYXJnaW5Ub3AgPiBtYXJnaW5Ub3BEZWZhdWx0KSBtYXJnaW5Ub3BEZWZhdWx0ID0gbWFyZ2luVG9wO1xuICAgIGlmIChtYXJnaW5SaWdodCA+IG1hcmdpblJpZ2h0RGVmYXVsdCkgbWFyZ2luUmlnaHREZWZhdWx0ID0gbWFyZ2luUmlnaHQ7XG4gICAgaWYgKG1hcmdpbkJvdHRvbSA+IG1hcmdpbkJvdHRvbURlZmF1bHQpIG1hcmdpbkJvdHRvbURlZmF1bHQgPSBtYXJnaW5Cb3R0b207XG4gICAgaWYgKG1hcmdpbkxlZnQgPiBtYXJnaW5MZWZ0RGVmYXVsdCkgbWFyZ2luTGVmdERlZmF1bHQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgYWN0dWFsIG1hcmdpbnMuIFRoZSBvcmRlciBvZiBwcmVjZWRlbmNlIGlzOiB0aGUgc2lkZS1zcGVjaWZpY1xuICAvLyBtYXJnaW4gb3B0aW9ucywgdGhlbiB0aGUgZ2xvYmFsIG1hcmdpbiBvcHRpb24sIHRoZW4gdGhlIGRlZmF1bHRzLlxuICBsZXQge1xuICAgIG1hcmdpbixcbiAgICBtYXJnaW5Ub3AgPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IG1hcmdpblRvcERlZmF1bHQsXG4gICAgbWFyZ2luUmlnaHQgPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IG1hcmdpblJpZ2h0RGVmYXVsdCxcbiAgICBtYXJnaW5Cb3R0b20gPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IG1hcmdpbkJvdHRvbURlZmF1bHQsXG4gICAgbWFyZ2luTGVmdCA9IG1hcmdpbiAhPT0gdW5kZWZpbmVkID8gbWFyZ2luIDogbWFyZ2luTGVmdERlZmF1bHRcbiAgfSA9IG9wdGlvbnM7XG5cbiAgLy8gQ29lcmNlIHRoZSBtYXJnaW4gb3B0aW9ucyB0byBudW1iZXJzLlxuICBtYXJnaW5Ub3AgPSArbWFyZ2luVG9wO1xuICBtYXJnaW5SaWdodCA9ICttYXJnaW5SaWdodDtcbiAgbWFyZ2luQm90dG9tID0gK21hcmdpbkJvdHRvbTtcbiAgbWFyZ2luTGVmdCA9ICttYXJnaW5MZWZ0O1xuXG4gIC8vIENvbXB1dGUgdGhlIG91dGVyIGRpbWVuc2lvbnMgb2YgdGhlIHBsb3QuIElmIHRoZSB0b3AgYW5kIGJvdHRvbSBtYXJnaW5zIGFyZVxuICAvLyBzcGVjaWZpZWQgZXhwbGljaXRseSwgYWRqdXN0IHRoZSBhdXRvbWF0aWMgaGVpZ2h0IGFjY29yZGluZ2x5LlxuICBsZXQge1xuICAgIHdpZHRoID0gNjQwLFxuICAgIGhlaWdodCA9IGF1dG9IZWlnaHQoc2NhbGVzLCBvcHRpb25zLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIG1hcmdpblRvcERlZmF1bHQsXG4gICAgICBtYXJnaW5SaWdodERlZmF1bHQsXG4gICAgICBtYXJnaW5Cb3R0b21EZWZhdWx0LFxuICAgICAgbWFyZ2luTGVmdERlZmF1bHRcbiAgICB9KSArIE1hdGgubWF4KDAsIG1hcmdpblRvcCAtIG1hcmdpblRvcERlZmF1bHQgKyBtYXJnaW5Cb3R0b20gLSBtYXJnaW5Cb3R0b21EZWZhdWx0KVxuICB9ID0gb3B0aW9ucztcblxuICAvLyBDb2VyY2UgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gIHdpZHRoID0gK3dpZHRoO1xuICBoZWlnaHQgPSAraGVpZ2h0O1xuXG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1hcmdpblRvcCxcbiAgICBtYXJnaW5SaWdodCxcbiAgICBtYXJnaW5Cb3R0b20sXG4gICAgbWFyZ2luTGVmdFxuICB9O1xuXG4gIC8vIENvbXB1dGUgdGhlIGZhY2V0IG1hcmdpbnMuXG4gIGlmIChzY2FsZXMuZnggfHwgc2NhbGVzLmZ5KSB7XG4gICAgbGV0IHtcbiAgICAgIG1hcmdpbjogZmFjZXRNYXJnaW4sXG4gICAgICBtYXJnaW5Ub3A6IGZhY2V0TWFyZ2luVG9wID0gZmFjZXRNYXJnaW4gIT09IHVuZGVmaW5lZCA/IGZhY2V0TWFyZ2luIDogbWFyZ2luVG9wLFxuICAgICAgbWFyZ2luUmlnaHQ6IGZhY2V0TWFyZ2luUmlnaHQgPSBmYWNldE1hcmdpbiAhPT0gdW5kZWZpbmVkID8gZmFjZXRNYXJnaW4gOiBtYXJnaW5SaWdodCxcbiAgICAgIG1hcmdpbkJvdHRvbTogZmFjZXRNYXJnaW5Cb3R0b20gPSBmYWNldE1hcmdpbiAhPT0gdW5kZWZpbmVkID8gZmFjZXRNYXJnaW4gOiBtYXJnaW5Cb3R0b20sXG4gICAgICBtYXJnaW5MZWZ0OiBmYWNldE1hcmdpbkxlZnQgPSBmYWNldE1hcmdpbiAhPT0gdW5kZWZpbmVkID8gZmFjZXRNYXJnaW4gOiBtYXJnaW5MZWZ0XG4gICAgfSA9IG9wdGlvbnMuZmFjZXQgPz8ge307XG5cbiAgICAvLyBDb2VyY2UgdGhlIGZhY2V0IG1hcmdpbiBvcHRpb25zIHRvIG51bWJlcnMuXG4gICAgZmFjZXRNYXJnaW5Ub3AgPSArZmFjZXRNYXJnaW5Ub3A7XG4gICAgZmFjZXRNYXJnaW5SaWdodCA9ICtmYWNldE1hcmdpblJpZ2h0O1xuICAgIGZhY2V0TWFyZ2luQm90dG9tID0gK2ZhY2V0TWFyZ2luQm90dG9tO1xuICAgIGZhY2V0TWFyZ2luTGVmdCA9ICtmYWNldE1hcmdpbkxlZnQ7XG5cbiAgICBkaW1lbnNpb25zLmZhY2V0ID0ge1xuICAgICAgbWFyZ2luVG9wOiBmYWNldE1hcmdpblRvcCxcbiAgICAgIG1hcmdpblJpZ2h0OiBmYWNldE1hcmdpblJpZ2h0LFxuICAgICAgbWFyZ2luQm90dG9tOiBmYWNldE1hcmdpbkJvdHRvbSxcbiAgICAgIG1hcmdpbkxlZnQ6IGZhY2V0TWFyZ2luTGVmdFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGltZW5zaW9ucztcbn1cblxuZnVuY3Rpb24gYXV0b0hlaWdodChcbiAge3gsIHksIGZ5LCBmeH0sXG4gIHtwcm9qZWN0aW9uLCBhc3BlY3RSYXRpb30sXG4gIHt3aWR0aCwgbWFyZ2luVG9wRGVmYXVsdCwgbWFyZ2luUmlnaHREZWZhdWx0LCBtYXJnaW5Cb3R0b21EZWZhdWx0LCBtYXJnaW5MZWZ0RGVmYXVsdH1cbikge1xuICBjb25zdCBuZnkgPSBmeSA/IGZ5LnNjYWxlLmRvbWFpbigpLmxlbmd0aCB8fCAxIDogMTtcblxuICAvLyBJZiBhIHByb2plY3Rpb24gaXMgc3BlY2lmaWVkLCBjb21wdXRlIGFuIGFzcGVjdCByYXRpbyBiYXNlZCBvbiB0aGUgZG9tYWluLFxuICAvLyBkZWZhdWx0aW5nIHRvIHRoZSBwcm9qZWN0aW9u4oCZcyBuYXR1cmFsIGFzcGVjdCByYXRpbyAoaWYga25vd24pLlxuICBjb25zdCBhciA9IHByb2plY3Rpb25Bc3BlY3RSYXRpbyhwcm9qZWN0aW9uKTtcbiAgaWYgKGFyKSB7XG4gICAgY29uc3QgbmZ4ID0gZnggPyBmeC5zY2FsZS5kb21haW4oKS5sZW5ndGggOiAxO1xuICAgIGNvbnN0IGZhciA9ICgoMS4xICogbmZ5IC0gMC4xKSAvICgxLjEgKiBuZnggLSAwLjEpKSAqIGFyOyAvLyAwLjEgaXMgZGVmYXVsdCBmYWNldCBwYWRkaW5nXG4gICAgY29uc3QgbGFyID0gTWF0aC5tYXgoMC4xLCBNYXRoLm1pbigxMCwgZmFyKSk7IC8vIGNsYW1wIHRoZSBhc3BlY3QgcmF0aW8gdG8gYSDigJxyZWFzb25hYmxl4oCdIHZhbHVlXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHdpZHRoIC0gbWFyZ2luTGVmdERlZmF1bHQgLSBtYXJnaW5SaWdodERlZmF1bHQpICogbGFyICsgbWFyZ2luVG9wRGVmYXVsdCArIG1hcmdpbkJvdHRvbURlZmF1bHQpO1xuICB9XG4gIGNvbnN0IG55ID0geSA/IChpc09yZGluYWxTY2FsZSh5KSA/IHkuc2NhbGUuZG9tYWluKCkubGVuZ3RoIHx8IDEgOiBNYXRoLm1heCg3LCAxNyAvIG5meSkpIDogMTtcblxuICAvLyBJZiBhIGRlc2lyZWQgYXNwZWN0IHJhdGlvIGlzIGdpdmVuLCBjb21wdXRlIGEgZGVmYXVsdCBoZWlnaHQgdG8gbWF0Y2guXG4gIGlmIChhc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgYXNwZWN0UmF0aW8gPSArYXNwZWN0UmF0aW87XG4gICAgaWYgKCEoaXNGaW5pdGUoYXNwZWN0UmF0aW8pICYmIGFzcGVjdFJhdGlvID4gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhc3BlY3RSYXRpbzogJHthc3BlY3RSYXRpb31gKTtcbiAgICBjb25zdCByYXRpbyA9IGFzcGVjdFJhdGlvTGVuZ3RoKFwieVwiLCB5KSAvIChhc3BlY3RSYXRpb0xlbmd0aChcInhcIiwgeCkgKiBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgZnhiID0gZnggPyBmeC5zY2FsZS5iYW5kd2lkdGgoKSA6IDE7XG4gICAgY29uc3QgZnliID0gZnkgPyBmeS5zY2FsZS5iYW5kd2lkdGgoKSA6IDE7XG4gICAgY29uc3QgdyA9IGZ4YiAqICh3aWR0aCAtIG1hcmdpbkxlZnREZWZhdWx0IC0gbWFyZ2luUmlnaHREZWZhdWx0KSAtIHguaW5zZXRMZWZ0IC0geC5pbnNldFJpZ2h0O1xuICAgIHJldHVybiAocmF0aW8gKiB3ICsgeS5pbnNldFRvcCArIHkuaW5zZXRCb3R0b20pIC8gZnliICsgbWFyZ2luVG9wRGVmYXVsdCArIG1hcmdpbkJvdHRvbURlZmF1bHQ7XG4gIH1cblxuICByZXR1cm4gISEoeSB8fCBmeSkgKiBNYXRoLm1heCgxLCBNYXRoLm1pbig2MCwgbnkgKiBuZnkpKSAqIDIwICsgISFmeCAqIDMwICsgNjA7XG59XG5cbmZ1bmN0aW9uIGFzcGVjdFJhdGlvTGVuZ3RoKGssIHNjYWxlKSB7XG4gIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcihgYXNwZWN0UmF0aW8gcmVxdWlyZXMgJHtrfSBzY2FsZWApO1xuICBjb25zdCB7dHlwZSwgZG9tYWlufSA9IHNjYWxlO1xuICBsZXQgdHJhbnNmb3JtO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgY2FzZSBcInV0Y1wiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICB0cmFuc2Zvcm0gPSBOdW1iZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG93XCI6IHtcbiAgICAgIGNvbnN0IGV4cG9uZW50ID0gc2NhbGUuc2NhbGUuZXhwb25lbnQoKTtcbiAgICAgIHRyYW5zZm9ybSA9ICh4KSA9PiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgICAgdHJhbnNmb3JtID0gTWF0aC5sb2c7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG9pbnRcIjpcbiAgICBjYXNlIFwiYmFuZFwiOlxuICAgICAgcmV0dXJuIGRvbWFpbi5sZW5ndGg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgJHtrfSBzY2FsZSBmb3IgYXNwZWN0UmF0aW86ICR7dHlwZX1gKTtcbiAgfVxuICBjb25zdCBbbWluLCBtYXhdID0gZXh0ZW50KGRvbWFpbik7XG4gIHJldHVybiBNYXRoLmFicyh0cmFuc2Zvcm0obWF4KSAtIHRyYW5zZm9ybShtaW4pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/dimensions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/facet.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/facet.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFacets: () => (/* binding */ createFacets),\n/* harmony export */   facetExclude: () => (/* binding */ facetExclude),\n/* harmony export */   facetFilter: () => (/* binding */ facetFilter),\n/* harmony export */   facetGroups: () => (/* binding */ facetGroups),\n/* harmony export */   facetTranslator: () => (/* binding */ facetTranslator),\n/* harmony export */   maybeFacetAnchor: () => (/* binding */ maybeFacetAnchor),\n/* harmony export */   recreateFacets: () => (/* binding */ recreateFacets)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n\n\n\n\n// Returns an array of {x?, y?, i} objects representing the facet domain.\nfunction createFacets(channelsByScale, options) {\n  const {fx, fy} = (0,_scales_js__WEBPACK_IMPORTED_MODULE_1__.createScales)(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain\n    ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.cross)(fxDomain, fyDomain).map(([x, y], i) => ({x, y, i}))\n    : fxDomain\n    ? fxDomain.map((x, i) => ({x, i}))\n    : fyDomain\n    ? fyDomain.map((y, i) => ({y, i}))\n    : undefined;\n}\n\nfunction recreateFacets(facets, {x: X, y: Y}) {\n  X &&= facetIndex(X);\n  Y &&= facetIndex(Y);\n  return facets\n    .filter(\n      X && Y // remove any facets no longer present in the domain\n        ? (f) => X.has(f.x) && Y.has(f.y)\n        : X\n        ? (f) => X.has(f.x)\n        : (f) => Y.has(f.y)\n    )\n    .sort(\n      X && Y // reorder facets to match the new scale domains\n        ? (a, b) => X.get(a.x) - X.get(b.x) || Y.get(a.y) - Y.get(b.y)\n        : X\n        ? (a, b) => X.get(a.x) - X.get(b.x)\n        : (a, b) => Y.get(a.y) - Y.get(b.y)\n    );\n}\n\n// Returns a (possibly nested) Map of [[key1, index1], [key2, index2], …]\n// representing the data indexes associated with each facet.\nfunction facetGroups(data, {fx, fy}) {\n  const I = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.range)(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy\n    ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollup)(\n        I,\n        (G) => ((G.fx = FX[G[0]]), (G.fy = FY[G[0]]), G),\n        (i) => FX[i],\n        (i) => FY[i]\n      )\n    : fx\n    ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollup)(\n        I,\n        (G) => ((G.fx = FX[G[0]]), G),\n        (i) => FX[i]\n      )\n    : (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollup)(\n        I,\n        (G) => ((G.fy = FY[G[0]]), G),\n        (i) => FY[i]\n      );\n}\n\nfunction facetTranslator(fx, fy, {marginTop, marginLeft}) {\n  const x = fx ? ({x}) => fx(x) - marginLeft : () => 0;\n  const y = fy ? ({y}) => fy(y) - marginTop : () => 0;\n  return function (d) {\n    if (this.tagName === \"svg\") {\n      this.setAttribute(\"x\", x(d));\n      this.setAttribute(\"y\", y(d));\n    } else {\n      this.setAttribute(\"transform\", `translate(${x(d)},${y(d)})`);\n    }\n  };\n}\n\n// Returns an index that for each facet lists all the elements present in other\n// facets in the original index. TODO Memoize to avoid repeated work?\nfunction facetExclude(index) {\n  const ex = [];\n  const e = new Uint32Array((0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(index, (d) => d.length));\n  for (const i of index) {\n    let n = 0;\n    for (const j of index) {\n      if (i === j) continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\n\nconst facetAnchors = new Map([\n  [\"top\", facetAnchorTop],\n  [\"right\", facetAnchorRight],\n  [\"bottom\", facetAnchorBottom],\n  [\"left\", facetAnchorLeft],\n  [\"top-left\", and(facetAnchorTop, facetAnchorLeft)],\n  [\"top-right\", and(facetAnchorTop, facetAnchorRight)],\n  [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)],\n  [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)],\n  [\"top-empty\", facetAnchorTopEmpty],\n  [\"right-empty\", facetAnchorRightEmpty],\n  [\"bottom-empty\", facetAnchorBottomEmpty],\n  [\"left-empty\", facetAnchorLeftEmpty],\n  [\"empty\", facetAnchorEmpty]\n]);\n\nfunction maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null) return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor) return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\n\nconst indexCache = new WeakMap();\n\nfunction facetIndex(V) {\n  let I = indexCache.get(V);\n  if (!I) indexCache.set(V, (I = new d3__WEBPACK_IMPORTED_MODULE_0__.InternMap((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.map)(V, (v, i) => [v, i]))));\n  return I;\n}\n\n// Like V.indexOf(v), but with the same semantics as InternMap.\nfunction facetIndexOf(V, v) {\n  return facetIndex(V).get(v);\n}\n\n// Like facets.find, but with the same semantics as InternMap.\nfunction facetFind(facets, x, y) {\n  x = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(x);\n  y = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(y);\n  return facets.find((f) => Object.is((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(f.x), x) && Object.is((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(f.y), y));\n}\n\nfunction facetEmpty(facets, x, y) {\n  return facetFind(facets, x, y)?.empty;\n}\n\nfunction facetAnchorTop(facets, {y: Y}, {y}) {\n  return Y ? facetIndexOf(Y, y) === 0 : true;\n}\n\nfunction facetAnchorBottom(facets, {y: Y}, {y}) {\n  return Y ? facetIndexOf(Y, y) === Y.length - 1 : true;\n}\n\nfunction facetAnchorLeft(facets, {x: X}, {x}) {\n  return X ? facetIndexOf(X, x) === 0 : true;\n}\n\nfunction facetAnchorRight(facets, {x: X}, {x}) {\n  return X ? facetIndexOf(X, x) === X.length - 1 : true;\n}\n\nfunction facetAnchorTopEmpty(facets, {y: Y}, {x, y, empty}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i > 0) return facetEmpty(facets, x, Y[i - 1]);\n}\n\nfunction facetAnchorBottomEmpty(facets, {y: Y}, {x, y, empty}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i < Y.length - 1) return facetEmpty(facets, x, Y[i + 1]);\n}\n\nfunction facetAnchorLeftEmpty(facets, {x: X}, {x, y, empty}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i > 0) return facetEmpty(facets, X[i - 1], y);\n}\n\nfunction facetAnchorRightEmpty(facets, {x: X}, {x, y, empty}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i < X.length - 1) return facetEmpty(facets, X[i + 1], y);\n}\n\nfunction facetAnchorEmpty(facets, channels, {empty}) {\n  return empty;\n}\n\nfunction and(a, b) {\n  return function () {\n    return a.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\n\n// Facet filter, by mark; for now only the \"eq\" filter is provided.\nfunction facetFilter(facets, {channels: {fx, fy}, groups}) {\n  return fx && fy\n    ? facets.map(({x, y}) => groups.get(x)?.get(y) ?? [])\n    : fx\n    ? facets.map(({x}) => groups.get(x) ?? [])\n    : facets.map(({y}) => groups.get(y) ?? []);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9mYWNldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ0Y7QUFDTjs7QUFFekMsd0JBQXdCLFdBQVc7QUFDNUI7QUFDUCxTQUFTLFFBQVEsRUFBRSx3REFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlDQUFLLDBDQUEwQyxRQUFRO0FBQzdEO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBOztBQUVPLGlDQUFpQyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ08sNEJBQTRCLE9BQU87QUFDMUMsWUFBWSxrREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwQ0FBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwQ0FBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sa0NBQWtDLHNCQUFzQjtBQUMvRCxtQkFBbUIsRUFBRTtBQUNyQixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsS0FBSyxHQUFHLEtBQUs7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLHVDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQVMsQ0FBQyxnREFBRztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGtEQUFLO0FBQ1gsTUFBTSxrREFBSztBQUNYLHNDQUFzQyxrREFBSyx1QkFBdUIsa0RBQUs7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxLQUFLLEdBQUcsRUFBRTtBQUMzQztBQUNBOztBQUVBLG9DQUFvQyxLQUFLLEdBQUcsRUFBRTtBQUM5QztBQUNBOztBQUVBLGtDQUFrQyxLQUFLLEdBQUcsRUFBRTtBQUM1QztBQUNBOztBQUVBLG1DQUFtQyxLQUFLLEdBQUcsRUFBRTtBQUM3QztBQUNBOztBQUVBLHNDQUFzQyxLQUFLLEdBQUcsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxLQUFLLEdBQUcsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxLQUFLLEdBQUcsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxLQUFLLEdBQUcsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDbkIsOEJBQThCLFdBQVcsT0FBTyxTQUFTO0FBQ2hFO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQixtQkFBbUIsRUFBRTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvZmFjZXQuanM/NWQ3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ludGVybk1hcCwgY3Jvc3MsIHJvbGx1cCwgc3VtfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7a2V5b2YsIG1hcCwgcmFuZ2V9IGZyb20gXCIuL29wdGlvbnMuanNcIjtcbmltcG9ydCB7Y3JlYXRlU2NhbGVzfSBmcm9tIFwiLi9zY2FsZXMuanNcIjtcblxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiB7eD8sIHk/LCBpfSBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgZmFjZXQgZG9tYWluLlxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZhY2V0cyhjaGFubmVsc0J5U2NhbGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge2Z4LCBmeX0gPSBjcmVhdGVTY2FsZXMoY2hhbm5lbHNCeVNjYWxlLCBvcHRpb25zKTtcbiAgY29uc3QgZnhEb21haW4gPSBmeD8uc2NhbGUuZG9tYWluKCk7XG4gIGNvbnN0IGZ5RG9tYWluID0gZnk/LnNjYWxlLmRvbWFpbigpO1xuICByZXR1cm4gZnhEb21haW4gJiYgZnlEb21haW5cbiAgICA/IGNyb3NzKGZ4RG9tYWluLCBmeURvbWFpbikubWFwKChbeCwgeV0sIGkpID0+ICh7eCwgeSwgaX0pKVxuICAgIDogZnhEb21haW5cbiAgICA/IGZ4RG9tYWluLm1hcCgoeCwgaSkgPT4gKHt4LCBpfSkpXG4gICAgOiBmeURvbWFpblxuICAgID8gZnlEb21haW4ubWFwKCh5LCBpKSA9PiAoe3ksIGl9KSlcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3JlYXRlRmFjZXRzKGZhY2V0cywge3g6IFgsIHk6IFl9KSB7XG4gIFggJiY9IGZhY2V0SW5kZXgoWCk7XG4gIFkgJiY9IGZhY2V0SW5kZXgoWSk7XG4gIHJldHVybiBmYWNldHNcbiAgICAuZmlsdGVyKFxuICAgICAgWCAmJiBZIC8vIHJlbW92ZSBhbnkgZmFjZXRzIG5vIGxvbmdlciBwcmVzZW50IGluIHRoZSBkb21haW5cbiAgICAgICAgPyAoZikgPT4gWC5oYXMoZi54KSAmJiBZLmhhcyhmLnkpXG4gICAgICAgIDogWFxuICAgICAgICA/IChmKSA9PiBYLmhhcyhmLngpXG4gICAgICAgIDogKGYpID0+IFkuaGFzKGYueSlcbiAgICApXG4gICAgLnNvcnQoXG4gICAgICBYICYmIFkgLy8gcmVvcmRlciBmYWNldHMgdG8gbWF0Y2ggdGhlIG5ldyBzY2FsZSBkb21haW5zXG4gICAgICAgID8gKGEsIGIpID0+IFguZ2V0KGEueCkgLSBYLmdldChiLngpIHx8IFkuZ2V0KGEueSkgLSBZLmdldChiLnkpXG4gICAgICAgIDogWFxuICAgICAgICA/IChhLCBiKSA9PiBYLmdldChhLngpIC0gWC5nZXQoYi54KVxuICAgICAgICA6IChhLCBiKSA9PiBZLmdldChhLnkpIC0gWS5nZXQoYi55KVxuICAgICk7XG59XG5cbi8vIFJldHVybnMgYSAocG9zc2libHkgbmVzdGVkKSBNYXAgb2YgW1trZXkxLCBpbmRleDFdLCBba2V5MiwgaW5kZXgyXSwg4oCmXVxuLy8gcmVwcmVzZW50aW5nIHRoZSBkYXRhIGluZGV4ZXMgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZmFjZXQuXG5leHBvcnQgZnVuY3Rpb24gZmFjZXRHcm91cHMoZGF0YSwge2Z4LCBmeX0pIHtcbiAgY29uc3QgSSA9IHJhbmdlKGRhdGEpO1xuICBjb25zdCBGWCA9IGZ4Py52YWx1ZTtcbiAgY29uc3QgRlkgPSBmeT8udmFsdWU7XG4gIHJldHVybiBmeCAmJiBmeVxuICAgID8gcm9sbHVwKFxuICAgICAgICBJLFxuICAgICAgICAoRykgPT4gKChHLmZ4ID0gRlhbR1swXV0pLCAoRy5meSA9IEZZW0dbMF1dKSwgRyksXG4gICAgICAgIChpKSA9PiBGWFtpXSxcbiAgICAgICAgKGkpID0+IEZZW2ldXG4gICAgICApXG4gICAgOiBmeFxuICAgID8gcm9sbHVwKFxuICAgICAgICBJLFxuICAgICAgICAoRykgPT4gKChHLmZ4ID0gRlhbR1swXV0pLCBHKSxcbiAgICAgICAgKGkpID0+IEZYW2ldXG4gICAgICApXG4gICAgOiByb2xsdXAoXG4gICAgICAgIEksXG4gICAgICAgIChHKSA9PiAoKEcuZnkgPSBGWVtHWzBdXSksIEcpLFxuICAgICAgICAoaSkgPT4gRllbaV1cbiAgICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWNldFRyYW5zbGF0b3IoZngsIGZ5LCB7bWFyZ2luVG9wLCBtYXJnaW5MZWZ0fSkge1xuICBjb25zdCB4ID0gZnggPyAoe3h9KSA9PiBmeCh4KSAtIG1hcmdpbkxlZnQgOiAoKSA9PiAwO1xuICBjb25zdCB5ID0gZnkgPyAoe3l9KSA9PiBmeSh5KSAtIG1hcmdpblRvcCA6ICgpID0+IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmICh0aGlzLnRhZ05hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCB4KGQpKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCB5KGQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3goZCl9LCR7eShkKX0pYCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIGFuIGluZGV4IHRoYXQgZm9yIGVhY2ggZmFjZXQgbGlzdHMgYWxsIHRoZSBlbGVtZW50cyBwcmVzZW50IGluIG90aGVyXG4vLyBmYWNldHMgaW4gdGhlIG9yaWdpbmFsIGluZGV4LiBUT0RPIE1lbW9pemUgdG8gYXZvaWQgcmVwZWF0ZWQgd29yaz9cbmV4cG9ydCBmdW5jdGlvbiBmYWNldEV4Y2x1ZGUoaW5kZXgpIHtcbiAgY29uc3QgZXggPSBbXTtcbiAgY29uc3QgZSA9IG5ldyBVaW50MzJBcnJheShzdW0oaW5kZXgsIChkKSA9PiBkLmxlbmd0aCkpO1xuICBmb3IgKGNvbnN0IGkgb2YgaW5kZXgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChjb25zdCBqIG9mIGluZGV4KSB7XG4gICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICBlLnNldChqLCBuKTtcbiAgICAgIG4gKz0gai5sZW5ndGg7XG4gICAgfVxuICAgIGV4LnB1c2goZS5zbGljZSgwLCBuKSk7XG4gIH1cbiAgcmV0dXJuIGV4O1xufVxuXG5jb25zdCBmYWNldEFuY2hvcnMgPSBuZXcgTWFwKFtcbiAgW1widG9wXCIsIGZhY2V0QW5jaG9yVG9wXSxcbiAgW1wicmlnaHRcIiwgZmFjZXRBbmNob3JSaWdodF0sXG4gIFtcImJvdHRvbVwiLCBmYWNldEFuY2hvckJvdHRvbV0sXG4gIFtcImxlZnRcIiwgZmFjZXRBbmNob3JMZWZ0XSxcbiAgW1widG9wLWxlZnRcIiwgYW5kKGZhY2V0QW5jaG9yVG9wLCBmYWNldEFuY2hvckxlZnQpXSxcbiAgW1widG9wLXJpZ2h0XCIsIGFuZChmYWNldEFuY2hvclRvcCwgZmFjZXRBbmNob3JSaWdodCldLFxuICBbXCJib3R0b20tbGVmdFwiLCBhbmQoZmFjZXRBbmNob3JCb3R0b20sIGZhY2V0QW5jaG9yTGVmdCldLFxuICBbXCJib3R0b20tcmlnaHRcIiwgYW5kKGZhY2V0QW5jaG9yQm90dG9tLCBmYWNldEFuY2hvclJpZ2h0KV0sXG4gIFtcInRvcC1lbXB0eVwiLCBmYWNldEFuY2hvclRvcEVtcHR5XSxcbiAgW1wicmlnaHQtZW1wdHlcIiwgZmFjZXRBbmNob3JSaWdodEVtcHR5XSxcbiAgW1wiYm90dG9tLWVtcHR5XCIsIGZhY2V0QW5jaG9yQm90dG9tRW1wdHldLFxuICBbXCJsZWZ0LWVtcHR5XCIsIGZhY2V0QW5jaG9yTGVmdEVtcHR5XSxcbiAgW1wiZW1wdHlcIiwgZmFjZXRBbmNob3JFbXB0eV1cbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVGYWNldEFuY2hvcihmYWNldEFuY2hvcikge1xuICBpZiAoZmFjZXRBbmNob3IgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFuY2hvciA9IGZhY2V0QW5jaG9ycy5nZXQoYCR7ZmFjZXRBbmNob3J9YC50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKGFuY2hvcikgcmV0dXJuIGFuY2hvcjtcbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGZhY2V0IGFuY2hvcjogJHtmYWNldEFuY2hvcn1gKTtcbn1cblxuY29uc3QgaW5kZXhDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGZhY2V0SW5kZXgoVikge1xuICBsZXQgSSA9IGluZGV4Q2FjaGUuZ2V0KFYpO1xuICBpZiAoIUkpIGluZGV4Q2FjaGUuc2V0KFYsIChJID0gbmV3IEludGVybk1hcChtYXAoViwgKHYsIGkpID0+IFt2LCBpXSkpKSk7XG4gIHJldHVybiBJO1xufVxuXG4vLyBMaWtlIFYuaW5kZXhPZih2KSwgYnV0IHdpdGggdGhlIHNhbWUgc2VtYW50aWNzIGFzIEludGVybk1hcC5cbmZ1bmN0aW9uIGZhY2V0SW5kZXhPZihWLCB2KSB7XG4gIHJldHVybiBmYWNldEluZGV4KFYpLmdldCh2KTtcbn1cblxuLy8gTGlrZSBmYWNldHMuZmluZCwgYnV0IHdpdGggdGhlIHNhbWUgc2VtYW50aWNzIGFzIEludGVybk1hcC5cbmZ1bmN0aW9uIGZhY2V0RmluZChmYWNldHMsIHgsIHkpIHtcbiAgeCA9IGtleW9mKHgpO1xuICB5ID0ga2V5b2YoeSk7XG4gIHJldHVybiBmYWNldHMuZmluZCgoZikgPT4gT2JqZWN0LmlzKGtleW9mKGYueCksIHgpICYmIE9iamVjdC5pcyhrZXlvZihmLnkpLCB5KSk7XG59XG5cbmZ1bmN0aW9uIGZhY2V0RW1wdHkoZmFjZXRzLCB4LCB5KSB7XG4gIHJldHVybiBmYWNldEZpbmQoZmFjZXRzLCB4LCB5KT8uZW1wdHk7XG59XG5cbmZ1bmN0aW9uIGZhY2V0QW5jaG9yVG9wKGZhY2V0cywge3k6IFl9LCB7eX0pIHtcbiAgcmV0dXJuIFkgPyBmYWNldEluZGV4T2YoWSwgeSkgPT09IDAgOiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmYWNldEFuY2hvckJvdHRvbShmYWNldHMsIHt5OiBZfSwge3l9KSB7XG4gIHJldHVybiBZID8gZmFjZXRJbmRleE9mKFksIHkpID09PSBZLmxlbmd0aCAtIDEgOiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmYWNldEFuY2hvckxlZnQoZmFjZXRzLCB7eDogWH0sIHt4fSkge1xuICByZXR1cm4gWCA/IGZhY2V0SW5kZXhPZihYLCB4KSA9PT0gMCA6IHRydWU7XG59XG5cbmZ1bmN0aW9uIGZhY2V0QW5jaG9yUmlnaHQoZmFjZXRzLCB7eDogWH0sIHt4fSkge1xuICByZXR1cm4gWCA/IGZhY2V0SW5kZXhPZihYLCB4KSA9PT0gWC5sZW5ndGggLSAxIDogdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmFjZXRBbmNob3JUb3BFbXB0eShmYWNldHMsIHt5OiBZfSwge3gsIHksIGVtcHR5fSkge1xuICBpZiAoZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFZKSByZXR1cm47XG4gIGNvbnN0IGkgPSBmYWNldEluZGV4T2YoWSwgeSk7XG4gIGlmIChpID4gMCkgcmV0dXJuIGZhY2V0RW1wdHkoZmFjZXRzLCB4LCBZW2kgLSAxXSk7XG59XG5cbmZ1bmN0aW9uIGZhY2V0QW5jaG9yQm90dG9tRW1wdHkoZmFjZXRzLCB7eTogWX0sIHt4LCB5LCBlbXB0eX0pIHtcbiAgaWYgKGVtcHR5KSByZXR1cm4gZmFsc2U7XG4gIGlmICghWSkgcmV0dXJuO1xuICBjb25zdCBpID0gZmFjZXRJbmRleE9mKFksIHkpO1xuICBpZiAoaSA8IFkubGVuZ3RoIC0gMSkgcmV0dXJuIGZhY2V0RW1wdHkoZmFjZXRzLCB4LCBZW2kgKyAxXSk7XG59XG5cbmZ1bmN0aW9uIGZhY2V0QW5jaG9yTGVmdEVtcHR5KGZhY2V0cywge3g6IFh9LCB7eCwgeSwgZW1wdHl9KSB7XG4gIGlmIChlbXB0eSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIVgpIHJldHVybjtcbiAgY29uc3QgaSA9IGZhY2V0SW5kZXhPZihYLCB4KTtcbiAgaWYgKGkgPiAwKSByZXR1cm4gZmFjZXRFbXB0eShmYWNldHMsIFhbaSAtIDFdLCB5KTtcbn1cblxuZnVuY3Rpb24gZmFjZXRBbmNob3JSaWdodEVtcHR5KGZhY2V0cywge3g6IFh9LCB7eCwgeSwgZW1wdHl9KSB7XG4gIGlmIChlbXB0eSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIVgpIHJldHVybjtcbiAgY29uc3QgaSA9IGZhY2V0SW5kZXhPZihYLCB4KTtcbiAgaWYgKGkgPCBYLmxlbmd0aCAtIDEpIHJldHVybiBmYWNldEVtcHR5KGZhY2V0cywgWFtpICsgMV0sIHkpO1xufVxuXG5mdW5jdGlvbiBmYWNldEFuY2hvckVtcHR5KGZhY2V0cywgY2hhbm5lbHMsIHtlbXB0eX0pIHtcbiAgcmV0dXJuIGVtcHR5O1xufVxuXG5mdW5jdGlvbiBhbmQoYSwgYikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgJiYgYi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBGYWNldCBmaWx0ZXIsIGJ5IG1hcms7IGZvciBub3cgb25seSB0aGUgXCJlcVwiIGZpbHRlciBpcyBwcm92aWRlZC5cbmV4cG9ydCBmdW5jdGlvbiBmYWNldEZpbHRlcihmYWNldHMsIHtjaGFubmVsczoge2Z4LCBmeX0sIGdyb3Vwc30pIHtcbiAgcmV0dXJuIGZ4ICYmIGZ5XG4gICAgPyBmYWNldHMubWFwKCh7eCwgeX0pID0+IGdyb3Vwcy5nZXQoeCk/LmdldCh5KSA/PyBbXSlcbiAgICA6IGZ4XG4gICAgPyBmYWNldHMubWFwKCh7eH0pID0+IGdyb3Vwcy5nZXQoeCkgPz8gW10pXG4gICAgOiBmYWNldHMubWFwKCh7eX0pID0+IGdyb3Vwcy5nZXQoeSkgPz8gW10pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/facet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/format.js":
/*!*******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/format.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAuto: () => (/* binding */ formatAuto),\n/* harmony export */   formatDefault: () => (/* binding */ formatDefault),\n/* harmony export */   formatIsoDate: () => (/* binding */ formatIsoDate),\n/* harmony export */   formatMonth: () => (/* binding */ formatMonth),\n/* harmony export */   formatNumber: () => (/* binding */ formatNumber),\n/* harmony export */   formatWeekday: () => (/* binding */ formatWeekday)\n/* harmony export */ });\n/* harmony import */ var isoformat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! isoformat */ \"(ssr)/./node_modules/isoformat/src/format.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize.js */ \"(ssr)/./node_modules/@observablehq/plot/src/memoize.js\");\n\n\n\n\nconst numberFormat = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_0__.memoize1)((locale) => {\n  return new Intl.NumberFormat(locale);\n});\n\nconst monthFormat = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_0__.memoize1)((locale, month) => {\n  return new Intl.DateTimeFormat(locale, {timeZone: \"UTC\", ...(month && {month})});\n});\n\nconst weekdayFormat = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_0__.memoize1)((locale, weekday) => {\n  return new Intl.DateTimeFormat(locale, {timeZone: \"UTC\", ...(weekday && {weekday})});\n});\n\nfunction formatNumber(locale = \"en-US\") {\n  const format = numberFormat(locale);\n  return (i) => (i != null && !isNaN(i) ? format.format(i) : undefined);\n}\n\nfunction formatMonth(locale = \"en-US\", format = \"short\") {\n  const fmt = monthFormat(locale, format);\n  return (i) => (i != null && !isNaN((i = +new Date(Date.UTC(2000, +i)))) ? fmt.format(i) : undefined);\n}\n\nfunction formatWeekday(locale = \"en-US\", format = \"short\") {\n  const fmt = weekdayFormat(locale, format);\n  return (i) => (i != null && !isNaN((i = +new Date(Date.UTC(2001, 0, +i)))) ? fmt.format(i) : undefined);\n}\n\nfunction formatIsoDate(date) {\n  return (0,isoformat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(date, \"Invalid Date\");\n}\n\nfunction formatAuto(locale = \"en-US\") {\n  const number = formatNumber(locale);\n  return (v) => (v instanceof Date ? formatIsoDate : typeof v === \"number\" ? number : _options_js__WEBPACK_IMPORTED_MODULE_2__.string)(v);\n}\n\n// TODO When Plot supports a top-level locale option, this should be removed\n// because it lacks context to know which locale to use; formatAuto should be\n// used instead whenever possible.\nconst formatDefault = formatAuto();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9mb3JtYXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ1Y7QUFDRTs7QUFFdEMscUJBQXFCLHFEQUFRO0FBQzdCO0FBQ0EsQ0FBQzs7QUFFRCxvQkFBb0IscURBQVE7QUFDNUIsMENBQTBDLCtCQUErQixNQUFNLEVBQUU7QUFDakYsQ0FBQzs7QUFFRCxzQkFBc0IscURBQVE7QUFDOUIsMENBQTBDLGlDQUFpQyxRQUFRLEVBQUU7QUFDckYsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFNBQVMscURBQVM7QUFDbEI7O0FBRU87QUFDUDtBQUNBLHNGQUFzRiwrQ0FBTTtBQUM1Rjs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9mb3JtYXQuanM/ZTViZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2Zvcm1hdCBhcyBpc29Gb3JtYXR9IGZyb20gXCJpc29mb3JtYXRcIjtcbmltcG9ydCB7c3RyaW5nfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge21lbW9pemUxfSBmcm9tIFwiLi9tZW1vaXplLmpzXCI7XG5cbmNvbnN0IG51bWJlckZvcm1hdCA9IG1lbW9pemUxKChsb2NhbGUpID0+IHtcbiAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUpO1xufSk7XG5cbmNvbnN0IG1vbnRoRm9ybWF0ID0gbWVtb2l6ZTEoKGxvY2FsZSwgbW9udGgpID0+IHtcbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge3RpbWVab25lOiBcIlVUQ1wiLCAuLi4obW9udGggJiYge21vbnRofSl9KTtcbn0pO1xuXG5jb25zdCB3ZWVrZGF5Rm9ybWF0ID0gbWVtb2l6ZTEoKGxvY2FsZSwgd2Vla2RheSkgPT4ge1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7dGltZVpvbmU6IFwiVVRDXCIsIC4uLih3ZWVrZGF5ICYmIHt3ZWVrZGF5fSl9KTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGxvY2FsZSA9IFwiZW4tVVNcIikge1xuICBjb25zdCBmb3JtYXQgPSBudW1iZXJGb3JtYXQobG9jYWxlKTtcbiAgcmV0dXJuIChpKSA9PiAoaSAhPSBudWxsICYmICFpc05hTihpKSA/IGZvcm1hdC5mb3JtYXQoaSkgOiB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TW9udGgobG9jYWxlID0gXCJlbi1VU1wiLCBmb3JtYXQgPSBcInNob3J0XCIpIHtcbiAgY29uc3QgZm10ID0gbW9udGhGb3JtYXQobG9jYWxlLCBmb3JtYXQpO1xuICByZXR1cm4gKGkpID0+IChpICE9IG51bGwgJiYgIWlzTmFOKChpID0gK25ldyBEYXRlKERhdGUuVVRDKDIwMDAsICtpKSkpKSA/IGZtdC5mb3JtYXQoaSkgOiB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShsb2NhbGUgPSBcImVuLVVTXCIsIGZvcm1hdCA9IFwic2hvcnRcIikge1xuICBjb25zdCBmbXQgPSB3ZWVrZGF5Rm9ybWF0KGxvY2FsZSwgZm9ybWF0KTtcbiAgcmV0dXJuIChpKSA9PiAoaSAhPSBudWxsICYmICFpc05hTigoaSA9ICtuZXcgRGF0ZShEYXRlLlVUQygyMDAxLCAwLCAraSkpKSkgPyBmbXQuZm9ybWF0KGkpIDogdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElzb0RhdGUoZGF0ZSkge1xuICByZXR1cm4gaXNvRm9ybWF0KGRhdGUsIFwiSW52YWxpZCBEYXRlXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QXV0byhsb2NhbGUgPSBcImVuLVVTXCIpIHtcbiAgY29uc3QgbnVtYmVyID0gZm9ybWF0TnVtYmVyKGxvY2FsZSk7XG4gIHJldHVybiAodikgPT4gKHYgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0SXNvRGF0ZSA6IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gbnVtYmVyIDogc3RyaW5nKSh2KTtcbn1cblxuLy8gVE9ETyBXaGVuIFBsb3Qgc3VwcG9ydHMgYSB0b3AtbGV2ZWwgbG9jYWxlIG9wdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVtb3ZlZFxuLy8gYmVjYXVzZSBpdCBsYWNrcyBjb250ZXh0IHRvIGtub3cgd2hpY2ggbG9jYWxlIHRvIHVzZTsgZm9ybWF0QXV0byBzaG91bGQgYmVcbi8vIHVzZWQgaW5zdGVhZCB3aGVuZXZlciBwb3NzaWJsZS5cbmV4cG9ydCBjb25zdCBmb3JtYXREZWZhdWx0ID0gZm9ybWF0QXV0bygpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Area: () => (/* reexport safe */ _marks_area_js__WEBPACK_IMPORTED_MODULE_2__.Area),\n/* harmony export */   Arrow: () => (/* reexport safe */ _marks_arrow_js__WEBPACK_IMPORTED_MODULE_3__.Arrow),\n/* harmony export */   BarX: () => (/* reexport safe */ _marks_bar_js__WEBPACK_IMPORTED_MODULE_6__.BarX),\n/* harmony export */   BarY: () => (/* reexport safe */ _marks_bar_js__WEBPACK_IMPORTED_MODULE_6__.BarY),\n/* harmony export */   Cell: () => (/* reexport safe */ _marks_cell_js__WEBPACK_IMPORTED_MODULE_9__.Cell),\n/* harmony export */   Contour: () => (/* reexport safe */ _marks_contour_js__WEBPACK_IMPORTED_MODULE_10__.Contour),\n/* harmony export */   Density: () => (/* reexport safe */ _marks_density_js__WEBPACK_IMPORTED_MODULE_13__.Density),\n/* harmony export */   Dot: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.Dot),\n/* harmony export */   Frame: () => (/* reexport safe */ _marks_frame_js__WEBPACK_IMPORTED_MODULE_16__.Frame),\n/* harmony export */   Geo: () => (/* reexport safe */ _marks_geo_js__WEBPACK_IMPORTED_MODULE_17__.Geo),\n/* harmony export */   Hexgrid: () => (/* reexport safe */ _marks_hexgrid_js__WEBPACK_IMPORTED_MODULE_18__.Hexgrid),\n/* harmony export */   Image: () => (/* reexport safe */ _marks_image_js__WEBPACK_IMPORTED_MODULE_19__.Image),\n/* harmony export */   Line: () => (/* reexport safe */ _marks_line_js__WEBPACK_IMPORTED_MODULE_20__.Line),\n/* harmony export */   Link: () => (/* reexport safe */ _marks_link_js__WEBPACK_IMPORTED_MODULE_22__.Link),\n/* harmony export */   Mark: () => (/* reexport safe */ _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   Raster: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.Raster),\n/* harmony export */   Rect: () => (/* reexport safe */ _marks_rect_js__WEBPACK_IMPORTED_MODULE_24__.Rect),\n/* harmony export */   RuleX: () => (/* reexport safe */ _marks_rule_js__WEBPACK_IMPORTED_MODULE_25__.RuleX),\n/* harmony export */   RuleY: () => (/* reexport safe */ _marks_rule_js__WEBPACK_IMPORTED_MODULE_25__.RuleY),\n/* harmony export */   Text: () => (/* reexport safe */ _marks_text_js__WEBPACK_IMPORTED_MODULE_26__.Text),\n/* harmony export */   TickX: () => (/* reexport safe */ _marks_tick_js__WEBPACK_IMPORTED_MODULE_27__.TickX),\n/* harmony export */   TickY: () => (/* reexport safe */ _marks_tick_js__WEBPACK_IMPORTED_MODULE_27__.TickY),\n/* harmony export */   Tip: () => (/* reexport safe */ _marks_tip_js__WEBPACK_IMPORTED_MODULE_28__.Tip),\n/* harmony export */   Vector: () => (/* reexport safe */ _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__.Vector),\n/* harmony export */   WaffleX: () => (/* reexport safe */ _marks_waffle_js__WEBPACK_IMPORTED_MODULE_31__.WaffleX),\n/* harmony export */   WaffleY: () => (/* reexport safe */ _marks_waffle_js__WEBPACK_IMPORTED_MODULE_31__.WaffleY),\n/* harmony export */   area: () => (/* reexport safe */ _marks_area_js__WEBPACK_IMPORTED_MODULE_2__.area),\n/* harmony export */   areaX: () => (/* reexport safe */ _marks_area_js__WEBPACK_IMPORTED_MODULE_2__.areaX),\n/* harmony export */   areaY: () => (/* reexport safe */ _marks_area_js__WEBPACK_IMPORTED_MODULE_2__.areaY),\n/* harmony export */   arrow: () => (/* reexport safe */ _marks_arrow_js__WEBPACK_IMPORTED_MODULE_3__.arrow),\n/* harmony export */   auto: () => (/* reexport safe */ _marks_auto_js__WEBPACK_IMPORTED_MODULE_4__.auto),\n/* harmony export */   autoSpec: () => (/* reexport safe */ _marks_auto_js__WEBPACK_IMPORTED_MODULE_4__.autoSpec),\n/* harmony export */   axisFx: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.axisFx),\n/* harmony export */   axisFy: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.axisFy),\n/* harmony export */   axisX: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.axisX),\n/* harmony export */   axisY: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.axisY),\n/* harmony export */   barX: () => (/* reexport safe */ _marks_bar_js__WEBPACK_IMPORTED_MODULE_6__.barX),\n/* harmony export */   barY: () => (/* reexport safe */ _marks_bar_js__WEBPACK_IMPORTED_MODULE_6__.barY),\n/* harmony export */   bin: () => (/* reexport safe */ _transforms_bin_js__WEBPACK_IMPORTED_MODULE_34__.bin),\n/* harmony export */   binX: () => (/* reexport safe */ _transforms_bin_js__WEBPACK_IMPORTED_MODULE_34__.binX),\n/* harmony export */   binY: () => (/* reexport safe */ _transforms_bin_js__WEBPACK_IMPORTED_MODULE_34__.binY),\n/* harmony export */   bollinger: () => (/* reexport safe */ _marks_bollinger_js__WEBPACK_IMPORTED_MODULE_7__.bollinger),\n/* harmony export */   bollingerX: () => (/* reexport safe */ _marks_bollinger_js__WEBPACK_IMPORTED_MODULE_7__.bollingerX),\n/* harmony export */   bollingerY: () => (/* reexport safe */ _marks_bollinger_js__WEBPACK_IMPORTED_MODULE_7__.bollingerY),\n/* harmony export */   boxX: () => (/* reexport safe */ _marks_box_js__WEBPACK_IMPORTED_MODULE_8__.boxX),\n/* harmony export */   boxY: () => (/* reexport safe */ _marks_box_js__WEBPACK_IMPORTED_MODULE_8__.boxY),\n/* harmony export */   cell: () => (/* reexport safe */ _marks_cell_js__WEBPACK_IMPORTED_MODULE_9__.cell),\n/* harmony export */   cellX: () => (/* reexport safe */ _marks_cell_js__WEBPACK_IMPORTED_MODULE_9__.cellX),\n/* harmony export */   cellY: () => (/* reexport safe */ _marks_cell_js__WEBPACK_IMPORTED_MODULE_9__.cellY),\n/* harmony export */   centroid: () => (/* reexport safe */ _transforms_centroid_js__WEBPACK_IMPORTED_MODULE_35__.centroid),\n/* harmony export */   circle: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.circle),\n/* harmony export */   cluster: () => (/* reexport safe */ _marks_tree_js__WEBPACK_IMPORTED_MODULE_29__.cluster),\n/* harmony export */   column: () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_32__.column),\n/* harmony export */   contour: () => (/* reexport safe */ _marks_contour_js__WEBPACK_IMPORTED_MODULE_10__.contour),\n/* harmony export */   crosshair: () => (/* reexport safe */ _marks_crosshair_js__WEBPACK_IMPORTED_MODULE_11__.crosshair),\n/* harmony export */   crosshairX: () => (/* reexport safe */ _marks_crosshair_js__WEBPACK_IMPORTED_MODULE_11__.crosshairX),\n/* harmony export */   crosshairY: () => (/* reexport safe */ _marks_crosshair_js__WEBPACK_IMPORTED_MODULE_11__.crosshairY),\n/* harmony export */   delaunayLink: () => (/* reexport safe */ _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__.delaunayLink),\n/* harmony export */   delaunayMesh: () => (/* reexport safe */ _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__.delaunayMesh),\n/* harmony export */   density: () => (/* reexport safe */ _marks_density_js__WEBPACK_IMPORTED_MODULE_13__.density),\n/* harmony export */   differenceX: () => (/* reexport safe */ _marks_difference_js__WEBPACK_IMPORTED_MODULE_14__.differenceX),\n/* harmony export */   differenceY: () => (/* reexport safe */ _marks_difference_js__WEBPACK_IMPORTED_MODULE_14__.differenceY),\n/* harmony export */   dodgeX: () => (/* reexport safe */ _transforms_dodge_js__WEBPACK_IMPORTED_MODULE_36__.dodgeX),\n/* harmony export */   dodgeY: () => (/* reexport safe */ _transforms_dodge_js__WEBPACK_IMPORTED_MODULE_36__.dodgeY),\n/* harmony export */   dot: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.dot),\n/* harmony export */   dotX: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.dotX),\n/* harmony export */   dotY: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.dotY),\n/* harmony export */   filter: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.filter),\n/* harmony export */   find: () => (/* reexport safe */ _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__.find),\n/* harmony export */   formatIsoDate: () => (/* reexport safe */ _format_js__WEBPACK_IMPORTED_MODULE_47__.formatIsoDate),\n/* harmony export */   formatMonth: () => (/* reexport safe */ _format_js__WEBPACK_IMPORTED_MODULE_47__.formatMonth),\n/* harmony export */   formatNumber: () => (/* reexport safe */ _format_js__WEBPACK_IMPORTED_MODULE_47__.formatNumber),\n/* harmony export */   formatWeekday: () => (/* reexport safe */ _format_js__WEBPACK_IMPORTED_MODULE_47__.formatWeekday),\n/* harmony export */   frame: () => (/* reexport safe */ _marks_frame_js__WEBPACK_IMPORTED_MODULE_16__.frame),\n/* harmony export */   geo: () => (/* reexport safe */ _marks_geo_js__WEBPACK_IMPORTED_MODULE_17__.geo),\n/* harmony export */   geoCentroid: () => (/* reexport safe */ _transforms_centroid_js__WEBPACK_IMPORTED_MODULE_35__.geoCentroid),\n/* harmony export */   graticule: () => (/* reexport safe */ _marks_geo_js__WEBPACK_IMPORTED_MODULE_17__.graticule),\n/* harmony export */   gridFx: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.gridFx),\n/* harmony export */   gridFy: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.gridFy),\n/* harmony export */   gridX: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.gridX),\n/* harmony export */   gridY: () => (/* reexport safe */ _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__.gridY),\n/* harmony export */   group: () => (/* reexport safe */ _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__.group),\n/* harmony export */   groupX: () => (/* reexport safe */ _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__.groupX),\n/* harmony export */   groupY: () => (/* reexport safe */ _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__.groupY),\n/* harmony export */   groupZ: () => (/* reexport safe */ _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__.groupZ),\n/* harmony export */   hexagon: () => (/* reexport safe */ _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__.hexagon),\n/* harmony export */   hexbin: () => (/* reexport safe */ _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_38__.hexbin),\n/* harmony export */   hexgrid: () => (/* reexport safe */ _marks_hexgrid_js__WEBPACK_IMPORTED_MODULE_18__.hexgrid),\n/* harmony export */   hull: () => (/* reexport safe */ _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__.hull),\n/* harmony export */   identity: () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_32__.identity),\n/* harmony export */   image: () => (/* reexport safe */ _marks_image_js__WEBPACK_IMPORTED_MODULE_19__.image),\n/* harmony export */   indexOf: () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_32__.indexOf),\n/* harmony export */   initializer: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.initializer),\n/* harmony export */   interpolateNearest: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.interpolateNearest),\n/* harmony export */   interpolateNone: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.interpolateNone),\n/* harmony export */   interpolatorBarycentric: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.interpolatorBarycentric),\n/* harmony export */   interpolatorRandomWalk: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.interpolatorRandomWalk),\n/* harmony export */   legend: () => (/* reexport safe */ _legends_js__WEBPACK_IMPORTED_MODULE_49__.legend),\n/* harmony export */   line: () => (/* reexport safe */ _marks_line_js__WEBPACK_IMPORTED_MODULE_20__.line),\n/* harmony export */   lineX: () => (/* reexport safe */ _marks_line_js__WEBPACK_IMPORTED_MODULE_20__.lineX),\n/* harmony export */   lineY: () => (/* reexport safe */ _marks_line_js__WEBPACK_IMPORTED_MODULE_20__.lineY),\n/* harmony export */   linearRegressionX: () => (/* reexport safe */ _marks_linearRegression_js__WEBPACK_IMPORTED_MODULE_21__.linearRegressionX),\n/* harmony export */   linearRegressionY: () => (/* reexport safe */ _marks_linearRegression_js__WEBPACK_IMPORTED_MODULE_21__.linearRegressionY),\n/* harmony export */   link: () => (/* reexport safe */ _marks_link_js__WEBPACK_IMPORTED_MODULE_22__.link),\n/* harmony export */   map: () => (/* reexport safe */ _transforms_map_js__WEBPACK_IMPORTED_MODULE_40__.map),\n/* harmony export */   mapX: () => (/* reexport safe */ _transforms_map_js__WEBPACK_IMPORTED_MODULE_40__.mapX),\n/* harmony export */   mapY: () => (/* reexport safe */ _transforms_map_js__WEBPACK_IMPORTED_MODULE_40__.mapY),\n/* harmony export */   marks: () => (/* reexport safe */ _mark_js__WEBPACK_IMPORTED_MODULE_0__.marks),\n/* harmony export */   normalize: () => (/* reexport safe */ _transforms_normalize_js__WEBPACK_IMPORTED_MODULE_39__.normalize),\n/* harmony export */   normalizeX: () => (/* reexport safe */ _transforms_normalize_js__WEBPACK_IMPORTED_MODULE_39__.normalizeX),\n/* harmony export */   normalizeY: () => (/* reexport safe */ _transforms_normalize_js__WEBPACK_IMPORTED_MODULE_39__.normalizeY),\n/* harmony export */   numberInterval: () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_32__.numberInterval),\n/* harmony export */   plot: () => (/* reexport safe */ _plot_js__WEBPACK_IMPORTED_MODULE_1__.plot),\n/* harmony export */   pointer: () => (/* reexport safe */ _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_46__.pointer),\n/* harmony export */   pointerX: () => (/* reexport safe */ _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_46__.pointerX),\n/* harmony export */   pointerY: () => (/* reexport safe */ _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_46__.pointerY),\n/* harmony export */   raster: () => (/* reexport safe */ _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__.raster),\n/* harmony export */   rect: () => (/* reexport safe */ _marks_rect_js__WEBPACK_IMPORTED_MODULE_24__.rect),\n/* harmony export */   rectX: () => (/* reexport safe */ _marks_rect_js__WEBPACK_IMPORTED_MODULE_24__.rectX),\n/* harmony export */   rectY: () => (/* reexport safe */ _marks_rect_js__WEBPACK_IMPORTED_MODULE_24__.rectY),\n/* harmony export */   reverse: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.reverse),\n/* harmony export */   ruleX: () => (/* reexport safe */ _marks_rule_js__WEBPACK_IMPORTED_MODULE_25__.ruleX),\n/* harmony export */   ruleY: () => (/* reexport safe */ _marks_rule_js__WEBPACK_IMPORTED_MODULE_25__.ruleY),\n/* harmony export */   scale: () => (/* reexport safe */ _scales_js__WEBPACK_IMPORTED_MODULE_48__.scale),\n/* harmony export */   select: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.select),\n/* harmony export */   selectFirst: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectFirst),\n/* harmony export */   selectLast: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectLast),\n/* harmony export */   selectMaxX: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectMaxX),\n/* harmony export */   selectMaxY: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectMaxY),\n/* harmony export */   selectMinX: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectMinX),\n/* harmony export */   selectMinY: () => (/* reexport safe */ _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__.selectMinY),\n/* harmony export */   shiftX: () => (/* reexport safe */ _transforms_shift_js__WEBPACK_IMPORTED_MODULE_41__.shiftX),\n/* harmony export */   shiftY: () => (/* reexport safe */ _transforms_shift_js__WEBPACK_IMPORTED_MODULE_41__.shiftY),\n/* harmony export */   shuffle: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.shuffle),\n/* harmony export */   sort: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.sort),\n/* harmony export */   sphere: () => (/* reexport safe */ _marks_geo_js__WEBPACK_IMPORTED_MODULE_17__.sphere),\n/* harmony export */   spike: () => (/* reexport safe */ _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__.spike),\n/* harmony export */   stackX: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackX),\n/* harmony export */   stackX1: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackX1),\n/* harmony export */   stackX2: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackX2),\n/* harmony export */   stackY: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackY),\n/* harmony export */   stackY1: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackY1),\n/* harmony export */   stackY2: () => (/* reexport safe */ _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__.stackY2),\n/* harmony export */   text: () => (/* reexport safe */ _marks_text_js__WEBPACK_IMPORTED_MODULE_26__.text),\n/* harmony export */   textX: () => (/* reexport safe */ _marks_text_js__WEBPACK_IMPORTED_MODULE_26__.textX),\n/* harmony export */   textY: () => (/* reexport safe */ _marks_text_js__WEBPACK_IMPORTED_MODULE_26__.textY),\n/* harmony export */   tickX: () => (/* reexport safe */ _marks_tick_js__WEBPACK_IMPORTED_MODULE_27__.tickX),\n/* harmony export */   tickY: () => (/* reexport safe */ _marks_tick_js__WEBPACK_IMPORTED_MODULE_27__.tickY),\n/* harmony export */   timeInterval: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_50__.timeInterval),\n/* harmony export */   tip: () => (/* reexport safe */ _marks_tip_js__WEBPACK_IMPORTED_MODULE_28__.tip),\n/* harmony export */   transform: () => (/* reexport safe */ _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__.basic),\n/* harmony export */   tree: () => (/* reexport safe */ _marks_tree_js__WEBPACK_IMPORTED_MODULE_29__.tree),\n/* harmony export */   treeLink: () => (/* reexport safe */ _transforms_tree_js__WEBPACK_IMPORTED_MODULE_45__.treeLink),\n/* harmony export */   treeNode: () => (/* reexport safe */ _transforms_tree_js__WEBPACK_IMPORTED_MODULE_45__.treeNode),\n/* harmony export */   utcInterval: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_50__.utcInterval),\n/* harmony export */   valueof: () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_32__.valueof),\n/* harmony export */   vector: () => (/* reexport safe */ _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__.vector),\n/* harmony export */   vectorX: () => (/* reexport safe */ _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__.vectorX),\n/* harmony export */   vectorY: () => (/* reexport safe */ _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__.vectorY),\n/* harmony export */   voronoi: () => (/* reexport safe */ _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__.voronoi),\n/* harmony export */   voronoiMesh: () => (/* reexport safe */ _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__.voronoiMesh),\n/* harmony export */   waffleX: () => (/* reexport safe */ _marks_waffle_js__WEBPACK_IMPORTED_MODULE_31__.waffleX),\n/* harmony export */   waffleY: () => (/* reexport safe */ _marks_waffle_js__WEBPACK_IMPORTED_MODULE_31__.waffleY),\n/* harmony export */   window: () => (/* reexport safe */ _transforms_window_js__WEBPACK_IMPORTED_MODULE_42__.window),\n/* harmony export */   windowX: () => (/* reexport safe */ _transforms_window_js__WEBPACK_IMPORTED_MODULE_42__.windowX),\n/* harmony export */   windowY: () => (/* reexport safe */ _transforms_window_js__WEBPACK_IMPORTED_MODULE_42__.windowY)\n/* harmony export */ });\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _plot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/plot.js\");\n/* harmony import */ var _marks_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./marks/area.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/area.js\");\n/* harmony import */ var _marks_arrow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./marks/arrow.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/arrow.js\");\n/* harmony import */ var _marks_auto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./marks/auto.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/auto.js\");\n/* harmony import */ var _marks_axis_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./marks/axis.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js\");\n/* harmony import */ var _marks_bar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./marks/bar.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\");\n/* harmony import */ var _marks_bollinger_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./marks/bollinger.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bollinger.js\");\n/* harmony import */ var _marks_box_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./marks/box.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/box.js\");\n/* harmony import */ var _marks_cell_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./marks/cell.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/cell.js\");\n/* harmony import */ var _marks_contour_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./marks/contour.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/contour.js\");\n/* harmony import */ var _marks_crosshair_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./marks/crosshair.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/crosshair.js\");\n/* harmony import */ var _marks_delaunay_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./marks/delaunay.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/delaunay.js\");\n/* harmony import */ var _marks_density_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./marks/density.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/density.js\");\n/* harmony import */ var _marks_difference_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./marks/difference.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/difference.js\");\n/* harmony import */ var _marks_dot_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./marks/dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n/* harmony import */ var _marks_frame_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./marks/frame.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/frame.js\");\n/* harmony import */ var _marks_geo_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./marks/geo.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/geo.js\");\n/* harmony import */ var _marks_hexgrid_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./marks/hexgrid.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/hexgrid.js\");\n/* harmony import */ var _marks_image_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./marks/image.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/image.js\");\n/* harmony import */ var _marks_line_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./marks/line.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/line.js\");\n/* harmony import */ var _marks_linearRegression_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./marks/linearRegression.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/linearRegression.js\");\n/* harmony import */ var _marks_link_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./marks/link.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/link.js\");\n/* harmony import */ var _marks_raster_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./marks/raster.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/raster.js\");\n/* harmony import */ var _marks_rect_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./marks/rect.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js\");\n/* harmony import */ var _marks_rule_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./marks/rule.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\");\n/* harmony import */ var _marks_text_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./marks/text.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\");\n/* harmony import */ var _marks_tick_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./marks/tick.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/tick.js\");\n/* harmony import */ var _marks_tip_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./marks/tip.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/tip.js\");\n/* harmony import */ var _marks_tree_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./marks/tree.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/tree.js\");\n/* harmony import */ var _marks_vector_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./marks/vector.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/vector.js\");\n/* harmony import */ var _marks_waffle_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./marks/waffle.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/waffle.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n/* harmony import */ var _transforms_centroid_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./transforms/centroid.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/centroid.js\");\n/* harmony import */ var _transforms_dodge_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./transforms/dodge.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/dodge.js\");\n/* harmony import */ var _transforms_group_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./transforms/group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n/* harmony import */ var _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./transforms/hexbin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/hexbin.js\");\n/* harmony import */ var _transforms_normalize_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./transforms/normalize.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/normalize.js\");\n/* harmony import */ var _transforms_map_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./transforms/map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n/* harmony import */ var _transforms_shift_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./transforms/shift.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/shift.js\");\n/* harmony import */ var _transforms_window_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./transforms/window.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/window.js\");\n/* harmony import */ var _transforms_select_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./transforms/select.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/select.js\");\n/* harmony import */ var _transforms_stack_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./transforms/stack.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\");\n/* harmony import */ var _transforms_tree_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./transforms/tree.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/tree.js\");\n/* harmony import */ var _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./interactions/pointer.js */ \"(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/@observablehq/plot/src/format.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _legends_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./legends.js */ \"(ssr)/./node_modules/@observablehq/plot/src/legends.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./time.js */ \"(ssr)/./node_modules/@observablehq/plot/src/time.js\");\n\n\n\n// Note: this side effect avoids a circular dependency.\n_mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark.prototype.plot = function ({marks = [], ...options} = {}) {\n  return (0,_plot_js__WEBPACK_IMPORTED_MODULE_1__.plot)({...options, marks: [...marks, this]});\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7O0FBRS9CO0FBQ0EsMENBQUksNkJBQTZCLHdCQUF3QixJQUFJO0FBQzdELFNBQVMsOENBQUksRUFBRSxvQ0FBb0M7QUFDbkQ7O0FBRStCO0FBQ087QUFDbUI7QUFDWDtBQUNDO0FBQzRDO0FBQ3JDO0FBQ2lCO0FBQzdCO0FBQ2U7QUFDTDtBQUNtQjtBQUNvQjtBQUN2QztBQUNXO0FBQ007QUFDdkI7QUFDYTtBQUNQO0FBQ047QUFDVztBQUN3QjtBQUN0QztBQUNNO0FBQ3NFO0FBQzlEO0FBQ0U7QUFDRjtBQUNFO0FBQ25CO0FBQ007QUFDNEI7QUFDTDtBQUNMO0FBQ3NDO0FBQ2xEO0FBQ1c7QUFDVjtBQUNxQjtBQUM1QjtBQUM4QjtBQUN4QjtBQUNDO0FBQ1c7QUFDdUQ7QUFDOUI7QUFDakM7QUFDYztBQUNjO0FBQ2xEO0FBQ0U7QUFDUTtBQUNRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9pbmRleC5qcz8xNjJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWFya30gZnJvbSBcIi4vbWFyay5qc1wiO1xuaW1wb3J0IHtwbG90fSBmcm9tIFwiLi9wbG90LmpzXCI7XG5cbi8vIE5vdGU6IHRoaXMgc2lkZSBlZmZlY3QgYXZvaWRzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbk1hcmsucHJvdG90eXBlLnBsb3QgPSBmdW5jdGlvbiAoe21hcmtzID0gW10sIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgcmV0dXJuIHBsb3Qoey4uLm9wdGlvbnMsIG1hcmtzOiBbLi4ubWFya3MsIHRoaXNdfSk7XG59O1xuXG5leHBvcnQge3Bsb3R9IGZyb20gXCIuL3Bsb3QuanNcIjtcbmV4cG9ydCB7TWFyaywgbWFya3N9IGZyb20gXCIuL21hcmsuanNcIjtcbmV4cG9ydCB7QXJlYSwgYXJlYSwgYXJlYVgsIGFyZWFZfSBmcm9tIFwiLi9tYXJrcy9hcmVhLmpzXCI7XG5leHBvcnQge0Fycm93LCBhcnJvd30gZnJvbSBcIi4vbWFya3MvYXJyb3cuanNcIjtcbmV4cG9ydCB7YXV0bywgYXV0b1NwZWN9IGZyb20gXCIuL21hcmtzL2F1dG8uanNcIjtcbmV4cG9ydCB7YXhpc1gsIGF4aXNZLCBheGlzRngsIGF4aXNGeSwgZ3JpZFgsIGdyaWRZLCBncmlkRngsIGdyaWRGeX0gZnJvbSBcIi4vbWFya3MvYXhpcy5qc1wiO1xuZXhwb3J0IHtCYXJYLCBCYXJZLCBiYXJYLCBiYXJZfSBmcm9tIFwiLi9tYXJrcy9iYXIuanNcIjtcbmV4cG9ydCB7Ym9sbGluZ2VyLCBib2xsaW5nZXJYLCBib2xsaW5nZXJZfSBmcm9tIFwiLi9tYXJrcy9ib2xsaW5nZXIuanNcIjtcbmV4cG9ydCB7Ym94WCwgYm94WX0gZnJvbSBcIi4vbWFya3MvYm94LmpzXCI7XG5leHBvcnQge0NlbGwsIGNlbGwsIGNlbGxYLCBjZWxsWX0gZnJvbSBcIi4vbWFya3MvY2VsbC5qc1wiO1xuZXhwb3J0IHtDb250b3VyLCBjb250b3VyfSBmcm9tIFwiLi9tYXJrcy9jb250b3VyLmpzXCI7XG5leHBvcnQge2Nyb3NzaGFpciwgY3Jvc3NoYWlyWCwgY3Jvc3NoYWlyWX0gZnJvbSBcIi4vbWFya3MvY3Jvc3NoYWlyLmpzXCI7XG5leHBvcnQge2RlbGF1bmF5TGluaywgZGVsYXVuYXlNZXNoLCBodWxsLCB2b3Jvbm9pLCB2b3Jvbm9pTWVzaH0gZnJvbSBcIi4vbWFya3MvZGVsYXVuYXkuanNcIjtcbmV4cG9ydCB7RGVuc2l0eSwgZGVuc2l0eX0gZnJvbSBcIi4vbWFya3MvZGVuc2l0eS5qc1wiO1xuZXhwb3J0IHtkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVl9IGZyb20gXCIuL21hcmtzL2RpZmZlcmVuY2UuanNcIjtcbmV4cG9ydCB7RG90LCBkb3QsIGRvdFgsIGRvdFksIGNpcmNsZSwgaGV4YWdvbn0gZnJvbSBcIi4vbWFya3MvZG90LmpzXCI7XG5leHBvcnQge0ZyYW1lLCBmcmFtZX0gZnJvbSBcIi4vbWFya3MvZnJhbWUuanNcIjtcbmV4cG9ydCB7R2VvLCBnZW8sIHNwaGVyZSwgZ3JhdGljdWxlfSBmcm9tIFwiLi9tYXJrcy9nZW8uanNcIjtcbmV4cG9ydCB7SGV4Z3JpZCwgaGV4Z3JpZH0gZnJvbSBcIi4vbWFya3MvaGV4Z3JpZC5qc1wiO1xuZXhwb3J0IHtJbWFnZSwgaW1hZ2V9IGZyb20gXCIuL21hcmtzL2ltYWdlLmpzXCI7XG5leHBvcnQge0xpbmUsIGxpbmUsIGxpbmVYLCBsaW5lWX0gZnJvbSBcIi4vbWFya3MvbGluZS5qc1wiO1xuZXhwb3J0IHtsaW5lYXJSZWdyZXNzaW9uWCwgbGluZWFyUmVncmVzc2lvbll9IGZyb20gXCIuL21hcmtzL2xpbmVhclJlZ3Jlc3Npb24uanNcIjtcbmV4cG9ydCB7TGluaywgbGlua30gZnJvbSBcIi4vbWFya3MvbGluay5qc1wiO1xuZXhwb3J0IHtSYXN0ZXIsIHJhc3Rlcn0gZnJvbSBcIi4vbWFya3MvcmFzdGVyLmpzXCI7XG5leHBvcnQge2ludGVycG9sYXRlTm9uZSwgaW50ZXJwb2xhdG9yQmFyeWNlbnRyaWMsIGludGVycG9sYXRlTmVhcmVzdCwgaW50ZXJwb2xhdG9yUmFuZG9tV2Fsa30gZnJvbSBcIi4vbWFya3MvcmFzdGVyLmpzXCI7XG5leHBvcnQge1JlY3QsIHJlY3QsIHJlY3RYLCByZWN0WX0gZnJvbSBcIi4vbWFya3MvcmVjdC5qc1wiO1xuZXhwb3J0IHtSdWxlWCwgUnVsZVksIHJ1bGVYLCBydWxlWX0gZnJvbSBcIi4vbWFya3MvcnVsZS5qc1wiO1xuZXhwb3J0IHtUZXh0LCB0ZXh0LCB0ZXh0WCwgdGV4dFl9IGZyb20gXCIuL21hcmtzL3RleHQuanNcIjtcbmV4cG9ydCB7VGlja1gsIFRpY2tZLCB0aWNrWCwgdGlja1l9IGZyb20gXCIuL21hcmtzL3RpY2suanNcIjtcbmV4cG9ydCB7VGlwLCB0aXB9IGZyb20gXCIuL21hcmtzL3RpcC5qc1wiO1xuZXhwb3J0IHt0cmVlLCBjbHVzdGVyfSBmcm9tIFwiLi9tYXJrcy90cmVlLmpzXCI7XG5leHBvcnQge1ZlY3RvciwgdmVjdG9yLCB2ZWN0b3JYLCB2ZWN0b3JZLCBzcGlrZX0gZnJvbSBcIi4vbWFya3MvdmVjdG9yLmpzXCI7XG5leHBvcnQge1dhZmZsZVgsIFdhZmZsZVksIHdhZmZsZVgsIHdhZmZsZVl9IGZyb20gXCIuL21hcmtzL3dhZmZsZS5qc1wiO1xuZXhwb3J0IHt2YWx1ZW9mLCBjb2x1bW4sIGlkZW50aXR5LCBpbmRleE9mfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5leHBvcnQge2ZpbHRlciwgcmV2ZXJzZSwgc29ydCwgc2h1ZmZsZSwgYmFzaWMgYXMgdHJhbnNmb3JtLCBpbml0aWFsaXplcn0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9iYXNpYy5qc1wiO1xuZXhwb3J0IHtiaW4sIGJpblgsIGJpbll9IGZyb20gXCIuL3RyYW5zZm9ybXMvYmluLmpzXCI7XG5leHBvcnQge2NlbnRyb2lkLCBnZW9DZW50cm9pZH0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9jZW50cm9pZC5qc1wiO1xuZXhwb3J0IHtkb2RnZVgsIGRvZGdlWX0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9kb2RnZS5qc1wiO1xuZXhwb3J0IHtmaW5kLCBncm91cCwgZ3JvdXBYLCBncm91cFksIGdyb3VwWn0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9ncm91cC5qc1wiO1xuZXhwb3J0IHtoZXhiaW59IGZyb20gXCIuL3RyYW5zZm9ybXMvaGV4YmluLmpzXCI7XG5leHBvcnQge25vcm1hbGl6ZSwgbm9ybWFsaXplWCwgbm9ybWFsaXplWX0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9ub3JtYWxpemUuanNcIjtcbmV4cG9ydCB7bWFwLCBtYXBYLCBtYXBZfSBmcm9tIFwiLi90cmFuc2Zvcm1zL21hcC5qc1wiO1xuZXhwb3J0IHtzaGlmdFgsIHNoaWZ0WX0gZnJvbSBcIi4vdHJhbnNmb3Jtcy9zaGlmdC5qc1wiO1xuZXhwb3J0IHt3aW5kb3csIHdpbmRvd1gsIHdpbmRvd1l9IGZyb20gXCIuL3RyYW5zZm9ybXMvd2luZG93LmpzXCI7XG5leHBvcnQge3NlbGVjdCwgc2VsZWN0Rmlyc3QsIHNlbGVjdExhc3QsIHNlbGVjdE1heFgsIHNlbGVjdE1heFksIHNlbGVjdE1pblgsIHNlbGVjdE1pbll9IGZyb20gXCIuL3RyYW5zZm9ybXMvc2VsZWN0LmpzXCI7XG5leHBvcnQge3N0YWNrWCwgc3RhY2tYMSwgc3RhY2tYMiwgc3RhY2tZLCBzdGFja1kxLCBzdGFja1kyfSBmcm9tIFwiLi90cmFuc2Zvcm1zL3N0YWNrLmpzXCI7XG5leHBvcnQge3RyZWVOb2RlLCB0cmVlTGlua30gZnJvbSBcIi4vdHJhbnNmb3Jtcy90cmVlLmpzXCI7XG5leHBvcnQge3BvaW50ZXIsIHBvaW50ZXJYLCBwb2ludGVyWX0gZnJvbSBcIi4vaW50ZXJhY3Rpb25zL3BvaW50ZXIuanNcIjtcbmV4cG9ydCB7Zm9ybWF0SXNvRGF0ZSwgZm9ybWF0TnVtYmVyLCBmb3JtYXRXZWVrZGF5LCBmb3JtYXRNb250aH0gZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5leHBvcnQge3NjYWxlfSBmcm9tIFwiLi9zY2FsZXMuanNcIjtcbmV4cG9ydCB7bGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRzLmpzXCI7XG5leHBvcnQge251bWJlckludGVydmFsfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5leHBvcnQge3RpbWVJbnRlcnZhbCwgdXRjSW50ZXJ2YWx9IGZyb20gXCIuL3RpbWUuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/interactions/pointer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anchorX: () => (/* binding */ anchorX),\n/* harmony export */   anchorY: () => (/* binding */ anchorY),\n/* harmony export */   pointer: () => (/* binding */ pointer),\n/* harmony export */   pointerX: () => (/* binding */ pointerX),\n/* harmony export */   pointerY: () => (/* binding */ pointerY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\n\n\n\nconst states = new WeakMap();\n\nfunction pointerK(kx, ky, {x, y, px, py, maxRadius = 40, channels, render, ...options} = {}) {\n  maxRadius = +maxRadius;\n  // When px or py is used, register an extra channel that the pointer\n  // interaction can use to control which point is focused; this allows pointing\n  // to function independently of where the downstream mark (e.g., a tip) is\n  // displayed. Also default x or y to null to disable maybeTuple etc.\n  if (px != null) (x ??= null), (channels = {...channels, px: {value: px, scale: \"x\"}});\n  if (py != null) (y ??= null), (channels = {...channels, py: {value: py, scale: \"y\"}});\n  return {\n    x,\n    y,\n    channels,\n    ...options,\n    // Unlike other composed transforms, the render transform must be the\n    // outermost render function because it will re-render dynamically in\n    // response to pointer events.\n    render: (0,_mark_js__WEBPACK_IMPORTED_MODULE_1__.composeRender)(function (index, scales, values, dimensions, context, next) {\n      context = {...context, pointerSticky: false};\n      const svg = context.ownerSVGElement;\n      const {data} = context.getMarkState(this);\n\n      // Isolate state per-pointer, per-plot; if the pointer is reused by\n      // multiple marks, they will share the same state (e.g., sticky modality).\n      let state = states.get(svg);\n      if (!state) states.set(svg, (state = {sticky: false, roots: [], renders: []}));\n\n      // This serves as a unique identifier of the rendered mark per-plot; it is\n      // used to record the currently-rendered elements (state.roots) so that we\n      // can tell when a rendered element is clicked on.\n      let renderIndex = state.renders.push(render) - 1;\n\n      // For faceting, we want to compute the local coordinates of each point,\n      // which means subtracting out the facet translation, if any. (It’s\n      // tempting to do this using the local coordinates in SVG, but that’s\n      // complicated by mark-specific transforms such as dx and dy.) Also, since\n      // band scales return the upper bound of the band, we have to offset by\n      // half the bandwidth.\n      const {x, y, fx, fy} = scales;\n      let tx = fx ? fx(index.fx) - dimensions.marginLeft : 0;\n      let ty = fy ? fy(index.fy) - dimensions.marginTop : 0;\n      if (x?.bandwidth) tx += x.bandwidth() / 2;\n      if (y?.bandwidth) ty += y.bandwidth() / 2;\n\n      // For faceting, we also need to record the closest point per facet per\n      // mark (!), since each facet has its own pointer event listeners; we only\n      // want the closest point across facets to be visible.\n      const faceted = index.fi != null;\n      let facetState;\n      if (faceted) {\n        let facetStates = state.facetStates;\n        if (!facetStates) state.facetStates = facetStates = new Map();\n        facetState = facetStates.get(this);\n        if (!facetState) facetStates.set(this, (facetState = new Map()));\n      }\n\n      // The order of precedence for the pointer position is: px & py; the\n      // middle of x1 & y1 and x2 & y2; or x1 & y1 (e.g., area); or lastly x &\n      // y. If a dimension is unspecified, the frame anchor is used.\n      const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_2__.applyFrameAnchor)(this, dimensions);\n      const {px: PX, py: PY} = values;\n      const px = PX ? (i) => PX[i] : anchorX(values, cx);\n      const py = PY ? (i) => PY[i] : anchorY(values, cy);\n\n      let i; // currently focused index\n      let g; // currently rendered mark\n      let s; // currently rendered stickiness\n      let f; // current animation frame\n\n      // When faceting, if more than one pointer would be visible, only show\n      // this one if it is the closest. We defer rendering using an animation\n      // frame to allow all pointer events to be received before deciding which\n      // mark to render; although when hiding, we render immediately.\n      function update(ii, ri) {\n        if (faceted) {\n          if (f) f = cancelAnimationFrame(f);\n          if (ii == null) facetState.delete(index.fi);\n          else {\n            facetState.set(index.fi, ri);\n            f = requestAnimationFrame(() => {\n              f = null;\n              for (const [fi, r] of facetState) {\n                if (r < ri || (r === ri && fi < index.fi)) {\n                  ii = null;\n                  break;\n                }\n              }\n              render(ii);\n            });\n            return;\n          }\n        }\n        render(ii);\n      }\n\n      function render(ii) {\n        if (i === ii && s === state.sticky) return; // the tooltip hasn’t moved\n        i = ii;\n        s = context.pointerSticky = state.sticky;\n        const I = i == null ? [] : [i];\n        if (faceted) (I.fx = index.fx), (I.fy = index.fy), (I.fi = index.fi);\n        const r = next(I, scales, values, dimensions, context);\n        if (g) {\n          // When faceting, preserve swapped mark and facet transforms; also\n          // remove ARIA attributes since these are promoted to the parent. This\n          // is perhaps brittle in that it depends on how Plot renders facets,\n          // but it produces a cleaner and more accessible SVG structure.\n          if (faceted) {\n            const p = g.parentNode;\n            const ft = g.getAttribute(\"transform\");\n            const mt = r.getAttribute(\"transform\");\n            ft ? r.setAttribute(\"transform\", ft) : r.removeAttribute(\"transform\");\n            mt ? p.setAttribute(\"transform\", mt) : p.removeAttribute(\"transform\");\n            r.removeAttribute(\"aria-label\");\n            r.removeAttribute(\"aria-description\");\n            r.removeAttribute(\"aria-hidden\");\n          }\n          g.replaceWith(r);\n        }\n        state.roots[renderIndex] = g = r;\n\n        // Dispatch the value. When simultaneously exiting this facet and\n        // entering a new one, prioritize the entering facet.\n        if (!(i == null && facetState?.size > 1)) {\n          const value = i == null ? null : (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.isArray)(data) ? data[i] : data.get(i);\n          context.dispatchValue(value);\n        }\n\n        return r;\n      }\n\n      // Select the closest point to the mouse in the current facet; for\n      // pointerX or pointerY, the orthogonal component of the distance is\n      // squashed, selecting primarily on the dominant dimension. Across facets,\n      // use unsquashed distance to determine the winner.\n      function pointermove(event) {\n        if (state.sticky || (event.pointerType === \"mouse\" && event.buttons === 1)) return; // dragging\n        let [xp, yp] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pointer)(event);\n        (xp -= tx), (yp -= ty); // correct for facets and band scales\n        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx;\n        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky;\n        let ii = null;\n        let ri = maxRadius * maxRadius;\n        for (const j of index) {\n          const dx = kpx * (px(j) - xp);\n          const dy = kpy * (py(j) - yp);\n          const rj = dx * dx + dy * dy;\n          if (rj <= ri) (ii = j), (ri = rj);\n        }\n        if (ii != null && (kx !== 1 || ky !== 1)) {\n          const dx = px(ii) - xp;\n          const dy = py(ii) - yp;\n          ri = dx * dx + dy * dy;\n        }\n        update(ii, ri);\n      }\n\n      function pointerdown(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (i == null) return; // not pointing\n        if (state.sticky && state.roots.some((r) => r?.contains(event.target))) return; // stay sticky\n        if (state.sticky) (state.sticky = false), state.renders.forEach((r) => r(null)); // clear all pointers\n        else (state.sticky = true), render(i);\n        event.stopImmediatePropagation(); // suppress other pointers\n      }\n\n      function pointerleave(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (!state.sticky) update(null);\n      }\n\n      // We listen to the svg element; listening to the window instead would let\n      // us receive pointer events from farther away, but would also make it\n      // hard to know when to remove the listeners. (Using a mutation observer\n      // to watch the entire document is likely too expensive.)\n      svg.addEventListener(\"pointerenter\", pointermove);\n      svg.addEventListener(\"pointermove\", pointermove);\n      svg.addEventListener(\"pointerdown\", pointerdown);\n      svg.addEventListener(\"pointerleave\", pointerleave);\n\n      return render(null);\n    }, render)\n  };\n}\n\nfunction pointer(options) {\n  return pointerK(1, 1, options);\n}\n\nfunction pointerX(options) {\n  return pointerK(1, 0.01, options);\n}\n\nfunction pointerY(options) {\n  return pointerK(0.01, 1, options);\n}\n\nfunction anchorX({x1: X1, x2: X2, x: X = X1}, cx) {\n  return X1 && X2 ? (i) => (X1[i] + X2[i]) / 2 : X ? (i) => X[i] : () => cx;\n}\n\nfunction anchorY({y1: Y1, y2: Y2, y: Y = Y1}, cy) {\n  return Y1 && Y2 ? (i) => (Y1[i] + Y2[i]) / 2 : Y ? (i) => Y[i] : () => cy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9pbnRlcmFjdGlvbnMvcG9pbnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBc0M7QUFDRztBQUNIO0FBQ087O0FBRTdDOztBQUVBLDJCQUEyQiw0REFBNEQsSUFBSTtBQUMzRjtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLHVCQUF1QjtBQUN0Riw2Q0FBNkMsa0JBQWtCLHVCQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBYTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQSxhQUFhLE1BQU07O0FBRW5CLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsNENBQTRDLHNDQUFzQzs7QUFFbEYsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RSx3Q0FBd0MseUJBQXlCO0FBQ2pFO0FBQ0EsdUJBQXVCLDJEQUFnQjtBQUN2QyxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0RBQU87QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1Rix1QkFBdUIsMkNBQU87QUFDOUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3RkFBd0Y7QUFDeEYseUZBQXlGO0FBQ3pGO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPLGtCQUFrQiwwQkFBMEI7QUFDbkQ7QUFDQTs7QUFFTyxrQkFBa0IsMEJBQTBCO0FBQ25EO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL2ludGVyYWN0aW9ucy9wb2ludGVyLmpzPzUwMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwb2ludGVyIGFzIHBvaW50b2Z9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtjb21wb3NlUmVuZGVyfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseUZyYW1lQW5jaG9yfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcblxuY29uc3Qgc3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gcG9pbnRlcksoa3gsIGt5LCB7eCwgeSwgcHgsIHB5LCBtYXhSYWRpdXMgPSA0MCwgY2hhbm5lbHMsIHJlbmRlciwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBtYXhSYWRpdXMgPSArbWF4UmFkaXVzO1xuICAvLyBXaGVuIHB4IG9yIHB5IGlzIHVzZWQsIHJlZ2lzdGVyIGFuIGV4dHJhIGNoYW5uZWwgdGhhdCB0aGUgcG9pbnRlclxuICAvLyBpbnRlcmFjdGlvbiBjYW4gdXNlIHRvIGNvbnRyb2wgd2hpY2ggcG9pbnQgaXMgZm9jdXNlZDsgdGhpcyBhbGxvd3MgcG9pbnRpbmdcbiAgLy8gdG8gZnVuY3Rpb24gaW5kZXBlbmRlbnRseSBvZiB3aGVyZSB0aGUgZG93bnN0cmVhbSBtYXJrIChlLmcuLCBhIHRpcCkgaXNcbiAgLy8gZGlzcGxheWVkLiBBbHNvIGRlZmF1bHQgeCBvciB5IHRvIG51bGwgdG8gZGlzYWJsZSBtYXliZVR1cGxlIGV0Yy5cbiAgaWYgKHB4ICE9IG51bGwpICh4ID8/PSBudWxsKSwgKGNoYW5uZWxzID0gey4uLmNoYW5uZWxzLCBweDoge3ZhbHVlOiBweCwgc2NhbGU6IFwieFwifX0pO1xuICBpZiAocHkgIT0gbnVsbCkgKHkgPz89IG51bGwpLCAoY2hhbm5lbHMgPSB7Li4uY2hhbm5lbHMsIHB5OiB7dmFsdWU6IHB5LCBzY2FsZTogXCJ5XCJ9fSk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIGNoYW5uZWxzLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gVW5saWtlIG90aGVyIGNvbXBvc2VkIHRyYW5zZm9ybXMsIHRoZSByZW5kZXIgdHJhbnNmb3JtIG11c3QgYmUgdGhlXG4gICAgLy8gb3V0ZXJtb3N0IHJlbmRlciBmdW5jdGlvbiBiZWNhdXNlIGl0IHdpbGwgcmUtcmVuZGVyIGR5bmFtaWNhbGx5IGluXG4gICAgLy8gcmVzcG9uc2UgdG8gcG9pbnRlciBldmVudHMuXG4gICAgcmVuZGVyOiBjb21wb3NlUmVuZGVyKGZ1bmN0aW9uIChpbmRleCwgc2NhbGVzLCB2YWx1ZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgIGNvbnRleHQgPSB7Li4uY29udGV4dCwgcG9pbnRlclN0aWNreTogZmFsc2V9O1xuICAgICAgY29uc3Qgc3ZnID0gY29udGV4dC5vd25lclNWR0VsZW1lbnQ7XG4gICAgICBjb25zdCB7ZGF0YX0gPSBjb250ZXh0LmdldE1hcmtTdGF0ZSh0aGlzKTtcblxuICAgICAgLy8gSXNvbGF0ZSBzdGF0ZSBwZXItcG9pbnRlciwgcGVyLXBsb3Q7IGlmIHRoZSBwb2ludGVyIGlzIHJldXNlZCBieVxuICAgICAgLy8gbXVsdGlwbGUgbWFya3MsIHRoZXkgd2lsbCBzaGFyZSB0aGUgc2FtZSBzdGF0ZSAoZS5nLiwgc3RpY2t5IG1vZGFsaXR5KS5cbiAgICAgIGxldCBzdGF0ZSA9IHN0YXRlcy5nZXQoc3ZnKTtcbiAgICAgIGlmICghc3RhdGUpIHN0YXRlcy5zZXQoc3ZnLCAoc3RhdGUgPSB7c3RpY2t5OiBmYWxzZSwgcm9vdHM6IFtdLCByZW5kZXJzOiBbXX0pKTtcblxuICAgICAgLy8gVGhpcyBzZXJ2ZXMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcmVuZGVyZWQgbWFyayBwZXItcGxvdDsgaXQgaXNcbiAgICAgIC8vIHVzZWQgdG8gcmVjb3JkIHRoZSBjdXJyZW50bHktcmVuZGVyZWQgZWxlbWVudHMgKHN0YXRlLnJvb3RzKSBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gdGVsbCB3aGVuIGEgcmVuZGVyZWQgZWxlbWVudCBpcyBjbGlja2VkIG9uLlxuICAgICAgbGV0IHJlbmRlckluZGV4ID0gc3RhdGUucmVuZGVycy5wdXNoKHJlbmRlcikgLSAxO1xuXG4gICAgICAvLyBGb3IgZmFjZXRpbmcsIHdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgZWFjaCBwb2ludCxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHN1YnRyYWN0aW5nIG91dCB0aGUgZmFjZXQgdHJhbnNsYXRpb24sIGlmIGFueS4gKEl04oCZc1xuICAgICAgLy8gdGVtcHRpbmcgdG8gZG8gdGhpcyB1c2luZyB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgaW4gU1ZHLCBidXQgdGhhdOKAmXNcbiAgICAgIC8vIGNvbXBsaWNhdGVkIGJ5IG1hcmstc3BlY2lmaWMgdHJhbnNmb3JtcyBzdWNoIGFzIGR4IGFuZCBkeS4pIEFsc28sIHNpbmNlXG4gICAgICAvLyBiYW5kIHNjYWxlcyByZXR1cm4gdGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBiYW5kLCB3ZSBoYXZlIHRvIG9mZnNldCBieVxuICAgICAgLy8gaGFsZiB0aGUgYmFuZHdpZHRoLlxuICAgICAgY29uc3Qge3gsIHksIGZ4LCBmeX0gPSBzY2FsZXM7XG4gICAgICBsZXQgdHggPSBmeCA/IGZ4KGluZGV4LmZ4KSAtIGRpbWVuc2lvbnMubWFyZ2luTGVmdCA6IDA7XG4gICAgICBsZXQgdHkgPSBmeSA/IGZ5KGluZGV4LmZ5KSAtIGRpbWVuc2lvbnMubWFyZ2luVG9wIDogMDtcbiAgICAgIGlmICh4Py5iYW5kd2lkdGgpIHR4ICs9IHguYmFuZHdpZHRoKCkgLyAyO1xuICAgICAgaWYgKHk/LmJhbmR3aWR0aCkgdHkgKz0geS5iYW5kd2lkdGgoKSAvIDI7XG5cbiAgICAgIC8vIEZvciBmYWNldGluZywgd2UgYWxzbyBuZWVkIHRvIHJlY29yZCB0aGUgY2xvc2VzdCBwb2ludCBwZXIgZmFjZXQgcGVyXG4gICAgICAvLyBtYXJrICghKSwgc2luY2UgZWFjaCBmYWNldCBoYXMgaXRzIG93biBwb2ludGVyIGV2ZW50IGxpc3RlbmVyczsgd2Ugb25seVxuICAgICAgLy8gd2FudCB0aGUgY2xvc2VzdCBwb2ludCBhY3Jvc3MgZmFjZXRzIHRvIGJlIHZpc2libGUuXG4gICAgICBjb25zdCBmYWNldGVkID0gaW5kZXguZmkgIT0gbnVsbDtcbiAgICAgIGxldCBmYWNldFN0YXRlO1xuICAgICAgaWYgKGZhY2V0ZWQpIHtcbiAgICAgICAgbGV0IGZhY2V0U3RhdGVzID0gc3RhdGUuZmFjZXRTdGF0ZXM7XG4gICAgICAgIGlmICghZmFjZXRTdGF0ZXMpIHN0YXRlLmZhY2V0U3RhdGVzID0gZmFjZXRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZhY2V0U3RhdGUgPSBmYWNldFN0YXRlcy5nZXQodGhpcyk7XG4gICAgICAgIGlmICghZmFjZXRTdGF0ZSkgZmFjZXRTdGF0ZXMuc2V0KHRoaXMsIChmYWNldFN0YXRlID0gbmV3IE1hcCgpKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBvcmRlciBvZiBwcmVjZWRlbmNlIGZvciB0aGUgcG9pbnRlciBwb3NpdGlvbiBpczogcHggJiBweTsgdGhlXG4gICAgICAvLyBtaWRkbGUgb2YgeDEgJiB5MSBhbmQgeDIgJiB5Mjsgb3IgeDEgJiB5MSAoZS5nLiwgYXJlYSk7IG9yIGxhc3RseSB4ICZcbiAgICAgIC8vIHkuIElmIGEgZGltZW5zaW9uIGlzIHVuc3BlY2lmaWVkLCB0aGUgZnJhbWUgYW5jaG9yIGlzIHVzZWQuXG4gICAgICBjb25zdCBbY3gsIGN5XSA9IGFwcGx5RnJhbWVBbmNob3IodGhpcywgZGltZW5zaW9ucyk7XG4gICAgICBjb25zdCB7cHg6IFBYLCBweTogUFl9ID0gdmFsdWVzO1xuICAgICAgY29uc3QgcHggPSBQWCA/IChpKSA9PiBQWFtpXSA6IGFuY2hvclgodmFsdWVzLCBjeCk7XG4gICAgICBjb25zdCBweSA9IFBZID8gKGkpID0+IFBZW2ldIDogYW5jaG9yWSh2YWx1ZXMsIGN5KTtcblxuICAgICAgbGV0IGk7IC8vIGN1cnJlbnRseSBmb2N1c2VkIGluZGV4XG4gICAgICBsZXQgZzsgLy8gY3VycmVudGx5IHJlbmRlcmVkIG1hcmtcbiAgICAgIGxldCBzOyAvLyBjdXJyZW50bHkgcmVuZGVyZWQgc3RpY2tpbmVzc1xuICAgICAgbGV0IGY7IC8vIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG5cbiAgICAgIC8vIFdoZW4gZmFjZXRpbmcsIGlmIG1vcmUgdGhhbiBvbmUgcG9pbnRlciB3b3VsZCBiZSB2aXNpYmxlLCBvbmx5IHNob3dcbiAgICAgIC8vIHRoaXMgb25lIGlmIGl0IGlzIHRoZSBjbG9zZXN0LiBXZSBkZWZlciByZW5kZXJpbmcgdXNpbmcgYW4gYW5pbWF0aW9uXG4gICAgICAvLyBmcmFtZSB0byBhbGxvdyBhbGwgcG9pbnRlciBldmVudHMgdG8gYmUgcmVjZWl2ZWQgYmVmb3JlIGRlY2lkaW5nIHdoaWNoXG4gICAgICAvLyBtYXJrIHRvIHJlbmRlcjsgYWx0aG91Z2ggd2hlbiBoaWRpbmcsIHdlIHJlbmRlciBpbW1lZGlhdGVseS5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShpaSwgcmkpIHtcbiAgICAgICAgaWYgKGZhY2V0ZWQpIHtcbiAgICAgICAgICBpZiAoZikgZiA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGYpO1xuICAgICAgICAgIGlmIChpaSA9PSBudWxsKSBmYWNldFN0YXRlLmRlbGV0ZShpbmRleC5maSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWNldFN0YXRlLnNldChpbmRleC5maSwgcmkpO1xuICAgICAgICAgICAgZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGYgPSBudWxsO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmaSwgcl0gb2YgZmFjZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyIDwgcmkgfHwgKHIgPT09IHJpICYmIGZpIDwgaW5kZXguZmkpKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyKGlpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoaWkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW5kZXIoaWkpIHtcbiAgICAgICAgaWYgKGkgPT09IGlpICYmIHMgPT09IHN0YXRlLnN0aWNreSkgcmV0dXJuOyAvLyB0aGUgdG9vbHRpcCBoYXNu4oCZdCBtb3ZlZFxuICAgICAgICBpID0gaWk7XG4gICAgICAgIHMgPSBjb250ZXh0LnBvaW50ZXJTdGlja3kgPSBzdGF0ZS5zdGlja3k7XG4gICAgICAgIGNvbnN0IEkgPSBpID09IG51bGwgPyBbXSA6IFtpXTtcbiAgICAgICAgaWYgKGZhY2V0ZWQpIChJLmZ4ID0gaW5kZXguZngpLCAoSS5meSA9IGluZGV4LmZ5KSwgKEkuZmkgPSBpbmRleC5maSk7XG4gICAgICAgIGNvbnN0IHIgPSBuZXh0KEksIHNjYWxlcywgdmFsdWVzLCBkaW1lbnNpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAvLyBXaGVuIGZhY2V0aW5nLCBwcmVzZXJ2ZSBzd2FwcGVkIG1hcmsgYW5kIGZhY2V0IHRyYW5zZm9ybXM7IGFsc29cbiAgICAgICAgICAvLyByZW1vdmUgQVJJQSBhdHRyaWJ1dGVzIHNpbmNlIHRoZXNlIGFyZSBwcm9tb3RlZCB0byB0aGUgcGFyZW50LiBUaGlzXG4gICAgICAgICAgLy8gaXMgcGVyaGFwcyBicml0dGxlIGluIHRoYXQgaXQgZGVwZW5kcyBvbiBob3cgUGxvdCByZW5kZXJzIGZhY2V0cyxcbiAgICAgICAgICAvLyBidXQgaXQgcHJvZHVjZXMgYSBjbGVhbmVyIGFuZCBtb3JlIGFjY2Vzc2libGUgU1ZHIHN0cnVjdHVyZS5cbiAgICAgICAgICBpZiAoZmFjZXRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGcucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGZ0ID0gZy5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgICBjb25zdCBtdCA9IHIuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICAgICAgZnQgPyByLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBmdCkgOiByLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIG10ID8gcC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgbXQpIDogcC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XG4gICAgICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnLnJlcGxhY2VXaXRoKHIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJvb3RzW3JlbmRlckluZGV4XSA9IGcgPSByO1xuXG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSB2YWx1ZS4gV2hlbiBzaW11bHRhbmVvdXNseSBleGl0aW5nIHRoaXMgZmFjZXQgYW5kXG4gICAgICAgIC8vIGVudGVyaW5nIGEgbmV3IG9uZSwgcHJpb3JpdGl6ZSB0aGUgZW50ZXJpbmcgZmFjZXQuXG4gICAgICAgIGlmICghKGkgPT0gbnVsbCAmJiBmYWNldFN0YXRlPy5zaXplID4gMSkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGkgPT0gbnVsbCA/IG51bGwgOiBpc0FycmF5KGRhdGEpID8gZGF0YVtpXSA6IGRhdGEuZ2V0KGkpO1xuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSBtb3VzZSBpbiB0aGUgY3VycmVudCBmYWNldDsgZm9yXG4gICAgICAvLyBwb2ludGVyWCBvciBwb2ludGVyWSwgdGhlIG9ydGhvZ29uYWwgY29tcG9uZW50IG9mIHRoZSBkaXN0YW5jZSBpc1xuICAgICAgLy8gc3F1YXNoZWQsIHNlbGVjdGluZyBwcmltYXJpbHkgb24gdGhlIGRvbWluYW50IGRpbWVuc2lvbi4gQWNyb3NzIGZhY2V0cyxcbiAgICAgIC8vIHVzZSB1bnNxdWFzaGVkIGRpc3RhbmNlIHRvIGRldGVybWluZSB0aGUgd2lubmVyLlxuICAgICAgZnVuY3Rpb24gcG9pbnRlcm1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0aWNreSB8fCAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiAmJiBldmVudC5idXR0b25zID09PSAxKSkgcmV0dXJuOyAvLyBkcmFnZ2luZ1xuICAgICAgICBsZXQgW3hwLCB5cF0gPSBwb2ludG9mKGV2ZW50KTtcbiAgICAgICAgKHhwIC09IHR4KSwgKHlwIC09IHR5KTsgLy8gY29ycmVjdCBmb3IgZmFjZXRzIGFuZCBiYW5kIHNjYWxlc1xuICAgICAgICBjb25zdCBrcHggPSB4cCA8IGRpbWVuc2lvbnMubWFyZ2luTGVmdCB8fCB4cCA+IGRpbWVuc2lvbnMud2lkdGggLSBkaW1lbnNpb25zLm1hcmdpblJpZ2h0ID8gMSA6IGt4O1xuICAgICAgICBjb25zdCBrcHkgPSB5cCA8IGRpbWVuc2lvbnMubWFyZ2luVG9wIHx8IHlwID4gZGltZW5zaW9ucy5oZWlnaHQgLSBkaW1lbnNpb25zLm1hcmdpbkJvdHRvbSA/IDEgOiBreTtcbiAgICAgICAgbGV0IGlpID0gbnVsbDtcbiAgICAgICAgbGV0IHJpID0gbWF4UmFkaXVzICogbWF4UmFkaXVzO1xuICAgICAgICBmb3IgKGNvbnN0IGogb2YgaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBkeCA9IGtweCAqIChweChqKSAtIHhwKTtcbiAgICAgICAgICBjb25zdCBkeSA9IGtweSAqIChweShqKSAtIHlwKTtcbiAgICAgICAgICBjb25zdCByaiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgIGlmIChyaiA8PSByaSkgKGlpID0gaiksIChyaSA9IHJqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWkgIT0gbnVsbCAmJiAoa3ggIT09IDEgfHwga3kgIT09IDEpKSB7XG4gICAgICAgICAgY29uc3QgZHggPSBweChpaSkgLSB4cDtcbiAgICAgICAgICBjb25zdCBkeSA9IHB5KGlpKSAtIHlwO1xuICAgICAgICAgIHJpID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKGlpLCByaSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSAhPT0gXCJtb3VzZVwiKSByZXR1cm47XG4gICAgICAgIGlmIChpID09IG51bGwpIHJldHVybjsgLy8gbm90IHBvaW50aW5nXG4gICAgICAgIGlmIChzdGF0ZS5zdGlja3kgJiYgc3RhdGUucm9vdHMuc29tZSgocikgPT4gcj8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkpIHJldHVybjsgLy8gc3RheSBzdGlja3lcbiAgICAgICAgaWYgKHN0YXRlLnN0aWNreSkgKHN0YXRlLnN0aWNreSA9IGZhbHNlKSwgc3RhdGUucmVuZGVycy5mb3JFYWNoKChyKSA9PiByKG51bGwpKTsgLy8gY2xlYXIgYWxsIHBvaW50ZXJzXG4gICAgICAgIGVsc2UgKHN0YXRlLnN0aWNreSA9IHRydWUpLCByZW5kZXIoaSk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAvLyBzdXBwcmVzcyBvdGhlciBwb2ludGVyc1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb2ludGVybGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlICE9PSBcIm1vdXNlXCIpIHJldHVybjtcbiAgICAgICAgaWYgKCFzdGF0ZS5zdGlja3kpIHVwZGF0ZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZSBzdmcgZWxlbWVudDsgbGlzdGVuaW5nIHRvIHRoZSB3aW5kb3cgaW5zdGVhZCB3b3VsZCBsZXRcbiAgICAgIC8vIHVzIHJlY2VpdmUgcG9pbnRlciBldmVudHMgZnJvbSBmYXJ0aGVyIGF3YXksIGJ1dCB3b3VsZCBhbHNvIG1ha2UgaXRcbiAgICAgIC8vIGhhcmQgdG8ga25vdyB3aGVuIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzLiAoVXNpbmcgYSBtdXRhdGlvbiBvYnNlcnZlclxuICAgICAgLy8gdG8gd2F0Y2ggdGhlIGVudGlyZSBkb2N1bWVudCBpcyBsaWtlbHkgdG9vIGV4cGVuc2l2ZS4pXG4gICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBwb2ludGVybW92ZSk7XG4gICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJtb3ZlKTtcbiAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgcG9pbnRlcmRvd24pO1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgcG9pbnRlcmxlYXZlKTtcblxuICAgICAgcmV0dXJuIHJlbmRlcihudWxsKTtcbiAgICB9LCByZW5kZXIpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludGVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBvaW50ZXJLKDEsIDEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlclgob3B0aW9ucykge1xuICByZXR1cm4gcG9pbnRlcksoMSwgMC4wMSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludGVyWShvcHRpb25zKSB7XG4gIHJldHVybiBwb2ludGVySygwLjAxLCAxLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuY2hvclgoe3gxOiBYMSwgeDI6IFgyLCB4OiBYID0gWDF9LCBjeCkge1xuICByZXR1cm4gWDEgJiYgWDIgPyAoaSkgPT4gKFgxW2ldICsgWDJbaV0pIC8gMiA6IFggPyAoaSkgPT4gWFtpXSA6ICgpID0+IGN4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5jaG9yWSh7eTE6IFkxLCB5MjogWTIsIHk6IFkgPSBZMX0sIGN5KSB7XG4gIHJldHVybiBZMSAmJiBZMiA/IChpKSA9PiAoWTFbaV0gKyBZMltpXSkgLyAyIDogWSA/IChpKSA9PiBZW2ldIDogKCkgPT4gY3k7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/legends.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/legends.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLegends: () => (/* binding */ createLegends),\n/* harmony export */   exposeLegends: () => (/* binding */ exposeLegends),\n/* harmony export */   legend: () => (/* binding */ legend)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _legends_ramp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./legends/ramp.js */ \"(ssr)/./node_modules/@observablehq/plot/src/legends/ramp.js\");\n/* harmony import */ var _legends_swatches_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legends/swatches.js */ \"(ssr)/./node_modules/@observablehq/plot/src/legends/swatches.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n\n\n\n\n\n\n\nconst legendRegistry = new Map([\n  [\"symbol\", _legends_swatches_js__WEBPACK_IMPORTED_MODULE_1__.legendSymbols],\n  [\"color\", legendColor],\n  [\"opacity\", legendOpacity]\n]);\n\nfunction legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale = options[key];\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isScaleOptions)(scale)) {\n      // e.g., ignore {color: \"red\"}\n      const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.createContext)(options);\n      let hint;\n      // For symbol legends, pass a hint to the symbol scale.\n      if (key === \"symbol\") {\n        const {fill, stroke = fill === undefined && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isScaleOptions)(options.color) ? \"color\" : undefined} = options;\n        hint = {fill, stroke};\n      }\n      return value((0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.normalizeScale)(key, scale, hint), legendOptions(context, scale, options), (key) =>\n        (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isScaleOptions)(options[key]) ? (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.normalizeScale)(key, options[key]) : null\n      );\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\n\nfunction exposeLegends(scales, context, defaults = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key)) throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales)) return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults[key], options), (key) => scales[key]);\n  };\n}\n\nfunction legendOptions({className, ...context}, {label, ticks, tickFormat} = {}, options) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.inherit)(options, {className, ...context}, {label, ticks, tickFormat});\n}\n\nfunction legendColor(color, {legend = true, ...options}) {\n  if (legend === true) legend = color.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color.domain === undefined) return; // no identity legend\n  switch (`${legend}`.toLowerCase()) {\n    case \"swatches\":\n      return (0,_legends_swatches_js__WEBPACK_IMPORTED_MODULE_1__.legendSwatches)(color, options);\n    case \"ramp\":\n      return (0,_legends_ramp_js__WEBPACK_IMPORTED_MODULE_5__.legendRamp)(color, options);\n    default:\n      throw new Error(`unknown legend type: ${legend}`);\n  }\n}\n\nfunction legendOpacity({type, interpolate, ...scale}, {legend = true, color = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rgb)(0, 0, 0), ...options}) {\n  if (!interpolate) throw new Error(`${type} opacity scales are not supported`);\n  if (legend === true) legend = \"ramp\";\n  if (`${legend}`.toLowerCase() !== \"ramp\") throw new Error(`${legend} opacity legends are not supported`);\n  return legendColor({type, ...scale, interpolate: interpolateOpacity(color)}, {legend, ...options});\n}\n\nfunction interpolateOpacity(color) {\n  const {r, g, b} = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rgb)(color) || (0,d3__WEBPACK_IMPORTED_MODULE_0__.rgb)(0, 0, 0); // treat invalid color as black\n  return (t) => `rgba(${r},${g},${b},${t})`;\n}\n\nfunction createLegends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend = value(scales[key], legendOptions(context, scales[key], o), (key) => scales[key]);\n      if (legend != null) legends.push(legend);\n    }\n  }\n  return legends;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9sZWdlbmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1QjtBQUNvQjtBQUNFO0FBQ3VCO0FBQ2Y7QUFDVjs7QUFFM0M7QUFDQSxhQUFhLCtEQUFhO0FBQzFCO0FBQ0E7QUFDQTs7QUFFTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLFFBQVEsMkRBQWM7QUFDdEIsdUJBQXVCO0FBQ3ZCLHNCQUFzQiwwREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQywyREFBYyx1Q0FBdUM7QUFDekcsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUJBQW1CLDBEQUFjO0FBQ2pDLFFBQVEsMkRBQWMsaUJBQWlCLDBEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFTyxxREFBcUQ7QUFDNUQ7QUFDQSwwRUFBMEUsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCLEdBQUcsMEJBQTBCLElBQUk7QUFDL0UsU0FBUyxvREFBTyxXQUFXLHNCQUFzQixHQUFHLHlCQUF5QjtBQUM3RTs7QUFFQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0EsMENBQTBDO0FBQzFDLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsb0VBQWM7QUFDM0I7QUFDQSxhQUFhLDREQUFVO0FBQ3ZCO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTs7QUFFQSx3QkFBd0IsNEJBQTRCLEdBQUcsdUJBQXVCLHVDQUFHLHNCQUFzQjtBQUN2Ryx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBLFNBQVMsT0FBTywrQ0FBK0MsUUFBUTtBQUN2RSxzQkFBc0IsdURBQXVELEdBQUcsbUJBQW1CO0FBQ25HOztBQUVBO0FBQ0EsU0FBUyxTQUFTLEVBQUUsdUNBQUcsV0FBVyx1Q0FBRyxXQUFXO0FBQ2hELHdCQUF3QixFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQ3pDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL2xlZ2VuZHMuanM/YjY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JnYn0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCB7bGVnZW5kUmFtcH0gZnJvbSBcIi4vbGVnZW5kcy9yYW1wLmpzXCI7XG5pbXBvcnQge2xlZ2VuZFN3YXRjaGVzLCBsZWdlbmRTeW1ib2xzfSBmcm9tIFwiLi9sZWdlbmRzL3N3YXRjaGVzLmpzXCI7XG5pbXBvcnQge2luaGVyaXQsIGlzU2NhbGVPcHRpb25zfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge25vcm1hbGl6ZVNjYWxlfSBmcm9tIFwiLi9zY2FsZXMuanNcIjtcblxuY29uc3QgbGVnZW5kUmVnaXN0cnkgPSBuZXcgTWFwKFtcbiAgW1wic3ltYm9sXCIsIGxlZ2VuZFN5bWJvbHNdLFxuICBbXCJjb2xvclwiLCBsZWdlbmRDb2xvcl0sXG4gIFtcIm9wYWNpdHlcIiwgbGVnZW5kT3BhY2l0eV1cbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gbGVnZW5kKG9wdGlvbnMgPSB7fSkge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBsZWdlbmRSZWdpc3RyeSkge1xuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChpc1NjYWxlT3B0aW9ucyhzY2FsZSkpIHtcbiAgICAgIC8vIGUuZy4sIGlnbm9yZSB7Y29sb3I6IFwicmVkXCJ9XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dChvcHRpb25zKTtcbiAgICAgIGxldCBoaW50O1xuICAgICAgLy8gRm9yIHN5bWJvbCBsZWdlbmRzLCBwYXNzIGEgaGludCB0byB0aGUgc3ltYm9sIHNjYWxlLlxuICAgICAgaWYgKGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBjb25zdCB7ZmlsbCwgc3Ryb2tlID0gZmlsbCA9PT0gdW5kZWZpbmVkICYmIGlzU2NhbGVPcHRpb25zKG9wdGlvbnMuY29sb3IpID8gXCJjb2xvclwiIDogdW5kZWZpbmVkfSA9IG9wdGlvbnM7XG4gICAgICAgIGhpbnQgPSB7ZmlsbCwgc3Ryb2tlfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZShub3JtYWxpemVTY2FsZShrZXksIHNjYWxlLCBoaW50KSwgbGVnZW5kT3B0aW9ucyhjb250ZXh0LCBzY2FsZSwgb3B0aW9ucyksIChrZXkpID0+XG4gICAgICAgIGlzU2NhbGVPcHRpb25zKG9wdGlvbnNba2V5XSkgPyBub3JtYWxpemVTY2FsZShrZXksIG9wdGlvbnNba2V5XSkgOiBudWxsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGxlZ2VuZCB0eXBlOyBubyBzY2FsZSBmb3VuZFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9zZUxlZ2VuZHMoc2NhbGVzLCBjb250ZXh0LCBkZWZhdWx0cyA9IHt9KSB7XG4gIHJldHVybiAoa2V5LCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFsZWdlbmRSZWdpc3RyeS5oYXMoa2V5KSkgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGxlZ2VuZCB0eXBlOiAke2tleX1gKTtcbiAgICBpZiAoIShrZXkgaW4gc2NhbGVzKSkgcmV0dXJuO1xuICAgIHJldHVybiBsZWdlbmRSZWdpc3RyeS5nZXQoa2V5KShzY2FsZXNba2V5XSwgbGVnZW5kT3B0aW9ucyhjb250ZXh0LCBkZWZhdWx0c1trZXldLCBvcHRpb25zKSwgKGtleSkgPT4gc2NhbGVzW2tleV0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdlbmRPcHRpb25zKHtjbGFzc05hbWUsIC4uLmNvbnRleHR9LCB7bGFiZWwsIHRpY2tzLCB0aWNrRm9ybWF0fSA9IHt9LCBvcHRpb25zKSB7XG4gIHJldHVybiBpbmhlcml0KG9wdGlvbnMsIHtjbGFzc05hbWUsIC4uLmNvbnRleHR9LCB7bGFiZWwsIHRpY2tzLCB0aWNrRm9ybWF0fSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZENvbG9yKGNvbG9yLCB7bGVnZW5kID0gdHJ1ZSwgLi4ub3B0aW9uc30pIHtcbiAgaWYgKGxlZ2VuZCA9PT0gdHJ1ZSkgbGVnZW5kID0gY29sb3IudHlwZSA9PT0gXCJvcmRpbmFsXCIgPyBcInN3YXRjaGVzXCIgOiBcInJhbXBcIjtcbiAgaWYgKGNvbG9yLmRvbWFpbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG5vIGlkZW50aXR5IGxlZ2VuZFxuICBzd2l0Y2ggKGAke2xlZ2VuZH1gLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwic3dhdGNoZXNcIjpcbiAgICAgIHJldHVybiBsZWdlbmRTd2F0Y2hlcyhjb2xvciwgb3B0aW9ucyk7XG4gICAgY2FzZSBcInJhbXBcIjpcbiAgICAgIHJldHVybiBsZWdlbmRSYW1wKGNvbG9yLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGxlZ2VuZCB0eXBlOiAke2xlZ2VuZH1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdlbmRPcGFjaXR5KHt0eXBlLCBpbnRlcnBvbGF0ZSwgLi4uc2NhbGV9LCB7bGVnZW5kID0gdHJ1ZSwgY29sb3IgPSByZ2IoMCwgMCwgMCksIC4uLm9wdGlvbnN9KSB7XG4gIGlmICghaW50ZXJwb2xhdGUpIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBvcGFjaXR5IHNjYWxlcyBhcmUgbm90IHN1cHBvcnRlZGApO1xuICBpZiAobGVnZW5kID09PSB0cnVlKSBsZWdlbmQgPSBcInJhbXBcIjtcbiAgaWYgKGAke2xlZ2VuZH1gLnRvTG93ZXJDYXNlKCkgIT09IFwicmFtcFwiKSB0aHJvdyBuZXcgRXJyb3IoYCR7bGVnZW5kfSBvcGFjaXR5IGxlZ2VuZHMgYXJlIG5vdCBzdXBwb3J0ZWRgKTtcbiAgcmV0dXJuIGxlZ2VuZENvbG9yKHt0eXBlLCAuLi5zY2FsZSwgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlT3BhY2l0eShjb2xvcil9LCB7bGVnZW5kLCAuLi5vcHRpb25zfSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlT3BhY2l0eShjb2xvcikge1xuICBjb25zdCB7ciwgZywgYn0gPSByZ2IoY29sb3IpIHx8IHJnYigwLCAwLCAwKTsgLy8gdHJlYXQgaW52YWxpZCBjb2xvciBhcyBibGFja1xuICByZXR1cm4gKHQpID0+IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7dH0pYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxlZ2VuZHMoc2NhbGVzLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGxlZ2VuZHMgPSBbXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbGVnZW5kUmVnaXN0cnkpIHtcbiAgICBjb25zdCBvID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvPy5sZWdlbmQgJiYga2V5IGluIHNjYWxlcykge1xuICAgICAgY29uc3QgbGVnZW5kID0gdmFsdWUoc2NhbGVzW2tleV0sIGxlZ2VuZE9wdGlvbnMoY29udGV4dCwgc2NhbGVzW2tleV0sIG8pLCAoa2V5KSA9PiBzY2FsZXNba2V5XSk7XG4gICAgICBpZiAobGVnZW5kICE9IG51bGwpIGxlZ2VuZHMucHVzaChsZWdlbmQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVnZW5kcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/legends.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/legends/ramp.js":
/*!*************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/legends/ramp.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   legendRamp: () => (/* binding */ legendRamp)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _axes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../axes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/axes.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_quantitative_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scales/quantitative.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\n\n\n\n\n\nfunction legendRamp(color, options) {\n  let {\n    label = color.label,\n    tickSize = 6,\n    width = 240,\n    height = 44 + tickSize,\n    marginTop = 18,\n    marginRight = 0,\n    marginBottom = 16 + tickSize,\n    marginLeft = 0,\n    style,\n    ticks = (width - marginLeft - marginRight) / 64,\n    tickFormat,\n    fontVariant = (0,_axes_js__WEBPACK_IMPORTED_MODULE_1__.inferFontVariant)(color),\n    round = true,\n    opacity,\n    className\n  } = options;\n  const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.createContext)(options);\n  className = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.maybeClassName)(className);\n  opacity = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.maybeNumberChannel)(opacity)[1];\n  if (tickFormat === null) tickFormat = () => null;\n\n  const svg = (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.create)(\"svg\", context)\n    .attr(\"class\", `${className}-ramp`)\n    .attr(\"font-family\", \"system-ui, sans-serif\")\n    .attr(\"font-size\", 10)\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", `0 0 ${width} ${height}`)\n    .call((svg) =>\n      // Warning: if you edit this, change defaultClassName.\n      svg.append(\"style\").text(\n        `:where(.${className}-ramp) {\n  display: block;\n  height: auto;\n  height: intrinsic;\n  max-width: 100%;\n  overflow: visible;\n}\n:where(.${className}-ramp text) {\n  white-space: pre;\n}`\n      )\n    )\n    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyInlineStyles, style);\n\n  let tickAdjust = (g) => g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n\n  let x;\n\n  // Some D3 scales use scale.interpolate, some scale.interpolator, and some\n  // scale.round; this normalizes the API so it works with all scale types.\n  const applyRange = round ? (x, range) => x.rangeRound(range) : (x, range) => x.range(range);\n\n  const {type, domain, range, interpolate, scale, pivot} = color;\n\n  // Continuous\n  if (interpolate) {\n    // Often interpolate is a “fixed” interpolator on the [0, 1] interval, as\n    // with a built-in color scheme, but sometimes it is a function that takes\n    // two arguments and is used in conjunction with the range.\n    const interpolator =\n      range === undefined\n        ? interpolate\n        : (0,d3__WEBPACK_IMPORTED_MODULE_0__.piecewise)(interpolate.length === 1 ? (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_5__.interpolatePiecewise)(interpolate) : interpolate, range);\n\n    // Construct a D3 scale of the same type, but with a range that evenly\n    // divides the horizontal extent of the legend. (In the common case, the\n    // domain.length is two, and so the range is simply the extent.) For a\n    // diverging scale, we need an extra point in the range for the pivot such\n    // that the pivot is always drawn in the middle.\n    x = applyRange(\n      scale.copy(),\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(\n        (0,d3__WEBPACK_IMPORTED_MODULE_0__.interpolateNumber)(marginLeft, width - marginRight),\n        Math.min(domain.length + (pivot !== undefined), range === undefined ? Infinity : range.length)\n      )\n    );\n\n    // Construct a 256×1 canvas, filling each pixel using the interpolator.\n    const n = 256;\n    const canvas = context.document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context2 = canvas.getContext(\"2d\");\n    for (let i = 0, j = n - 1; i < n; ++i) {\n      context2.fillStyle = interpolator(i / j);\n      context2.fillRect(i, 0, 1, 1);\n    }\n\n    svg\n      .append(\"image\")\n      .attr(\"opacity\", opacity)\n      .attr(\"x\", marginLeft)\n      .attr(\"y\", marginTop)\n      .attr(\"width\", width - marginLeft - marginRight)\n      .attr(\"height\", height - marginTop - marginBottom)\n      .attr(\"preserveAspectRatio\", \"none\")\n      .attr(\"xlink:href\", canvas.toDataURL());\n  }\n\n  // Threshold\n  else if (type === \"threshold\") {\n    const thresholds = domain;\n\n    const thresholdFormat =\n      tickFormat === undefined ? (d) => d : typeof tickFormat === \"string\" ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.format)(tickFormat) : tickFormat;\n\n    // Construct a linear scale with evenly-spaced ticks for each of the\n    // thresholds; the domain extends one beyond the threshold extent.\n    x = applyRange((0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleLinear)().domain([-1, range.length - 1]), [marginLeft, width - marginRight]);\n\n    svg\n      .append(\"g\")\n      .attr(\"fill-opacity\", opacity)\n      .selectAll()\n      .data(range)\n      .enter()\n      .append(\"rect\")\n      .attr(\"x\", (d, i) => x(i - 1))\n      .attr(\"y\", marginTop)\n      .attr(\"width\", (d, i) => x(i) - x(i - 1))\n      .attr(\"height\", height - marginTop - marginBottom)\n      .attr(\"fill\", (d) => d);\n\n    ticks = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.map)(thresholds, (_, i) => i);\n    tickFormat = (i) => thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal (hopefully!)\n  else {\n    x = applyRange((0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleBand)().domain(domain), [marginLeft, width - marginRight]);\n\n    svg\n      .append(\"g\")\n      .attr(\"fill-opacity\", opacity)\n      .selectAll()\n      .data(domain)\n      .enter()\n      .append(\"rect\")\n      .attr(\"x\", x)\n      .attr(\"y\", marginTop)\n      .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n      .attr(\"height\", height - marginTop - marginBottom)\n      .attr(\"fill\", scale);\n\n    tickAdjust = () => {};\n  }\n\n  svg\n    .append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)\n    .call(\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.axisBottom)(x)\n        .ticks(Array.isArray(ticks) ? null : ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(Array.isArray(ticks) ? ticks : null)\n    )\n    .attr(\"font-size\", null)\n    .attr(\"font-family\", null)\n    .attr(\"font-variant\", (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.impliedString)(fontVariant, \"normal\"))\n    .call(tickAdjust)\n    .call((g) => g.select(\".domain\").remove());\n\n  if (label !== undefined) {\n    svg\n      .append(\"text\")\n      .attr(\"x\", marginLeft)\n      .attr(\"y\", marginTop - 6)\n      .attr(\"fill\", \"currentColor\") // TODO move to stylesheet?\n      .attr(\"font-weight\", \"bold\")\n      .text(label);\n  }\n\n  return svg.node();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9sZWdlbmRzL3JhbXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRztBQUMxRDtBQUNRO0FBQ0U7QUFDUztBQUNjOztBQUV0RTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQiwwREFBYTtBQUMvQixjQUFjLHlEQUFjO0FBQzVCLFlBQVksK0RBQWtCO0FBQzlCOztBQUVBLGNBQWMsbURBQU07QUFDcEIsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxFQUFFLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxVQUFVLHdEQUFpQjs7QUFFM0I7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsU0FBUyxnREFBZ0Q7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUFTLDRCQUE0Qiw2RUFBb0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBUTtBQUNkLFFBQVEscURBQWlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFLDBDQUFNOztBQUVuRjtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUIsK0NBQVc7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFHO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBLE1BQU0sOENBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQWE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbGVnZW5kcy9yYW1wLmpzPzNhYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtxdWFudGl6ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIHBpZWNld2lzZSwgZm9ybWF0LCBzY2FsZUJhbmQsIHNjYWxlTGluZWFyLCBheGlzQm90dG9tfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7aW5mZXJGb250VmFyaWFudH0gZnJvbSBcIi4uL2F4ZXMuanNcIjtcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgY3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHttYXAsIG1heWJlTnVtYmVyQ2hhbm5lbH0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVQaWVjZXdpc2V9IGZyb20gXCIuLi9zY2FsZXMvcXVhbnRpdGF0aXZlLmpzXCI7XG5pbXBvcnQge2FwcGx5SW5saW5lU3R5bGVzLCBpbXBsaWVkU3RyaW5nLCBtYXliZUNsYXNzTmFtZX0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdlbmRSYW1wKGNvbG9yLCBvcHRpb25zKSB7XG4gIGxldCB7XG4gICAgbGFiZWwgPSBjb2xvci5sYWJlbCxcbiAgICB0aWNrU2l6ZSA9IDYsXG4gICAgd2lkdGggPSAyNDAsXG4gICAgaGVpZ2h0ID0gNDQgKyB0aWNrU2l6ZSxcbiAgICBtYXJnaW5Ub3AgPSAxOCxcbiAgICBtYXJnaW5SaWdodCA9IDAsXG4gICAgbWFyZ2luQm90dG9tID0gMTYgKyB0aWNrU2l6ZSxcbiAgICBtYXJnaW5MZWZ0ID0gMCxcbiAgICBzdHlsZSxcbiAgICB0aWNrcyA9ICh3aWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodCkgLyA2NCxcbiAgICB0aWNrRm9ybWF0LFxuICAgIGZvbnRWYXJpYW50ID0gaW5mZXJGb250VmFyaWFudChjb2xvciksXG4gICAgcm91bmQgPSB0cnVlLFxuICAgIG9wYWNpdHksXG4gICAgY2xhc3NOYW1lXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dChvcHRpb25zKTtcbiAgY2xhc3NOYW1lID0gbWF5YmVDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgb3BhY2l0eSA9IG1heWJlTnVtYmVyQ2hhbm5lbChvcGFjaXR5KVsxXTtcbiAgaWYgKHRpY2tGb3JtYXQgPT09IG51bGwpIHRpY2tGb3JtYXQgPSAoKSA9PiBudWxsO1xuXG4gIGNvbnN0IHN2ZyA9IGNyZWF0ZShcInN2Z1wiLCBjb250ZXh0KVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgYCR7Y2xhc3NOYW1lfS1yYW1wYClcbiAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsIFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIpXG4gICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgLmF0dHIoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YClcbiAgICAuY2FsbCgoc3ZnKSA9PlxuICAgICAgLy8gV2FybmluZzogaWYgeW91IGVkaXQgdGhpcywgY2hhbmdlIGRlZmF1bHRDbGFzc05hbWUuXG4gICAgICBzdmcuYXBwZW5kKFwic3R5bGVcIikudGV4dChcbiAgICAgICAgYDp3aGVyZSguJHtjbGFzc05hbWV9LXJhbXApIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogYXV0bztcbiAgaGVpZ2h0OiBpbnRyaW5zaWM7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgb3ZlcmZsb3c6IHZpc2libGU7XG59XG46d2hlcmUoLiR7Y2xhc3NOYW1lfS1yYW1wIHRleHQpIHtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbn1gXG4gICAgICApXG4gICAgKVxuICAgIC5jYWxsKGFwcGx5SW5saW5lU3R5bGVzLCBzdHlsZSk7XG5cbiAgbGV0IHRpY2tBZGp1c3QgPSAoZykgPT4gZy5zZWxlY3RBbGwoXCIudGljayBsaW5lXCIpLmF0dHIoXCJ5MVwiLCBtYXJnaW5Ub3AgKyBtYXJnaW5Cb3R0b20gLSBoZWlnaHQpO1xuXG4gIGxldCB4O1xuXG4gIC8vIFNvbWUgRDMgc2NhbGVzIHVzZSBzY2FsZS5pbnRlcnBvbGF0ZSwgc29tZSBzY2FsZS5pbnRlcnBvbGF0b3IsIGFuZCBzb21lXG4gIC8vIHNjYWxlLnJvdW5kOyB0aGlzIG5vcm1hbGl6ZXMgdGhlIEFQSSBzbyBpdCB3b3JrcyB3aXRoIGFsbCBzY2FsZSB0eXBlcy5cbiAgY29uc3QgYXBwbHlSYW5nZSA9IHJvdW5kID8gKHgsIHJhbmdlKSA9PiB4LnJhbmdlUm91bmQocmFuZ2UpIDogKHgsIHJhbmdlKSA9PiB4LnJhbmdlKHJhbmdlKTtcblxuICBjb25zdCB7dHlwZSwgZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUsIHNjYWxlLCBwaXZvdH0gPSBjb2xvcjtcblxuICAvLyBDb250aW51b3VzXG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIC8vIE9mdGVuIGludGVycG9sYXRlIGlzIGEg4oCcZml4ZWTigJ0gaW50ZXJwb2xhdG9yIG9uIHRoZSBbMCwgMV0gaW50ZXJ2YWwsIGFzXG4gICAgLy8gd2l0aCBhIGJ1aWx0LWluIGNvbG9yIHNjaGVtZSwgYnV0IHNvbWV0aW1lcyBpdCBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAgICAvLyB0d28gYXJndW1lbnRzIGFuZCBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHJhbmdlLlxuICAgIGNvbnN0IGludGVycG9sYXRvciA9XG4gICAgICByYW5nZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gaW50ZXJwb2xhdGVcbiAgICAgICAgOiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUubGVuZ3RoID09PSAxID8gaW50ZXJwb2xhdGVQaWVjZXdpc2UoaW50ZXJwb2xhdGUpIDogaW50ZXJwb2xhdGUsIHJhbmdlKTtcblxuICAgIC8vIENvbnN0cnVjdCBhIEQzIHNjYWxlIG9mIHRoZSBzYW1lIHR5cGUsIGJ1dCB3aXRoIGEgcmFuZ2UgdGhhdCBldmVubHlcbiAgICAvLyBkaXZpZGVzIHRoZSBob3Jpem9udGFsIGV4dGVudCBvZiB0aGUgbGVnZW5kLiAoSW4gdGhlIGNvbW1vbiBjYXNlLCB0aGVcbiAgICAvLyBkb21haW4ubGVuZ3RoIGlzIHR3bywgYW5kIHNvIHRoZSByYW5nZSBpcyBzaW1wbHkgdGhlIGV4dGVudC4pIEZvciBhXG4gICAgLy8gZGl2ZXJnaW5nIHNjYWxlLCB3ZSBuZWVkIGFuIGV4dHJhIHBvaW50IGluIHRoZSByYW5nZSBmb3IgdGhlIHBpdm90IHN1Y2hcbiAgICAvLyB0aGF0IHRoZSBwaXZvdCBpcyBhbHdheXMgZHJhd24gaW4gdGhlIG1pZGRsZS5cbiAgICB4ID0gYXBwbHlSYW5nZShcbiAgICAgIHNjYWxlLmNvcHkoKSxcbiAgICAgIHF1YW50aXplKFxuICAgICAgICBpbnRlcnBvbGF0ZU51bWJlcihtYXJnaW5MZWZ0LCB3aWR0aCAtIG1hcmdpblJpZ2h0KSxcbiAgICAgICAgTWF0aC5taW4oZG9tYWluLmxlbmd0aCArIChwaXZvdCAhPT0gdW5kZWZpbmVkKSwgcmFuZ2UgPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogcmFuZ2UubGVuZ3RoKVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDb25zdHJ1Y3QgYSAyNTbDlzEgY2FudmFzLCBmaWxsaW5nIGVhY2ggcGl4ZWwgdXNpbmcgdGhlIGludGVycG9sYXRvci5cbiAgICBjb25zdCBuID0gMjU2O1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBuO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IGNvbnRleHQyID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG4gLSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb250ZXh0Mi5maWxsU3R5bGUgPSBpbnRlcnBvbGF0b3IoaSAvIGopO1xuICAgICAgY29udGV4dDIuZmlsbFJlY3QoaSwgMCwgMSwgMSk7XG4gICAgfVxuXG4gICAgc3ZnXG4gICAgICAuYXBwZW5kKFwiaW1hZ2VcIilcbiAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBvcGFjaXR5KVxuICAgICAgLmF0dHIoXCJ4XCIsIG1hcmdpbkxlZnQpXG4gICAgICAuYXR0cihcInlcIiwgbWFyZ2luVG9wKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbSlcbiAgICAgIC5hdHRyKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIilcbiAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBjYW52YXMudG9EYXRhVVJMKCkpO1xuICB9XG5cbiAgLy8gVGhyZXNob2xkXG4gIGVsc2UgaWYgKHR5cGUgPT09IFwidGhyZXNob2xkXCIpIHtcbiAgICBjb25zdCB0aHJlc2hvbGRzID0gZG9tYWluO1xuXG4gICAgY29uc3QgdGhyZXNob2xkRm9ybWF0ID1cbiAgICAgIHRpY2tGb3JtYXQgPT09IHVuZGVmaW5lZCA/IChkKSA9PiBkIDogdHlwZW9mIHRpY2tGb3JtYXQgPT09IFwic3RyaW5nXCIgPyBmb3JtYXQodGlja0Zvcm1hdCkgOiB0aWNrRm9ybWF0O1xuXG4gICAgLy8gQ29uc3RydWN0IGEgbGluZWFyIHNjYWxlIHdpdGggZXZlbmx5LXNwYWNlZCB0aWNrcyBmb3IgZWFjaCBvZiB0aGVcbiAgICAvLyB0aHJlc2hvbGRzOyB0aGUgZG9tYWluIGV4dGVuZHMgb25lIGJleW9uZCB0aGUgdGhyZXNob2xkIGV4dGVudC5cbiAgICB4ID0gYXBwbHlSYW5nZShzY2FsZUxpbmVhcigpLmRvbWFpbihbLTEsIHJhbmdlLmxlbmd0aCAtIDFdKSwgW21hcmdpbkxlZnQsIHdpZHRoIC0gbWFyZ2luUmlnaHRdKTtcblxuICAgIHN2Z1xuICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHkpXG4gICAgICAuc2VsZWN0QWxsKClcbiAgICAgIC5kYXRhKHJhbmdlKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IHgoaSAtIDEpKVxuICAgICAgLmF0dHIoXCJ5XCIsIG1hcmdpblRvcClcbiAgICAgIC5hdHRyKFwid2lkdGhcIiwgKGQsIGkpID0+IHgoaSkgLSB4KGkgLSAxKSlcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbSlcbiAgICAgIC5hdHRyKFwiZmlsbFwiLCAoZCkgPT4gZCk7XG5cbiAgICB0aWNrcyA9IG1hcCh0aHJlc2hvbGRzLCAoXywgaSkgPT4gaSk7XG4gICAgdGlja0Zvcm1hdCA9IChpKSA9PiB0aHJlc2hvbGRGb3JtYXQodGhyZXNob2xkc1tpXSwgaSk7XG4gIH1cblxuICAvLyBPcmRpbmFsIChob3BlZnVsbHkhKVxuICBlbHNlIHtcbiAgICB4ID0gYXBwbHlSYW5nZShzY2FsZUJhbmQoKS5kb21haW4oZG9tYWluKSwgW21hcmdpbkxlZnQsIHdpZHRoIC0gbWFyZ2luUmlnaHRdKTtcblxuICAgIHN2Z1xuICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHkpXG4gICAgICAuc2VsZWN0QWxsKClcbiAgICAgIC5kYXRhKGRvbWFpbilcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgLmF0dHIoXCJ4XCIsIHgpXG4gICAgICAuYXR0cihcInlcIiwgbWFyZ2luVG9wKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLm1heCgwLCB4LmJhbmR3aWR0aCgpIC0gMSkpXG4gICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgLSBtYXJnaW5Ub3AgLSBtYXJnaW5Cb3R0b20pXG4gICAgICAuYXR0cihcImZpbGxcIiwgc2NhbGUpO1xuXG4gICAgdGlja0FkanVzdCA9ICgpID0+IHt9O1xuICB9XG5cbiAgc3ZnXG4gICAgLmFwcGVuZChcImdcIilcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKDAsJHtoZWlnaHQgLSBtYXJnaW5Cb3R0b219KWApXG4gICAgLmNhbGwoXG4gICAgICBheGlzQm90dG9tKHgpXG4gICAgICAgIC50aWNrcyhBcnJheS5pc0FycmF5KHRpY2tzKSA/IG51bGwgOiB0aWNrcywgdHlwZW9mIHRpY2tGb3JtYXQgPT09IFwic3RyaW5nXCIgPyB0aWNrRm9ybWF0IDogdW5kZWZpbmVkKVxuICAgICAgICAudGlja0Zvcm1hdCh0eXBlb2YgdGlja0Zvcm1hdCA9PT0gXCJmdW5jdGlvblwiID8gdGlja0Zvcm1hdCA6IHVuZGVmaW5lZClcbiAgICAgICAgLnRpY2tTaXplKHRpY2tTaXplKVxuICAgICAgICAudGlja1ZhbHVlcyhBcnJheS5pc0FycmF5KHRpY2tzKSA/IHRpY2tzIDogbnVsbClcbiAgICApXG4gICAgLmF0dHIoXCJmb250LXNpemVcIiwgbnVsbClcbiAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsIG51bGwpXG4gICAgLmF0dHIoXCJmb250LXZhcmlhbnRcIiwgaW1wbGllZFN0cmluZyhmb250VmFyaWFudCwgXCJub3JtYWxcIikpXG4gICAgLmNhbGwodGlja0FkanVzdClcbiAgICAuY2FsbCgoZykgPT4gZy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpKTtcblxuICBpZiAobGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHN2Z1xuICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgIC5hdHRyKFwieFwiLCBtYXJnaW5MZWZ0KVxuICAgICAgLmF0dHIoXCJ5XCIsIG1hcmdpblRvcCAtIDYpXG4gICAgICAuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIikgLy8gVE9ETyBtb3ZlIHRvIHN0eWxlc2hlZXQ/XG4gICAgICAuYXR0cihcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgLnRleHQobGFiZWwpO1xuICB9XG5cbiAgcmV0dXJuIHN2Zy5ub2RlKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/legends/ramp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/legends/swatches.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/legends/swatches.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   legendSwatches: () => (/* binding */ legendSwatches),\n/* harmony export */   legendSymbols: () => (/* binding */ legendSymbols)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _axes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/axes.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _marks_axis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../marks/axis.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js\");\n\n\n\n\n\n\n\n\nfunction maybeScale(scale, key) {\n  if (key == null) return key;\n  const s = scale(key);\n  if (!s) throw new Error(`scale not found: ${key}`);\n  return s;\n}\n\nfunction legendSwatches(color, {opacity, ...options} = {}) {\n  if (!(0,_scales_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinalScale)(color) && !(0,_scales_js__WEBPACK_IMPORTED_MODULE_1__.isThresholdScale)(color))\n    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color.type})`);\n  return legendItems(color, options, (selection, scale, width, height) =>\n    selection\n      .append(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"fill\", scale.scale)\n      .attr(\"fill-opacity\", (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(opacity)[1])\n      .append(\"rect\")\n      .attr(\"width\", \"100%\")\n      .attr(\"height\", \"100%\")\n  );\n}\n\nfunction legendSymbols(\n  symbol,\n  {\n    fill = symbol.hint?.fill !== undefined ? symbol.hint.fill : \"none\",\n    fillOpacity = 1,\n    stroke = symbol.hint?.stroke !== undefined ? symbol.hint.stroke : (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNoneish)(fill) ? \"currentColor\" : \"none\",\n    strokeOpacity = 1,\n    strokeWidth = 1.5,\n    r = 4.5,\n    ...options\n  } = {},\n  scale\n) {\n  const [vf, cf] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeColorChannel)(fill);\n  const [vs, cs] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeColorChannel)(stroke);\n  const sf = maybeScale(scale, vf);\n  const ss = maybeScale(scale, vs);\n  const size = r * r * Math.PI;\n  fillOpacity = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(fillOpacity)[1];\n  strokeOpacity = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(strokeOpacity)[1];\n  strokeWidth = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(strokeWidth)[1];\n  return legendItems(symbol, options, (selection, scale, width, height) =>\n    selection\n      .append(\"svg\")\n      .attr(\"viewBox\", \"-8 -8 16 16\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"fill\", vf === \"color\" ? (d) => sf.scale(d) : cf)\n      .attr(\"fill-opacity\", fillOpacity)\n      .attr(\"stroke\", vs === \"color\" ? (d) => ss.scale(d) : cs)\n      .attr(\"stroke-opacity\", strokeOpacity)\n      .attr(\"stroke-width\", strokeWidth)\n      .append(\"path\")\n      .attr(\"d\", (d) => {\n        const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n        symbol.scale(d).draw(p, size);\n        return p;\n      })\n  );\n}\n\nfunction legendItems(scale, options = {}, swatch) {\n  let {\n    columns,\n    tickFormat,\n    fontVariant = (0,_axes_js__WEBPACK_IMPORTED_MODULE_3__.inferFontVariant)(scale),\n    // TODO label,\n    swatchSize = 15,\n    swatchWidth = swatchSize,\n    swatchHeight = swatchSize,\n    marginLeft = 0,\n    className,\n    style,\n    width\n  } = options;\n  const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.createContext)(options);\n  className = (0,_style_js__WEBPACK_IMPORTED_MODULE_5__.maybeClassName)(className);\n  tickFormat = (0,_marks_axis_js__WEBPACK_IMPORTED_MODULE_6__.inferTickFormat)(scale.scale, scale.domain, undefined, tickFormat);\n\n  const swatches = (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"div\", context).attr(\n    \"class\",\n    `${className}-swatches ${className}-swatches-${columns != null ? \"columns\" : \"wrap\"}`\n  );\n\n  let extraStyle;\n\n  if (columns != null) {\n    extraStyle = `:where(.${className}-swatches-columns .${className}-swatch) {\n  display: flex;\n  align-items: center;\n  break-inside: avoid;\n  padding-bottom: 1px;\n}\n:where(.${className}-swatches-columns .${className}-swatch::before) {\n  flex-shrink: 0;\n}\n:where(.${className}-swatches-columns .${className}-swatch-label) {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}`;\n\n    swatches\n      .style(\"columns\", columns)\n      .selectAll()\n      .data(scale.domain)\n      .enter()\n      .append(\"div\")\n      .attr(\"class\", `${className}-swatch`)\n      .call(swatch, scale, swatchWidth, swatchHeight)\n      .call((item) =>\n        item.append(\"div\").attr(\"class\", `${className}-swatch-label`).attr(\"title\", tickFormat).text(tickFormat)\n      );\n  } else {\n    extraStyle = `:where(.${className}-swatches-wrap) {\n  display: flex;\n  align-items: center;\n  min-height: 33px;\n  flex-wrap: wrap;\n}\n:where(.${className}-swatches-wrap .${className}-swatch) {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}`;\n\n    swatches\n      .selectAll()\n      .data(scale.domain)\n      .enter()\n      .append(\"span\")\n      .attr(\"class\", `${className}-swatch`)\n      .call(swatch, scale, swatchWidth, swatchHeight)\n      .append(function () {\n        return this.ownerDocument.createTextNode(tickFormat.apply(this, arguments));\n      });\n  }\n\n  return swatches\n    .call((div) =>\n      div.insert(\"style\", \"*\").text(\n        `:where(.${className}-swatches) {\n  font-family: system-ui, sans-serif;\n  font-size: 10px;\n  margin-bottom: 0.5em;\n}\n:where(.${className}-swatch > svg) {\n  margin-right: 0.5em;\n  overflow: visible;\n}\n${extraStyle}`\n      )\n    )\n    .style(\"margin-left\", marginLeft ? `${+marginLeft}px` : null)\n    .style(\"width\", width === undefined ? null : `${+width}px`)\n    .style(\"font-variant\", (0,_style_js__WEBPACK_IMPORTED_MODULE_5__.impliedString)(fontVariant, \"normal\"))\n    .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyInlineStyles, style)\n    .node();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9sZWdlbmRzL3N3YXRjaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxQztBQUNPO0FBQ1E7QUFDMkI7QUFDakI7QUFDZTtBQUM1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7QUFDQTs7QUFFTyxnQ0FBZ0MscUJBQXFCLElBQUk7QUFDaEUsT0FBTywwREFBYyxZQUFZLDREQUFnQjtBQUNqRCxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxzREFBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUIsOERBQWlCO0FBQ3BDLG1CQUFtQiw4REFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFrQjtBQUNsQyxrQkFBa0IsK0RBQWtCO0FBQ3BDLGdCQUFnQiwrREFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQUk7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLDBEQUFhO0FBQy9CLGNBQWMseURBQWM7QUFDNUIsZUFBZSwrREFBZTs7QUFFOUIsbUJBQW1CLG1EQUFNO0FBQ3pCO0FBQ0EsT0FBTyxVQUFVLFlBQVksVUFBVSxZQUFZLHFDQUFxQztBQUN4Rjs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixVQUFVLHFCQUFxQixVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVUscUJBQXFCLFVBQVU7QUFDbkQ7QUFDQTtBQUNBLFVBQVUsVUFBVSxxQkFBcUIsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBLElBQUk7QUFDSiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVLGtCQUFrQixVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLFdBQVc7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsb0RBQW9ELE9BQU87QUFDM0QsMkJBQTJCLHdEQUFhO0FBQ3hDLFVBQVUsd0RBQWlCO0FBQzNCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL2xlZ2VuZHMvc3dhdGNoZXMuanM/N2ZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhdGhSb3VuZCBhcyBwYXRofSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7aW5mZXJGb250VmFyaWFudH0gZnJvbSBcIi4uL2F4ZXMuanNcIjtcbmltcG9ydCB7Y3JlYXRlLCBjcmVhdGVDb250ZXh0fSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtpc05vbmVpc2gsIG1heWJlQ29sb3JDaGFubmVsLCBtYXliZU51bWJlckNoYW5uZWx9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2lzT3JkaW5hbFNjYWxlLCBpc1RocmVzaG9sZFNjYWxlfSBmcm9tIFwiLi4vc2NhbGVzLmpzXCI7XG5pbXBvcnQge2FwcGx5SW5saW5lU3R5bGVzLCBpbXBsaWVkU3RyaW5nLCBtYXliZUNsYXNzTmFtZX0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge2luZmVyVGlja0Zvcm1hdH0gZnJvbSBcIi4uL21hcmtzL2F4aXMuanNcIjtcblxuZnVuY3Rpb24gbWF5YmVTY2FsZShzY2FsZSwga2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIGtleTtcbiAgY29uc3QgcyA9IHNjYWxlKGtleSk7XG4gIGlmICghcykgdGhyb3cgbmV3IEVycm9yKGBzY2FsZSBub3QgZm91bmQ6ICR7a2V5fWApO1xuICByZXR1cm4gcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZ2VuZFN3YXRjaGVzKGNvbG9yLCB7b3BhY2l0eSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBpZiAoIWlzT3JkaW5hbFNjYWxlKGNvbG9yKSAmJiAhaXNUaHJlc2hvbGRTY2FsZShjb2xvcikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBzd2F0Y2hlcyBsZWdlbmQgcmVxdWlyZXMgb3JkaW5hbCBvciB0aHJlc2hvbGQgY29sb3Igc2NhbGUgKG5vdCAke2NvbG9yLnR5cGV9KWApO1xuICByZXR1cm4gbGVnZW5kSXRlbXMoY29sb3IsIG9wdGlvbnMsIChzZWxlY3Rpb24sIHNjYWxlLCB3aWR0aCwgaGVpZ2h0KSA9PlxuICAgIHNlbGVjdGlvblxuICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgIC5hdHRyKFwiZmlsbFwiLCBzY2FsZS5zY2FsZSlcbiAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIG1heWJlTnVtYmVyQ2hhbm5lbChvcGFjaXR5KVsxXSlcbiAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdlbmRTeW1ib2xzKFxuICBzeW1ib2wsXG4gIHtcbiAgICBmaWxsID0gc3ltYm9sLmhpbnQ/LmZpbGwgIT09IHVuZGVmaW5lZCA/IHN5bWJvbC5oaW50LmZpbGwgOiBcIm5vbmVcIixcbiAgICBmaWxsT3BhY2l0eSA9IDEsXG4gICAgc3Ryb2tlID0gc3ltYm9sLmhpbnQ/LnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gc3ltYm9sLmhpbnQuc3Ryb2tlIDogaXNOb25laXNoKGZpbGwpID8gXCJjdXJyZW50Q29sb3JcIiA6IFwibm9uZVwiLFxuICAgIHN0cm9rZU9wYWNpdHkgPSAxLFxuICAgIHN0cm9rZVdpZHRoID0gMS41LFxuICAgIHIgPSA0LjUsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge30sXG4gIHNjYWxlXG4pIHtcbiAgY29uc3QgW3ZmLCBjZl0gPSBtYXliZUNvbG9yQ2hhbm5lbChmaWxsKTtcbiAgY29uc3QgW3ZzLCBjc10gPSBtYXliZUNvbG9yQ2hhbm5lbChzdHJva2UpO1xuICBjb25zdCBzZiA9IG1heWJlU2NhbGUoc2NhbGUsIHZmKTtcbiAgY29uc3Qgc3MgPSBtYXliZVNjYWxlKHNjYWxlLCB2cyk7XG4gIGNvbnN0IHNpemUgPSByICogciAqIE1hdGguUEk7XG4gIGZpbGxPcGFjaXR5ID0gbWF5YmVOdW1iZXJDaGFubmVsKGZpbGxPcGFjaXR5KVsxXTtcbiAgc3Ryb2tlT3BhY2l0eSA9IG1heWJlTnVtYmVyQ2hhbm5lbChzdHJva2VPcGFjaXR5KVsxXTtcbiAgc3Ryb2tlV2lkdGggPSBtYXliZU51bWJlckNoYW5uZWwoc3Ryb2tlV2lkdGgpWzFdO1xuICByZXR1cm4gbGVnZW5kSXRlbXMoc3ltYm9sLCBvcHRpb25zLCAoc2VsZWN0aW9uLCBzY2FsZSwgd2lkdGgsIGhlaWdodCkgPT5cbiAgICBzZWxlY3Rpb25cbiAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgIC5hdHRyKFwidmlld0JveFwiLCBcIi04IC04IDE2IDE2XCIpXG4gICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgLmF0dHIoXCJmaWxsXCIsIHZmID09PSBcImNvbG9yXCIgPyAoZCkgPT4gc2Yuc2NhbGUoZCkgOiBjZilcbiAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIGZpbGxPcGFjaXR5KVxuICAgICAgLmF0dHIoXCJzdHJva2VcIiwgdnMgPT09IFwiY29sb3JcIiA/IChkKSA9PiBzcy5zY2FsZShkKSA6IGNzKVxuICAgICAgLmF0dHIoXCJzdHJva2Utb3BhY2l0eVwiLCBzdHJva2VPcGFjaXR5KVxuICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgc3Ryb2tlV2lkdGgpXG4gICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgLmF0dHIoXCJkXCIsIChkKSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBwYXRoKCk7XG4gICAgICAgIHN5bWJvbC5zY2FsZShkKS5kcmF3KHAsIHNpemUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEl0ZW1zKHNjYWxlLCBvcHRpb25zID0ge30sIHN3YXRjaCkge1xuICBsZXQge1xuICAgIGNvbHVtbnMsXG4gICAgdGlja0Zvcm1hdCxcbiAgICBmb250VmFyaWFudCA9IGluZmVyRm9udFZhcmlhbnQoc2NhbGUpLFxuICAgIC8vIFRPRE8gbGFiZWwsXG4gICAgc3dhdGNoU2l6ZSA9IDE1LFxuICAgIHN3YXRjaFdpZHRoID0gc3dhdGNoU2l6ZSxcbiAgICBzd2F0Y2hIZWlnaHQgPSBzd2F0Y2hTaXplLFxuICAgIG1hcmdpbkxlZnQgPSAwLFxuICAgIGNsYXNzTmFtZSxcbiAgICBzdHlsZSxcbiAgICB3aWR0aFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvbnRleHQob3B0aW9ucyk7XG4gIGNsYXNzTmFtZSA9IG1heWJlQ2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gIHRpY2tGb3JtYXQgPSBpbmZlclRpY2tGb3JtYXQoc2NhbGUuc2NhbGUsIHNjYWxlLmRvbWFpbiwgdW5kZWZpbmVkLCB0aWNrRm9ybWF0KTtcblxuICBjb25zdCBzd2F0Y2hlcyA9IGNyZWF0ZShcImRpdlwiLCBjb250ZXh0KS5hdHRyKFxuICAgIFwiY2xhc3NcIixcbiAgICBgJHtjbGFzc05hbWV9LXN3YXRjaGVzICR7Y2xhc3NOYW1lfS1zd2F0Y2hlcy0ke2NvbHVtbnMgIT0gbnVsbCA/IFwiY29sdW1uc1wiIDogXCJ3cmFwXCJ9YFxuICApO1xuXG4gIGxldCBleHRyYVN0eWxlO1xuXG4gIGlmIChjb2x1bW5zICE9IG51bGwpIHtcbiAgICBleHRyYVN0eWxlID0gYDp3aGVyZSguJHtjbGFzc05hbWV9LXN3YXRjaGVzLWNvbHVtbnMgLiR7Y2xhc3NOYW1lfS1zd2F0Y2gpIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYnJlYWstaW5zaWRlOiBhdm9pZDtcbiAgcGFkZGluZy1ib3R0b206IDFweDtcbn1cbjp3aGVyZSguJHtjbGFzc05hbWV9LXN3YXRjaGVzLWNvbHVtbnMgLiR7Y2xhc3NOYW1lfS1zd2F0Y2g6OmJlZm9yZSkge1xuICBmbGV4LXNocmluazogMDtcbn1cbjp3aGVyZSguJHtjbGFzc05hbWV9LXN3YXRjaGVzLWNvbHVtbnMgLiR7Y2xhc3NOYW1lfS1zd2F0Y2gtbGFiZWwpIHtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG59YDtcblxuICAgIHN3YXRjaGVzXG4gICAgICAuc3R5bGUoXCJjb2x1bW5zXCIsIGNvbHVtbnMpXG4gICAgICAuc2VsZWN0QWxsKClcbiAgICAgIC5kYXRhKHNjYWxlLmRvbWFpbilcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIGAke2NsYXNzTmFtZX0tc3dhdGNoYClcbiAgICAgIC5jYWxsKHN3YXRjaCwgc2NhbGUsIHN3YXRjaFdpZHRoLCBzd2F0Y2hIZWlnaHQpXG4gICAgICAuY2FsbCgoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsIGAke2NsYXNzTmFtZX0tc3dhdGNoLWxhYmVsYCkuYXR0cihcInRpdGxlXCIsIHRpY2tGb3JtYXQpLnRleHQodGlja0Zvcm1hdClcbiAgICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZXh0cmFTdHlsZSA9IGA6d2hlcmUoLiR7Y2xhc3NOYW1lfS1zd2F0Y2hlcy13cmFwKSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIG1pbi1oZWlnaHQ6IDMzcHg7XG4gIGZsZXgtd3JhcDogd3JhcDtcbn1cbjp3aGVyZSguJHtjbGFzc05hbWV9LXN3YXRjaGVzLXdyYXAgLiR7Y2xhc3NOYW1lfS1zd2F0Y2gpIHtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIG1hcmdpbi1yaWdodDogMWVtO1xufWA7XG5cbiAgICBzd2F0Y2hlc1xuICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAuZGF0YShzY2FsZS5kb21haW4pXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgYCR7Y2xhc3NOYW1lfS1zd2F0Y2hgKVxuICAgICAgLmNhbGwoc3dhdGNoLCBzY2FsZSwgc3dhdGNoV2lkdGgsIHN3YXRjaEhlaWdodClcbiAgICAgIC5hcHBlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRpY2tGb3JtYXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzd2F0Y2hlc1xuICAgIC5jYWxsKChkaXYpID0+XG4gICAgICBkaXYuaW5zZXJ0KFwic3R5bGVcIiwgXCIqXCIpLnRleHQoXG4gICAgICAgIGA6d2hlcmUoLiR7Y2xhc3NOYW1lfS1zd2F0Y2hlcykge1xuICBmb250LWZhbWlseTogc3lzdGVtLXVpLCBzYW5zLXNlcmlmO1xuICBmb250LXNpemU6IDEwcHg7XG4gIG1hcmdpbi1ib3R0b206IDAuNWVtO1xufVxuOndoZXJlKC4ke2NsYXNzTmFtZX0tc3dhdGNoID4gc3ZnKSB7XG4gIG1hcmdpbi1yaWdodDogMC41ZW07XG4gIG92ZXJmbG93OiB2aXNpYmxlO1xufVxuJHtleHRyYVN0eWxlfWBcbiAgICAgIClcbiAgICApXG4gICAgLnN0eWxlKFwibWFyZ2luLWxlZnRcIiwgbWFyZ2luTGVmdCA/IGAkeyttYXJnaW5MZWZ0fXB4YCA6IG51bGwpXG4gICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggPT09IHVuZGVmaW5lZCA/IG51bGwgOiBgJHsrd2lkdGh9cHhgKVxuICAgIC5zdHlsZShcImZvbnQtdmFyaWFudFwiLCBpbXBsaWVkU3RyaW5nKGZvbnRWYXJpYW50LCBcIm5vcm1hbFwiKSlcbiAgICAuY2FsbChhcHBseUlubGluZVN0eWxlcywgc3R5bGUpXG4gICAgLm5vZGUoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/legends/swatches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/mark.js":
/*!*****************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/mark.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   composeRender: () => (/* binding */ composeRender),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   withTip: () => (/* binding */ withTip)\n/* harmony export */ });\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _facet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./facet.js */ \"(ssr)/./node_modules/@observablehq/plot/src/facet.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\n\n\n\n\nclass Mark {\n  constructor(data, channels = {}, options = {}, defaults) {\n    const {\n      facet = \"auto\",\n      facetAnchor,\n      fx,\n      fy,\n      sort,\n      dx = 0,\n      dy = 0,\n      margin = 0,\n      marginTop = margin,\n      marginRight = margin,\n      marginBottom = margin,\n      marginLeft = margin,\n      className,\n      clip = defaults?.clip,\n      channels: extraChannels,\n      tip,\n      render\n    } = options;\n    this.data = data;\n    this.sort = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isDomainSort)(sort) ? sort : null;\n    this.initializer = (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_1__.initializer)(options).initializer;\n    this.transform = this.initializer ? options.transform : (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_1__.basic)(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.keyword)(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = data === _options_js__WEBPACK_IMPORTED_MODULE_0__.singleton && typeof fx === \"string\" ? [fx] : fx;\n      this.fy = data === _options_js__WEBPACK_IMPORTED_MODULE_0__.singleton && typeof fy === \"string\" ? [fy] : fy;\n    }\n    this.facetAnchor = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.maybeFacetAnchor)(facetAnchor);\n    channels = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeNamed)(channels);\n    if (extraChannels !== undefined) channels = {...maybeChannels(extraChannels), ...channels};\n    if (defaults !== undefined) channels = {...(0,_style_js__WEBPACK_IMPORTED_MODULE_3__.styles)(this, options, defaults), ...channels};\n    this.channels = Object.fromEntries(\n      Object.entries(channels)\n        .map(([name, channel]) => {\n          if ((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isOptions)(channel.value)) {\n            // apply scale and label overrides\n            const {value, label = channel.label, scale = channel.scale} = channel.value;\n            channel = {...channel, label, scale, value};\n          }\n          if (data === _options_js__WEBPACK_IMPORTED_MODULE_0__.singleton && typeof channel.value === \"string\") {\n            // convert field names to singleton values for decoration marks (e.g., frame)\n            const {value} = channel;\n            channel = {...channel, value: [value]};\n          }\n          return [name, channel];\n        })\n        .filter(([name, {value, optional}]) => {\n          if (value != null) return true;\n          if (optional) return false;\n          throw new Error(`missing channel value: ${name}`);\n        })\n    );\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeClip)(clip);\n    this.tip = maybeTip(tip);\n    this.className = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.string)(className);\n    // Super-faceting currently disallow position channels; in the future, we\n    // could allow position to be specified in fx and fy in addition to (or\n    // instead of) x and y.\n    if (this.facet === \"super\") {\n      if (fx || fy) throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const {scale} = channels[name];\n        if (scale !== \"x\" && scale !== \"y\") continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n    if (render != null) {\n      this.render = composeRender(render, this.render);\n    }\n  }\n  initialize(facets, facetChannels, plotOptions) {\n    let data = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.dataify)(this.data);\n    if (facets === undefined && data != null) facets = [(0,_options_js__WEBPACK_IMPORTED_MODULE_0__.range)(data)];\n    const originalFacets = facets;\n    if (this.transform != null) ({facets, data} = this.transform(data, facets, plotOptions)), (data = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.dataify)(data));\n    if (facets !== undefined) facets.original = originalFacets; // needed to read facetChannels\n    const channels = (0,_channel_js__WEBPACK_IMPORTED_MODULE_4__.createChannels)(this.channels, data);\n    if (this.sort != null) (0,_channel_js__WEBPACK_IMPORTED_MODULE_4__.channelDomain)(data, facets, channels, facetChannels, this.sort); // mutates facetChannels!\n    return {data, facets, channels};\n  }\n  filter(index, channels, values) {\n    for (const name in channels) {\n      const {filter = _defined_js__WEBPACK_IMPORTED_MODULE_5__.defined} = channels[name];\n      if (filter !== null) {\n        const value = values[name];\n        index = index.filter((i) => filter(value[i]));\n      }\n    }\n    return index;\n  }\n  // If there is a projection, and there are paired x and y channels associated\n  // with the x and y scale respectively (and not already in screen coordinates\n  // as with an initializer), then apply the projection, replacing the x and y\n  // values. Note that the x and y scales themselves don’t exist if there is a\n  // projection, but whether the channels are associated with scales still\n  // determines whether the projection should apply; think of the projection as\n  // a combination xy-scale.\n  project(channels, values, context) {\n    for (const cx in channels) {\n      if (channels[cx].scale === \"x\" && /^x|x$/.test(cx)) {\n        const cy = cx.replace(/^x|x$/, \"y\");\n        if (cy in channels && channels[cy].scale === \"y\") {\n          (0,_projection_js__WEBPACK_IMPORTED_MODULE_6__.project)(cx, cy, values, context.projection);\n        }\n      }\n    }\n  }\n  scale(channels, scales, context) {\n    const values = (0,_channel_js__WEBPACK_IMPORTED_MODULE_4__.valueObject)(channels, scales);\n    if (context.projection) this.project(channels, values, context);\n    return values;\n  }\n}\n\nfunction marks(...marks) {\n  marks.plot = Mark.prototype.plot;\n  return marks;\n}\n\nfunction composeRender(r1, r2) {\n  if (r1 == null) return r2 === null ? undefined : r2;\n  if (r2 == null) return r1 === null ? undefined : r1;\n  if (typeof r1 !== \"function\") throw new TypeError(`invalid render transform: ${r1}`);\n  if (typeof r2 !== \"function\") throw new TypeError(`invalid render transform: ${r2}`);\n  return function (i, s, v, d, c, next) {\n    return r1.call(this, i, s, v, d, c, (i, s, v, d, c) => {\n      return r2.call(this, i, s, v, d, c, next); // preserve this\n    });\n  };\n}\n\nfunction maybeChannels(channels) {\n  return Object.fromEntries(\n    Object.entries((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeNamed)(channels)).map(([name, channel]) => {\n      channel = typeof channel === \"string\" ? {value: channel, label: name} : (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeValue)(channel); // for shorthand extra channels, use name as label\n      if (channel.filter === undefined && channel.scale == null) channel = {...channel, filter: null};\n      return [name, channel];\n    })\n  );\n}\n\nfunction maybeTip(tip) {\n  return tip === true\n    ? \"xy\"\n    : tip === false || tip == null\n    ? null\n    : typeof tip === \"string\"\n    ? (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.keyword)(tip, \"tip\", [\"x\", \"y\", \"xy\"])\n    : tip; // tip options object\n}\n\nfunction withTip(options, pointer) {\n  return options?.tip === true\n    ? {...options, tip: pointer}\n    : (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(options?.tip) && options.tip.pointer === undefined\n    ? {...options, tip: {...options.tip, pointer}}\n    : options;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdFO0FBQ25DO0FBQ087QUFDbUI7QUFDNEM7QUFDbkU7QUFDTjtBQUN1Qjs7QUFFbEQ7QUFDUCxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQkFBZ0IseURBQVk7QUFDNUIsdUJBQXVCLGlFQUFXO0FBQ2xDLDREQUE0RCwyREFBSztBQUNqRTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixvREFBTztBQUMxQix5QkFBeUIsa0RBQVM7QUFDbEMseUJBQXlCLGtEQUFTO0FBQ2xDO0FBQ0EsdUJBQXVCLDJEQUFnQjtBQUN2QyxlQUFlLHVEQUFVO0FBQ3pCLGlEQUFpRDtBQUNqRCw0Q0FBNEMsR0FBRyxpREFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFTO0FBQ3ZCO0FBQ0EsbUJBQW1CLHFEQUFxRDtBQUN4RSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUIsa0RBQVM7QUFDaEM7QUFDQSxtQkFBbUIsT0FBTztBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekI7QUFDQSxxQkFBcUIsbURBQU07QUFDM0IsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBTztBQUN0Qix3REFBd0Qsa0RBQUs7QUFDN0Q7QUFDQSxrQ0FBa0MsY0FBYyxzREFBc0Qsb0RBQU87QUFDN0csZ0VBQWdFO0FBQ2hFLHFCQUFxQiwyREFBYztBQUNuQywyQkFBMkIsMERBQWEsb0RBQW9EO0FBQzVGLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsZ0RBQU8sRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlGQUFpRixHQUFHO0FBQ3BGLGlGQUFpRixHQUFHO0FBQ3BGO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix1REFBVTtBQUM3QiwrQ0FBK0MsNkJBQTZCLEVBQUUsdURBQVUsV0FBVztBQUNuRyw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFPO0FBQ2IsV0FBVztBQUNYOztBQUVPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsTUFBTSxxREFBUTtBQUNkLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmsuanM/NTM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NoYW5uZWxEb21haW4sIGNyZWF0ZUNoYW5uZWxzLCB2YWx1ZU9iamVjdH0gZnJvbSBcIi4vY2hhbm5lbC5qc1wiO1xuaW1wb3J0IHtkZWZpbmVkfSBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge21heWJlRmFjZXRBbmNob3J9IGZyb20gXCIuL2ZhY2V0LmpzXCI7XG5pbXBvcnQge21heWJlQ2xpcCwgbWF5YmVOYW1lZCwgbWF5YmVWYWx1ZX0gZnJvbSBcIi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtkYXRhaWZ5LCBpc0RvbWFpblNvcnQsIGlzT2JqZWN0LCBpc09wdGlvbnMsIGtleXdvcmQsIHJhbmdlLCBzaW5nbGV0b24sIHN0cmluZ30gZnJvbSBcIi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtwcm9qZWN0fSBmcm9tIFwiLi9wcm9qZWN0aW9uLmpzXCI7XG5pbXBvcnQge3N0eWxlc30gZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB7YmFzaWMsIGluaXRpYWxpemVyfSBmcm9tIFwiLi90cmFuc2Zvcm1zL2Jhc2ljLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgY2hhbm5lbHMgPSB7fSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZhY2V0ID0gXCJhdXRvXCIsXG4gICAgICBmYWNldEFuY2hvcixcbiAgICAgIGZ4LFxuICAgICAgZnksXG4gICAgICBzb3J0LFxuICAgICAgZHggPSAwLFxuICAgICAgZHkgPSAwLFxuICAgICAgbWFyZ2luID0gMCxcbiAgICAgIG1hcmdpblRvcCA9IG1hcmdpbixcbiAgICAgIG1hcmdpblJpZ2h0ID0gbWFyZ2luLFxuICAgICAgbWFyZ2luQm90dG9tID0gbWFyZ2luLFxuICAgICAgbWFyZ2luTGVmdCA9IG1hcmdpbixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGNsaXAgPSBkZWZhdWx0cz8uY2xpcCxcbiAgICAgIGNoYW5uZWxzOiBleHRyYUNoYW5uZWxzLFxuICAgICAgdGlwLFxuICAgICAgcmVuZGVyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNvcnQgPSBpc0RvbWFpblNvcnQoc29ydCkgPyBzb3J0IDogbnVsbDtcbiAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXIob3B0aW9ucykuaW5pdGlhbGl6ZXI7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLmluaXRpYWxpemVyID8gb3B0aW9ucy50cmFuc2Zvcm0gOiBiYXNpYyhvcHRpb25zKS50cmFuc2Zvcm07XG4gICAgaWYgKGZhY2V0ID09PSBudWxsIHx8IGZhY2V0ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5mYWNldCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFjZXQgPSBrZXl3b3JkKGZhY2V0ID09PSB0cnVlID8gXCJpbmNsdWRlXCIgOiBmYWNldCwgXCJmYWNldFwiLCBbXCJhdXRvXCIsIFwiaW5jbHVkZVwiLCBcImV4Y2x1ZGVcIiwgXCJzdXBlclwiXSk7XG4gICAgICB0aGlzLmZ4ID0gZGF0YSA9PT0gc2luZ2xldG9uICYmIHR5cGVvZiBmeCA9PT0gXCJzdHJpbmdcIiA/IFtmeF0gOiBmeDtcbiAgICAgIHRoaXMuZnkgPSBkYXRhID09PSBzaW5nbGV0b24gJiYgdHlwZW9mIGZ5ID09PSBcInN0cmluZ1wiID8gW2Z5XSA6IGZ5O1xuICAgIH1cbiAgICB0aGlzLmZhY2V0QW5jaG9yID0gbWF5YmVGYWNldEFuY2hvcihmYWNldEFuY2hvcik7XG4gICAgY2hhbm5lbHMgPSBtYXliZU5hbWVkKGNoYW5uZWxzKTtcbiAgICBpZiAoZXh0cmFDaGFubmVscyAhPT0gdW5kZWZpbmVkKSBjaGFubmVscyA9IHsuLi5tYXliZUNoYW5uZWxzKGV4dHJhQ2hhbm5lbHMpLCAuLi5jaGFubmVsc307XG4gICAgaWYgKGRlZmF1bHRzICE9PSB1bmRlZmluZWQpIGNoYW5uZWxzID0gey4uLnN0eWxlcyh0aGlzLCBvcHRpb25zLCBkZWZhdWx0cyksIC4uLmNoYW5uZWxzfTtcbiAgICB0aGlzLmNoYW5uZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoY2hhbm5lbHMpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBjaGFubmVsXSkgPT4ge1xuICAgICAgICAgIGlmIChpc09wdGlvbnMoY2hhbm5lbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IHNjYWxlIGFuZCBsYWJlbCBvdmVycmlkZXNcbiAgICAgICAgICAgIGNvbnN0IHt2YWx1ZSwgbGFiZWwgPSBjaGFubmVsLmxhYmVsLCBzY2FsZSA9IGNoYW5uZWwuc2NhbGV9ID0gY2hhbm5lbC52YWx1ZTtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB7Li4uY2hhbm5lbCwgbGFiZWwsIHNjYWxlLCB2YWx1ZX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhID09PSBzaW5nbGV0b24gJiYgdHlwZW9mIGNoYW5uZWwudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZmllbGQgbmFtZXMgdG8gc2luZ2xldG9uIHZhbHVlcyBmb3IgZGVjb3JhdGlvbiBtYXJrcyAoZS5nLiwgZnJhbWUpXG4gICAgICAgICAgICBjb25zdCB7dmFsdWV9ID0gY2hhbm5lbDtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB7Li4uY2hhbm5lbCwgdmFsdWU6IFt2YWx1ZV19O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYW5uZWxdO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKChbbmFtZSwge3ZhbHVlLCBvcHRpb25hbH1dKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChvcHRpb25hbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBjaGFubmVsIHZhbHVlOiAke25hbWV9YCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmR4ID0gK2R4O1xuICAgIHRoaXMuZHkgPSArZHk7XG4gICAgdGhpcy5tYXJnaW5Ub3AgPSArbWFyZ2luVG9wO1xuICAgIHRoaXMubWFyZ2luUmlnaHQgPSArbWFyZ2luUmlnaHQ7XG4gICAgdGhpcy5tYXJnaW5Cb3R0b20gPSArbWFyZ2luQm90dG9tO1xuICAgIHRoaXMubWFyZ2luTGVmdCA9ICttYXJnaW5MZWZ0O1xuICAgIHRoaXMuY2xpcCA9IG1heWJlQ2xpcChjbGlwKTtcbiAgICB0aGlzLnRpcCA9IG1heWJlVGlwKHRpcCk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBzdHJpbmcoY2xhc3NOYW1lKTtcbiAgICAvLyBTdXBlci1mYWNldGluZyBjdXJyZW50bHkgZGlzYWxsb3cgcG9zaXRpb24gY2hhbm5lbHM7IGluIHRoZSBmdXR1cmUsIHdlXG4gICAgLy8gY291bGQgYWxsb3cgcG9zaXRpb24gdG8gYmUgc3BlY2lmaWVkIGluIGZ4IGFuZCBmeSBpbiBhZGRpdGlvbiB0byAob3JcbiAgICAvLyBpbnN0ZWFkIG9mKSB4IGFuZCB5LlxuICAgIGlmICh0aGlzLmZhY2V0ID09PSBcInN1cGVyXCIpIHtcbiAgICAgIGlmIChmeCB8fCBmeSkgdGhyb3cgbmV3IEVycm9yKGBzdXBlci1mYWNldGluZyBjYW5ub3QgdXNlIGZ4IG9yIGZ5YCk7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5jaGFubmVscykge1xuICAgICAgICBjb25zdCB7c2NhbGV9ID0gY2hhbm5lbHNbbmFtZV07XG4gICAgICAgIGlmIChzY2FsZSAhPT0gXCJ4XCIgJiYgc2NhbGUgIT09IFwieVwiKSBjb250aW51ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXBlci1mYWNldGluZyBjYW5ub3QgdXNlIHggb3IgeWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gY29tcG9zZVJlbmRlcihyZW5kZXIsIHRoaXMucmVuZGVyKTtcbiAgICB9XG4gIH1cbiAgaW5pdGlhbGl6ZShmYWNldHMsIGZhY2V0Q2hhbm5lbHMsIHBsb3RPcHRpb25zKSB7XG4gICAgbGV0IGRhdGEgPSBkYXRhaWZ5KHRoaXMuZGF0YSk7XG4gICAgaWYgKGZhY2V0cyA9PT0gdW5kZWZpbmVkICYmIGRhdGEgIT0gbnVsbCkgZmFjZXRzID0gW3JhbmdlKGRhdGEpXTtcbiAgICBjb25zdCBvcmlnaW5hbEZhY2V0cyA9IGZhY2V0cztcbiAgICBpZiAodGhpcy50cmFuc2Zvcm0gIT0gbnVsbCkgKHtmYWNldHMsIGRhdGF9ID0gdGhpcy50cmFuc2Zvcm0oZGF0YSwgZmFjZXRzLCBwbG90T3B0aW9ucykpLCAoZGF0YSA9IGRhdGFpZnkoZGF0YSkpO1xuICAgIGlmIChmYWNldHMgIT09IHVuZGVmaW5lZCkgZmFjZXRzLm9yaWdpbmFsID0gb3JpZ2luYWxGYWNldHM7IC8vIG5lZWRlZCB0byByZWFkIGZhY2V0Q2hhbm5lbHNcbiAgICBjb25zdCBjaGFubmVscyA9IGNyZWF0ZUNoYW5uZWxzKHRoaXMuY2hhbm5lbHMsIGRhdGEpO1xuICAgIGlmICh0aGlzLnNvcnQgIT0gbnVsbCkgY2hhbm5lbERvbWFpbihkYXRhLCBmYWNldHMsIGNoYW5uZWxzLCBmYWNldENoYW5uZWxzLCB0aGlzLnNvcnQpOyAvLyBtdXRhdGVzIGZhY2V0Q2hhbm5lbHMhXG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHMsIGNoYW5uZWxzfTtcbiAgfVxuICBmaWx0ZXIoaW5kZXgsIGNoYW5uZWxzLCB2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIHtcbiAgICAgIGNvbnN0IHtmaWx0ZXIgPSBkZWZpbmVkfSA9IGNoYW5uZWxzW25hbWVdO1xuICAgICAgaWYgKGZpbHRlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tuYW1lXTtcbiAgICAgICAgaW5kZXggPSBpbmRleC5maWx0ZXIoKGkpID0+IGZpbHRlcih2YWx1ZVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLy8gSWYgdGhlcmUgaXMgYSBwcm9qZWN0aW9uLCBhbmQgdGhlcmUgYXJlIHBhaXJlZCB4IGFuZCB5IGNoYW5uZWxzIGFzc29jaWF0ZWRcbiAgLy8gd2l0aCB0aGUgeCBhbmQgeSBzY2FsZSByZXNwZWN0aXZlbHkgKGFuZCBub3QgYWxyZWFkeSBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgLy8gYXMgd2l0aCBhbiBpbml0aWFsaXplciksIHRoZW4gYXBwbHkgdGhlIHByb2plY3Rpb24sIHJlcGxhY2luZyB0aGUgeCBhbmQgeVxuICAvLyB2YWx1ZXMuIE5vdGUgdGhhdCB0aGUgeCBhbmQgeSBzY2FsZXMgdGhlbXNlbHZlcyBkb27igJl0IGV4aXN0IGlmIHRoZXJlIGlzIGFcbiAgLy8gcHJvamVjdGlvbiwgYnV0IHdoZXRoZXIgdGhlIGNoYW5uZWxzIGFyZSBhc3NvY2lhdGVkIHdpdGggc2NhbGVzIHN0aWxsXG4gIC8vIGRldGVybWluZXMgd2hldGhlciB0aGUgcHJvamVjdGlvbiBzaG91bGQgYXBwbHk7IHRoaW5rIG9mIHRoZSBwcm9qZWN0aW9uIGFzXG4gIC8vIGEgY29tYmluYXRpb24geHktc2NhbGUuXG4gIHByb2plY3QoY2hhbm5lbHMsIHZhbHVlcywgY29udGV4dCkge1xuICAgIGZvciAoY29uc3QgY3ggaW4gY2hhbm5lbHMpIHtcbiAgICAgIGlmIChjaGFubmVsc1tjeF0uc2NhbGUgPT09IFwieFwiICYmIC9eeHx4JC8udGVzdChjeCkpIHtcbiAgICAgICAgY29uc3QgY3kgPSBjeC5yZXBsYWNlKC9eeHx4JC8sIFwieVwiKTtcbiAgICAgICAgaWYgKGN5IGluIGNoYW5uZWxzICYmIGNoYW5uZWxzW2N5XS5zY2FsZSA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICBwcm9qZWN0KGN4LCBjeSwgdmFsdWVzLCBjb250ZXh0LnByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNjYWxlKGNoYW5uZWxzLCBzY2FsZXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZU9iamVjdChjaGFubmVscywgc2NhbGVzKTtcbiAgICBpZiAoY29udGV4dC5wcm9qZWN0aW9uKSB0aGlzLnByb2plY3QoY2hhbm5lbHMsIHZhbHVlcywgY29udGV4dCk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya3MoLi4ubWFya3MpIHtcbiAgbWFya3MucGxvdCA9IE1hcmsucHJvdG90eXBlLnBsb3Q7XG4gIHJldHVybiBtYXJrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VSZW5kZXIocjEsIHIyKSB7XG4gIGlmIChyMSA9PSBudWxsKSByZXR1cm4gcjIgPT09IG51bGwgPyB1bmRlZmluZWQgOiByMjtcbiAgaWYgKHIyID09IG51bGwpIHJldHVybiByMSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHIxO1xuICBpZiAodHlwZW9mIHIxICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgcmVuZGVyIHRyYW5zZm9ybTogJHtyMX1gKTtcbiAgaWYgKHR5cGVvZiByMiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIHJlbmRlciB0cmFuc2Zvcm06ICR7cjJ9YCk7XG4gIHJldHVybiBmdW5jdGlvbiAoaSwgcywgdiwgZCwgYywgbmV4dCkge1xuICAgIHJldHVybiByMS5jYWxsKHRoaXMsIGksIHMsIHYsIGQsIGMsIChpLCBzLCB2LCBkLCBjKSA9PiB7XG4gICAgICByZXR1cm4gcjIuY2FsbCh0aGlzLCBpLCBzLCB2LCBkLCBjLCBuZXh0KTsgLy8gcHJlc2VydmUgdGhpc1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYXliZUNoYW5uZWxzKGNoYW5uZWxzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobWF5YmVOYW1lZChjaGFubmVscykpLm1hcCgoW25hbWUsIGNoYW5uZWxdKSA9PiB7XG4gICAgICBjaGFubmVsID0gdHlwZW9mIGNoYW5uZWwgPT09IFwic3RyaW5nXCIgPyB7dmFsdWU6IGNoYW5uZWwsIGxhYmVsOiBuYW1lfSA6IG1heWJlVmFsdWUoY2hhbm5lbCk7IC8vIGZvciBzaG9ydGhhbmQgZXh0cmEgY2hhbm5lbHMsIHVzZSBuYW1lIGFzIGxhYmVsXG4gICAgICBpZiAoY2hhbm5lbC5maWx0ZXIgPT09IHVuZGVmaW5lZCAmJiBjaGFubmVsLnNjYWxlID09IG51bGwpIGNoYW5uZWwgPSB7Li4uY2hhbm5lbCwgZmlsdGVyOiBudWxsfTtcbiAgICAgIHJldHVybiBbbmFtZSwgY2hhbm5lbF07XG4gICAgfSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVUaXAodGlwKSB7XG4gIHJldHVybiB0aXAgPT09IHRydWVcbiAgICA/IFwieHlcIlxuICAgIDogdGlwID09PSBmYWxzZSB8fCB0aXAgPT0gbnVsbFxuICAgID8gbnVsbFxuICAgIDogdHlwZW9mIHRpcCA9PT0gXCJzdHJpbmdcIlxuICAgID8ga2V5d29yZCh0aXAsIFwidGlwXCIsIFtcInhcIiwgXCJ5XCIsIFwieHlcIl0pXG4gICAgOiB0aXA7IC8vIHRpcCBvcHRpb25zIG9iamVjdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFRpcChvcHRpb25zLCBwb2ludGVyKSB7XG4gIHJldHVybiBvcHRpb25zPy50aXAgPT09IHRydWVcbiAgICA/IHsuLi5vcHRpb25zLCB0aXA6IHBvaW50ZXJ9XG4gICAgOiBpc09iamVjdChvcHRpb25zPy50aXApICYmIG9wdGlvbnMudGlwLnBvaW50ZXIgPT09IHVuZGVmaW5lZFxuICAgID8gey4uLm9wdGlvbnMsIHRpcDogey4uLm9wdGlvbnMudGlwLCBwb2ludGVyfX1cbiAgICA6IG9wdGlvbnM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/mark.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marker.js":
/*!*******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyGroupedMarkers: () => (/* binding */ applyGroupedMarkers),\n/* harmony export */   applyMarkers: () => (/* binding */ applyMarkers),\n/* harmony export */   markers: () => (/* binding */ markers)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memoize.js */ \"(ssr)/./node_modules/@observablehq/plot/src/memoize.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n\n\n\n\nfunction markers(mark, {marker, markerStart = marker, markerMid = marker, markerEnd = marker} = {}) {\n  mark.markerStart = maybeMarker(markerStart);\n  mark.markerMid = maybeMarker(markerMid);\n  mark.markerEnd = maybeMarker(markerEnd);\n}\n\nfunction maybeMarker(marker) {\n  if (marker == null || marker === false) return null;\n  if (marker === true) return markerCircleFill;\n  if (typeof marker === \"function\") return marker;\n  switch (`${marker}`.toLowerCase()) {\n    case \"none\":\n      return null;\n    case \"arrow\":\n      return markerArrow(\"auto\");\n    case \"arrow-reverse\":\n      return markerArrow(\"auto-start-reverse\");\n    case \"dot\":\n      return markerDot;\n    case \"circle\":\n    case \"circle-fill\":\n      return markerCircleFill;\n    case \"circle-stroke\":\n      return markerCircleStroke;\n    case \"tick\":\n      return markerTick(\"auto\");\n    case \"tick-x\":\n      return markerTick(90);\n    case \"tick-y\":\n      return markerTick(0);\n  }\n  throw new Error(`invalid marker: ${marker}`);\n}\n\nfunction markerArrow(orient) {\n  return (color, context) =>\n    (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.create)(\"svg:marker\", context)\n      .attr(\"viewBox\", \"-5 -5 10 10\")\n      .attr(\"markerWidth\", 6.67)\n      .attr(\"markerHeight\", 6.67)\n      .attr(\"orient\", orient)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", color)\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"stroke-linecap\", \"round\")\n      .attr(\"stroke-linejoin\", \"round\")\n      .call((marker) => marker.append(\"path\").attr(\"d\", \"M-1.5,-3l3,3l-3,3\"))\n      .node();\n}\n\nfunction markerDot(color, context) {\n  return (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.create)(\"svg:marker\", context)\n    .attr(\"viewBox\", \"-5 -5 10 10\")\n    .attr(\"markerWidth\", 6.67)\n    .attr(\"markerHeight\", 6.67)\n    .attr(\"fill\", color)\n    .attr(\"stroke\", \"none\")\n    .call((marker) => marker.append(\"circle\").attr(\"r\", 2.5))\n    .node();\n}\n\nfunction markerCircleFill(color, context) {\n  return (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.create)(\"svg:marker\", context)\n    .attr(\"viewBox\", \"-5 -5 10 10\")\n    .attr(\"markerWidth\", 6.67)\n    .attr(\"markerHeight\", 6.67)\n    .attr(\"fill\", color)\n    .attr(\"stroke\", \"var(--plot-background)\")\n    .attr(\"stroke-width\", 1.5)\n    .call((marker) => marker.append(\"circle\").attr(\"r\", 3))\n    .node();\n}\n\nfunction markerCircleStroke(color, context) {\n  return (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.create)(\"svg:marker\", context)\n    .attr(\"viewBox\", \"-5 -5 10 10\")\n    .attr(\"markerWidth\", 6.67)\n    .attr(\"markerHeight\", 6.67)\n    .attr(\"fill\", \"var(--plot-background)\")\n    .attr(\"stroke\", color)\n    .attr(\"stroke-width\", 1.5)\n    .call((marker) => marker.append(\"circle\").attr(\"r\", 3))\n    .node();\n}\n\nfunction markerTick(orient) {\n  return (color, context) =>\n    (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.create)(\"svg:marker\", context)\n      .attr(\"viewBox\", \"-3 -3 6 6\")\n      .attr(\"markerWidth\", 6)\n      .attr(\"markerHeight\", 6)\n      .attr(\"orient\", orient)\n      .attr(\"stroke\", color)\n      .call((marker) => marker.append(\"path\").attr(\"d\", \"M0,-3v6\"))\n      .node();\n}\n\nlet nextMarkerId = 0;\n\nfunction applyMarkers(path, mark, {stroke: S}, context) {\n  return applyMarkersColor(path, mark, S && ((i) => S[i]), null, context);\n}\n\nfunction applyGroupedMarkers(path, mark, {stroke: S, z: Z}, context) {\n  return applyMarkersColor(path, mark, S && (([i]) => S[i]), Z, context);\n}\n\nconst START = 1;\nconst END = 2;\n\n/**\n * When rendering lines or areas with variable aesthetics, a single series\n * produces multiple path elements. The first path element is a START segment;\n * the last path element is an END segment. When there is only a single path\n * element, it is both a START and an END segment.\n */\nfunction getGroupedOrientation(path, Z) {\n  const O = new Uint8Array(Z.length);\n  const D = path.data().filter((I) => I.length > 1);\n  const n = D.length;\n\n  // Forward pass to find start segments.\n  for (let i = 0, z = _memoize_js__WEBPACK_IMPORTED_MODULE_1__.unset; i < n; ++i) {\n    const I = D[i];\n    if (I.length > 1) {\n      const i = I[0];\n      if (z !== (z = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(Z[i]))) O[i] |= START;\n    }\n  }\n\n  // Backwards pass to find end segments.\n  for (let i = n - 1, z = _memoize_js__WEBPACK_IMPORTED_MODULE_1__.unset; i >= 0; --i) {\n    const I = D[i];\n    if (I.length > 1) {\n      const i = I[0];\n      if (z !== (z = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyof)(Z[i]))) O[i] |= END;\n    }\n  }\n\n  return ([i]) => O[i];\n}\n\nfunction applyMarkersColor(path, {markerStart, markerMid, markerEnd, stroke}, strokeof = () => stroke, Z, context) {\n  if (!markerStart && !markerMid && !markerEnd) return;\n  const iriByMarkerColor = new Map();\n  const orient = Z && getGroupedOrientation(path, Z);\n\n  function applyMarker(name, marker, filter) {\n    return function (i) {\n      if (filter && !filter(i)) return;\n      const color = strokeof(i);\n      let iriByColor = iriByMarkerColor.get(marker);\n      if (!iriByColor) iriByMarkerColor.set(marker, (iriByColor = new Map()));\n      let iri = iriByColor.get(color);\n      if (!iri) {\n        const node = this.parentNode.insertBefore(marker(color, context), this);\n        const id = `plot-marker-${++nextMarkerId}`;\n        node.setAttribute(\"id\", id);\n        iriByColor.set(color, (iri = `url(#${id})`));\n      }\n      this.setAttribute(name, iri);\n    };\n  }\n\n  if (markerStart) path.each(applyMarker(\"marker-start\", markerStart, orient && ((i) => orient(i) & START)));\n  if (markerMid && orient) path.each(applyMarker(\"marker-start\", markerMid, (i) => !(orient(i) & START)));\n  if (markerMid) path.each(applyMarker(\"marker-mid\", markerMid));\n  if (markerEnd) path.each(applyMarker(\"marker-end\", markerEnd, orient && ((i) => orient(i) & END)));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ0Q7QUFDQTs7QUFFNUIsd0JBQXdCLHNFQUFzRSxJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsbURBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtREFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsbURBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPLG1DQUFtQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRU8sMENBQTBDLGdCQUFnQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsOENBQUssRUFBRSxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBSztBQUMxQjtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDhDQUFLLEVBQUUsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQUs7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya2VyLmpzPzI1ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCB7dW5zZXR9IGZyb20gXCIuL21lbW9pemUuanNcIjtcbmltcG9ydCB7a2V5b2Z9IGZyb20gXCIuL29wdGlvbnMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcnMobWFyaywge21hcmtlciwgbWFya2VyU3RhcnQgPSBtYXJrZXIsIG1hcmtlck1pZCA9IG1hcmtlciwgbWFya2VyRW5kID0gbWFya2VyfSA9IHt9KSB7XG4gIG1hcmsubWFya2VyU3RhcnQgPSBtYXliZU1hcmtlcihtYXJrZXJTdGFydCk7XG4gIG1hcmsubWFya2VyTWlkID0gbWF5YmVNYXJrZXIobWFya2VyTWlkKTtcbiAgbWFyay5tYXJrZXJFbmQgPSBtYXliZU1hcmtlcihtYXJrZXJFbmQpO1xufVxuXG5mdW5jdGlvbiBtYXliZU1hcmtlcihtYXJrZXIpIHtcbiAgaWYgKG1hcmtlciA9PSBudWxsIHx8IG1hcmtlciA9PT0gZmFsc2UpIHJldHVybiBudWxsO1xuICBpZiAobWFya2VyID09PSB0cnVlKSByZXR1cm4gbWFya2VyQ2lyY2xlRmlsbDtcbiAgaWYgKHR5cGVvZiBtYXJrZXIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG1hcmtlcjtcbiAgc3dpdGNoIChgJHttYXJrZXJ9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJhcnJvd1wiOlxuICAgICAgcmV0dXJuIG1hcmtlckFycm93KFwiYXV0b1wiKTtcbiAgICBjYXNlIFwiYXJyb3ctcmV2ZXJzZVwiOlxuICAgICAgcmV0dXJuIG1hcmtlckFycm93KFwiYXV0by1zdGFydC1yZXZlcnNlXCIpO1xuICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgIHJldHVybiBtYXJrZXJEb3Q7XG4gICAgY2FzZSBcImNpcmNsZVwiOlxuICAgIGNhc2UgXCJjaXJjbGUtZmlsbFwiOlxuICAgICAgcmV0dXJuIG1hcmtlckNpcmNsZUZpbGw7XG4gICAgY2FzZSBcImNpcmNsZS1zdHJva2VcIjpcbiAgICAgIHJldHVybiBtYXJrZXJDaXJjbGVTdHJva2U7XG4gICAgY2FzZSBcInRpY2tcIjpcbiAgICAgIHJldHVybiBtYXJrZXJUaWNrKFwiYXV0b1wiKTtcbiAgICBjYXNlIFwidGljay14XCI6XG4gICAgICByZXR1cm4gbWFya2VyVGljayg5MCk7XG4gICAgY2FzZSBcInRpY2steVwiOlxuICAgICAgcmV0dXJuIG1hcmtlclRpY2soMCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG1hcmtlcjogJHttYXJrZXJ9YCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtlckFycm93KG9yaWVudCkge1xuICByZXR1cm4gKGNvbG9yLCBjb250ZXh0KSA9PlxuICAgIGNyZWF0ZShcInN2ZzptYXJrZXJcIiwgY29udGV4dClcbiAgICAgIC5hdHRyKFwidmlld0JveFwiLCBcIi01IC01IDEwIDEwXCIpXG4gICAgICAuYXR0cihcIm1hcmtlcldpZHRoXCIsIDYuNjcpXG4gICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCA2LjY3KVxuICAgICAgLmF0dHIoXCJvcmllbnRcIiwgb3JpZW50KVxuICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sb3IpXG4gICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAuYXR0cihcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIilcbiAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIilcbiAgICAgIC5jYWxsKChtYXJrZXIpID0+IG1hcmtlci5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIFwiTS0xLjUsLTNsMywzbC0zLDNcIikpXG4gICAgICAubm9kZSgpO1xufVxuXG5mdW5jdGlvbiBtYXJrZXJEb3QoY29sb3IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGNyZWF0ZShcInN2ZzptYXJrZXJcIiwgY29udGV4dClcbiAgICAuYXR0cihcInZpZXdCb3hcIiwgXCItNSAtNSAxMCAxMFwiKVxuICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgNi42NylcbiAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCA2LjY3KVxuICAgIC5hdHRyKFwiZmlsbFwiLCBjb2xvcilcbiAgICAuYXR0cihcInN0cm9rZVwiLCBcIm5vbmVcIilcbiAgICAuY2FsbCgobWFya2VyKSA9PiBtYXJrZXIuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsIDIuNSkpXG4gICAgLm5vZGUoKTtcbn1cblxuZnVuY3Rpb24gbWFya2VyQ2lyY2xlRmlsbChjb2xvciwgY29udGV4dCkge1xuICByZXR1cm4gY3JlYXRlKFwic3ZnOm1hcmtlclwiLCBjb250ZXh0KVxuICAgIC5hdHRyKFwidmlld0JveFwiLCBcIi01IC01IDEwIDEwXCIpXG4gICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCA2LjY3KVxuICAgIC5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDYuNjcpXG4gICAgLmF0dHIoXCJmaWxsXCIsIGNvbG9yKVxuICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwidmFyKC0tcGxvdC1iYWNrZ3JvdW5kKVwiKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAuY2FsbCgobWFya2VyKSA9PiBtYXJrZXIuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsIDMpKVxuICAgIC5ub2RlKCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtlckNpcmNsZVN0cm9rZShjb2xvciwgY29udGV4dCkge1xuICByZXR1cm4gY3JlYXRlKFwic3ZnOm1hcmtlclwiLCBjb250ZXh0KVxuICAgIC5hdHRyKFwidmlld0JveFwiLCBcIi01IC01IDEwIDEwXCIpXG4gICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCA2LjY3KVxuICAgIC5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDYuNjcpXG4gICAgLmF0dHIoXCJmaWxsXCIsIFwidmFyKC0tcGxvdC1iYWNrZ3JvdW5kKVwiKVxuICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbG9yKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAuY2FsbCgobWFya2VyKSA9PiBtYXJrZXIuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsIDMpKVxuICAgIC5ub2RlKCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtlclRpY2sob3JpZW50KSB7XG4gIHJldHVybiAoY29sb3IsIGNvbnRleHQpID0+XG4gICAgY3JlYXRlKFwic3ZnOm1hcmtlclwiLCBjb250ZXh0KVxuICAgICAgLmF0dHIoXCJ2aWV3Qm94XCIsIFwiLTMgLTMgNiA2XCIpXG4gICAgICAuYXR0cihcIm1hcmtlcldpZHRoXCIsIDYpXG4gICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCA2KVxuICAgICAgLmF0dHIoXCJvcmllbnRcIiwgb3JpZW50KVxuICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sb3IpXG4gICAgICAuY2FsbCgobWFya2VyKSA9PiBtYXJrZXIuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLCBcIk0wLC0zdjZcIikpXG4gICAgICAubm9kZSgpO1xufVxuXG5sZXQgbmV4dE1hcmtlcklkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWFya2VycyhwYXRoLCBtYXJrLCB7c3Ryb2tlOiBTfSwgY29udGV4dCkge1xuICByZXR1cm4gYXBwbHlNYXJrZXJzQ29sb3IocGF0aCwgbWFyaywgUyAmJiAoKGkpID0+IFNbaV0pLCBudWxsLCBjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5R3JvdXBlZE1hcmtlcnMocGF0aCwgbWFyaywge3N0cm9rZTogUywgejogWn0sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFwcGx5TWFya2Vyc0NvbG9yKHBhdGgsIG1hcmssIFMgJiYgKChbaV0pID0+IFNbaV0pLCBaLCBjb250ZXh0KTtcbn1cblxuY29uc3QgU1RBUlQgPSAxO1xuY29uc3QgRU5EID0gMjtcblxuLyoqXG4gKiBXaGVuIHJlbmRlcmluZyBsaW5lcyBvciBhcmVhcyB3aXRoIHZhcmlhYmxlIGFlc3RoZXRpY3MsIGEgc2luZ2xlIHNlcmllc1xuICogcHJvZHVjZXMgbXVsdGlwbGUgcGF0aCBlbGVtZW50cy4gVGhlIGZpcnN0IHBhdGggZWxlbWVudCBpcyBhIFNUQVJUIHNlZ21lbnQ7XG4gKiB0aGUgbGFzdCBwYXRoIGVsZW1lbnQgaXMgYW4gRU5EIHNlZ21lbnQuIFdoZW4gdGhlcmUgaXMgb25seSBhIHNpbmdsZSBwYXRoXG4gKiBlbGVtZW50LCBpdCBpcyBib3RoIGEgU1RBUlQgYW5kIGFuIEVORCBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBnZXRHcm91cGVkT3JpZW50YXRpb24ocGF0aCwgWikge1xuICBjb25zdCBPID0gbmV3IFVpbnQ4QXJyYXkoWi5sZW5ndGgpO1xuICBjb25zdCBEID0gcGF0aC5kYXRhKCkuZmlsdGVyKChJKSA9PiBJLmxlbmd0aCA+IDEpO1xuICBjb25zdCBuID0gRC5sZW5ndGg7XG5cbiAgLy8gRm9yd2FyZCBwYXNzIHRvIGZpbmQgc3RhcnQgc2VnbWVudHMuXG4gIGZvciAobGV0IGkgPSAwLCB6ID0gdW5zZXQ7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBJID0gRFtpXTtcbiAgICBpZiAoSS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBpID0gSVswXTtcbiAgICAgIGlmICh6ICE9PSAoeiA9IGtleW9mKFpbaV0pKSkgT1tpXSB8PSBTVEFSVDtcbiAgICB9XG4gIH1cblxuICAvLyBCYWNrd2FyZHMgcGFzcyB0byBmaW5kIGVuZCBzZWdtZW50cy5cbiAgZm9yIChsZXQgaSA9IG4gLSAxLCB6ID0gdW5zZXQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgSSA9IERbaV07XG4gICAgaWYgKEkubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgaSA9IElbMF07XG4gICAgICBpZiAoeiAhPT0gKHogPSBrZXlvZihaW2ldKSkpIE9baV0gfD0gRU5EO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoW2ldKSA9PiBPW2ldO1xufVxuXG5mdW5jdGlvbiBhcHBseU1hcmtlcnNDb2xvcihwYXRoLCB7bWFya2VyU3RhcnQsIG1hcmtlck1pZCwgbWFya2VyRW5kLCBzdHJva2V9LCBzdHJva2VvZiA9ICgpID0+IHN0cm9rZSwgWiwgY29udGV4dCkge1xuICBpZiAoIW1hcmtlclN0YXJ0ICYmICFtYXJrZXJNaWQgJiYgIW1hcmtlckVuZCkgcmV0dXJuO1xuICBjb25zdCBpcmlCeU1hcmtlckNvbG9yID0gbmV3IE1hcCgpO1xuICBjb25zdCBvcmllbnQgPSBaICYmIGdldEdyb3VwZWRPcmllbnRhdGlvbihwYXRoLCBaKTtcblxuICBmdW5jdGlvbiBhcHBseU1hcmtlcihuYW1lLCBtYXJrZXIsIGZpbHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyKGkpKSByZXR1cm47XG4gICAgICBjb25zdCBjb2xvciA9IHN0cm9rZW9mKGkpO1xuICAgICAgbGV0IGlyaUJ5Q29sb3IgPSBpcmlCeU1hcmtlckNvbG9yLmdldChtYXJrZXIpO1xuICAgICAgaWYgKCFpcmlCeUNvbG9yKSBpcmlCeU1hcmtlckNvbG9yLnNldChtYXJrZXIsIChpcmlCeUNvbG9yID0gbmV3IE1hcCgpKSk7XG4gICAgICBsZXQgaXJpID0gaXJpQnlDb2xvci5nZXQoY29sb3IpO1xuICAgICAgaWYgKCFpcmkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobWFya2VyKGNvbG9yLCBjb250ZXh0KSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGlkID0gYHBsb3QtbWFya2VyLSR7KytuZXh0TWFya2VySWR9YDtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgICAgIGlyaUJ5Q29sb3Iuc2V0KGNvbG9yLCAoaXJpID0gYHVybCgjJHtpZH0pYCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaXJpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKG1hcmtlclN0YXJ0KSBwYXRoLmVhY2goYXBwbHlNYXJrZXIoXCJtYXJrZXItc3RhcnRcIiwgbWFya2VyU3RhcnQsIG9yaWVudCAmJiAoKGkpID0+IG9yaWVudChpKSAmIFNUQVJUKSkpO1xuICBpZiAobWFya2VyTWlkICYmIG9yaWVudCkgcGF0aC5lYWNoKGFwcGx5TWFya2VyKFwibWFya2VyLXN0YXJ0XCIsIG1hcmtlck1pZCwgKGkpID0+ICEob3JpZW50KGkpICYgU1RBUlQpKSk7XG4gIGlmIChtYXJrZXJNaWQpIHBhdGguZWFjaChhcHBseU1hcmtlcihcIm1hcmtlci1taWRcIiwgbWFya2VyTWlkKSk7XG4gIGlmIChtYXJrZXJFbmQpIHBhdGguZWFjaChhcHBseU1hcmtlcihcIm1hcmtlci1lbmRcIiwgbWFya2VyRW5kLCBvcmllbnQgJiYgKChpKSA9PiBvcmllbnQoaSkgJiBFTkQpKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/area.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/area.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Area: () => (/* binding */ Area),\n/* harmony export */   area: () => (/* binding */ area),\n/* harmony export */   areaX: () => (/* binding */ areaX),\n/* harmony export */   areaY: () => (/* binding */ areaY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve.js */ \"(ssr)/./node_modules/@observablehq/plot/src/curve.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n/* harmony import */ var _transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transforms/identity.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js\");\n/* harmony import */ var _transforms_stack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/stack.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\");\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nclass Area extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true},\n        z: {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeZ)(options), optional: true}\n      },\n      options,\n      defaults\n    );\n    this.z = z;\n    this.curve = (0,_curve_js__WEBPACK_IMPORTED_MODULE_3__.maybeCurve)(curve, tension);\n  }\n  filter(index) {\n    return index;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1} = channels;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyTransform, this, scales, 0, 0)\n      .call((g) =>\n        g\n          .selectAll()\n          .data((0,_style_js__WEBPACK_IMPORTED_MODULE_5__.groupIndex)(index, [X1, Y1, X2, Y2], this, channels))\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyDirectStyles, this)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyGroupedChannelStyles, this, channels)\n          .attr(\n            \"d\",\n            (0,d3__WEBPACK_IMPORTED_MODULE_0__.area)()\n              .curve(this.curve)\n              .defined((i) => i >= 0)\n              .x0((i) => X1[i])\n              .y0((i) => Y1[i])\n              .x1((i) => X2[i])\n              .y1((i) => Y2[i])\n          )\n      )\n      .node();\n  }\n}\n\nfunction area(data, options) {\n  if (options === undefined) return areaY(data, {x: _options_js__WEBPACK_IMPORTED_MODULE_2__.first, y: _options_js__WEBPACK_IMPORTED_MODULE_2__.second});\n  return new Area(data, options);\n}\n\nfunction areaX(data, options) {\n  const {y = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, ...rest} = (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_6__.maybeDenseIntervalY)(options);\n  return new Area(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_7__.maybeStackX)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__.maybeIdentityX)({...rest, y1: y, y2: undefined}, y === _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf ? \"x2\" : \"x\")));\n}\n\nfunction areaY(data, options) {\n  const {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, ...rest} = (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_6__.maybeDenseIntervalX)(options);\n  return new Area(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_7__.maybeStackY)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__.maybeIdentityY)({...rest, x1: x, x2: undefined}, x === _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf ? \"y2\" : \"y\")));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9hcmVhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNFO0FBQ1A7QUFDNkI7QUFPeEM7QUFDeUQ7QUFDTDtBQUNUOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxtQkFBbUIsMENBQUk7QUFDOUIsZ0NBQWdDO0FBQ2hDLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELFlBQVksT0FBTyxtREFBTTtBQUN6QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQTBDO0FBQ3JELFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQVU7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakMsZ0JBQWdCLGdFQUF5QjtBQUN6QztBQUNBO0FBQ0EsWUFBWSx3Q0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsaURBQWlELEdBQUcsOENBQUssS0FBSywrQ0FBTSxDQUFDO0FBQ3JFO0FBQ0E7O0FBRU87QUFDUCxTQUFTLElBQUksZ0RBQU8sV0FBVyxFQUFFLHVFQUFtQjtBQUNwRCx3QkFBd0IsaUVBQVcsQ0FBQyx1RUFBYyxFQUFFLDhCQUE4QixRQUFRLGdEQUFPO0FBQ2pHOztBQUVPO0FBQ1AsU0FBUyxJQUFJLGdEQUFPLFdBQVcsRUFBRSx1RUFBbUI7QUFDcEQsd0JBQXdCLGlFQUFXLENBQUMsdUVBQWMsRUFBRSw4QkFBOEIsUUFBUSxnREFBTztBQUNqRyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvYXJlYS5qcz9kMjVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXJlYSBhcyBzaGFwZUFyZWF9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge21heWJlQ3VydmV9IGZyb20gXCIuLi9jdXJ2ZS5qc1wiO1xuaW1wb3J0IHtNYXJrfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtmaXJzdCwgaW5kZXhPZiwgbWF5YmVaLCBzZWNvbmR9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge1xuICBhcHBseURpcmVjdFN0eWxlcyxcbiAgYXBwbHlJbmRpcmVjdFN0eWxlcyxcbiAgYXBwbHlUcmFuc2Zvcm0sXG4gIGFwcGx5R3JvdXBlZENoYW5uZWxTdHlsZXMsXG4gIGdyb3VwSW5kZXhcbn0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge21heWJlRGVuc2VJbnRlcnZhbFgsIG1heWJlRGVuc2VJbnRlcnZhbFl9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2Jpbi5qc1wiO1xuaW1wb3J0IHttYXliZUlkZW50aXR5WCwgbWF5YmVJZGVudGl0eVl9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge21heWJlU3RhY2tYLCBtYXliZVN0YWNrWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvc3RhY2suanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJhcmVhXCIsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDFcbn07XG5cbmV4cG9ydCBjbGFzcyBBcmVhIGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt4MSwgeTEsIHgyLCB5MiwgeiwgY3VydmUsIHRlbnNpb259ID0gb3B0aW9ucztcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHgxOiB7dmFsdWU6IHgxLCBzY2FsZTogXCJ4XCJ9LFxuICAgICAgICB5MToge3ZhbHVlOiB5MSwgc2NhbGU6IFwieVwifSxcbiAgICAgICAgeDI6IHt2YWx1ZTogeDIsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5Mjoge3ZhbHVlOiB5Miwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHo6IHt2YWx1ZTogbWF5YmVaKG9wdGlvbnMpLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy5jdXJ2ZSA9IG1heWJlQ3VydmUoY3VydmUsIHRlbnNpb24pO1xuICB9XG4gIGZpbHRlcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eDE6IFgxLCB5MTogWTEsIHgyOiBYMiA9IFgxLCB5MjogWTIgPSBZMX0gPSBjaGFubmVscztcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywgc2NhbGVzLCAwLCAwKVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAuZGF0YShncm91cEluZGV4KGluZGV4LCBbWDEsIFkxLCBYMiwgWTJdLCB0aGlzLCBjaGFubmVscykpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCB0aGlzKVxuICAgICAgICAgIC5jYWxsKGFwcGx5R3JvdXBlZENoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgICAgIC5hdHRyKFxuICAgICAgICAgICAgXCJkXCIsXG4gICAgICAgICAgICBzaGFwZUFyZWEoKVxuICAgICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSlcbiAgICAgICAgICAgICAgLmRlZmluZWQoKGkpID0+IGkgPj0gMClcbiAgICAgICAgICAgICAgLngwKChpKSA9PiBYMVtpXSlcbiAgICAgICAgICAgICAgLnkwKChpKSA9PiBZMVtpXSlcbiAgICAgICAgICAgICAgLngxKChpKSA9PiBYMltpXSlcbiAgICAgICAgICAgICAgLnkxKChpKSA9PiBZMltpXSlcbiAgICAgICAgICApXG4gICAgICApXG4gICAgICAubm9kZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVhKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGFyZWFZKGRhdGEsIHt4OiBmaXJzdCwgeTogc2Vjb25kfSk7XG4gIHJldHVybiBuZXcgQXJlYShkYXRhLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyZWFYKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qge3kgPSBpbmRleE9mLCAuLi5yZXN0fSA9IG1heWJlRGVuc2VJbnRlcnZhbFkob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgQXJlYShkYXRhLCBtYXliZVN0YWNrWChtYXliZUlkZW50aXR5WCh7Li4ucmVzdCwgeTE6IHksIHkyOiB1bmRlZmluZWR9LCB5ID09PSBpbmRleE9mID8gXCJ4MlwiIDogXCJ4XCIpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVhWShkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHt4ID0gaW5kZXhPZiwgLi4ucmVzdH0gPSBtYXliZURlbnNlSW50ZXJ2YWxYKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IEFyZWEoZGF0YSwgbWF5YmVTdGFja1kobWF5YmVJZGVudGl0eVkoey4uLnJlc3QsIHgxOiB4LCB4MjogdW5kZWZpbmVkfSwgeCA9PT0gaW5kZXhPZiA/IFwieTJcIiA6IFwieVwiKSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/area.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Arrow: () => (/* binding */ Arrow),\n/* harmony export */   arrow: () => (/* binding */ arrow)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ \"(ssr)/./node_modules/@observablehq/plot/src/math.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./link.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/link.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\n\nclass Arrow extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8, // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset,\n      sweep\n    } = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n    this.sweep = maybeSweep(sweep);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1, SW} = channels;\n    const {strokeWidth, bend, headAngle, headLength, insetStart, insetEnd} = this;\n    const sw = SW ? (i) => SW[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.constant)(strokeWidth === undefined ? 1 : strokeWidth);\n\n    // The angle between the arrow’s shaft and one of the wings; the “head”\n    // angle between the wings is twice this value.\n    const wingAngle = (headAngle * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians) / 2;\n\n    // The length of the arrowhead’s “wings” (the line segments that extend from\n    // the end point) relative to the stroke width.\n    const wingScale = headLength / 1.5;\n\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyDirectStyles, this)\n          .attr(\"d\", (i) => {\n            // The start ⟨x1,y1⟩ and end ⟨x2,y2⟩ points may be inset, and the\n            // ending line angle may be altered for inset swoopy arrows.\n            let x1 = X1[i],\n              y1 = Y1[i],\n              x2 = X2[i],\n              y2 = Y2[i];\n            const lineLength = Math.hypot(x2 - x1, y2 - y1);\n            if (lineLength <= insetStart + insetEnd) return null;\n            let lineAngle = Math.atan2(y2 - y1, x2 - x1);\n\n            // We don’t allow the wing length to be too large relative to the\n            // length of the arrow. (Plot.vector allows arbitrarily large\n            // wings, but that’s okay since vectors are usually small.)\n            const headLength = Math.min(wingScale * sw(i), lineLength / 3);\n\n            // When bending, the offset between the straight line between the two points\n            // and the outgoing tangent from the start point. (Also the negative\n            // incoming tangent to the end point.) This must be within ±π/2. A positive\n            // angle will produce a clockwise curve; a negative angle will produce a\n            // counterclockwise curve; zero will produce a straight line.\n            const bendAngle = this.sweep(x1, y1, x2, y2) * bend * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians;\n\n            // The radius of the circle that intersects with the two endpoints\n            // and has the specified bend angle.\n            const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n\n            // Apply insets.\n            if (insetStart || insetEnd) {\n              if (r < 1e5) {\n                // For inset swoopy arrows, compute the circle-circle\n                // intersection between a circle centered around the\n                // respective arrow endpoint and the center of the circle\n                // segment that forms the shaft of the arrow.\n                const sign = Math.sign(bendAngle);\n                const [cx, cy] = pointPointCenter([x1, y1], [x2, y2], r, sign);\n                if (insetStart) {\n                  [x1, y1] = circleCircleIntersect([cx, cy, r], [x1, y1, insetStart], -sign * Math.sign(insetStart));\n                }\n                // For the end inset, rotate the arrowhead so that it aligns\n                // with the truncated end of the arrow. Since the arrow is a\n                // segment of the circle centered at ⟨cx,cy⟩, we can compute\n                // the angular difference to the new endpoint.\n                if (insetEnd) {\n                  const [x, y] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign * Math.sign(insetEnd));\n                  lineAngle += Math.atan2(y - cy, x - cx) - Math.atan2(y2 - cy, x2 - cx);\n                  (x2 = x), (y2 = y);\n                }\n              } else {\n                // For inset straight arrows, offset along the straight line.\n                const dx = x2 - x1,\n                  dy = y2 - y1,\n                  d = Math.hypot(dx, dy);\n                if (insetStart) (x1 += (dx / d) * insetStart), (y1 += (dy / d) * insetStart);\n                if (insetEnd) (x2 -= (dx / d) * insetEnd), (y2 -= (dy / d) * insetEnd);\n              }\n            }\n\n            // The angle of the arrow as it approaches the endpoint, and the\n            // angles of the adjacent wings. Here “left” refers to if the\n            // arrow is pointing up.\n            const endAngle = lineAngle + bendAngle;\n            const leftAngle = endAngle + wingAngle;\n            const rightAngle = endAngle - wingAngle;\n\n            // The endpoints of the two wings.\n            const x3 = x2 - headLength * Math.cos(leftAngle);\n            const y3 = y2 - headLength * Math.sin(leftAngle);\n            const x4 = x2 - headLength * Math.cos(rightAngle);\n            const y4 = y2 - headLength * Math.sin(rightAngle);\n\n            // If the radius is very large (or even infinite, as when the bend\n            // angle is zero), then render a straight line.\n            const a = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;\n            const h = headLength ? `M${x3},${y3}L${x2},${y2}L${x4},${y4}` : \"\";\n            return `M${x1},${y1}${a}${x2},${y2}${h}`;\n          })\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\n// Maybe flip the bend angle, depending on the arrow orientation.\nfunction maybeSweep(sweep = 1) {\n  if (typeof sweep === \"number\") return (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.constant)(Math.sign(sweep));\n  if (typeof sweep === \"function\") return (x1, y1, x2, y2) => Math.sign(sweep(x1, y1, x2, y2));\n  switch ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyword)(sweep, \"sweep\", [\"+x\", \"-x\", \"+y\", \"-y\"])) {\n    case \"+x\":\n      return (x1, y1, x2) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.ascending)(x1, x2);\n    case \"-x\":\n      return (x1, y1, x2) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(x1, x2);\n    case \"+y\":\n      return (x1, y1, x2, y2) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.ascending)(y1, y2);\n    case \"-y\":\n      return (x1, y1, x2, y2) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(y1, y2);\n  }\n}\n\n// Returns the center of a circle that goes through the two given points ⟨ax,ay⟩\n// and ⟨bx,by⟩ and has radius r. There are two such points; use the sign +1 or\n// -1 to choose between them. Returns [NaN, NaN] if r is too small.\nfunction pointPointCenter([ax, ay], [bx, by], r, sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const k = (sign * Math.sqrt(r * r - (d * d) / 4)) / d;\n  return [(ax + bx) / 2 - dy * k, (ay + by) / 2 + dx * k];\n}\n\n// Given two circles, one centered at ⟨ax,ay⟩ with radius ar, and the other\n// centered at ⟨bx,by⟩ with radius br, returns a point at which the two circles\n// intersect. There are typically two such points; use the sign +1 or -1 to\n// chose between them. Returns [NaN, NaN] if there is no intersection.\n// https://mathworld.wolfram.com/Circle-CircleIntersection.html\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const x = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y = sign * Math.sqrt(ar * ar - x * x);\n  return [ax + (dx * x + dy * y) / d, ay + (dy * x - dx * y) / d];\n}\n\nfunction arrow(data, {x, x1, x2, y, y1, y2, ...options} = {}) {\n  [x1, x2] = (0,_link_js__WEBPACK_IMPORTED_MODULE_6__.maybeSameValue)(x, x1, x2);\n  [y1, y2] = (0,_link_js__WEBPACK_IMPORTED_MODULE_6__.maybeSameValue)(y, y1, y2);\n  return new Arrow(data, {...options, x1, x2, y1, y2});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9hcnJvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBeUM7QUFDSjtBQUNMO0FBQ0c7QUFDYTtBQUN1RDtBQUM5RDs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxvQkFBb0IsMENBQUk7QUFDL0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWE7QUFDYixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQThDO0FBQ3pELFdBQVcsZ0VBQWdFO0FBQzNFLG1DQUFtQyxxREFBUTs7QUFFM0MsaUVBQWlFO0FBQ2pFO0FBQ0EsbUNBQW1DLDZDQUFPOztBQUUxQztBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHVDQUF1QztBQUN2QyxrRUFBa0UsNkNBQU87O0FBRXpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsR0FBRyxHQUFHLE1BQU0sdUJBQXVCO0FBQ3pFLHVDQUF1QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDeEUsdUJBQXVCLEdBQUcsR0FBRyxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsRUFBRTtBQUNuRCxXQUFXO0FBQ1gsZ0JBQWdCLHlEQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFRO0FBQ2hEO0FBQ0EsVUFBVSxvREFBTztBQUNqQjtBQUNBLDZCQUE2Qiw2Q0FBUztBQUN0QztBQUNBLDZCQUE2Qiw4Q0FBVTtBQUN2QztBQUNBLGlDQUFpQyw2Q0FBUztBQUMxQztBQUNBLGlDQUFpQyw4Q0FBVTtBQUMzQztBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxzQkFBc0Isa0NBQWtDLElBQUk7QUFDbkUsYUFBYSx3REFBYztBQUMzQixhQUFhLHdEQUFjO0FBQzNCLDBCQUEwQiwyQkFBMkI7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2Fycm93LmpzP2E4OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthc2NlbmRpbmcsIGRlc2NlbmRpbmd9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge3JhZGlhbnN9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2NvbnN0YW50LCBrZXl3b3JkfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseUNoYW5uZWxTdHlsZXMsIGFwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybX0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge21heWJlU2FtZVZhbHVlfSBmcm9tIFwiLi9saW5rLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiYXJyb3dcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VXaWR0aDogMS41XG59O1xuXG5leHBvcnQgY2xhc3MgQXJyb3cgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICBiZW5kID0gMCxcbiAgICAgIGhlYWRBbmdsZSA9IDYwLFxuICAgICAgaGVhZExlbmd0aCA9IDgsIC8vIERpc2FibGUgdGhlIGFycm93IHdpdGggaGVhZExlbmd0aCA9IDA7IG9yLCB1c2UgUGxvdC5saW5rLlxuICAgICAgaW5zZXQgPSAwLFxuICAgICAgaW5zZXRTdGFydCA9IGluc2V0LFxuICAgICAgaW5zZXRFbmQgPSBpbnNldCxcbiAgICAgIHN3ZWVwXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4MToge3ZhbHVlOiB4MSwgc2NhbGU6IFwieFwifSxcbiAgICAgICAgeTE6IHt2YWx1ZTogeTEsIHNjYWxlOiBcInlcIn0sXG4gICAgICAgIHgyOiB7dmFsdWU6IHgyLCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeTI6IHt2YWx1ZTogeTIsIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLmJlbmQgPSBiZW5kID09PSB0cnVlID8gMjIuNSA6IE1hdGgubWF4KC05MCwgTWF0aC5taW4oOTAsIGJlbmQpKTtcbiAgICB0aGlzLmhlYWRBbmdsZSA9ICtoZWFkQW5nbGU7XG4gICAgdGhpcy5oZWFkTGVuZ3RoID0gK2hlYWRMZW5ndGg7XG4gICAgdGhpcy5pbnNldFN0YXJ0ID0gK2luc2V0U3RhcnQ7XG4gICAgdGhpcy5pbnNldEVuZCA9ICtpbnNldEVuZDtcbiAgICB0aGlzLnN3ZWVwID0gbWF5YmVTd2VlcChzd2VlcCk7XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3Qge3gxOiBYMSwgeTE6IFkxLCB4MjogWDIgPSBYMSwgeTI6IFkyID0gWTEsIFNXfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHtzdHJva2VXaWR0aCwgYmVuZCwgaGVhZEFuZ2xlLCBoZWFkTGVuZ3RoLCBpbnNldFN0YXJ0LCBpbnNldEVuZH0gPSB0aGlzO1xuICAgIGNvbnN0IHN3ID0gU1cgPyAoaSkgPT4gU1dbaV0gOiBjb25zdGFudChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHN0cm9rZVdpZHRoKTtcblxuICAgIC8vIFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBhcnJvd+KAmXMgc2hhZnQgYW5kIG9uZSBvZiB0aGUgd2luZ3M7IHRoZSDigJxoZWFk4oCdXG4gICAgLy8gYW5nbGUgYmV0d2VlbiB0aGUgd2luZ3MgaXMgdHdpY2UgdGhpcyB2YWx1ZS5cbiAgICBjb25zdCB3aW5nQW5nbGUgPSAoaGVhZEFuZ2xlICogcmFkaWFucykgLyAyO1xuXG4gICAgLy8gVGhlIGxlbmd0aCBvZiB0aGUgYXJyb3doZWFk4oCZcyDigJx3aW5nc+KAnSAodGhlIGxpbmUgc2VnbWVudHMgdGhhdCBleHRlbmQgZnJvbVxuICAgIC8vIHRoZSBlbmQgcG9pbnQpIHJlbGF0aXZlIHRvIHRoZSBzdHJva2Ugd2lkdGguXG4gICAgY29uc3Qgd2luZ1NjYWxlID0gaGVhZExlbmd0aCAvIDEuNTtcblxuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCBzY2FsZXMpXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcImRcIiwgKGkpID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBzdGFydCDin6h4MSx5MeKfqSBhbmQgZW5kIOKfqHgyLHky4p+pIHBvaW50cyBtYXkgYmUgaW5zZXQsIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGVuZGluZyBsaW5lIGFuZ2xlIG1heSBiZSBhbHRlcmVkIGZvciBpbnNldCBzd29vcHkgYXJyb3dzLlxuICAgICAgICAgICAgbGV0IHgxID0gWDFbaV0sXG4gICAgICAgICAgICAgIHkxID0gWTFbaV0sXG4gICAgICAgICAgICAgIHgyID0gWDJbaV0sXG4gICAgICAgICAgICAgIHkyID0gWTJbaV07XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gTWF0aC5oeXBvdCh4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgICAgICAgIGlmIChsaW5lTGVuZ3RoIDw9IGluc2V0U3RhcnQgKyBpbnNldEVuZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbGluZUFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcblxuICAgICAgICAgICAgLy8gV2UgZG9u4oCZdCBhbGxvdyB0aGUgd2luZyBsZW5ndGggdG8gYmUgdG9vIGxhcmdlIHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIHRoZSBhcnJvdy4gKFBsb3QudmVjdG9yIGFsbG93cyBhcmJpdHJhcmlseSBsYXJnZVxuICAgICAgICAgICAgLy8gd2luZ3MsIGJ1dCB0aGF04oCZcyBva2F5IHNpbmNlIHZlY3RvcnMgYXJlIHVzdWFsbHkgc21hbGwuKVxuICAgICAgICAgICAgY29uc3QgaGVhZExlbmd0aCA9IE1hdGgubWluKHdpbmdTY2FsZSAqIHN3KGkpLCBsaW5lTGVuZ3RoIC8gMyk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gYmVuZGluZywgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBzdHJhaWdodCBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHNcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgb3V0Z29pbmcgdGFuZ2VudCBmcm9tIHRoZSBzdGFydCBwb2ludC4gKEFsc28gdGhlIG5lZ2F0aXZlXG4gICAgICAgICAgICAvLyBpbmNvbWluZyB0YW5nZW50IHRvIHRoZSBlbmQgcG9pbnQuKSBUaGlzIG11c3QgYmUgd2l0aGluIMKxz4AvMi4gQSBwb3NpdGl2ZVxuICAgICAgICAgICAgLy8gYW5nbGUgd2lsbCBwcm9kdWNlIGEgY2xvY2t3aXNlIGN1cnZlOyBhIG5lZ2F0aXZlIGFuZ2xlIHdpbGwgcHJvZHVjZSBhXG4gICAgICAgICAgICAvLyBjb3VudGVyY2xvY2t3aXNlIGN1cnZlOyB6ZXJvIHdpbGwgcHJvZHVjZSBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgICAgICBjb25zdCBiZW5kQW5nbGUgPSB0aGlzLnN3ZWVwKHgxLCB5MSwgeDIsIHkyKSAqIGJlbmQgKiByYWRpYW5zO1xuXG4gICAgICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHR3byBlbmRwb2ludHNcbiAgICAgICAgICAgIC8vIGFuZCBoYXMgdGhlIHNwZWNpZmllZCBiZW5kIGFuZ2xlLlxuICAgICAgICAgICAgY29uc3QgciA9IE1hdGguaHlwb3QobGluZUxlbmd0aCAvIE1hdGgudGFuKGJlbmRBbmdsZSksIGxpbmVMZW5ndGgpIC8gMjtcblxuICAgICAgICAgICAgLy8gQXBwbHkgaW5zZXRzLlxuICAgICAgICAgICAgaWYgKGluc2V0U3RhcnQgfHwgaW5zZXRFbmQpIHtcbiAgICAgICAgICAgICAgaWYgKHIgPCAxZTUpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5zZXQgc3dvb3B5IGFycm93cywgY29tcHV0ZSB0aGUgY2lyY2xlLWNpcmNsZVxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgY2lyY2xlIGNlbnRlcmVkIGFyb3VuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlIGFycm93IGVuZHBvaW50IGFuZCB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IHRoYXQgZm9ybXMgdGhlIHNoYWZ0IG9mIHRoZSBhcnJvdy5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKGJlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSBwb2ludFBvaW50Q2VudGVyKFt4MSwgeTFdLCBbeDIsIHkyXSwgciwgc2lnbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2V0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIFt4MSwgeTFdID0gY2lyY2xlQ2lyY2xlSW50ZXJzZWN0KFtjeCwgY3ksIHJdLCBbeDEsIHkxLCBpbnNldFN0YXJ0XSwgLXNpZ24gKiBNYXRoLnNpZ24oaW5zZXRTdGFydCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGVuZCBpbnNldCwgcm90YXRlIHRoZSBhcnJvd2hlYWQgc28gdGhhdCBpdCBhbGlnbnNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSB0cnVuY2F0ZWQgZW5kIG9mIHRoZSBhcnJvdy4gU2luY2UgdGhlIGFycm93IGlzIGFcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50IG9mIHRoZSBjaXJjbGUgY2VudGVyZWQgYXQg4p+oY3gsY3nin6ksIHdlIGNhbiBjb21wdXRlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFuZ3VsYXIgZGlmZmVyZW5jZSB0byB0aGUgbmV3IGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIGlmIChpbnNldEVuZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgW3gsIHldID0gY2lyY2xlQ2lyY2xlSW50ZXJzZWN0KFtjeCwgY3ksIHJdLCBbeDIsIHkyLCBpbnNldEVuZF0sIHNpZ24gKiBNYXRoLnNpZ24oaW5zZXRFbmQpKTtcbiAgICAgICAgICAgICAgICAgIGxpbmVBbmdsZSArPSBNYXRoLmF0YW4yKHkgLSBjeSwgeCAtIGN4KSAtIE1hdGguYXRhbjIoeTIgLSBjeSwgeDIgLSBjeCk7XG4gICAgICAgICAgICAgICAgICAoeDIgPSB4KSwgKHkyID0geSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBpbnNldCBzdHJhaWdodCBhcnJvd3MsIG9mZnNldCBhbG9uZyB0aGUgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHgyIC0geDEsXG4gICAgICAgICAgICAgICAgICBkeSA9IHkyIC0geTEsXG4gICAgICAgICAgICAgICAgICBkID0gTWF0aC5oeXBvdChkeCwgZHkpO1xuICAgICAgICAgICAgICAgIGlmIChpbnNldFN0YXJ0KSAoeDEgKz0gKGR4IC8gZCkgKiBpbnNldFN0YXJ0KSwgKHkxICs9IChkeSAvIGQpICogaW5zZXRTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGluc2V0RW5kKSAoeDIgLT0gKGR4IC8gZCkgKiBpbnNldEVuZCksICh5MiAtPSAoZHkgLyBkKSAqIGluc2V0RW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgYW5nbGUgb2YgdGhlIGFycm93IGFzIGl0IGFwcHJvYWNoZXMgdGhlIGVuZHBvaW50LCBhbmQgdGhlXG4gICAgICAgICAgICAvLyBhbmdsZXMgb2YgdGhlIGFkamFjZW50IHdpbmdzLiBIZXJlIOKAnGxlZnTigJ0gcmVmZXJzIHRvIGlmIHRoZVxuICAgICAgICAgICAgLy8gYXJyb3cgaXMgcG9pbnRpbmcgdXAuXG4gICAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IGxpbmVBbmdsZSArIGJlbmRBbmdsZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGVuZEFuZ2xlICsgd2luZ0FuZ2xlO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRBbmdsZSA9IGVuZEFuZ2xlIC0gd2luZ0FuZ2xlO1xuXG4gICAgICAgICAgICAvLyBUaGUgZW5kcG9pbnRzIG9mIHRoZSB0d28gd2luZ3MuXG4gICAgICAgICAgICBjb25zdCB4MyA9IHgyIC0gaGVhZExlbmd0aCAqIE1hdGguY29zKGxlZnRBbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB5MyA9IHkyIC0gaGVhZExlbmd0aCAqIE1hdGguc2luKGxlZnRBbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB4NCA9IHgyIC0gaGVhZExlbmd0aCAqIE1hdGguY29zKHJpZ2h0QW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgeTQgPSB5MiAtIGhlYWRMZW5ndGggKiBNYXRoLnNpbihyaWdodEFuZ2xlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHJhZGl1cyBpcyB2ZXJ5IGxhcmdlIChvciBldmVuIGluZmluaXRlLCBhcyB3aGVuIHRoZSBiZW5kXG4gICAgICAgICAgICAvLyBhbmdsZSBpcyB6ZXJvKSwgdGhlbiByZW5kZXIgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICAgICAgY29uc3QgYSA9IHIgPCAxZTUgPyBgQSR7cn0sJHtyfSAwLDAsJHtiZW5kQW5nbGUgPiAwID8gMSA6IDB9IGAgOiBgTGA7XG4gICAgICAgICAgICBjb25zdCBoID0gaGVhZExlbmd0aCA/IGBNJHt4M30sJHt5M31MJHt4Mn0sJHt5Mn1MJHt4NH0sJHt5NH1gIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBgTSR7eDF9LCR7eTF9JHthfSR7eDJ9LCR7eTJ9JHtofWA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG4vLyBNYXliZSBmbGlwIHRoZSBiZW5kIGFuZ2xlLCBkZXBlbmRpbmcgb24gdGhlIGFycm93IG9yaWVudGF0aW9uLlxuZnVuY3Rpb24gbWF5YmVTd2VlcChzd2VlcCA9IDEpIHtcbiAgaWYgKHR5cGVvZiBzd2VlcCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNvbnN0YW50KE1hdGguc2lnbihzd2VlcCkpO1xuICBpZiAodHlwZW9mIHN3ZWVwID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAoeDEsIHkxLCB4MiwgeTIpID0+IE1hdGguc2lnbihzd2VlcCh4MSwgeTEsIHgyLCB5MikpO1xuICBzd2l0Y2ggKGtleXdvcmQoc3dlZXAsIFwic3dlZXBcIiwgW1wiK3hcIiwgXCIteFwiLCBcIit5XCIsIFwiLXlcIl0pKSB7XG4gICAgY2FzZSBcIit4XCI6XG4gICAgICByZXR1cm4gKHgxLCB5MSwgeDIpID0+IGFzY2VuZGluZyh4MSwgeDIpO1xuICAgIGNhc2UgXCIteFwiOlxuICAgICAgcmV0dXJuICh4MSwgeTEsIHgyKSA9PiBkZXNjZW5kaW5nKHgxLCB4Mik7XG4gICAgY2FzZSBcIit5XCI6XG4gICAgICByZXR1cm4gKHgxLCB5MSwgeDIsIHkyKSA9PiBhc2NlbmRpbmcoeTEsIHkyKTtcbiAgICBjYXNlIFwiLXlcIjpcbiAgICAgIHJldHVybiAoeDEsIHkxLCB4MiwgeTIpID0+IGRlc2NlbmRpbmcoeTEsIHkyKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgYSBjaXJjbGUgdGhhdCBnb2VzIHRocm91Z2ggdGhlIHR3byBnaXZlbiBwb2ludHMg4p+oYXgsYXnin6lcbi8vIGFuZCDin6hieCxieeKfqSBhbmQgaGFzIHJhZGl1cyByLiBUaGVyZSBhcmUgdHdvIHN1Y2ggcG9pbnRzOyB1c2UgdGhlIHNpZ24gKzEgb3Jcbi8vIC0xIHRvIGNob29zZSBiZXR3ZWVuIHRoZW0uIFJldHVybnMgW05hTiwgTmFOXSBpZiByIGlzIHRvbyBzbWFsbC5cbmZ1bmN0aW9uIHBvaW50UG9pbnRDZW50ZXIoW2F4LCBheV0sIFtieCwgYnldLCByLCBzaWduKSB7XG4gIGNvbnN0IGR4ID0gYnggLSBheCxcbiAgICBkeSA9IGJ5IC0gYXksXG4gICAgZCA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgY29uc3QgayA9IChzaWduICogTWF0aC5zcXJ0KHIgKiByIC0gKGQgKiBkKSAvIDQpKSAvIGQ7XG4gIHJldHVybiBbKGF4ICsgYngpIC8gMiAtIGR5ICogaywgKGF5ICsgYnkpIC8gMiArIGR4ICoga107XG59XG5cbi8vIEdpdmVuIHR3byBjaXJjbGVzLCBvbmUgY2VudGVyZWQgYXQg4p+oYXgsYXnin6kgd2l0aCByYWRpdXMgYXIsIGFuZCB0aGUgb3RoZXJcbi8vIGNlbnRlcmVkIGF0IOKfqGJ4LGJ54p+pIHdpdGggcmFkaXVzIGJyLCByZXR1cm5zIGEgcG9pbnQgYXQgd2hpY2ggdGhlIHR3byBjaXJjbGVzXG4vLyBpbnRlcnNlY3QuIFRoZXJlIGFyZSB0eXBpY2FsbHkgdHdvIHN1Y2ggcG9pbnRzOyB1c2UgdGhlIHNpZ24gKzEgb3IgLTEgdG9cbi8vIGNob3NlIGJldHdlZW4gdGhlbS4gUmV0dXJucyBbTmFOLCBOYU5dIGlmIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbi8vIGh0dHBzOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1DaXJjbGVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY2lyY2xlQ2lyY2xlSW50ZXJzZWN0KFtheCwgYXksIGFyXSwgW2J4LCBieSwgYnJdLCBzaWduKSB7XG4gIGNvbnN0IGR4ID0gYnggLSBheCxcbiAgICBkeSA9IGJ5IC0gYXksXG4gICAgZCA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgY29uc3QgeCA9IChkeCAqIGR4ICsgZHkgKiBkeSAtIGJyICogYnIgKyBhciAqIGFyKSAvICgyICogZCk7XG4gIGNvbnN0IHkgPSBzaWduICogTWF0aC5zcXJ0KGFyICogYXIgLSB4ICogeCk7XG4gIHJldHVybiBbYXggKyAoZHggKiB4ICsgZHkgKiB5KSAvIGQsIGF5ICsgKGR5ICogeCAtIGR4ICogeSkgLyBkXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycm93KGRhdGEsIHt4LCB4MSwgeDIsIHksIHkxLCB5MiwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeDEsIHgyXSA9IG1heWJlU2FtZVZhbHVlKHgsIHgxLCB4Mik7XG4gIFt5MSwgeTJdID0gbWF5YmVTYW1lVmFsdWUoeSwgeTEsIHkyKTtcbiAgcmV0dXJuIG5ldyBBcnJvdyhkYXRhLCB7Li4ub3B0aW9ucywgeDEsIHgyLCB5MSwgeTJ9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/arrow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/auto.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/auto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auto: () => (/* binding */ auto),\n/* harmony export */   autoSpec: () => (/* binding */ autoSpec)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n/* harmony import */ var _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transforms/group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./area.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/area.js\");\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bar.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\");\n/* harmony import */ var _cell_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cell.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/cell.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n/* harmony import */ var _frame_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./frame.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/frame.js\");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/line.js\");\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rect.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js\");\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rule.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction autoSpec(data, options) {\n  options = normalizeOptions(options);\n\n  // Greedily materialize columns for type inference; we’ll need them anyway to\n  // plot! Note that we don’t apply any type inference to the fx and fy\n  // channels, if present; these are always ordinal (at least for now).\n  const {x, y, color, size} = options;\n  const X = materializeValue(data, x);\n  const Y = materializeValue(data, y);\n  const C = materializeValue(data, color);\n  const S = materializeValue(data, size);\n\n  // Compute the default options.\n  let {\n    fx,\n    fy,\n    x: {value: xValue, reduce: xReduce, zero: xZero, ...xOptions},\n    y: {value: yValue, reduce: yReduce, zero: yZero, ...yOptions},\n    color: {value: colorValue, color: colorColor, reduce: colorReduce},\n    size: {value: sizeValue, reduce: sizeReduce}, // TODO constant radius?\n    mark\n  } = options;\n\n  // Determine the default reducer, if any.\n  if (xReduce === undefined)\n    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === undefined)\n    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n\n  // Determine the default size reducer, if any.\n  if (\n    sizeReduce === undefined &&\n    sizeValue == null &&\n    colorReduce == null &&\n    xReduce == null &&\n    yReduce == null &&\n    (xValue == null || (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X)) &&\n    (yValue == null || (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y))\n  ) {\n    sizeReduce = \"count\";\n  }\n\n  // Determine the default zero-ness.\n  if (xZero === undefined) xZero = isZeroReducer(xReduce) ? true : undefined;\n  if (yZero === undefined) yZero = isZeroReducer(yReduce) ? true : undefined;\n\n  // TODO Shorthand: array of primitives should result in a histogram\n  if (xValue == null && yValue == null) throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null) throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null) throw new Error(\"reducing y requires x\");\n\n  // Determine the default mark type.\n  if (mark === undefined) {\n    mark =\n      sizeValue != null || sizeReduce != null\n        ? \"dot\"\n        : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null // histogram or heatmap\n        ? \"bar\"\n        : xValue != null && yValue != null\n        ? (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) || (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y) || (xReduce == null && yReduce == null && !isMonotonic(X) && !isMonotonic(Y))\n          ? \"dot\"\n          : \"line\"\n        : xValue != null || yValue != null\n        ? \"rule\"\n        : null;\n  }\n\n  let Z; // may be set to null to disable series-by-color for line and area\n  let colorMode; // \"fill\" or \"stroke\"\n\n  // Determine the mark implementation.\n  let markImpl;\n  switch (mark) {\n    case \"dot\":\n      markImpl = _dot_js__WEBPACK_IMPORTED_MODULE_2__.dot;\n      colorMode = \"stroke\";\n      break;\n    case \"line\":\n      markImpl =\n        (X && Y) || xReduce != null || yReduce != null // same logic as area (see below), but default to line\n          ? yZero || yReduce != null || (X && isMonotonic(X))\n            ? _line_js__WEBPACK_IMPORTED_MODULE_3__.lineY\n            : xZero || xReduce != null || (Y && isMonotonic(Y))\n            ? _line_js__WEBPACK_IMPORTED_MODULE_3__.lineX\n            : _line_js__WEBPACK_IMPORTED_MODULE_3__.line\n          : X // 1d line by index\n          ? _line_js__WEBPACK_IMPORTED_MODULE_3__.lineX\n          : _line_js__WEBPACK_IMPORTED_MODULE_3__.lineY;\n      colorMode = \"stroke\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"area\":\n      markImpl = !(yZero || yReduce != null) && (xZero || xReduce != null || (Y && isMonotonic(Y))) ? _area_js__WEBPACK_IMPORTED_MODULE_4__.areaX : _area_js__WEBPACK_IMPORTED_MODULE_4__.areaY; // favor areaY if unsure\n      colorMode = \"fill\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"rule\":\n      markImpl = X ? _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleX : _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleY;\n      colorMode = \"stroke\";\n      break;\n    case \"bar\":\n      markImpl =\n        xReduce != null // bin or group on y\n          ? (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y)\n            ? isSelectReducer(xReduce) && X && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X)\n              ? _cell_js__WEBPACK_IMPORTED_MODULE_6__.cell\n              : _bar_js__WEBPACK_IMPORTED_MODULE_7__.barX\n            : _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectX\n          : yReduce != null // bin or group on x\n          ? (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X)\n            ? isSelectReducer(yReduce) && Y && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y)\n              ? _cell_js__WEBPACK_IMPORTED_MODULE_6__.cell\n              : _bar_js__WEBPACK_IMPORTED_MODULE_7__.barY\n            : _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectY\n          : colorReduce != null || sizeReduce != null // bin or group on both x and y\n          ? X && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) && Y && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y)\n            ? _cell_js__WEBPACK_IMPORTED_MODULE_6__.cell\n            : X && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X)\n            ? _bar_js__WEBPACK_IMPORTED_MODULE_7__.barY\n            : Y && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y)\n            ? _bar_js__WEBPACK_IMPORTED_MODULE_7__.barX\n            : _rect_js__WEBPACK_IMPORTED_MODULE_8__.rect\n          : X && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(X) && !(Y && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(Y))\n          ? _bar_js__WEBPACK_IMPORTED_MODULE_7__.barX // if y is temporal, treat as ordinal\n          : Y && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(Y) && !(X && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(X))\n          ? _bar_js__WEBPACK_IMPORTED_MODULE_7__.barY // if x is temporal, treat as ordinal\n          : _cell_js__WEBPACK_IMPORTED_MODULE_6__.cell;\n      colorMode = \"fill\";\n      break;\n    default:\n      throw new Error(`invalid mark: ${mark}`);\n  }\n\n  // Determine the mark options.\n  let markOptions = {\n    fx,\n    fy,\n    x: X ?? undefined, // treat null x as undefined for implicit stack\n    y: Y ?? undefined, // treat null y as undefined for implicit stack\n    [colorMode]: C ?? colorColor,\n    z: Z,\n    r: S ?? undefined, // treat null size as undefined for default constant radius\n    tip: true\n  };\n  let transformImpl;\n  let transformOptions = {[colorMode]: colorReduce ?? undefined, r: sizeReduce ?? undefined};\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`); // for now at least\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transformImpl = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupX : _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transformImpl = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y) ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupY : _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X && Y) {\n      transformImpl = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y) ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.group : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) ? _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y) ? _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX : _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin;\n    } else if (X) {\n      transformImpl = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(X) ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupX : _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX;\n    } else if (Y) {\n      transformImpl = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOrdinal)(Y) ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupY : _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY;\n    }\n  }\n\n  // When using the bin transform, pass through additional options (e.g., thresholds).\n  if (transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin || transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX) markOptions.x = {value: X, ...xOptions};\n  if (transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin || transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY) markOptions.y = {value: Y, ...yOptions};\n\n  // If zero-ness is not specified, default based on whether the resolved mark\n  // type will include a zero baseline.\n  if (xZero === undefined)\n    xZero =\n      X &&\n      !(transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin || transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX) &&\n      (markImpl === _bar_js__WEBPACK_IMPORTED_MODULE_7__.barX || markImpl === _area_js__WEBPACK_IMPORTED_MODULE_4__.areaX || markImpl === _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectX || markImpl === _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleY);\n  if (yZero === undefined)\n    yZero =\n      Y &&\n      !(transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin || transformImpl === _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY) &&\n      (markImpl === _bar_js__WEBPACK_IMPORTED_MODULE_7__.barY || markImpl === _area_js__WEBPACK_IMPORTED_MODULE_4__.areaY || markImpl === _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectY || markImpl === _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleX);\n\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      zero: !!xZero,\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      zero: !!yZero,\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...(colorColor !== undefined && {color: colorColor})\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark,\n    markImpl: implNames[markImpl],\n    markOptions,\n    transformImpl: implNames[transformImpl],\n    transformOptions,\n    colorMode\n  };\n}\n\nfunction auto(data, options) {\n  const spec = autoSpec(data, options);\n  const {\n    fx,\n    fy,\n    x: {zero: xZero},\n    y: {zero: yZero},\n    markOptions,\n    transformOptions,\n    colorMode\n  } = spec;\n  const markImpl = impls[spec.markImpl];\n  const transformImpl = impls[spec.transformImpl];\n  // In the case of filled marks (particularly bars and areas) the frame and\n  // rules should come after the mark; in the case of stroked marks\n  // (particularly dots and lines) they should come before the mark.\n  const frames = fx != null || fy != null ? (0,_frame_js__WEBPACK_IMPORTED_MODULE_11__.frame)({strokeOpacity: 0.1}) : null;\n  const rules = [xZero ? (0,_rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleX)([0]) : null, yZero ? (0,_rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleY)([0]) : null];\n  const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions) : markOptions);\n  return colorMode === \"stroke\" ? (0,_mark_js__WEBPACK_IMPORTED_MODULE_12__.marks)(frames, rules, mark) : (0,_mark_js__WEBPACK_IMPORTED_MODULE_12__.marks)(frames, mark, rules);\n}\n\n// TODO What about sorted within series?\nfunction isMonotonic(values) {\n  let previous;\n  let previousOrder;\n  for (const value of values) {\n    if (value == null) continue;\n    if (previous === undefined) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign((0,d3__WEBPACK_IMPORTED_MODULE_0__.ascending)(previous, value));\n    if (!order) continue; // skip zero, NaN\n    if (previousOrder !== undefined && order !== previousOrder) return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\n\n// Allow x and y and other dimensions to be specified as shorthand field names\n// (but note that they can also be specified as a {transform} object such as\n// Plot.identity). We don’t support reducers for the faceting, but for symmetry\n// with x and y we allow facets to be specified as {value} objects.\nfunction normalizeOptions({x, y, color, size, fx, fy, mark} = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(x)) x = makeOptions(x);\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(y)) y = makeOptions(y);\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(color)) color = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isColor)(color) ? {color} : makeOptions(color);\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(size)) size = makeOptions(size);\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(fx)) ({value: fx} = makeOptions(fx));\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(fy)) ({value: fy} = makeOptions(fy));\n  if (mark != null) mark = `${mark}`.toLowerCase();\n  return {x, y, color, size, fx, fy, mark};\n}\n\n// To apply heuristics based on the data types (values), realize the columns. We\n// could maybe look at the data.schema here, but Plot’s behavior depends on the\n// actual values anyway, so this probably is what we want.\nfunction materializeValue(data, options) {\n  const V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, options.value);\n  if (V) V.label = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.labelof)(options.value);\n  return V;\n}\n\nfunction makeOptions(value) {\n  return isReducer(value) ? {reduce: value} : {value};\n}\n\n// The distinct, count, sum, and proportion reducers are additive (stackable).\nfunction isZeroReducer(reduce) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce);\n}\n\n// The first, last, and mode reducers preserve the type of the aggregated values.\nfunction isSelectReducer(reduce) {\n  return /^(?:first|last|mode)$/i.test(reduce);\n}\n\n// https://github.com/observablehq/plot/blob/818562649280e155136f730fc496e0b3d15ae464/src/transforms/group.js#L236\nfunction isReducer(reduce) {\n  if (reduce == null) return false;\n  if (typeof reduce.reduceIndex === \"function\") return true;\n  if (typeof reduce.reduce === \"function\" && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(reduce)) return true; // N.B. array.reduce\n  if (/^p\\d{2}$/i.test(reduce)) return true;\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\": // TODO remove me?\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\": // TODO remove me?\n    case \"max\":\n    case \"max-index\": // TODO remove me?\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      // These are technically reducers, but I think we’d want to treat them as fields?\n      // case \"x\":\n      // case \"x1\":\n      // case \"x2\":\n      // case \"y\":\n      // case \"y1\":\n      // case \"y2\":\n      return true;\n  }\n  return false;\n}\n\nfunction isHighCardinality(value) {\n  return value ? new d3__WEBPACK_IMPORTED_MODULE_0__.InternSet(value).size > value.length >> 1 : false;\n}\n\nconst impls = {\n  dot: _dot_js__WEBPACK_IMPORTED_MODULE_2__.dot,\n  line: _line_js__WEBPACK_IMPORTED_MODULE_3__.line,\n  lineX: _line_js__WEBPACK_IMPORTED_MODULE_3__.lineX,\n  lineY: _line_js__WEBPACK_IMPORTED_MODULE_3__.lineY,\n  areaX: _area_js__WEBPACK_IMPORTED_MODULE_4__.areaX,\n  areaY: _area_js__WEBPACK_IMPORTED_MODULE_4__.areaY,\n  ruleX: _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleX,\n  ruleY: _rule_js__WEBPACK_IMPORTED_MODULE_5__.ruleY,\n  barX: _bar_js__WEBPACK_IMPORTED_MODULE_7__.barX,\n  barY: _bar_js__WEBPACK_IMPORTED_MODULE_7__.barY,\n  rect: _rect_js__WEBPACK_IMPORTED_MODULE_8__.rect,\n  rectX: _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectX,\n  rectY: _rect_js__WEBPACK_IMPORTED_MODULE_8__.rectY,\n  cell: _cell_js__WEBPACK_IMPORTED_MODULE_6__.cell,\n  bin: _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.bin,\n  binX: _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binX,\n  binY: _transforms_bin_js__WEBPACK_IMPORTED_MODULE_10__.binY,\n  group: _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.group,\n  groupX: _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupX,\n  groupY: _transforms_group_js__WEBPACK_IMPORTED_MODULE_9__.groupY\n};\n\n// Instead of returning the mark or transform implementation directly, we return\n// the implementation name to facilitate code compilation (“eject to explicit\n// marks”). An implementation-to-name mapping needs to live somewhere for\n// compilation, and by having it in Plot we can more easily introduce a new mark\n// or transform implementation in Plot.auto without having to synchronize a\n// downstream change in the compiler.\nconst implNames = Object.fromEntries(Object.entries(impls).map(([name, impl]) => [impl, name]));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9hdXRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNQO0FBQ2tFO0FBQzlDO0FBQ1E7QUFDdEI7QUFDSDtBQUNMO0FBQ0Y7QUFDSTtBQUNZO0FBQ0E7QUFDTjs7QUFFaEM7QUFDUDs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUF5RDtBQUNqRSxRQUFRLHlEQUF5RDtBQUNqRSxZQUFZLDBEQUEwRDtBQUN0RSxXQUFXLHFDQUFxQztBQUNoRDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBUztBQUNoQyx1QkFBdUIsc0RBQVM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBUyxPQUFPLHNEQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFLO0FBQ25CO0FBQ0EsY0FBYywyQ0FBSztBQUNuQixjQUFjLDBDQUFJO0FBQ2xCO0FBQ0EsWUFBWSwyQ0FBSztBQUNqQixZQUFZLDJDQUFLO0FBQ2pCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxzR0FBc0csMkNBQUssR0FBRywyQ0FBSyxFQUFFO0FBQ3JIO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQUssR0FBRywyQ0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUztBQUNyQiwrQ0FBK0Msc0RBQVM7QUFDeEQsZ0JBQWdCLDBDQUFJO0FBQ3BCLGdCQUFnQix5Q0FBSTtBQUNwQixjQUFjLDJDQUFLO0FBQ25CO0FBQ0EsWUFBWSxzREFBUztBQUNyQiwrQ0FBK0Msc0RBQVM7QUFDeEQsZ0JBQWdCLDBDQUFJO0FBQ3BCLGdCQUFnQix5Q0FBSTtBQUNwQixjQUFjLDJDQUFLO0FBQ25CO0FBQ0EsaUJBQWlCLHNEQUFTLFlBQVksc0RBQVM7QUFDL0MsY0FBYywwQ0FBSTtBQUNsQixtQkFBbUIsc0RBQVM7QUFDNUIsY0FBYyx5Q0FBSTtBQUNsQixtQkFBbUIsc0RBQVM7QUFDNUIsY0FBYyx5Q0FBSTtBQUNsQixjQUFjLDBDQUFJO0FBQ2xCLGlCQUFpQixzREFBUyxjQUFjLHNEQUFTO0FBQ2pELFlBQVkseUNBQUk7QUFDaEIsaUJBQWlCLHNEQUFTLGNBQWMsc0RBQVM7QUFDakQsWUFBWSx5Q0FBSTtBQUNoQixZQUFZLDBDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG1EQUFtRDtBQUNuRCxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isc0RBQVMsTUFBTSx3REFBTSxHQUFHLHFEQUFJO0FBQ2hELElBQUk7QUFDSjtBQUNBLG9CQUFvQixzREFBUyxNQUFNLHdEQUFNLEdBQUcscURBQUk7QUFDaEQsSUFBSTtBQUNKO0FBQ0Esc0JBQXNCLHNEQUFTLE9BQU8sc0RBQVMsTUFBTSx1REFBSyxHQUFHLHNEQUFTLE1BQU0scURBQUksR0FBRyxzREFBUyxNQUFNLHFEQUFJLEdBQUcsb0RBQUc7QUFDNUcsTUFBTTtBQUNOLHNCQUFzQixzREFBUyxNQUFNLHdEQUFNLEdBQUcscURBQUk7QUFDbEQsTUFBTTtBQUNOLHNCQUFzQixzREFBUyxNQUFNLHdEQUFNLEdBQUcscURBQUk7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixvREFBRyxzQkFBc0IscURBQUksbUJBQW1CO0FBQ3hFLHdCQUF3QixvREFBRyxzQkFBc0IscURBQUksbUJBQW1COztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFHLHNCQUFzQixxREFBSTtBQUN2RCxvQkFBb0IseUNBQUksaUJBQWlCLDJDQUFLLGlCQUFpQiwyQ0FBSyxpQkFBaUIsMkNBQUs7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFHLHNCQUFzQixxREFBSTtBQUN2RCxvQkFBb0IseUNBQUksaUJBQWlCLDJDQUFLLGlCQUFpQiwyQ0FBSyxpQkFBaUIsMkNBQUs7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsNENBQTRDLGlEQUFLLEVBQUUsbUJBQW1CO0FBQ3RFLHlCQUF5QiwrQ0FBSyxzQkFBc0IsK0NBQUs7QUFDekQ7QUFDQSxrQ0FBa0MsZ0RBQUssd0JBQXdCLGdEQUFLO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFTO0FBQ3JDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBLG9EQUFvRCxPQUFPO0FBQzNELDJCQUEyQixpQ0FBaUMsSUFBSTtBQUNoRSxPQUFPLHNEQUFTO0FBQ2hCLE9BQU8sc0RBQVM7QUFDaEIsT0FBTyxzREFBUyxpQkFBaUIsb0RBQU8sV0FBVyxPQUFPO0FBQzFELE9BQU8sc0RBQVM7QUFDaEIsTUFBTSxzREFBUyxRQUFRLFdBQVc7QUFDbEMsTUFBTSxzREFBUyxRQUFRLFdBQVc7QUFDbEMsOEJBQThCLEtBQUs7QUFDbkMsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBTztBQUNuQixtQkFBbUIsb0RBQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixlQUFlLEdBQUc7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscURBQVEsdUJBQXVCO0FBQzVFLFlBQVksRUFBRTtBQUNkLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUNBQVM7QUFDOUI7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOLE9BQU87QUFDUCxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUCxPQUFPO0FBQ1AsT0FBTztBQUNQLE1BQU07QUFDTixNQUFNO0FBQ04sTUFBTTtBQUNOLE9BQU87QUFDUCxPQUFPO0FBQ1AsTUFBTTtBQUNOLEtBQUs7QUFDTCxNQUFNO0FBQ04sTUFBTTtBQUNOLE9BQU87QUFDUCxRQUFRO0FBQ1IsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9hdXRvLmpzP2I0MzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthc2NlbmRpbmcsIEludGVyblNldH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge21hcmtzfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtpc0NvbG9yLCBpc051bWVyaWMsIGlzT2JqZWN0LCBpc09wdGlvbnMsIGlzT3JkaW5hbCwgbGFiZWxvZiwgdmFsdWVvZn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7YmluLCBiaW5YLCBiaW5ZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9iaW4uanNcIjtcbmltcG9ydCB7Z3JvdXAsIGdyb3VwWCwgZ3JvdXBZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9ncm91cC5qc1wiO1xuaW1wb3J0IHthcmVhWCwgYXJlYVl9IGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCB7YmFyWCwgYmFyWX0gZnJvbSBcIi4vYmFyLmpzXCI7XG5pbXBvcnQge2NlbGx9IGZyb20gXCIuL2NlbGwuanNcIjtcbmltcG9ydCB7ZG90fSBmcm9tIFwiLi9kb3QuanNcIjtcbmltcG9ydCB7ZnJhbWV9IGZyb20gXCIuL2ZyYW1lLmpzXCI7XG5pbXBvcnQge2xpbmUsIGxpbmVYLCBsaW5lWX0gZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IHtyZWN0LCByZWN0WCwgcmVjdFl9IGZyb20gXCIuL3JlY3QuanNcIjtcbmltcG9ydCB7cnVsZVgsIHJ1bGVZfSBmcm9tIFwiLi9ydWxlLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhdXRvU3BlYyhkYXRhLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIEdyZWVkaWx5IG1hdGVyaWFsaXplIGNvbHVtbnMgZm9yIHR5cGUgaW5mZXJlbmNlOyB3ZeKAmWxsIG5lZWQgdGhlbSBhbnl3YXkgdG9cbiAgLy8gcGxvdCEgTm90ZSB0aGF0IHdlIGRvbuKAmXQgYXBwbHkgYW55IHR5cGUgaW5mZXJlbmNlIHRvIHRoZSBmeCBhbmQgZnlcbiAgLy8gY2hhbm5lbHMsIGlmIHByZXNlbnQ7IHRoZXNlIGFyZSBhbHdheXMgb3JkaW5hbCAoYXQgbGVhc3QgZm9yIG5vdykuXG4gIGNvbnN0IHt4LCB5LCBjb2xvciwgc2l6ZX0gPSBvcHRpb25zO1xuICBjb25zdCBYID0gbWF0ZXJpYWxpemVWYWx1ZShkYXRhLCB4KTtcbiAgY29uc3QgWSA9IG1hdGVyaWFsaXplVmFsdWUoZGF0YSwgeSk7XG4gIGNvbnN0IEMgPSBtYXRlcmlhbGl6ZVZhbHVlKGRhdGEsIGNvbG9yKTtcbiAgY29uc3QgUyA9IG1hdGVyaWFsaXplVmFsdWUoZGF0YSwgc2l6ZSk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICBsZXQge1xuICAgIGZ4LFxuICAgIGZ5LFxuICAgIHg6IHt2YWx1ZTogeFZhbHVlLCByZWR1Y2U6IHhSZWR1Y2UsIHplcm86IHhaZXJvLCAuLi54T3B0aW9uc30sXG4gICAgeToge3ZhbHVlOiB5VmFsdWUsIHJlZHVjZTogeVJlZHVjZSwgemVybzogeVplcm8sIC4uLnlPcHRpb25zfSxcbiAgICBjb2xvcjoge3ZhbHVlOiBjb2xvclZhbHVlLCBjb2xvcjogY29sb3JDb2xvciwgcmVkdWNlOiBjb2xvclJlZHVjZX0sXG4gICAgc2l6ZToge3ZhbHVlOiBzaXplVmFsdWUsIHJlZHVjZTogc2l6ZVJlZHVjZX0sIC8vIFRPRE8gY29uc3RhbnQgcmFkaXVzP1xuICAgIG1hcmtcbiAgfSA9IG9wdGlvbnM7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBkZWZhdWx0IHJlZHVjZXIsIGlmIGFueS5cbiAgaWYgKHhSZWR1Y2UgPT09IHVuZGVmaW5lZClcbiAgICB4UmVkdWNlID0geVJlZHVjZSA9PSBudWxsICYmIHhWYWx1ZSA9PSBudWxsICYmIHNpemVWYWx1ZSA9PSBudWxsICYmIHlWYWx1ZSAhPSBudWxsID8gXCJjb3VudFwiIDogbnVsbDtcbiAgaWYgKHlSZWR1Y2UgPT09IHVuZGVmaW5lZClcbiAgICB5UmVkdWNlID0geFJlZHVjZSA9PSBudWxsICYmIHlWYWx1ZSA9PSBudWxsICYmIHNpemVWYWx1ZSA9PSBudWxsICYmIHhWYWx1ZSAhPSBudWxsID8gXCJjb3VudFwiIDogbnVsbDtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGRlZmF1bHQgc2l6ZSByZWR1Y2VyLCBpZiBhbnkuXG4gIGlmIChcbiAgICBzaXplUmVkdWNlID09PSB1bmRlZmluZWQgJiZcbiAgICBzaXplVmFsdWUgPT0gbnVsbCAmJlxuICAgIGNvbG9yUmVkdWNlID09IG51bGwgJiZcbiAgICB4UmVkdWNlID09IG51bGwgJiZcbiAgICB5UmVkdWNlID09IG51bGwgJiZcbiAgICAoeFZhbHVlID09IG51bGwgfHwgaXNPcmRpbmFsKFgpKSAmJlxuICAgICh5VmFsdWUgPT0gbnVsbCB8fCBpc09yZGluYWwoWSkpXG4gICkge1xuICAgIHNpemVSZWR1Y2UgPSBcImNvdW50XCI7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIGRlZmF1bHQgemVyby1uZXNzLlxuICBpZiAoeFplcm8gPT09IHVuZGVmaW5lZCkgeFplcm8gPSBpc1plcm9SZWR1Y2VyKHhSZWR1Y2UpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgaWYgKHlaZXJvID09PSB1bmRlZmluZWQpIHlaZXJvID0gaXNaZXJvUmVkdWNlcih5UmVkdWNlKSA/IHRydWUgOiB1bmRlZmluZWQ7XG5cbiAgLy8gVE9ETyBTaG9ydGhhbmQ6IGFycmF5IG9mIHByaW1pdGl2ZXMgc2hvdWxkIHJlc3VsdCBpbiBhIGhpc3RvZ3JhbVxuICBpZiAoeFZhbHVlID09IG51bGwgJiYgeVZhbHVlID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIm11c3Qgc3BlY2lmeSB4IG9yIHlcIik7XG4gIGlmICh4UmVkdWNlICE9IG51bGwgJiYgeVZhbHVlID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcInJlZHVjaW5nIHggcmVxdWlyZXMgeVwiKTtcbiAgaWYgKHlSZWR1Y2UgIT0gbnVsbCAmJiB4VmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwicmVkdWNpbmcgeSByZXF1aXJlcyB4XCIpO1xuXG4gIC8vIERldGVybWluZSB0aGUgZGVmYXVsdCBtYXJrIHR5cGUuXG4gIGlmIChtYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXJrID1cbiAgICAgIHNpemVWYWx1ZSAhPSBudWxsIHx8IHNpemVSZWR1Y2UgIT0gbnVsbFxuICAgICAgICA/IFwiZG90XCJcbiAgICAgICAgOiBpc1plcm9SZWR1Y2VyKHhSZWR1Y2UpIHx8IGlzWmVyb1JlZHVjZXIoeVJlZHVjZSkgfHwgY29sb3JSZWR1Y2UgIT0gbnVsbCAvLyBoaXN0b2dyYW0gb3IgaGVhdG1hcFxuICAgICAgICA/IFwiYmFyXCJcbiAgICAgICAgOiB4VmFsdWUgIT0gbnVsbCAmJiB5VmFsdWUgIT0gbnVsbFxuICAgICAgICA/IGlzT3JkaW5hbChYKSB8fCBpc09yZGluYWwoWSkgfHwgKHhSZWR1Y2UgPT0gbnVsbCAmJiB5UmVkdWNlID09IG51bGwgJiYgIWlzTW9ub3RvbmljKFgpICYmICFpc01vbm90b25pYyhZKSlcbiAgICAgICAgICA/IFwiZG90XCJcbiAgICAgICAgICA6IFwibGluZVwiXG4gICAgICAgIDogeFZhbHVlICE9IG51bGwgfHwgeVZhbHVlICE9IG51bGxcbiAgICAgICAgPyBcInJ1bGVcIlxuICAgICAgICA6IG51bGw7XG4gIH1cblxuICBsZXQgWjsgLy8gbWF5IGJlIHNldCB0byBudWxsIHRvIGRpc2FibGUgc2VyaWVzLWJ5LWNvbG9yIGZvciBsaW5lIGFuZCBhcmVhXG4gIGxldCBjb2xvck1vZGU7IC8vIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCJcblxuICAvLyBEZXRlcm1pbmUgdGhlIG1hcmsgaW1wbGVtZW50YXRpb24uXG4gIGxldCBtYXJrSW1wbDtcbiAgc3dpdGNoIChtYXJrKSB7XG4gICAgY2FzZSBcImRvdFwiOlxuICAgICAgbWFya0ltcGwgPSBkb3Q7XG4gICAgICBjb2xvck1vZGUgPSBcInN0cm9rZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIG1hcmtJbXBsID1cbiAgICAgICAgKFggJiYgWSkgfHwgeFJlZHVjZSAhPSBudWxsIHx8IHlSZWR1Y2UgIT0gbnVsbCAvLyBzYW1lIGxvZ2ljIGFzIGFyZWEgKHNlZSBiZWxvdyksIGJ1dCBkZWZhdWx0IHRvIGxpbmVcbiAgICAgICAgICA/IHlaZXJvIHx8IHlSZWR1Y2UgIT0gbnVsbCB8fCAoWCAmJiBpc01vbm90b25pYyhYKSlcbiAgICAgICAgICAgID8gbGluZVlcbiAgICAgICAgICAgIDogeFplcm8gfHwgeFJlZHVjZSAhPSBudWxsIHx8IChZICYmIGlzTW9ub3RvbmljKFkpKVxuICAgICAgICAgICAgPyBsaW5lWFxuICAgICAgICAgICAgOiBsaW5lXG4gICAgICAgICAgOiBYIC8vIDFkIGxpbmUgYnkgaW5kZXhcbiAgICAgICAgICA/IGxpbmVYXG4gICAgICAgICAgOiBsaW5lWTtcbiAgICAgIGNvbG9yTW9kZSA9IFwic3Ryb2tlXCI7XG4gICAgICBpZiAoaXNIaWdoQ2FyZGluYWxpdHkoQykpIFogPSBudWxsOyAvLyBUT0RPIG9ubHkgaWYgeiBub3Qgc2V0IGJ5IHVzZXJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICBtYXJrSW1wbCA9ICEoeVplcm8gfHwgeVJlZHVjZSAhPSBudWxsKSAmJiAoeFplcm8gfHwgeFJlZHVjZSAhPSBudWxsIHx8IChZICYmIGlzTW9ub3RvbmljKFkpKSkgPyBhcmVhWCA6IGFyZWFZOyAvLyBmYXZvciBhcmVhWSBpZiB1bnN1cmVcbiAgICAgIGNvbG9yTW9kZSA9IFwiZmlsbFwiO1xuICAgICAgaWYgKGlzSGlnaENhcmRpbmFsaXR5KEMpKSBaID0gbnVsbDsgLy8gVE9ETyBvbmx5IGlmIHogbm90IHNldCBieSB1c2VyXG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicnVsZVwiOlxuICAgICAgbWFya0ltcGwgPSBYID8gcnVsZVggOiBydWxlWTtcbiAgICAgIGNvbG9yTW9kZSA9IFwic3Ryb2tlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFyXCI6XG4gICAgICBtYXJrSW1wbCA9XG4gICAgICAgIHhSZWR1Y2UgIT0gbnVsbCAvLyBiaW4gb3IgZ3JvdXAgb24geVxuICAgICAgICAgID8gaXNPcmRpbmFsKFkpXG4gICAgICAgICAgICA/IGlzU2VsZWN0UmVkdWNlcih4UmVkdWNlKSAmJiBYICYmIGlzT3JkaW5hbChYKVxuICAgICAgICAgICAgICA/IGNlbGxcbiAgICAgICAgICAgICAgOiBiYXJYXG4gICAgICAgICAgICA6IHJlY3RYXG4gICAgICAgICAgOiB5UmVkdWNlICE9IG51bGwgLy8gYmluIG9yIGdyb3VwIG9uIHhcbiAgICAgICAgICA/IGlzT3JkaW5hbChYKVxuICAgICAgICAgICAgPyBpc1NlbGVjdFJlZHVjZXIoeVJlZHVjZSkgJiYgWSAmJiBpc09yZGluYWwoWSlcbiAgICAgICAgICAgICAgPyBjZWxsXG4gICAgICAgICAgICAgIDogYmFyWVxuICAgICAgICAgICAgOiByZWN0WVxuICAgICAgICAgIDogY29sb3JSZWR1Y2UgIT0gbnVsbCB8fCBzaXplUmVkdWNlICE9IG51bGwgLy8gYmluIG9yIGdyb3VwIG9uIGJvdGggeCBhbmQgeVxuICAgICAgICAgID8gWCAmJiBpc09yZGluYWwoWCkgJiYgWSAmJiBpc09yZGluYWwoWSlcbiAgICAgICAgICAgID8gY2VsbFxuICAgICAgICAgICAgOiBYICYmIGlzT3JkaW5hbChYKVxuICAgICAgICAgICAgPyBiYXJZXG4gICAgICAgICAgICA6IFkgJiYgaXNPcmRpbmFsKFkpXG4gICAgICAgICAgICA/IGJhclhcbiAgICAgICAgICAgIDogcmVjdFxuICAgICAgICAgIDogWCAmJiBpc051bWVyaWMoWCkgJiYgIShZICYmIGlzTnVtZXJpYyhZKSlcbiAgICAgICAgICA/IGJhclggLy8gaWYgeSBpcyB0ZW1wb3JhbCwgdHJlYXQgYXMgb3JkaW5hbFxuICAgICAgICAgIDogWSAmJiBpc051bWVyaWMoWSkgJiYgIShYICYmIGlzTnVtZXJpYyhYKSlcbiAgICAgICAgICA/IGJhclkgLy8gaWYgeCBpcyB0ZW1wb3JhbCwgdHJlYXQgYXMgb3JkaW5hbFxuICAgICAgICAgIDogY2VsbDtcbiAgICAgIGNvbG9yTW9kZSA9IFwiZmlsbFwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBtYXJrOiAke21hcmt9YCk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIG1hcmsgb3B0aW9ucy5cbiAgbGV0IG1hcmtPcHRpb25zID0ge1xuICAgIGZ4LFxuICAgIGZ5LFxuICAgIHg6IFggPz8gdW5kZWZpbmVkLCAvLyB0cmVhdCBudWxsIHggYXMgdW5kZWZpbmVkIGZvciBpbXBsaWNpdCBzdGFja1xuICAgIHk6IFkgPz8gdW5kZWZpbmVkLCAvLyB0cmVhdCBudWxsIHkgYXMgdW5kZWZpbmVkIGZvciBpbXBsaWNpdCBzdGFja1xuICAgIFtjb2xvck1vZGVdOiBDID8/IGNvbG9yQ29sb3IsXG4gICAgejogWixcbiAgICByOiBTID8/IHVuZGVmaW5lZCwgLy8gdHJlYXQgbnVsbCBzaXplIGFzIHVuZGVmaW5lZCBmb3IgZGVmYXVsdCBjb25zdGFudCByYWRpdXNcbiAgICB0aXA6IHRydWVcbiAgfTtcbiAgbGV0IHRyYW5zZm9ybUltcGw7XG4gIGxldCB0cmFuc2Zvcm1PcHRpb25zID0ge1tjb2xvck1vZGVdOiBjb2xvclJlZHVjZSA/PyB1bmRlZmluZWQsIHI6IHNpemVSZWR1Y2UgPz8gdW5kZWZpbmVkfTtcbiAgaWYgKHhSZWR1Y2UgIT0gbnVsbCAmJiB5UmVkdWNlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWR1Y2UgYm90aCB4IGFuZCB5YCk7IC8vIGZvciBub3cgYXQgbGVhc3RcbiAgfSBlbHNlIGlmICh5UmVkdWNlICE9IG51bGwpIHtcbiAgICB0cmFuc2Zvcm1PcHRpb25zLnkgPSB5UmVkdWNlO1xuICAgIHRyYW5zZm9ybUltcGwgPSBpc09yZGluYWwoWCkgPyBncm91cFggOiBiaW5YO1xuICB9IGVsc2UgaWYgKHhSZWR1Y2UgIT0gbnVsbCkge1xuICAgIHRyYW5zZm9ybU9wdGlvbnMueCA9IHhSZWR1Y2U7XG4gICAgdHJhbnNmb3JtSW1wbCA9IGlzT3JkaW5hbChZKSA/IGdyb3VwWSA6IGJpblk7XG4gIH0gZWxzZSBpZiAoY29sb3JSZWR1Y2UgIT0gbnVsbCB8fCBzaXplUmVkdWNlICE9IG51bGwpIHtcbiAgICBpZiAoWCAmJiBZKSB7XG4gICAgICB0cmFuc2Zvcm1JbXBsID0gaXNPcmRpbmFsKFgpICYmIGlzT3JkaW5hbChZKSA/IGdyb3VwIDogaXNPcmRpbmFsKFgpID8gYmluWSA6IGlzT3JkaW5hbChZKSA/IGJpblggOiBiaW47XG4gICAgfSBlbHNlIGlmIChYKSB7XG4gICAgICB0cmFuc2Zvcm1JbXBsID0gaXNPcmRpbmFsKFgpID8gZ3JvdXBYIDogYmluWDtcbiAgICB9IGVsc2UgaWYgKFkpIHtcbiAgICAgIHRyYW5zZm9ybUltcGwgPSBpc09yZGluYWwoWSkgPyBncm91cFkgOiBiaW5ZO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gdXNpbmcgdGhlIGJpbiB0cmFuc2Zvcm0sIHBhc3MgdGhyb3VnaCBhZGRpdGlvbmFsIG9wdGlvbnMgKGUuZy4sIHRocmVzaG9sZHMpLlxuICBpZiAodHJhbnNmb3JtSW1wbCA9PT0gYmluIHx8IHRyYW5zZm9ybUltcGwgPT09IGJpblgpIG1hcmtPcHRpb25zLnggPSB7dmFsdWU6IFgsIC4uLnhPcHRpb25zfTtcbiAgaWYgKHRyYW5zZm9ybUltcGwgPT09IGJpbiB8fCB0cmFuc2Zvcm1JbXBsID09PSBiaW5ZKSBtYXJrT3B0aW9ucy55ID0ge3ZhbHVlOiBZLCAuLi55T3B0aW9uc307XG5cbiAgLy8gSWYgemVyby1uZXNzIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHQgYmFzZWQgb24gd2hldGhlciB0aGUgcmVzb2x2ZWQgbWFya1xuICAvLyB0eXBlIHdpbGwgaW5jbHVkZSBhIHplcm8gYmFzZWxpbmUuXG4gIGlmICh4WmVybyA9PT0gdW5kZWZpbmVkKVxuICAgIHhaZXJvID1cbiAgICAgIFggJiZcbiAgICAgICEodHJhbnNmb3JtSW1wbCA9PT0gYmluIHx8IHRyYW5zZm9ybUltcGwgPT09IGJpblgpICYmXG4gICAgICAobWFya0ltcGwgPT09IGJhclggfHwgbWFya0ltcGwgPT09IGFyZWFYIHx8IG1hcmtJbXBsID09PSByZWN0WCB8fCBtYXJrSW1wbCA9PT0gcnVsZVkpO1xuICBpZiAoeVplcm8gPT09IHVuZGVmaW5lZClcbiAgICB5WmVybyA9XG4gICAgICBZICYmXG4gICAgICAhKHRyYW5zZm9ybUltcGwgPT09IGJpbiB8fCB0cmFuc2Zvcm1JbXBsID09PSBiaW5ZKSAmJlxuICAgICAgKG1hcmtJbXBsID09PSBiYXJZIHx8IG1hcmtJbXBsID09PSBhcmVhWSB8fCBtYXJrSW1wbCA9PT0gcmVjdFkgfHwgbWFya0ltcGwgPT09IHJ1bGVYKTtcblxuICByZXR1cm4ge1xuICAgIGZ4OiBmeCA/PyBudWxsLFxuICAgIGZ5OiBmeSA/PyBudWxsLFxuICAgIHg6IHtcbiAgICAgIHZhbHVlOiB4VmFsdWUgPz8gbnVsbCxcbiAgICAgIHJlZHVjZTogeFJlZHVjZSA/PyBudWxsLFxuICAgICAgemVybzogISF4WmVybyxcbiAgICAgIC4uLnhPcHRpb25zXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB2YWx1ZTogeVZhbHVlID8/IG51bGwsXG4gICAgICByZWR1Y2U6IHlSZWR1Y2UgPz8gbnVsbCxcbiAgICAgIHplcm86ICEheVplcm8sXG4gICAgICAuLi55T3B0aW9uc1xuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHZhbHVlOiBjb2xvclZhbHVlID8/IG51bGwsXG4gICAgICByZWR1Y2U6IGNvbG9yUmVkdWNlID8/IG51bGwsXG4gICAgICAuLi4oY29sb3JDb2xvciAhPT0gdW5kZWZpbmVkICYmIHtjb2xvcjogY29sb3JDb2xvcn0pXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICB2YWx1ZTogc2l6ZVZhbHVlID8/IG51bGwsXG4gICAgICByZWR1Y2U6IHNpemVSZWR1Y2UgPz8gbnVsbFxuICAgIH0sXG4gICAgbWFyayxcbiAgICBtYXJrSW1wbDogaW1wbE5hbWVzW21hcmtJbXBsXSxcbiAgICBtYXJrT3B0aW9ucyxcbiAgICB0cmFuc2Zvcm1JbXBsOiBpbXBsTmFtZXNbdHJhbnNmb3JtSW1wbF0sXG4gICAgdHJhbnNmb3JtT3B0aW9ucyxcbiAgICBjb2xvck1vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG8oZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBzcGVjID0gYXV0b1NwZWMoZGF0YSwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICBmeCxcbiAgICBmeSxcbiAgICB4OiB7emVybzogeFplcm99LFxuICAgIHk6IHt6ZXJvOiB5WmVyb30sXG4gICAgbWFya09wdGlvbnMsXG4gICAgdHJhbnNmb3JtT3B0aW9ucyxcbiAgICBjb2xvck1vZGVcbiAgfSA9IHNwZWM7XG4gIGNvbnN0IG1hcmtJbXBsID0gaW1wbHNbc3BlYy5tYXJrSW1wbF07XG4gIGNvbnN0IHRyYW5zZm9ybUltcGwgPSBpbXBsc1tzcGVjLnRyYW5zZm9ybUltcGxdO1xuICAvLyBJbiB0aGUgY2FzZSBvZiBmaWxsZWQgbWFya3MgKHBhcnRpY3VsYXJseSBiYXJzIGFuZCBhcmVhcykgdGhlIGZyYW1lIGFuZFxuICAvLyBydWxlcyBzaG91bGQgY29tZSBhZnRlciB0aGUgbWFyazsgaW4gdGhlIGNhc2Ugb2Ygc3Ryb2tlZCBtYXJrc1xuICAvLyAocGFydGljdWxhcmx5IGRvdHMgYW5kIGxpbmVzKSB0aGV5IHNob3VsZCBjb21lIGJlZm9yZSB0aGUgbWFyay5cbiAgY29uc3QgZnJhbWVzID0gZnggIT0gbnVsbCB8fCBmeSAhPSBudWxsID8gZnJhbWUoe3N0cm9rZU9wYWNpdHk6IDAuMX0pIDogbnVsbDtcbiAgY29uc3QgcnVsZXMgPSBbeFplcm8gPyBydWxlWChbMF0pIDogbnVsbCwgeVplcm8gPyBydWxlWShbMF0pIDogbnVsbF07XG4gIGNvbnN0IG1hcmsgPSBtYXJrSW1wbChkYXRhLCB0cmFuc2Zvcm1JbXBsID8gdHJhbnNmb3JtSW1wbCh0cmFuc2Zvcm1PcHRpb25zLCBtYXJrT3B0aW9ucykgOiBtYXJrT3B0aW9ucyk7XG4gIHJldHVybiBjb2xvck1vZGUgPT09IFwic3Ryb2tlXCIgPyBtYXJrcyhmcmFtZXMsIHJ1bGVzLCBtYXJrKSA6IG1hcmtzKGZyYW1lcywgbWFyaywgcnVsZXMpO1xufVxuXG4vLyBUT0RPIFdoYXQgYWJvdXQgc29ydGVkIHdpdGhpbiBzZXJpZXM/XG5mdW5jdGlvbiBpc01vbm90b25pYyh2YWx1ZXMpIHtcbiAgbGV0IHByZXZpb3VzO1xuICBsZXQgcHJldmlvdXNPcmRlcjtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZXZpb3VzID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXIgPSBNYXRoLnNpZ24oYXNjZW5kaW5nKHByZXZpb3VzLCB2YWx1ZSkpO1xuICAgIGlmICghb3JkZXIpIGNvbnRpbnVlOyAvLyBza2lwIHplcm8sIE5hTlxuICAgIGlmIChwcmV2aW91c09yZGVyICE9PSB1bmRlZmluZWQgJiYgb3JkZXIgIT09IHByZXZpb3VzT3JkZXIpIHJldHVybiBmYWxzZTtcbiAgICBwcmV2aW91cyA9IHZhbHVlO1xuICAgIHByZXZpb3VzT3JkZXIgPSBvcmRlcjtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQWxsb3cgeCBhbmQgeSBhbmQgb3RoZXIgZGltZW5zaW9ucyB0byBiZSBzcGVjaWZpZWQgYXMgc2hvcnRoYW5kIGZpZWxkIG5hbWVzXG4vLyAoYnV0IG5vdGUgdGhhdCB0aGV5IGNhbiBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIHt0cmFuc2Zvcm19IG9iamVjdCBzdWNoIGFzXG4vLyBQbG90LmlkZW50aXR5KS4gV2UgZG9u4oCZdCBzdXBwb3J0IHJlZHVjZXJzIGZvciB0aGUgZmFjZXRpbmcsIGJ1dCBmb3Igc3ltbWV0cnlcbi8vIHdpdGggeCBhbmQgeSB3ZSBhbGxvdyBmYWNldHMgdG8gYmUgc3BlY2lmaWVkIGFzIHt2YWx1ZX0gb2JqZWN0cy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMoe3gsIHksIGNvbG9yLCBzaXplLCBmeCwgZnksIG1hcmt9ID0ge30pIHtcbiAgaWYgKCFpc09wdGlvbnMoeCkpIHggPSBtYWtlT3B0aW9ucyh4KTtcbiAgaWYgKCFpc09wdGlvbnMoeSkpIHkgPSBtYWtlT3B0aW9ucyh5KTtcbiAgaWYgKCFpc09wdGlvbnMoY29sb3IpKSBjb2xvciA9IGlzQ29sb3IoY29sb3IpID8ge2NvbG9yfSA6IG1ha2VPcHRpb25zKGNvbG9yKTtcbiAgaWYgKCFpc09wdGlvbnMoc2l6ZSkpIHNpemUgPSBtYWtlT3B0aW9ucyhzaXplKTtcbiAgaWYgKGlzT3B0aW9ucyhmeCkpICh7dmFsdWU6IGZ4fSA9IG1ha2VPcHRpb25zKGZ4KSk7XG4gIGlmIChpc09wdGlvbnMoZnkpKSAoe3ZhbHVlOiBmeX0gPSBtYWtlT3B0aW9ucyhmeSkpO1xuICBpZiAobWFyayAhPSBudWxsKSBtYXJrID0gYCR7bWFya31gLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB7eCwgeSwgY29sb3IsIHNpemUsIGZ4LCBmeSwgbWFya307XG59XG5cbi8vIFRvIGFwcGx5IGhldXJpc3RpY3MgYmFzZWQgb24gdGhlIGRhdGEgdHlwZXMgKHZhbHVlcyksIHJlYWxpemUgdGhlIGNvbHVtbnMuIFdlXG4vLyBjb3VsZCBtYXliZSBsb29rIGF0IHRoZSBkYXRhLnNjaGVtYSBoZXJlLCBidXQgUGxvdOKAmXMgYmVoYXZpb3IgZGVwZW5kcyBvbiB0aGVcbi8vIGFjdHVhbCB2YWx1ZXMgYW55d2F5LCBzbyB0aGlzIHByb2JhYmx5IGlzIHdoYXQgd2Ugd2FudC5cbmZ1bmN0aW9uIG1hdGVyaWFsaXplVmFsdWUoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBWID0gdmFsdWVvZihkYXRhLCBvcHRpb25zLnZhbHVlKTtcbiAgaWYgKFYpIFYubGFiZWwgPSBsYWJlbG9mKG9wdGlvbnMudmFsdWUpO1xuICByZXR1cm4gVjtcbn1cblxuZnVuY3Rpb24gbWFrZU9wdGlvbnModmFsdWUpIHtcbiAgcmV0dXJuIGlzUmVkdWNlcih2YWx1ZSkgPyB7cmVkdWNlOiB2YWx1ZX0gOiB7dmFsdWV9O1xufVxuXG4vLyBUaGUgZGlzdGluY3QsIGNvdW50LCBzdW0sIGFuZCBwcm9wb3J0aW9uIHJlZHVjZXJzIGFyZSBhZGRpdGl2ZSAoc3RhY2thYmxlKS5cbmZ1bmN0aW9uIGlzWmVyb1JlZHVjZXIocmVkdWNlKSB7XG4gIHJldHVybiAvXig/OmRpc3RpbmN0fGNvdW50fHN1bXxwcm9wb3J0aW9uKSQvaS50ZXN0KHJlZHVjZSk7XG59XG5cbi8vIFRoZSBmaXJzdCwgbGFzdCwgYW5kIG1vZGUgcmVkdWNlcnMgcHJlc2VydmUgdGhlIHR5cGUgb2YgdGhlIGFnZ3JlZ2F0ZWQgdmFsdWVzLlxuZnVuY3Rpb24gaXNTZWxlY3RSZWR1Y2VyKHJlZHVjZSkge1xuICByZXR1cm4gL14oPzpmaXJzdHxsYXN0fG1vZGUpJC9pLnRlc3QocmVkdWNlKTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29ic2VydmFibGVocS9wbG90L2Jsb2IvODE4NTYyNjQ5MjgwZTE1NTEzNmY3MzBmYzQ5NmUwYjNkMTVhZTQ2NC9zcmMvdHJhbnNmb3Jtcy9ncm91cC5qcyNMMjM2XG5mdW5jdGlvbiBpc1JlZHVjZXIocmVkdWNlKSB7XG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHJlZHVjZS5yZWR1Y2VJbmRleCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiByZWR1Y2UucmVkdWNlID09PSBcImZ1bmN0aW9uXCIgJiYgaXNPYmplY3QocmVkdWNlKSkgcmV0dXJuIHRydWU7IC8vIE4uQi4gYXJyYXkucmVkdWNlXG4gIGlmICgvXnBcXGR7Mn0kL2kudGVzdChyZWR1Y2UpKSByZXR1cm4gdHJ1ZTtcbiAgc3dpdGNoIChgJHtyZWR1Y2V9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImZpcnN0XCI6XG4gICAgY2FzZSBcImxhc3RcIjpcbiAgICBjYXNlIFwiY291bnRcIjpcbiAgICBjYXNlIFwiZGlzdGluY3RcIjpcbiAgICBjYXNlIFwic3VtXCI6XG4gICAgY2FzZSBcInByb3BvcnRpb25cIjpcbiAgICBjYXNlIFwicHJvcG9ydGlvbi1mYWNldFwiOiAvLyBUT0RPIHJlbW92ZSBtZT9cbiAgICBjYXNlIFwiZGV2aWF0aW9uXCI6XG4gICAgY2FzZSBcIm1pblwiOlxuICAgIGNhc2UgXCJtaW4taW5kZXhcIjogLy8gVE9ETyByZW1vdmUgbWU/XG4gICAgY2FzZSBcIm1heFwiOlxuICAgIGNhc2UgXCJtYXgtaW5kZXhcIjogLy8gVE9ETyByZW1vdmUgbWU/XG4gICAgY2FzZSBcIm1lYW5cIjpcbiAgICBjYXNlIFwibWVkaWFuXCI6XG4gICAgY2FzZSBcInZhcmlhbmNlXCI6XG4gICAgY2FzZSBcIm1vZGVcIjpcbiAgICAgIC8vIFRoZXNlIGFyZSB0ZWNobmljYWxseSByZWR1Y2VycywgYnV0IEkgdGhpbmsgd2XigJlkIHdhbnQgdG8gdHJlYXQgdGhlbSBhcyBmaWVsZHM/XG4gICAgICAvLyBjYXNlIFwieFwiOlxuICAgICAgLy8gY2FzZSBcIngxXCI6XG4gICAgICAvLyBjYXNlIFwieDJcIjpcbiAgICAgIC8vIGNhc2UgXCJ5XCI6XG4gICAgICAvLyBjYXNlIFwieTFcIjpcbiAgICAgIC8vIGNhc2UgXCJ5MlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0hpZ2hDYXJkaW5hbGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyBuZXcgSW50ZXJuU2V0KHZhbHVlKS5zaXplID4gdmFsdWUubGVuZ3RoID4+IDEgOiBmYWxzZTtcbn1cblxuY29uc3QgaW1wbHMgPSB7XG4gIGRvdCxcbiAgbGluZSxcbiAgbGluZVgsXG4gIGxpbmVZLFxuICBhcmVhWCxcbiAgYXJlYVksXG4gIHJ1bGVYLFxuICBydWxlWSxcbiAgYmFyWCxcbiAgYmFyWSxcbiAgcmVjdCxcbiAgcmVjdFgsXG4gIHJlY3RZLFxuICBjZWxsLFxuICBiaW4sXG4gIGJpblgsXG4gIGJpblksXG4gIGdyb3VwLFxuICBncm91cFgsXG4gIGdyb3VwWVxufTtcblxuLy8gSW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlIG1hcmsgb3IgdHJhbnNmb3JtIGltcGxlbWVudGF0aW9uIGRpcmVjdGx5LCB3ZSByZXR1cm5cbi8vIHRoZSBpbXBsZW1lbnRhdGlvbiBuYW1lIHRvIGZhY2lsaXRhdGUgY29kZSBjb21waWxhdGlvbiAo4oCcZWplY3QgdG8gZXhwbGljaXRcbi8vIG1hcmtz4oCdKS4gQW4gaW1wbGVtZW50YXRpb24tdG8tbmFtZSBtYXBwaW5nIG5lZWRzIHRvIGxpdmUgc29tZXdoZXJlIGZvclxuLy8gY29tcGlsYXRpb24sIGFuZCBieSBoYXZpbmcgaXQgaW4gUGxvdCB3ZSBjYW4gbW9yZSBlYXNpbHkgaW50cm9kdWNlIGEgbmV3IG1hcmtcbi8vIG9yIHRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiBpbiBQbG90LmF1dG8gd2l0aG91dCBoYXZpbmcgdG8gc3luY2hyb25pemUgYVxuLy8gZG93bnN0cmVhbSBjaGFuZ2UgaW4gdGhlIGNvbXBpbGVyLlxuY29uc3QgaW1wbE5hbWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGltcGxzKS5tYXAoKFtuYW1lLCBpbXBsXSkgPT4gW2ltcGwsIG5hbWVdKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/auto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/axis.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   axisFx: () => (/* binding */ axisFx),\n/* harmony export */   axisFy: () => (/* binding */ axisFy),\n/* harmony export */   axisX: () => (/* binding */ axisX),\n/* harmony export */   axisY: () => (/* binding */ axisY),\n/* harmony export */   gridFx: () => (/* binding */ gridFx),\n/* harmony export */   gridFy: () => (/* binding */ gridFy),\n/* harmony export */   gridX: () => (/* binding */ gridX),\n/* harmony export */   gridY: () => (/* binding */ gridY),\n/* harmony export */   inferTickFormat: () => (/* binding */ inferTickFormat)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../format.js */ \"(ssr)/./node_modules/@observablehq/plot/src/format.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ \"(ssr)/./node_modules/@observablehq/plot/src/math.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../time.js */ \"(ssr)/./node_modules/@observablehq/plot/src/time.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rule.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\");\n/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/vector.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isIterable)(data)) (options = data), (data = null);\n  if (options === undefined) options = {};\n  return [data, options];\n}\n\nfunction maybeAnchor({anchor} = {}, anchors) {\n  return anchor === undefined ? anchors[0] : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyword)(anchor, \"anchor\", anchors);\n}\n\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\n\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\n\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\n\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\n\nfunction axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\n\nfunction axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\n\nfunction axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\n\nfunction axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\n\nfunction axisKy(\n  k,\n  anchor,\n  data,\n  {\n    color = \"currentColor\",\n    opacity = 1,\n    stroke = color,\n    strokeOpacity = opacity,\n    strokeWidth = 1,\n    fill = color,\n    fillOpacity = opacity,\n    textAnchor,\n    textStroke,\n    textStrokeOpacity,\n    textStrokeWidth,\n    tickSize = k === \"y\" ? 6 : 0,\n    tickPadding,\n    tickRotate,\n    x,\n    margin,\n    marginTop = margin === undefined ? 20 : margin,\n    marginRight = margin === undefined ? (anchor === \"right\" ? 40 : 0) : margin,\n    marginBottom = margin === undefined ? 20 : margin,\n    marginLeft = margin === undefined ? (anchor === \"left\" ? 40 : 0) : margin,\n    label,\n    labelAnchor,\n    labelArrow,\n    labelOffset,\n    ariaLabel = `${k}-axis`,\n    ...options\n  }\n) {\n  tickSize = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickSize);\n  tickPadding = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickPadding);\n  tickRotate = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyword)(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.marks)(\n    tickSize && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(stroke)\n      ? axisTickKy(k, anchor, data, {\n          stroke,\n          strokeOpacity,\n          strokeWidth,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          x,\n          ariaLabel,\n          ...options\n        })\n      : null,\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill)\n      ? axisTextKy(k, anchor, data, {\n          fill,\n          fillOpacity,\n          stroke: textStroke,\n          strokeOpacity: textStrokeOpacity,\n          strokeWidth: textStrokeWidth,\n          textAnchor,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          x,\n          marginTop,\n          marginRight,\n          marginBottom,\n          marginLeft,\n          ariaLabel,\n          ...options\n        })\n      : null,\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill) && label !== null\n      ? (0,_text_js__WEBPACK_IMPORTED_MODULE_3__.text)(\n          [],\n          labelOptions({fill, fillOpacity, ...options}, function (data, facets, channels, scales, dimensions) {\n            const scale = scales[k];\n            const {marginTop, marginRight, marginBottom, marginLeft} = (k === \"y\" && dimensions.inset) || dimensions;\n            const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"top\");\n            const clo = labelOffset ?? (anchor === \"right\" ? marginRight : marginLeft) - 3;\n            if (cla === \"center\") {\n              this.textAnchor = undefined; // middle\n              this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n              this.frameAnchor = anchor;\n              this.rotate = -90;\n            } else {\n              this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n              this.lineAnchor = cla;\n              this.frameAnchor = `${cla}-${anchor}`;\n              this.rotate = 0;\n            }\n            this.dy = cla === \"top\" ? 3 - marginTop : cla === \"bottom\" ? marginBottom - 3 : 0;\n            this.dx = anchor === \"right\" ? clo : -clo;\n            this.ariaLabel = `${ariaLabel} label`;\n            return {\n              facets: [[0]],\n              channels: {text: {value: [formatAxisLabel(k, scale, {anchor, label, labelAnchor: cla, labelArrow})]}}\n            };\n          })\n        )\n      : null\n  );\n}\n\nfunction axisKx(\n  k,\n  anchor,\n  data,\n  {\n    color = \"currentColor\",\n    opacity = 1,\n    stroke = color,\n    strokeOpacity = opacity,\n    strokeWidth = 1,\n    fill = color,\n    fillOpacity = opacity,\n    textAnchor,\n    textStroke,\n    textStrokeOpacity,\n    textStrokeWidth,\n    tickSize = k === \"x\" ? 6 : 0,\n    tickPadding,\n    tickRotate,\n    y,\n    margin,\n    marginTop = margin === undefined ? (anchor === \"top\" ? 30 : 0) : margin,\n    marginRight = margin === undefined ? 20 : margin,\n    marginBottom = margin === undefined ? (anchor === \"bottom\" ? 30 : 0) : margin,\n    marginLeft = margin === undefined ? 20 : margin,\n    label,\n    labelAnchor,\n    labelArrow,\n    labelOffset,\n    ariaLabel = `${k}-axis`,\n    ...options\n  }\n) {\n  tickSize = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickSize);\n  tickPadding = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickPadding);\n  tickRotate = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyword)(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.marks)(\n    tickSize && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(stroke)\n      ? axisTickKx(k, anchor, data, {\n          stroke,\n          strokeOpacity,\n          strokeWidth,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          y,\n          ariaLabel,\n          ...options\n        })\n      : null,\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill)\n      ? axisTextKx(k, anchor, data, {\n          fill,\n          fillOpacity,\n          stroke: textStroke,\n          strokeOpacity: textStrokeOpacity,\n          strokeWidth: textStrokeWidth,\n          textAnchor,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          y,\n          marginTop,\n          marginRight,\n          marginBottom,\n          marginLeft,\n          ariaLabel,\n          ...options\n        })\n      : null,\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill) && label !== null\n      ? (0,_text_js__WEBPACK_IMPORTED_MODULE_3__.text)(\n          [],\n          labelOptions({fill, fillOpacity, ...options}, function (data, facets, channels, scales, dimensions) {\n            const scale = scales[k];\n            const {marginTop, marginRight, marginBottom, marginLeft} = (k === \"x\" && dimensions.inset) || dimensions;\n            const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"right\");\n            const clo = labelOffset ?? (anchor === \"top\" ? marginTop : marginBottom) - 3;\n            if (cla === \"center\") {\n              this.frameAnchor = anchor;\n              this.textAnchor = undefined; // middle\n            } else {\n              this.frameAnchor = `${anchor}-${cla}`;\n              this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n            }\n            this.lineAnchor = anchor;\n            this.dy = anchor === \"top\" ? -clo : clo;\n            this.dx = cla === \"right\" ? marginRight - 3 : cla === \"left\" ? 3 - marginLeft : 0;\n            this.ariaLabel = `${ariaLabel} label`;\n            return {\n              facets: [[0]],\n              channels: {text: {value: [formatAxisLabel(k, scale, {anchor, label, labelAnchor: cla, labelArrow})]}}\n            };\n          })\n        )\n      : null\n  );\n}\n\nfunction axisTickKy(\n  k,\n  anchor,\n  data,\n  {\n    strokeWidth = 1,\n    strokeLinecap = null,\n    strokeLinejoin = null,\n    facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    dx = 0,\n    y = k === \"y\" ? undefined : null,\n    ariaLabel,\n    ...options\n  }\n) {\n  return axisMark(\n    _vector_js__WEBPACK_IMPORTED_MODULE_4__.vectorY,\n    k,\n    data,\n    {\n      ariaLabel: `${ariaLabel} tick`,\n      ariaHidden: true\n    },\n    {\n      strokeWidth,\n      strokeLinecap,\n      strokeLinejoin,\n      facetAnchor,\n      frameAnchor,\n      y,\n      ...options,\n      dx: anchor === \"left\" ? +dx - _style_js__WEBPACK_IMPORTED_MODULE_5__.offset + +insetLeft : +dx + _style_js__WEBPACK_IMPORTED_MODULE_5__.offset - insetRight,\n      anchor: \"start\",\n      length: tickSize,\n      shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n    }\n  );\n}\n\nfunction axisTickKx(\n  k,\n  anchor,\n  data,\n  {\n    strokeWidth = 1,\n    strokeLinecap = null,\n    strokeLinejoin = null,\n    facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    inset = 0,\n    insetTop = inset,\n    insetBottom = inset,\n    dy = 0,\n    x = k === \"x\" ? undefined : null,\n    ariaLabel,\n    ...options\n  }\n) {\n  return axisMark(\n    _vector_js__WEBPACK_IMPORTED_MODULE_4__.vectorX,\n    k,\n    data,\n    {\n      ariaLabel: `${ariaLabel} tick`,\n      ariaHidden: true\n    },\n    {\n      strokeWidth,\n      strokeLinejoin,\n      strokeLinecap,\n      facetAnchor,\n      frameAnchor,\n      x,\n      ...options,\n      dy: anchor === \"bottom\" ? +dy - _style_js__WEBPACK_IMPORTED_MODULE_5__.offset - insetBottom : +dy + _style_js__WEBPACK_IMPORTED_MODULE_5__.offset + +insetTop,\n      anchor: \"start\",\n      length: tickSize,\n      shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n    }\n  );\n}\n\nfunction axisTextKy(\n  k,\n  anchor,\n  data,\n  {\n    facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    tickRotate = 0,\n    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * _math_js__WEBPACK_IMPORTED_MODULE_6__.radians) : 0),\n    text,\n    textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\",\n    lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\",\n    fontVariant,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    dx = 0,\n    ariaLabel,\n    y = k === \"y\" ? undefined : null,\n    ...options\n  }\n) {\n  return axisMark(\n    _text_js__WEBPACK_IMPORTED_MODULE_3__.textY,\n    k,\n    data,\n    {ariaLabel: `${ariaLabel} tick label`},\n    {\n      facetAnchor,\n      frameAnchor,\n      text,\n      textAnchor,\n      lineAnchor,\n      fontVariant,\n      rotate: tickRotate,\n      y,\n      ...options,\n      dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n    },\n    function (scale, data, ticks, tickFormat, channels) {\n      if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n      if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n    }\n  );\n}\n\nfunction axisTextKx(\n  k,\n  anchor,\n  data,\n  {\n    facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    tickRotate = 0,\n    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * _math_js__WEBPACK_IMPORTED_MODULE_6__.radians) : 0),\n    text,\n    textAnchor = Math.abs(tickRotate) >= 10 ? ((tickRotate < 0) ^ (anchor === \"bottom\") ? \"start\" : \"end\") : \"middle\",\n    lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\",\n    fontVariant,\n    inset = 0,\n    insetTop = inset,\n    insetBottom = inset,\n    dy = 0,\n    x = k === \"x\" ? undefined : null,\n    ariaLabel,\n    ...options\n  }\n) {\n  return axisMark(\n    _text_js__WEBPACK_IMPORTED_MODULE_3__.textX,\n    k,\n    data,\n    {ariaLabel: `${ariaLabel} tick label`},\n    {\n      facetAnchor,\n      frameAnchor,\n      text: text === undefined ? null : text,\n      textAnchor,\n      lineAnchor,\n      fontVariant,\n      rotate: tickRotate,\n      x,\n      ...options,\n      dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n    },\n    function (scale, data, ticks, tickFormat, channels) {\n      if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n      if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n    }\n  );\n}\n\nfunction gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\n\nfunction gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\n\nfunction gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\n\nfunction gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\n\nfunction gridKy(\n  k,\n  anchor,\n  data,\n  {\n    y = k === \"y\" ? undefined : null,\n    x = null,\n    x1 = anchor === \"left\" ? x : null,\n    x2 = anchor === \"right\" ? x : null,\n    ariaLabel = `${k}-grid`,\n    ariaHidden = true,\n    ...options\n  }\n) {\n  return axisMark(_rule_js__WEBPACK_IMPORTED_MODULE_7__.ruleY, k, data, {ariaLabel, ariaHidden}, {y, x1, x2, ...gridDefaults(options)});\n}\n\nfunction gridKx(\n  k,\n  anchor,\n  data,\n  {\n    x = k === \"x\" ? undefined : null,\n    y = null,\n    y1 = anchor === \"top\" ? y : null,\n    y2 = anchor === \"bottom\" ? y : null,\n    ariaLabel = `${k}-grid`,\n    ariaHidden = true,\n    ...options\n  }\n) {\n  return axisMark(_rule_js__WEBPACK_IMPORTED_MODULE_7__.ruleX, k, data, {ariaLabel, ariaHidden}, {x, y1, y2, ...gridDefaults(options)});\n}\n\nfunction gridDefaults({\n  color = \"currentColor\",\n  opacity = 0.1,\n  stroke = color,\n  strokeOpacity = opacity,\n  strokeWidth = 1,\n  ...options\n}) {\n  return {stroke, strokeOpacity, strokeWidth, ...options};\n}\n\nfunction labelOptions(\n  {\n    fill,\n    fillOpacity,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariant,\n    fontWeight,\n    monospace,\n    pointerEvents,\n    shapeRendering,\n    clip = false\n  },\n  initializer\n) {\n  // Only propagate these options if constant.\n  [, fill] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(fill);\n  [, fillOpacity] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(fillOpacity);\n  return {\n    facet: \"super\",\n    x: null,\n    y: null,\n    fill,\n    fillOpacity,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariant,\n    fontWeight,\n    monospace,\n    pointerEvents,\n    shapeRendering,\n    clip,\n    initializer\n  };\n}\n\nfunction axisMark(mark, k, data, properties, options, initialize) {\n  let channels;\n\n  function axisInitializer(data, facets, _channels, scales, dimensions, context) {\n    const initializeFacets = data == null && (k === \"fx\" || k === \"fy\");\n    const {[k]: scale} = scales;\n    if (!scale) throw new Error(`missing scale: ${k}`);\n    const domain = scale.domain();\n    let {interval, ticks, tickFormat, tickSpacing = k === \"x\" ? 80 : 35} = options;\n    // For a scale with a temporal domain, also allow the ticks to be specified\n    // as a string which is promoted to a time interval. In the case of ordinal\n    // scales, the interval is interpreted as UTC.\n    if (typeof ticks === \"string\" && hasTemporalDomain(scale)) (interval = ticks), (ticks = undefined);\n    // The interval axis option is an alternative method of specifying ticks;\n    // for example, for a numeric scale, ticks = 5 means “about 5 ticks” whereas\n    // interval = 5 means “ticks every 5 units”. (This is not to be confused\n    // with the interval scale option, which affects the scale’s behavior!)\n    // Lastly use the tickSpacing option to infer the desired tick count.\n    if (ticks === undefined) ticks = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeRangeInterval)(interval, scale.type) ?? inferTickCount(scale, tickSpacing);\n    if (data == null) {\n      if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isIterable)(ticks)) {\n        // Use explicit ticks, if specified.\n        data = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.arrayify)(ticks);\n      } else if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isInterval)(ticks)) {\n        // Use the tick interval, if specified.\n        data = inclusiveRange(ticks, ...(0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain));\n      } else if (scale.interval) {\n        // If the scale interval is a standard time interval such as \"day\", we\n        // may be able to generalize the scale interval it to a larger aligned\n        // time interval to create the desired number of ticks.\n        let interval = scale.interval;\n        if (scale.ticks) {\n          const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain);\n          const n = (max - min) / interval[_time_js__WEBPACK_IMPORTED_MODULE_8__.intervalDuration]; // current tick count\n          // We don’t explicitly check that given interval is a time interval;\n          // in that case the generalized interval will be undefined, just like\n          // a nonstandard interval. TODO Generalize integer intervals, too.\n          interval = (0,_time_js__WEBPACK_IMPORTED_MODULE_8__.generalizeTimeInterval)(interval, n / ticks) ?? interval;\n          data = inclusiveRange(interval, min, max);\n        } else {\n          data = domain;\n          const n = data.length; // current tick count\n          interval = (0,_time_js__WEBPACK_IMPORTED_MODULE_8__.generalizeTimeInterval)(interval, n / ticks) ?? interval;\n          if (interval !== scale.interval) data = inclusiveRange(interval, ...(0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(data));\n        }\n        if (interval === scale.interval) {\n          // If we weren’t able to generalize the scale’s interval, compute the\n          // positive number n such that taking every nth value from the scale’s\n          // domain produces as close as possible to the desired number of\n          // ticks. For example, if the domain has 100 values and 5 ticks are\n          // desired, n = 20.\n          const n = Math.round(data.length / ticks);\n          if (n > 1) data = data.filter((d, i) => i % n === 0);\n        }\n      } else if (scale.ticks) {\n        data = scale.ticks(ticks);\n      } else {\n        // For ordinal scales, the domain will already be generated using the\n        // scale’s interval, if any.\n        data = domain;\n      }\n      if (!scale.ticks && data.length && data !== domain) {\n        // For ordinal scales, intersect the ticks with the scale domain since\n        // the scale is only defined on its domain. If all of the ticks are\n        // removed, then warn that the ticks and scale domain may be misaligned\n        // (e.g., \"year\" ticks and \"4 weeks\" interval).\n        const domainSet = new d3__WEBPACK_IMPORTED_MODULE_0__.InternSet(domain);\n        data = data.filter((d) => domainSet.has(d));\n        if (!data.length) (0,_warnings_js__WEBPACK_IMPORTED_MODULE_9__.warn)(`Warning: the ${k}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`); // prettier-ignore\n      }\n      if (k === \"y\" || k === \"x\") {\n        facets = [(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(data)];\n      } else {\n        channels[k] = {scale: k, value: _options_js__WEBPACK_IMPORTED_MODULE_1__.identity};\n      }\n    }\n    initialize?.call(this, scale, data, ticks, tickFormat, channels);\n    const initializedChannels = Object.fromEntries(\n      Object.entries(channels).map(([name, channel]) => {\n        return [name, {...channel, value: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, channel.value)}];\n      })\n    );\n    if (initializeFacets) facets = context.filterFacets(data, initializedChannels);\n    return {data, facets, channels: initializedChannels};\n  }\n\n  // Apply any basic initializers after the axis initializer computes the ticks.\n  const basicInitializer = (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_10__.initializer)(options).initializer;\n  const m = mark(data, (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_10__.initializer)({...options, initializer: axisInitializer}, basicInitializer));\n  if (data == null) {\n    channels = m.channels;\n    m.channels = {};\n  } else {\n    channels = {};\n  }\n  if (properties !== undefined) Object.assign(m, properties);\n  if (m.clip === undefined) m.clip = false; // don’t clip axes by default\n  return m;\n}\n\nfunction inferTickCount(scale, tickSpacing) {\n  const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(scale.range());\n  return (max - min) / tickSpacing;\n}\n\nfunction inferTextChannel(scale, data, ticks, tickFormat, anchor) {\n  return {value: inferTickFormat(scale, data, ticks, tickFormat, anchor)};\n}\n\n// D3’s ordinal scales simply use toString by default, but if the ordinal scale\n// domain (or ticks) are numbers or dates (say because we’re applying a time\n// interval to the ordinal scale), we want Plot’s default formatter. And for\n// time ticks, we want to use the multi-line time format (e.g., Jan 26) if\n// possible, or the default ISO format (2014-01-26). TODO We need a better way\n// to infer whether the ordinal scale is UTC or local time.\nfunction inferTickFormat(scale, data, ticks, tickFormat, anchor) {\n  return typeof tickFormat === \"function\" && !(scale.type === \"log\" && scale.tickFormat)\n    ? tickFormat\n    : tickFormat === undefined && data && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(data)\n    ? (0,_time_js__WEBPACK_IMPORTED_MODULE_8__.inferTimeFormat)(scale.type, data, anchor) ?? _format_js__WEBPACK_IMPORTED_MODULE_11__.formatDefault\n    : scale.tickFormat\n    ? scale.tickFormat(typeof ticks === \"number\" ? ticks : null, tickFormat)\n    : typeof tickFormat === \"string\" && scale.domain().length > 0\n    ? ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(scale.domain()) ? d3__WEBPACK_IMPORTED_MODULE_0__.utcFormat : d3__WEBPACK_IMPORTED_MODULE_0__.format)(tickFormat)\n    : tickFormat === undefined\n    ? _format_js__WEBPACK_IMPORTED_MODULE_11__.formatDefault\n    : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.constant)(tickFormat);\n}\n\nfunction inclusiveRange(interval, min, max) {\n  return interval.range(min, interval.offset(interval.floor(max)));\n}\n\nconst shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\n\nconst shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\n\nconst shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\n\nconst shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\n\n// TODO Unify this with the other inferFontVariant; here we only have a scale\n// function rather than a scale descriptor.\nfunction inferFontVariant(scale) {\n  return scale.bandwidth && !scale.interval ? undefined : \"tabular-nums\";\n}\n\n// Takes the scale label, and if this is not an ordinal scale and the label was\n// inferred from an associated channel, adds an orientation-appropriate arrow.\nfunction formatAxisLabel(k, scale, {anchor, label = scale.label, labelAnchor, labelArrow} = {}) {\n  if (label == null || (label.inferred && hasTemporalDomain(scale) && /^(date|time|year)$/i.test(label))) return;\n  label = String(label); // coerce to a string after checking if inferred\n  if (labelArrow === \"auto\") labelArrow = (!scale.bandwidth || scale.interval) && !/[↑↓→←]/.test(label);\n  if (!labelArrow) return label;\n  if (labelArrow === true) {\n    const order = (0,_scales_js__WEBPACK_IMPORTED_MODULE_12__.inferScaleOrder)(scale);\n    if (order)\n      labelArrow =\n        /x$/.test(k) || labelAnchor === \"center\"\n          ? /x$/.test(k) === order < 0\n            ? \"left\"\n            : \"right\"\n          : order < 0\n          ? \"up\"\n          : \"down\";\n  }\n  switch (labelArrow) {\n    case \"left\":\n      return `← ${label}`;\n    case \"right\":\n      return `${label} →`;\n    case \"up\":\n      return anchor === \"right\" ? `${label} ↑` : `↑ ${label}`;\n    case \"down\":\n      return anchor === \"right\" ? `${label} ↓` : `↓ ${label}`;\n  }\n  return label;\n}\n\nfunction maybeLabelArrow(labelArrow = \"auto\") {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(labelArrow)\n    ? false\n    : typeof labelArrow === \"boolean\"\n    ? labelArrow\n    : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyword)(labelArrow, \"labelArrow\", [\"auto\", \"up\", \"right\", \"down\", \"left\"]);\n}\n\nfunction hasTemporalDomain(scale) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(scale.domain());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9heGlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDYjtBQUNWO0FBQ0U7QUFDeUQ7QUFDaEI7QUFDWTtBQUMzQztBQUNWO0FBQ2tEO0FBQ2xDO0FBQ2Y7QUFDRztBQUNNO0FBQ0E7O0FBRTdDO0FBQ0EsK0JBQStCLHVEQUFVO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUSxJQUFJO0FBQ2xDLDZDQUE2QyxvREFBTztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQU07QUFDbkIsZ0JBQWdCLG1EQUFNO0FBQ3RCLGVBQWUsbURBQU07QUFDckIsK0NBQStDLG9EQUFPO0FBQ3REO0FBQ0EsU0FBUywrQ0FBSztBQUNkLGlCQUFpQixzREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssc0RBQVM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSyxzREFBUztBQUNkLFFBQVEsOENBQUk7QUFDWjtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQSxtQkFBbUIsa0RBQWtEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLEdBQUcsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxtQ0FBbUMsNENBQTRDO0FBQy9HO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFNO0FBQ25CLGdCQUFnQixtREFBTTtBQUN0QixlQUFlLG1EQUFNO0FBQ3JCLCtDQUErQyxvREFBTztBQUN0RDtBQUNBLFNBQVMsK0NBQUs7QUFDZCxpQkFBaUIsc0RBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLLHNEQUFTO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssc0RBQVM7QUFDZCxRQUFRLDhDQUFJO0FBQ1o7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0EsbUJBQW1CLGtEQUFrRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxjQUFjO0FBQ2Qsb0NBQW9DLE9BQU8sR0FBRyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0EseUJBQXlCLE9BQU8sbUNBQW1DLDRDQUE0QztBQUMvRztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtDQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2Q0FBTSxzQkFBc0IsNkNBQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0NBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUFNLHVCQUF1Qiw2Q0FBTTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLDZDQUFPO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFLO0FBQ1Q7QUFDQTtBQUNBLEtBQUssY0FBYyxXQUFXLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLDZDQUFPO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFLO0FBQ1Q7QUFDQTtBQUNBLEtBQUssY0FBYyxXQUFXLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQUssWUFBWSxzQkFBc0IsR0FBRyxvQ0FBb0M7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQUssWUFBWSxzQkFBc0IsR0FBRyxvQ0FBb0M7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQWlCO0FBQzlCLG9CQUFvQiwrREFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixrREFBa0QsRUFBRTtBQUNwRDtBQUNBLFNBQVMsZ0VBQWdFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrREFBa0I7QUFDdkQ7QUFDQSxVQUFVLHVEQUFVO0FBQ3BCO0FBQ0EsZUFBZSxxREFBUTtBQUN2QixRQUFRLFNBQVMsdURBQVU7QUFDM0I7QUFDQSx3Q0FBd0MsMENBQU07QUFDOUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQU07QUFDbkMsMkNBQTJDLHNEQUFnQixHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBc0I7QUFDM0M7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQ0FBaUM7QUFDakMscUJBQXFCLGdFQUFzQjtBQUMzQyw4RUFBOEUsMENBQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUFTO0FBQ3ZDO0FBQ0EsMEJBQTBCLGtEQUFJLGlCQUFpQixFQUFFLHNHQUFzRztBQUN2SjtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFLO0FBQ3ZCLFFBQVE7QUFDUix1QkFBdUIsaUJBQWlCLGlEQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CLG9EQUFPLHNCQUFzQjtBQUN2RSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLDJCQUEyQixrRUFBVztBQUN0Qyx1QkFBdUIsa0VBQVcsRUFBRSx5Q0FBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDBDQUFNO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMENBQTBDLHVEQUFVO0FBQ3BELE1BQU0seURBQWUsOEJBQThCLHNEQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdURBQVUsbUJBQW1CLHlDQUFTLEdBQUcsc0NBQU07QUFDdEQ7QUFDQSxNQUFNLHNEQUFhO0FBQ25CLE1BQU0scURBQVE7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFzRCxJQUFJO0FBQzlGO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EscUNBQXFDLE9BQU8sVUFBVSxNQUFNO0FBQzVEO0FBQ0EscUNBQXFDLE9BQU8sVUFBVSxNQUFNO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsc0RBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBTztBQUNiOztBQUVBO0FBQ0EsU0FBUyx1REFBVTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvYXhpcy5qcz9hODM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW50ZXJuU2V0LCBleHRlbnQsIGZvcm1hdCwgdXRjRm9ybWF0fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Zm9ybWF0RGVmYXVsdH0gZnJvbSBcIi4uL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHttYXJrc30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7cmFkaWFuc30gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXJyYXlpZnksIGNvbnN0YW50LCBpZGVudGl0eSwga2V5d29yZCwgbnVtYmVyLCByYW5nZSwgdmFsdWVvZn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7aXNJdGVyYWJsZSwgaXNOb25laXNoLCBpc1RlbXBvcmFsLCBpc0ludGVydmFsfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHttYXliZUNvbG9yQ2hhbm5lbCwgbWF5YmVOdW1iZXJDaGFubmVsLCBtYXliZVJhbmdlSW50ZXJ2YWx9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2luZmVyU2NhbGVPcmRlcn0gZnJvbSBcIi4uL3NjYWxlcy5qc1wiO1xuaW1wb3J0IHtvZmZzZXR9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHtnZW5lcmFsaXplVGltZUludGVydmFsLCBpbmZlclRpbWVGb3JtYXQsIGludGVydmFsRHVyYXRpb259IGZyb20gXCIuLi90aW1lLmpzXCI7XG5pbXBvcnQge2luaXRpYWxpemVyfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9iYXNpYy5qc1wiO1xuaW1wb3J0IHt3YXJufSBmcm9tIFwiLi4vd2FybmluZ3MuanNcIjtcbmltcG9ydCB7cnVsZVgsIHJ1bGVZfSBmcm9tIFwiLi9ydWxlLmpzXCI7XG5pbXBvcnQge3RleHQsIHRleHRYLCB0ZXh0WX0gZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHt2ZWN0b3JYLCB2ZWN0b3JZfSBmcm9tIFwiLi92ZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gbWF5YmVEYXRhKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyICYmICFpc0l0ZXJhYmxlKGRhdGEpKSAob3B0aW9ucyA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG4gIHJldHVybiBbZGF0YSwgb3B0aW9uc107XG59XG5cbmZ1bmN0aW9uIG1heWJlQW5jaG9yKHthbmNob3J9ID0ge30sIGFuY2hvcnMpIHtcbiAgcmV0dXJuIGFuY2hvciA9PT0gdW5kZWZpbmVkID8gYW5jaG9yc1swXSA6IGtleXdvcmQoYW5jaG9yLCBcImFuY2hvclwiLCBhbmNob3JzKTtcbn1cblxuZnVuY3Rpb24gYW5jaG9yWShvcHRpb25zKSB7XG4gIHJldHVybiBtYXliZUFuY2hvcihvcHRpb25zLCBbXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xufVxuXG5mdW5jdGlvbiBhbmNob3JGeShvcHRpb25zKSB7XG4gIHJldHVybiBtYXliZUFuY2hvcihvcHRpb25zLCBbXCJyaWdodFwiLCBcImxlZnRcIl0pO1xufVxuXG5mdW5jdGlvbiBhbmNob3JYKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG1heWJlQW5jaG9yKG9wdGlvbnMsIFtcImJvdHRvbVwiLCBcInRvcFwiXSk7XG59XG5cbmZ1bmN0aW9uIGFuY2hvckZ4KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG1heWJlQW5jaG9yKG9wdGlvbnMsIFtcInRvcFwiLCBcImJvdHRvbVwiXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzWSgpIHtcbiAgY29uc3QgW2RhdGEsIG9wdGlvbnNdID0gbWF5YmVEYXRhKC4uLmFyZ3VtZW50cyk7XG4gIHJldHVybiBheGlzS3koXCJ5XCIsIGFuY2hvclkob3B0aW9ucyksIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc0Z5KCkge1xuICBjb25zdCBbZGF0YSwgb3B0aW9uc10gPSBtYXliZURhdGEoLi4uYXJndW1lbnRzKTtcbiAgcmV0dXJuIGF4aXNLeShcImZ5XCIsIGFuY2hvckZ5KG9wdGlvbnMpLCBkYXRhLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNYKCkge1xuICBjb25zdCBbZGF0YSwgb3B0aW9uc10gPSBtYXliZURhdGEoLi4uYXJndW1lbnRzKTtcbiAgcmV0dXJuIGF4aXNLeChcInhcIiwgYW5jaG9yWChvcHRpb25zKSwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzRngoKSB7XG4gIGNvbnN0IFtkYXRhLCBvcHRpb25zXSA9IG1heWJlRGF0YSguLi5hcmd1bWVudHMpO1xuICByZXR1cm4gYXhpc0t4KFwiZnhcIiwgYW5jaG9yRngob3B0aW9ucyksIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBheGlzS3koXG4gIGssXG4gIGFuY2hvcixcbiAgZGF0YSxcbiAge1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBvcGFjaXR5ID0gMSxcbiAgICBzdHJva2UgPSBjb2xvcixcbiAgICBzdHJva2VPcGFjaXR5ID0gb3BhY2l0eSxcbiAgICBzdHJva2VXaWR0aCA9IDEsXG4gICAgZmlsbCA9IGNvbG9yLFxuICAgIGZpbGxPcGFjaXR5ID0gb3BhY2l0eSxcbiAgICB0ZXh0QW5jaG9yLFxuICAgIHRleHRTdHJva2UsXG4gICAgdGV4dFN0cm9rZU9wYWNpdHksXG4gICAgdGV4dFN0cm9rZVdpZHRoLFxuICAgIHRpY2tTaXplID0gayA9PT0gXCJ5XCIgPyA2IDogMCxcbiAgICB0aWNrUGFkZGluZyxcbiAgICB0aWNrUm90YXRlLFxuICAgIHgsXG4gICAgbWFyZ2luLFxuICAgIG1hcmdpblRvcCA9IG1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMjAgOiBtYXJnaW4sXG4gICAgbWFyZ2luUmlnaHQgPSBtYXJnaW4gPT09IHVuZGVmaW5lZCA/IChhbmNob3IgPT09IFwicmlnaHRcIiA/IDQwIDogMCkgOiBtYXJnaW4sXG4gICAgbWFyZ2luQm90dG9tID0gbWFyZ2luID09PSB1bmRlZmluZWQgPyAyMCA6IG1hcmdpbixcbiAgICBtYXJnaW5MZWZ0ID0gbWFyZ2luID09PSB1bmRlZmluZWQgPyAoYW5jaG9yID09PSBcImxlZnRcIiA/IDQwIDogMCkgOiBtYXJnaW4sXG4gICAgbGFiZWwsXG4gICAgbGFiZWxBbmNob3IsXG4gICAgbGFiZWxBcnJvdyxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBhcmlhTGFiZWwgPSBgJHtrfS1heGlzYCxcbiAgICAuLi5vcHRpb25zXG4gIH1cbikge1xuICB0aWNrU2l6ZSA9IG51bWJlcih0aWNrU2l6ZSk7XG4gIHRpY2tQYWRkaW5nID0gbnVtYmVyKHRpY2tQYWRkaW5nKTtcbiAgdGlja1JvdGF0ZSA9IG51bWJlcih0aWNrUm90YXRlKTtcbiAgaWYgKGxhYmVsQW5jaG9yICE9PSB1bmRlZmluZWQpIGxhYmVsQW5jaG9yID0ga2V5d29yZChsYWJlbEFuY2hvciwgXCJsYWJlbEFuY2hvclwiLCBbXCJjZW50ZXJcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl0pO1xuICBsYWJlbEFycm93ID0gbWF5YmVMYWJlbEFycm93KGxhYmVsQXJyb3cpO1xuICByZXR1cm4gbWFya3MoXG4gICAgdGlja1NpemUgJiYgIWlzTm9uZWlzaChzdHJva2UpXG4gICAgICA/IGF4aXNUaWNrS3koaywgYW5jaG9yLCBkYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGlja1NpemUsXG4gICAgICAgICAgdGlja1BhZGRpbmcsXG4gICAgICAgICAgdGlja1JvdGF0ZSxcbiAgICAgICAgICB4LFxuICAgICAgICAgIGFyaWFMYWJlbCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pXG4gICAgICA6IG51bGwsXG4gICAgIWlzTm9uZWlzaChmaWxsKVxuICAgICAgPyBheGlzVGV4dEt5KGssIGFuY2hvciwgZGF0YSwge1xuICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiB0ZXh0U3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRleHRTdHJva2VPcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiB0ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGV4dEFuY2hvcixcbiAgICAgICAgICB0aWNrU2l6ZSxcbiAgICAgICAgICB0aWNrUGFkZGluZyxcbiAgICAgICAgICB0aWNrUm90YXRlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgbWFyZ2luVG9wLFxuICAgICAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgICAgIG1hcmdpbkJvdHRvbSxcbiAgICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICAgIGFyaWFMYWJlbCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pXG4gICAgICA6IG51bGwsXG4gICAgIWlzTm9uZWlzaChmaWxsKSAmJiBsYWJlbCAhPT0gbnVsbFxuICAgICAgPyB0ZXh0KFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIGxhYmVsT3B0aW9ucyh7ZmlsbCwgZmlsbE9wYWNpdHksIC4uLm9wdGlvbnN9LCBmdW5jdGlvbiAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trXTtcbiAgICAgICAgICAgIGNvbnN0IHttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnR9ID0gKGsgPT09IFwieVwiICYmIGRpbWVuc2lvbnMuaW5zZXQpIHx8IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBjb25zdCBjbGEgPSBsYWJlbEFuY2hvciA/PyAoc2NhbGUuYmFuZHdpZHRoID8gXCJjZW50ZXJcIiA6IFwidG9wXCIpO1xuICAgICAgICAgICAgY29uc3QgY2xvID0gbGFiZWxPZmZzZXQgPz8gKGFuY2hvciA9PT0gXCJyaWdodFwiID8gbWFyZ2luUmlnaHQgOiBtYXJnaW5MZWZ0KSAtIDM7XG4gICAgICAgICAgICBpZiAoY2xhID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9IHVuZGVmaW5lZDsgLy8gbWlkZGxlXG4gICAgICAgICAgICAgIHRoaXMubGluZUFuY2hvciA9IGFuY2hvciA9PT0gXCJyaWdodFwiID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVBbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICAgIHRoaXMucm90YXRlID0gLTkwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gYW5jaG9yID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogXCJzdGFydFwiO1xuICAgICAgICAgICAgICB0aGlzLmxpbmVBbmNob3IgPSBjbGE7XG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVBbmNob3IgPSBgJHtjbGF9LSR7YW5jaG9yfWA7XG4gICAgICAgICAgICAgIHRoaXMucm90YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHkgPSBjbGEgPT09IFwidG9wXCIgPyAzIC0gbWFyZ2luVG9wIDogY2xhID09PSBcImJvdHRvbVwiID8gbWFyZ2luQm90dG9tIC0gMyA6IDA7XG4gICAgICAgICAgICB0aGlzLmR4ID0gYW5jaG9yID09PSBcInJpZ2h0XCIgPyBjbG8gOiAtY2xvO1xuICAgICAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSBgJHthcmlhTGFiZWx9IGxhYmVsYDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZhY2V0czogW1swXV0sXG4gICAgICAgICAgICAgIGNoYW5uZWxzOiB7dGV4dDoge3ZhbHVlOiBbZm9ybWF0QXhpc0xhYmVsKGssIHNjYWxlLCB7YW5jaG9yLCBsYWJlbCwgbGFiZWxBbmNob3I6IGNsYSwgbGFiZWxBcnJvd30pXX19XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIDogbnVsbFxuICApO1xufVxuXG5mdW5jdGlvbiBheGlzS3goXG4gIGssXG4gIGFuY2hvcixcbiAgZGF0YSxcbiAge1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBvcGFjaXR5ID0gMSxcbiAgICBzdHJva2UgPSBjb2xvcixcbiAgICBzdHJva2VPcGFjaXR5ID0gb3BhY2l0eSxcbiAgICBzdHJva2VXaWR0aCA9IDEsXG4gICAgZmlsbCA9IGNvbG9yLFxuICAgIGZpbGxPcGFjaXR5ID0gb3BhY2l0eSxcbiAgICB0ZXh0QW5jaG9yLFxuICAgIHRleHRTdHJva2UsXG4gICAgdGV4dFN0cm9rZU9wYWNpdHksXG4gICAgdGV4dFN0cm9rZVdpZHRoLFxuICAgIHRpY2tTaXplID0gayA9PT0gXCJ4XCIgPyA2IDogMCxcbiAgICB0aWNrUGFkZGluZyxcbiAgICB0aWNrUm90YXRlLFxuICAgIHksXG4gICAgbWFyZ2luLFxuICAgIG1hcmdpblRvcCA9IG1hcmdpbiA9PT0gdW5kZWZpbmVkID8gKGFuY2hvciA9PT0gXCJ0b3BcIiA/IDMwIDogMCkgOiBtYXJnaW4sXG4gICAgbWFyZ2luUmlnaHQgPSBtYXJnaW4gPT09IHVuZGVmaW5lZCA/IDIwIDogbWFyZ2luLFxuICAgIG1hcmdpbkJvdHRvbSA9IG1hcmdpbiA9PT0gdW5kZWZpbmVkID8gKGFuY2hvciA9PT0gXCJib3R0b21cIiA/IDMwIDogMCkgOiBtYXJnaW4sXG4gICAgbWFyZ2luTGVmdCA9IG1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMjAgOiBtYXJnaW4sXG4gICAgbGFiZWwsXG4gICAgbGFiZWxBbmNob3IsXG4gICAgbGFiZWxBcnJvdyxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBhcmlhTGFiZWwgPSBgJHtrfS1heGlzYCxcbiAgICAuLi5vcHRpb25zXG4gIH1cbikge1xuICB0aWNrU2l6ZSA9IG51bWJlcih0aWNrU2l6ZSk7XG4gIHRpY2tQYWRkaW5nID0gbnVtYmVyKHRpY2tQYWRkaW5nKTtcbiAgdGlja1JvdGF0ZSA9IG51bWJlcih0aWNrUm90YXRlKTtcbiAgaWYgKGxhYmVsQW5jaG9yICE9PSB1bmRlZmluZWQpIGxhYmVsQW5jaG9yID0ga2V5d29yZChsYWJlbEFuY2hvciwgXCJsYWJlbEFuY2hvclwiLCBbXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuICBsYWJlbEFycm93ID0gbWF5YmVMYWJlbEFycm93KGxhYmVsQXJyb3cpO1xuICByZXR1cm4gbWFya3MoXG4gICAgdGlja1NpemUgJiYgIWlzTm9uZWlzaChzdHJva2UpXG4gICAgICA/IGF4aXNUaWNrS3goaywgYW5jaG9yLCBkYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGlja1NpemUsXG4gICAgICAgICAgdGlja1BhZGRpbmcsXG4gICAgICAgICAgdGlja1JvdGF0ZSxcbiAgICAgICAgICB5LFxuICAgICAgICAgIGFyaWFMYWJlbCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pXG4gICAgICA6IG51bGwsXG4gICAgIWlzTm9uZWlzaChmaWxsKVxuICAgICAgPyBheGlzVGV4dEt4KGssIGFuY2hvciwgZGF0YSwge1xuICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiB0ZXh0U3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRleHRTdHJva2VPcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiB0ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGV4dEFuY2hvcixcbiAgICAgICAgICB0aWNrU2l6ZSxcbiAgICAgICAgICB0aWNrUGFkZGluZyxcbiAgICAgICAgICB0aWNrUm90YXRlLFxuICAgICAgICAgIHksXG4gICAgICAgICAgbWFyZ2luVG9wLFxuICAgICAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgICAgIG1hcmdpbkJvdHRvbSxcbiAgICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICAgIGFyaWFMYWJlbCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pXG4gICAgICA6IG51bGwsXG4gICAgIWlzTm9uZWlzaChmaWxsKSAmJiBsYWJlbCAhPT0gbnVsbFxuICAgICAgPyB0ZXh0KFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIGxhYmVsT3B0aW9ucyh7ZmlsbCwgZmlsbE9wYWNpdHksIC4uLm9wdGlvbnN9LCBmdW5jdGlvbiAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trXTtcbiAgICAgICAgICAgIGNvbnN0IHttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnR9ID0gKGsgPT09IFwieFwiICYmIGRpbWVuc2lvbnMuaW5zZXQpIHx8IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBjb25zdCBjbGEgPSBsYWJlbEFuY2hvciA/PyAoc2NhbGUuYmFuZHdpZHRoID8gXCJjZW50ZXJcIiA6IFwicmlnaHRcIik7XG4gICAgICAgICAgICBjb25zdCBjbG8gPSBsYWJlbE9mZnNldCA/PyAoYW5jaG9yID09PSBcInRvcFwiID8gbWFyZ2luVG9wIDogbWFyZ2luQm90dG9tKSAtIDM7XG4gICAgICAgICAgICBpZiAoY2xhID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVBbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9IHVuZGVmaW5lZDsgLy8gbWlkZGxlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmZyYW1lQW5jaG9yID0gYCR7YW5jaG9yfS0ke2NsYX1gO1xuICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSBjbGEgPT09IFwicmlnaHRcIiA/IFwiZW5kXCIgOiBcInN0YXJ0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpbmVBbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICB0aGlzLmR5ID0gYW5jaG9yID09PSBcInRvcFwiID8gLWNsbyA6IGNsbztcbiAgICAgICAgICAgIHRoaXMuZHggPSBjbGEgPT09IFwicmlnaHRcIiA/IG1hcmdpblJpZ2h0IC0gMyA6IGNsYSA9PT0gXCJsZWZ0XCIgPyAzIC0gbWFyZ2luTGVmdCA6IDA7XG4gICAgICAgICAgICB0aGlzLmFyaWFMYWJlbCA9IGAke2FyaWFMYWJlbH0gbGFiZWxgO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZmFjZXRzOiBbWzBdXSxcbiAgICAgICAgICAgICAgY2hhbm5lbHM6IHt0ZXh0OiB7dmFsdWU6IFtmb3JtYXRBeGlzTGFiZWwoaywgc2NhbGUsIHthbmNob3IsIGxhYmVsLCBsYWJlbEFuY2hvcjogY2xhLCBsYWJlbEFycm93fSldfX1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgOiBudWxsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaWNrS3koXG4gIGssXG4gIGFuY2hvcixcbiAgZGF0YSxcbiAge1xuICAgIHN0cm9rZVdpZHRoID0gMSxcbiAgICBzdHJva2VMaW5lY2FwID0gbnVsbCxcbiAgICBzdHJva2VMaW5lam9pbiA9IG51bGwsXG4gICAgZmFjZXRBbmNob3IgPSBhbmNob3IgKyAoayA9PT0gXCJ5XCIgPyBcIi1lbXB0eVwiIDogXCJcIiksXG4gICAgZnJhbWVBbmNob3IgPSBhbmNob3IsXG4gICAgdGlja1NpemUsXG4gICAgaW5zZXQgPSAwLFxuICAgIGluc2V0TGVmdCA9IGluc2V0LFxuICAgIGluc2V0UmlnaHQgPSBpbnNldCxcbiAgICBkeCA9IDAsXG4gICAgeSA9IGsgPT09IFwieVwiID8gdW5kZWZpbmVkIDogbnVsbCxcbiAgICBhcmlhTGFiZWwsXG4gICAgLi4ub3B0aW9uc1xuICB9XG4pIHtcbiAgcmV0dXJuIGF4aXNNYXJrKFxuICAgIHZlY3RvclksXG4gICAgayxcbiAgICBkYXRhLFxuICAgIHtcbiAgICAgIGFyaWFMYWJlbDogYCR7YXJpYUxhYmVsfSB0aWNrYCxcbiAgICAgIGFyaWFIaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlTGluZWNhcCxcbiAgICAgIHN0cm9rZUxpbmVqb2luLFxuICAgICAgZmFjZXRBbmNob3IsXG4gICAgICBmcmFtZUFuY2hvcixcbiAgICAgIHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZHg6IGFuY2hvciA9PT0gXCJsZWZ0XCIgPyArZHggLSBvZmZzZXQgKyAraW5zZXRMZWZ0IDogK2R4ICsgb2Zmc2V0IC0gaW5zZXRSaWdodCxcbiAgICAgIGFuY2hvcjogXCJzdGFydFwiLFxuICAgICAgbGVuZ3RoOiB0aWNrU2l6ZSxcbiAgICAgIHNoYXBlOiBhbmNob3IgPT09IFwibGVmdFwiID8gc2hhcGVUaWNrTGVmdCA6IHNoYXBlVGlja1JpZ2h0XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBheGlzVGlja0t4KFxuICBrLFxuICBhbmNob3IsXG4gIGRhdGEsXG4gIHtcbiAgICBzdHJva2VXaWR0aCA9IDEsXG4gICAgc3Ryb2tlTGluZWNhcCA9IG51bGwsXG4gICAgc3Ryb2tlTGluZWpvaW4gPSBudWxsLFxuICAgIGZhY2V0QW5jaG9yID0gYW5jaG9yICsgKGsgPT09IFwieFwiID8gXCItZW1wdHlcIiA6IFwiXCIpLFxuICAgIGZyYW1lQW5jaG9yID0gYW5jaG9yLFxuICAgIHRpY2tTaXplLFxuICAgIGluc2V0ID0gMCxcbiAgICBpbnNldFRvcCA9IGluc2V0LFxuICAgIGluc2V0Qm90dG9tID0gaW5zZXQsXG4gICAgZHkgPSAwLFxuICAgIHggPSBrID09PSBcInhcIiA/IHVuZGVmaW5lZCA6IG51bGwsXG4gICAgYXJpYUxhYmVsLFxuICAgIC4uLm9wdGlvbnNcbiAgfVxuKSB7XG4gIHJldHVybiBheGlzTWFyayhcbiAgICB2ZWN0b3JYLFxuICAgIGssXG4gICAgZGF0YSxcbiAgICB7XG4gICAgICBhcmlhTGFiZWw6IGAke2FyaWFMYWJlbH0gdGlja2AsXG4gICAgICBhcmlhSGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZUxpbmVqb2luLFxuICAgICAgc3Ryb2tlTGluZWNhcCxcbiAgICAgIGZhY2V0QW5jaG9yLFxuICAgICAgZnJhbWVBbmNob3IsXG4gICAgICB4LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGR5OiBhbmNob3IgPT09IFwiYm90dG9tXCIgPyArZHkgLSBvZmZzZXQgLSBpbnNldEJvdHRvbSA6ICtkeSArIG9mZnNldCArICtpbnNldFRvcCxcbiAgICAgIGFuY2hvcjogXCJzdGFydFwiLFxuICAgICAgbGVuZ3RoOiB0aWNrU2l6ZSxcbiAgICAgIHNoYXBlOiBhbmNob3IgPT09IFwiYm90dG9tXCIgPyBzaGFwZVRpY2tCb3R0b20gOiBzaGFwZVRpY2tUb3BcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGF4aXNUZXh0S3koXG4gIGssXG4gIGFuY2hvcixcbiAgZGF0YSxcbiAge1xuICAgIGZhY2V0QW5jaG9yID0gYW5jaG9yICsgKGsgPT09IFwieVwiID8gXCItZW1wdHlcIiA6IFwiXCIpLFxuICAgIGZyYW1lQW5jaG9yID0gYW5jaG9yLFxuICAgIHRpY2tTaXplLFxuICAgIHRpY2tSb3RhdGUgPSAwLFxuICAgIHRpY2tQYWRkaW5nID0gTWF0aC5tYXgoMywgOSAtIHRpY2tTaXplKSArIChNYXRoLmFicyh0aWNrUm90YXRlKSA+IDYwID8gNCAqIE1hdGguY29zKHRpY2tSb3RhdGUgKiByYWRpYW5zKSA6IDApLFxuICAgIHRleHQsXG4gICAgdGV4dEFuY2hvciA9IE1hdGguYWJzKHRpY2tSb3RhdGUpID4gNjAgPyBcIm1pZGRsZVwiIDogYW5jaG9yID09PSBcImxlZnRcIiA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsXG4gICAgbGluZUFuY2hvciA9IHRpY2tSb3RhdGUgPiA2MCA/IFwidG9wXCIgOiB0aWNrUm90YXRlIDwgLTYwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCIsXG4gICAgZm9udFZhcmlhbnQsXG4gICAgaW5zZXQgPSAwLFxuICAgIGluc2V0TGVmdCA9IGluc2V0LFxuICAgIGluc2V0UmlnaHQgPSBpbnNldCxcbiAgICBkeCA9IDAsXG4gICAgYXJpYUxhYmVsLFxuICAgIHkgPSBrID09PSBcInlcIiA/IHVuZGVmaW5lZCA6IG51bGwsXG4gICAgLi4ub3B0aW9uc1xuICB9XG4pIHtcbiAgcmV0dXJuIGF4aXNNYXJrKFxuICAgIHRleHRZLFxuICAgIGssXG4gICAgZGF0YSxcbiAgICB7YXJpYUxhYmVsOiBgJHthcmlhTGFiZWx9IHRpY2sgbGFiZWxgfSxcbiAgICB7XG4gICAgICBmYWNldEFuY2hvcixcbiAgICAgIGZyYW1lQW5jaG9yLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRBbmNob3IsXG4gICAgICBsaW5lQW5jaG9yLFxuICAgICAgZm9udFZhcmlhbnQsXG4gICAgICByb3RhdGU6IHRpY2tSb3RhdGUsXG4gICAgICB5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGR4OiBhbmNob3IgPT09IFwibGVmdFwiID8gK2R4IC0gdGlja1NpemUgLSB0aWNrUGFkZGluZyArICtpbnNldExlZnQgOiArZHggKyArdGlja1NpemUgKyArdGlja1BhZGRpbmcgLSBpbnNldFJpZ2h0XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoc2NhbGUsIGRhdGEsIHRpY2tzLCB0aWNrRm9ybWF0LCBjaGFubmVscykge1xuICAgICAgaWYgKGZvbnRWYXJpYW50ID09PSB1bmRlZmluZWQpIHRoaXMuZm9udFZhcmlhbnQgPSBpbmZlckZvbnRWYXJpYW50KHNjYWxlKTtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIGNoYW5uZWxzLnRleHQgPSBpbmZlclRleHRDaGFubmVsKHNjYWxlLCBkYXRhLCB0aWNrcywgdGlja0Zvcm1hdCwgYW5jaG9yKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGF4aXNUZXh0S3goXG4gIGssXG4gIGFuY2hvcixcbiAgZGF0YSxcbiAge1xuICAgIGZhY2V0QW5jaG9yID0gYW5jaG9yICsgKGsgPT09IFwieFwiID8gXCItZW1wdHlcIiA6IFwiXCIpLFxuICAgIGZyYW1lQW5jaG9yID0gYW5jaG9yLFxuICAgIHRpY2tTaXplLFxuICAgIHRpY2tSb3RhdGUgPSAwLFxuICAgIHRpY2tQYWRkaW5nID0gTWF0aC5tYXgoMywgOSAtIHRpY2tTaXplKSArIChNYXRoLmFicyh0aWNrUm90YXRlKSA+PSAxMCA/IDQgKiBNYXRoLmNvcyh0aWNrUm90YXRlICogcmFkaWFucykgOiAwKSxcbiAgICB0ZXh0LFxuICAgIHRleHRBbmNob3IgPSBNYXRoLmFicyh0aWNrUm90YXRlKSA+PSAxMCA/ICgodGlja1JvdGF0ZSA8IDApIF4gKGFuY2hvciA9PT0gXCJib3R0b21cIikgPyBcInN0YXJ0XCIgOiBcImVuZFwiKSA6IFwibWlkZGxlXCIsXG4gICAgbGluZUFuY2hvciA9IE1hdGguYWJzKHRpY2tSb3RhdGUpID49IDEwID8gXCJtaWRkbGVcIiA6IGFuY2hvciA9PT0gXCJib3R0b21cIiA/IFwidG9wXCIgOiBcImJvdHRvbVwiLFxuICAgIGZvbnRWYXJpYW50LFxuICAgIGluc2V0ID0gMCxcbiAgICBpbnNldFRvcCA9IGluc2V0LFxuICAgIGluc2V0Qm90dG9tID0gaW5zZXQsXG4gICAgZHkgPSAwLFxuICAgIHggPSBrID09PSBcInhcIiA/IHVuZGVmaW5lZCA6IG51bGwsXG4gICAgYXJpYUxhYmVsLFxuICAgIC4uLm9wdGlvbnNcbiAgfVxuKSB7XG4gIHJldHVybiBheGlzTWFyayhcbiAgICB0ZXh0WCxcbiAgICBrLFxuICAgIGRhdGEsXG4gICAge2FyaWFMYWJlbDogYCR7YXJpYUxhYmVsfSB0aWNrIGxhYmVsYH0sXG4gICAge1xuICAgICAgZmFjZXRBbmNob3IsXG4gICAgICBmcmFtZUFuY2hvcixcbiAgICAgIHRleHQ6IHRleHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0ZXh0LFxuICAgICAgdGV4dEFuY2hvcixcbiAgICAgIGxpbmVBbmNob3IsXG4gICAgICBmb250VmFyaWFudCxcbiAgICAgIHJvdGF0ZTogdGlja1JvdGF0ZSxcbiAgICAgIHgsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZHk6IGFuY2hvciA9PT0gXCJib3R0b21cIiA/ICtkeSArICt0aWNrU2l6ZSArICt0aWNrUGFkZGluZyAtIGluc2V0Qm90dG9tIDogK2R5IC0gdGlja1NpemUgLSB0aWNrUGFkZGluZyArICtpbnNldFRvcFxuICAgIH0sXG4gICAgZnVuY3Rpb24gKHNjYWxlLCBkYXRhLCB0aWNrcywgdGlja0Zvcm1hdCwgY2hhbm5lbHMpIHtcbiAgICAgIGlmIChmb250VmFyaWFudCA9PT0gdW5kZWZpbmVkKSB0aGlzLmZvbnRWYXJpYW50ID0gaW5mZXJGb250VmFyaWFudChzY2FsZSk7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSBjaGFubmVscy50ZXh0ID0gaW5mZXJUZXh0Q2hhbm5lbChzY2FsZSwgZGF0YSwgdGlja3MsIHRpY2tGb3JtYXQsIGFuY2hvcik7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZFkoKSB7XG4gIGNvbnN0IFtkYXRhLCBvcHRpb25zXSA9IG1heWJlRGF0YSguLi5hcmd1bWVudHMpO1xuICByZXR1cm4gZ3JpZEt5KFwieVwiLCBhbmNob3JZKG9wdGlvbnMpLCBkYXRhLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRGeSgpIHtcbiAgY29uc3QgW2RhdGEsIG9wdGlvbnNdID0gbWF5YmVEYXRhKC4uLmFyZ3VtZW50cyk7XG4gIHJldHVybiBncmlkS3koXCJmeVwiLCBhbmNob3JGeShvcHRpb25zKSwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmlkWCgpIHtcbiAgY29uc3QgW2RhdGEsIG9wdGlvbnNdID0gbWF5YmVEYXRhKC4uLmFyZ3VtZW50cyk7XG4gIHJldHVybiBncmlkS3goXCJ4XCIsIGFuY2hvclgob3B0aW9ucyksIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZEZ4KCkge1xuICBjb25zdCBbZGF0YSwgb3B0aW9uc10gPSBtYXliZURhdGEoLi4uYXJndW1lbnRzKTtcbiAgcmV0dXJuIGdyaWRLeChcImZ4XCIsIGFuY2hvckZ4KG9wdGlvbnMpLCBkYXRhLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ3JpZEt5KFxuICBrLFxuICBhbmNob3IsXG4gIGRhdGEsXG4gIHtcbiAgICB5ID0gayA9PT0gXCJ5XCIgPyB1bmRlZmluZWQgOiBudWxsLFxuICAgIHggPSBudWxsLFxuICAgIHgxID0gYW5jaG9yID09PSBcImxlZnRcIiA/IHggOiBudWxsLFxuICAgIHgyID0gYW5jaG9yID09PSBcInJpZ2h0XCIgPyB4IDogbnVsbCxcbiAgICBhcmlhTGFiZWwgPSBgJHtrfS1ncmlkYCxcbiAgICBhcmlhSGlkZGVuID0gdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH1cbikge1xuICByZXR1cm4gYXhpc01hcmsocnVsZVksIGssIGRhdGEsIHthcmlhTGFiZWwsIGFyaWFIaWRkZW59LCB7eSwgeDEsIHgyLCAuLi5ncmlkRGVmYXVsdHMob3B0aW9ucyl9KTtcbn1cblxuZnVuY3Rpb24gZ3JpZEt4KFxuICBrLFxuICBhbmNob3IsXG4gIGRhdGEsXG4gIHtcbiAgICB4ID0gayA9PT0gXCJ4XCIgPyB1bmRlZmluZWQgOiBudWxsLFxuICAgIHkgPSBudWxsLFxuICAgIHkxID0gYW5jaG9yID09PSBcInRvcFwiID8geSA6IG51bGwsXG4gICAgeTIgPSBhbmNob3IgPT09IFwiYm90dG9tXCIgPyB5IDogbnVsbCxcbiAgICBhcmlhTGFiZWwgPSBgJHtrfS1ncmlkYCxcbiAgICBhcmlhSGlkZGVuID0gdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH1cbikge1xuICByZXR1cm4gYXhpc01hcmsocnVsZVgsIGssIGRhdGEsIHthcmlhTGFiZWwsIGFyaWFIaWRkZW59LCB7eCwgeTEsIHkyLCAuLi5ncmlkRGVmYXVsdHMob3B0aW9ucyl9KTtcbn1cblxuZnVuY3Rpb24gZ3JpZERlZmF1bHRzKHtcbiAgY29sb3IgPSBcImN1cnJlbnRDb2xvclwiLFxuICBvcGFjaXR5ID0gMC4xLFxuICBzdHJva2UgPSBjb2xvcixcbiAgc3Ryb2tlT3BhY2l0eSA9IG9wYWNpdHksXG4gIHN0cm9rZVdpZHRoID0gMSxcbiAgLi4ub3B0aW9uc1xufSkge1xuICByZXR1cm4ge3N0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGgsIC4uLm9wdGlvbnN9O1xufVxuXG5mdW5jdGlvbiBsYWJlbE9wdGlvbnMoXG4gIHtcbiAgICBmaWxsLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIGZvbnRGYW1pbHksXG4gICAgZm9udFNpemUsXG4gICAgZm9udFN0eWxlLFxuICAgIGZvbnRWYXJpYW50LFxuICAgIGZvbnRXZWlnaHQsXG4gICAgbW9ub3NwYWNlLFxuICAgIHBvaW50ZXJFdmVudHMsXG4gICAgc2hhcGVSZW5kZXJpbmcsXG4gICAgY2xpcCA9IGZhbHNlXG4gIH0sXG4gIGluaXRpYWxpemVyXG4pIHtcbiAgLy8gT25seSBwcm9wYWdhdGUgdGhlc2Ugb3B0aW9ucyBpZiBjb25zdGFudC5cbiAgWywgZmlsbF0gPSBtYXliZUNvbG9yQ2hhbm5lbChmaWxsKTtcbiAgWywgZmlsbE9wYWNpdHldID0gbWF5YmVOdW1iZXJDaGFubmVsKGZpbGxPcGFjaXR5KTtcbiAgcmV0dXJuIHtcbiAgICBmYWNldDogXCJzdXBlclwiLFxuICAgIHg6IG51bGwsXG4gICAgeTogbnVsbCxcbiAgICBmaWxsLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIGZvbnRGYW1pbHksXG4gICAgZm9udFNpemUsXG4gICAgZm9udFN0eWxlLFxuICAgIGZvbnRWYXJpYW50LFxuICAgIGZvbnRXZWlnaHQsXG4gICAgbW9ub3NwYWNlLFxuICAgIHBvaW50ZXJFdmVudHMsXG4gICAgc2hhcGVSZW5kZXJpbmcsXG4gICAgY2xpcCxcbiAgICBpbml0aWFsaXplclxuICB9O1xufVxuXG5mdW5jdGlvbiBheGlzTWFyayhtYXJrLCBrLCBkYXRhLCBwcm9wZXJ0aWVzLCBvcHRpb25zLCBpbml0aWFsaXplKSB7XG4gIGxldCBjaGFubmVscztcblxuICBmdW5jdGlvbiBheGlzSW5pdGlhbGl6ZXIoZGF0YSwgZmFjZXRzLCBfY2hhbm5lbHMsIHNjYWxlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IGluaXRpYWxpemVGYWNldHMgPSBkYXRhID09IG51bGwgJiYgKGsgPT09IFwiZnhcIiB8fCBrID09PSBcImZ5XCIpO1xuICAgIGNvbnN0IHtba106IHNjYWxlfSA9IHNjYWxlcztcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgc2NhbGU6ICR7a31gKTtcbiAgICBjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcbiAgICBsZXQge2ludGVydmFsLCB0aWNrcywgdGlja0Zvcm1hdCwgdGlja1NwYWNpbmcgPSBrID09PSBcInhcIiA/IDgwIDogMzV9ID0gb3B0aW9ucztcbiAgICAvLyBGb3IgYSBzY2FsZSB3aXRoIGEgdGVtcG9yYWwgZG9tYWluLCBhbHNvIGFsbG93IHRoZSB0aWNrcyB0byBiZSBzcGVjaWZpZWRcbiAgICAvLyBhcyBhIHN0cmluZyB3aGljaCBpcyBwcm9tb3RlZCB0byBhIHRpbWUgaW50ZXJ2YWwuIEluIHRoZSBjYXNlIG9mIG9yZGluYWxcbiAgICAvLyBzY2FsZXMsIHRoZSBpbnRlcnZhbCBpcyBpbnRlcnByZXRlZCBhcyBVVEMuXG4gICAgaWYgKHR5cGVvZiB0aWNrcyA9PT0gXCJzdHJpbmdcIiAmJiBoYXNUZW1wb3JhbERvbWFpbihzY2FsZSkpIChpbnRlcnZhbCA9IHRpY2tzKSwgKHRpY2tzID0gdW5kZWZpbmVkKTtcbiAgICAvLyBUaGUgaW50ZXJ2YWwgYXhpcyBvcHRpb24gaXMgYW4gYWx0ZXJuYXRpdmUgbWV0aG9kIG9mIHNwZWNpZnlpbmcgdGlja3M7XG4gICAgLy8gZm9yIGV4YW1wbGUsIGZvciBhIG51bWVyaWMgc2NhbGUsIHRpY2tzID0gNSBtZWFucyDigJxhYm91dCA1IHRpY2tz4oCdIHdoZXJlYXNcbiAgICAvLyBpbnRlcnZhbCA9IDUgbWVhbnMg4oCcdGlja3MgZXZlcnkgNSB1bml0c+KAnS4gKFRoaXMgaXMgbm90IHRvIGJlIGNvbmZ1c2VkXG4gICAgLy8gd2l0aCB0aGUgaW50ZXJ2YWwgc2NhbGUgb3B0aW9uLCB3aGljaCBhZmZlY3RzIHRoZSBzY2FsZeKAmXMgYmVoYXZpb3IhKVxuICAgIC8vIExhc3RseSB1c2UgdGhlIHRpY2tTcGFjaW5nIG9wdGlvbiB0byBpbmZlciB0aGUgZGVzaXJlZCB0aWNrIGNvdW50LlxuICAgIGlmICh0aWNrcyA9PT0gdW5kZWZpbmVkKSB0aWNrcyA9IG1heWJlUmFuZ2VJbnRlcnZhbChpbnRlcnZhbCwgc2NhbGUudHlwZSkgPz8gaW5mZXJUaWNrQ291bnQoc2NhbGUsIHRpY2tTcGFjaW5nKTtcbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNJdGVyYWJsZSh0aWNrcykpIHtcbiAgICAgICAgLy8gVXNlIGV4cGxpY2l0IHRpY2tzLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgIGRhdGEgPSBhcnJheWlmeSh0aWNrcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW50ZXJ2YWwodGlja3MpKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgdGljayBpbnRlcnZhbCwgaWYgc3BlY2lmaWVkLlxuICAgICAgICBkYXRhID0gaW5jbHVzaXZlUmFuZ2UodGlja3MsIC4uLmV4dGVudChkb21haW4pKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NhbGUuaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNjYWxlIGludGVydmFsIGlzIGEgc3RhbmRhcmQgdGltZSBpbnRlcnZhbCBzdWNoIGFzIFwiZGF5XCIsIHdlXG4gICAgICAgIC8vIG1heSBiZSBhYmxlIHRvIGdlbmVyYWxpemUgdGhlIHNjYWxlIGludGVydmFsIGl0IHRvIGEgbGFyZ2VyIGFsaWduZWRcbiAgICAgICAgLy8gdGltZSBpbnRlcnZhbCB0byBjcmVhdGUgdGhlIGRlc2lyZWQgbnVtYmVyIG9mIHRpY2tzLlxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBzY2FsZS5pbnRlcnZhbDtcbiAgICAgICAgaWYgKHNjYWxlLnRpY2tzKSB7XG4gICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IGV4dGVudChkb21haW4pO1xuICAgICAgICAgIGNvbnN0IG4gPSAobWF4IC0gbWluKSAvIGludGVydmFsW2ludGVydmFsRHVyYXRpb25dOyAvLyBjdXJyZW50IHRpY2sgY291bnRcbiAgICAgICAgICAvLyBXZSBkb27igJl0IGV4cGxpY2l0bHkgY2hlY2sgdGhhdCBnaXZlbiBpbnRlcnZhbCBpcyBhIHRpbWUgaW50ZXJ2YWw7XG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHRoZSBnZW5lcmFsaXplZCBpbnRlcnZhbCB3aWxsIGJlIHVuZGVmaW5lZCwganVzdCBsaWtlXG4gICAgICAgICAgLy8gYSBub25zdGFuZGFyZCBpbnRlcnZhbC4gVE9ETyBHZW5lcmFsaXplIGludGVnZXIgaW50ZXJ2YWxzLCB0b28uXG4gICAgICAgICAgaW50ZXJ2YWwgPSBnZW5lcmFsaXplVGltZUludGVydmFsKGludGVydmFsLCBuIC8gdGlja3MpID8/IGludGVydmFsO1xuICAgICAgICAgIGRhdGEgPSBpbmNsdXNpdmVSYW5nZShpbnRlcnZhbCwgbWluLCBtYXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBkb21haW47XG4gICAgICAgICAgY29uc3QgbiA9IGRhdGEubGVuZ3RoOyAvLyBjdXJyZW50IHRpY2sgY291bnRcbiAgICAgICAgICBpbnRlcnZhbCA9IGdlbmVyYWxpemVUaW1lSW50ZXJ2YWwoaW50ZXJ2YWwsIG4gLyB0aWNrcykgPz8gaW50ZXJ2YWw7XG4gICAgICAgICAgaWYgKGludGVydmFsICE9PSBzY2FsZS5pbnRlcnZhbCkgZGF0YSA9IGluY2x1c2l2ZVJhbmdlKGludGVydmFsLCAuLi5leHRlbnQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnZhbCA9PT0gc2NhbGUuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAvLyBJZiB3ZSB3ZXJlbuKAmXQgYWJsZSB0byBnZW5lcmFsaXplIHRoZSBzY2FsZeKAmXMgaW50ZXJ2YWwsIGNvbXB1dGUgdGhlXG4gICAgICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyIG4gc3VjaCB0aGF0IHRha2luZyBldmVyeSBudGggdmFsdWUgZnJvbSB0aGUgc2NhbGXigJlzXG4gICAgICAgICAgLy8gZG9tYWluIHByb2R1Y2VzIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHRoZSBkZXNpcmVkIG51bWJlciBvZlxuICAgICAgICAgIC8vIHRpY2tzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIGRvbWFpbiBoYXMgMTAwIHZhbHVlcyBhbmQgNSB0aWNrcyBhcmVcbiAgICAgICAgICAvLyBkZXNpcmVkLCBuID0gMjAuXG4gICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoZGF0YS5sZW5ndGggLyB0aWNrcyk7XG4gICAgICAgICAgaWYgKG4gPiAxKSBkYXRhID0gZGF0YS5maWx0ZXIoKGQsIGkpID0+IGkgJSBuID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzY2FsZS50aWNrcykge1xuICAgICAgICBkYXRhID0gc2NhbGUudGlja3ModGlja3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9yZGluYWwgc2NhbGVzLCB0aGUgZG9tYWluIHdpbGwgYWxyZWFkeSBiZSBnZW5lcmF0ZWQgdXNpbmcgdGhlXG4gICAgICAgIC8vIHNjYWxl4oCZcyBpbnRlcnZhbCwgaWYgYW55LlxuICAgICAgICBkYXRhID0gZG9tYWluO1xuICAgICAgfVxuICAgICAgaWYgKCFzY2FsZS50aWNrcyAmJiBkYXRhLmxlbmd0aCAmJiBkYXRhICE9PSBkb21haW4pIHtcbiAgICAgICAgLy8gRm9yIG9yZGluYWwgc2NhbGVzLCBpbnRlcnNlY3QgdGhlIHRpY2tzIHdpdGggdGhlIHNjYWxlIGRvbWFpbiBzaW5jZVxuICAgICAgICAvLyB0aGUgc2NhbGUgaXMgb25seSBkZWZpbmVkIG9uIGl0cyBkb21haW4uIElmIGFsbCBvZiB0aGUgdGlja3MgYXJlXG4gICAgICAgIC8vIHJlbW92ZWQsIHRoZW4gd2FybiB0aGF0IHRoZSB0aWNrcyBhbmQgc2NhbGUgZG9tYWluIG1heSBiZSBtaXNhbGlnbmVkXG4gICAgICAgIC8vIChlLmcuLCBcInllYXJcIiB0aWNrcyBhbmQgXCI0IHdlZWtzXCIgaW50ZXJ2YWwpLlxuICAgICAgICBjb25zdCBkb21haW5TZXQgPSBuZXcgSW50ZXJuU2V0KGRvbWFpbik7XG4gICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcigoZCkgPT4gZG9tYWluU2V0LmhhcyhkKSk7XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHdhcm4oYFdhcm5pbmc6IHRoZSAke2t9LWF4aXMgdGlja3MgYXBwZWFyIHRvIG5vdCBhbGlnbiB3aXRoIHRoZSBzY2FsZSBkb21haW4sIHJlc3VsdGluZyBpbiBubyB0aWNrcy4gVHJ5IGRpZmZlcmVudCB0aWNrcz9gKTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICB9XG4gICAgICBpZiAoayA9PT0gXCJ5XCIgfHwgayA9PT0gXCJ4XCIpIHtcbiAgICAgICAgZmFjZXRzID0gW3JhbmdlKGRhdGEpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5uZWxzW2tdID0ge3NjYWxlOiBrLCB2YWx1ZTogaWRlbnRpdHl9O1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsaXplPy5jYWxsKHRoaXMsIHNjYWxlLCBkYXRhLCB0aWNrcywgdGlja0Zvcm1hdCwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGluaXRpYWxpemVkQ2hhbm5lbHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhjaGFubmVscykubWFwKChbbmFtZSwgY2hhbm5lbF0pID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCB7Li4uY2hhbm5lbCwgdmFsdWU6IHZhbHVlb2YoZGF0YSwgY2hhbm5lbC52YWx1ZSl9XTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAoaW5pdGlhbGl6ZUZhY2V0cykgZmFjZXRzID0gY29udGV4dC5maWx0ZXJGYWNldHMoZGF0YSwgaW5pdGlhbGl6ZWRDaGFubmVscyk7XG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHMsIGNoYW5uZWxzOiBpbml0aWFsaXplZENoYW5uZWxzfTtcbiAgfVxuXG4gIC8vIEFwcGx5IGFueSBiYXNpYyBpbml0aWFsaXplcnMgYWZ0ZXIgdGhlIGF4aXMgaW5pdGlhbGl6ZXIgY29tcHV0ZXMgdGhlIHRpY2tzLlxuICBjb25zdCBiYXNpY0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXIob3B0aW9ucykuaW5pdGlhbGl6ZXI7XG4gIGNvbnN0IG0gPSBtYXJrKGRhdGEsIGluaXRpYWxpemVyKHsuLi5vcHRpb25zLCBpbml0aWFsaXplcjogYXhpc0luaXRpYWxpemVyfSwgYmFzaWNJbml0aWFsaXplcikpO1xuICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgY2hhbm5lbHMgPSBtLmNoYW5uZWxzO1xuICAgIG0uY2hhbm5lbHMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVscyA9IHt9O1xuICB9XG4gIGlmIChwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIE9iamVjdC5hc3NpZ24obSwgcHJvcGVydGllcyk7XG4gIGlmIChtLmNsaXAgPT09IHVuZGVmaW5lZCkgbS5jbGlwID0gZmFsc2U7IC8vIGRvbuKAmXQgY2xpcCBheGVzIGJ5IGRlZmF1bHRcbiAgcmV0dXJuIG07XG59XG5cbmZ1bmN0aW9uIGluZmVyVGlja0NvdW50KHNjYWxlLCB0aWNrU3BhY2luZykge1xuICBjb25zdCBbbWluLCBtYXhdID0gZXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xuICByZXR1cm4gKG1heCAtIG1pbikgLyB0aWNrU3BhY2luZztcbn1cblxuZnVuY3Rpb24gaW5mZXJUZXh0Q2hhbm5lbChzY2FsZSwgZGF0YSwgdGlja3MsIHRpY2tGb3JtYXQsIGFuY2hvcikge1xuICByZXR1cm4ge3ZhbHVlOiBpbmZlclRpY2tGb3JtYXQoc2NhbGUsIGRhdGEsIHRpY2tzLCB0aWNrRm9ybWF0LCBhbmNob3IpfTtcbn1cblxuLy8gRDPigJlzIG9yZGluYWwgc2NhbGVzIHNpbXBseSB1c2UgdG9TdHJpbmcgYnkgZGVmYXVsdCwgYnV0IGlmIHRoZSBvcmRpbmFsIHNjYWxlXG4vLyBkb21haW4gKG9yIHRpY2tzKSBhcmUgbnVtYmVycyBvciBkYXRlcyAoc2F5IGJlY2F1c2Ugd2XigJlyZSBhcHBseWluZyBhIHRpbWVcbi8vIGludGVydmFsIHRvIHRoZSBvcmRpbmFsIHNjYWxlKSwgd2Ugd2FudCBQbG904oCZcyBkZWZhdWx0IGZvcm1hdHRlci4gQW5kIGZvclxuLy8gdGltZSB0aWNrcywgd2Ugd2FudCB0byB1c2UgdGhlIG11bHRpLWxpbmUgdGltZSBmb3JtYXQgKGUuZy4sIEphbiAyNikgaWZcbi8vIHBvc3NpYmxlLCBvciB0aGUgZGVmYXVsdCBJU08gZm9ybWF0ICgyMDE0LTAxLTI2KS4gVE9ETyBXZSBuZWVkIGEgYmV0dGVyIHdheVxuLy8gdG8gaW5mZXIgd2hldGhlciB0aGUgb3JkaW5hbCBzY2FsZSBpcyBVVEMgb3IgbG9jYWwgdGltZS5cbmV4cG9ydCBmdW5jdGlvbiBpbmZlclRpY2tGb3JtYXQoc2NhbGUsIGRhdGEsIHRpY2tzLCB0aWNrRm9ybWF0LCBhbmNob3IpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aWNrRm9ybWF0ID09PSBcImZ1bmN0aW9uXCIgJiYgIShzY2FsZS50eXBlID09PSBcImxvZ1wiICYmIHNjYWxlLnRpY2tGb3JtYXQpXG4gICAgPyB0aWNrRm9ybWF0XG4gICAgOiB0aWNrRm9ybWF0ID09PSB1bmRlZmluZWQgJiYgZGF0YSAmJiBpc1RlbXBvcmFsKGRhdGEpXG4gICAgPyBpbmZlclRpbWVGb3JtYXQoc2NhbGUudHlwZSwgZGF0YSwgYW5jaG9yKSA/PyBmb3JtYXREZWZhdWx0XG4gICAgOiBzY2FsZS50aWNrRm9ybWF0XG4gICAgPyBzY2FsZS50aWNrRm9ybWF0KHR5cGVvZiB0aWNrcyA9PT0gXCJudW1iZXJcIiA/IHRpY2tzIDogbnVsbCwgdGlja0Zvcm1hdClcbiAgICA6IHR5cGVvZiB0aWNrRm9ybWF0ID09PSBcInN0cmluZ1wiICYmIHNjYWxlLmRvbWFpbigpLmxlbmd0aCA+IDBcbiAgICA/IChpc1RlbXBvcmFsKHNjYWxlLmRvbWFpbigpKSA/IHV0Y0Zvcm1hdCA6IGZvcm1hdCkodGlja0Zvcm1hdClcbiAgICA6IHRpY2tGb3JtYXQgPT09IHVuZGVmaW5lZFxuICAgID8gZm9ybWF0RGVmYXVsdFxuICAgIDogY29uc3RhbnQodGlja0Zvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGluY2x1c2l2ZVJhbmdlKGludGVydmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gaW50ZXJ2YWwucmFuZ2UobWluLCBpbnRlcnZhbC5vZmZzZXQoaW50ZXJ2YWwuZmxvb3IobWF4KSkpO1xufVxuXG5jb25zdCBzaGFwZVRpY2tCb3R0b20gPSB7XG4gIGRyYXcoY29udGV4dCwgbCkge1xuICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIGwpO1xuICB9XG59O1xuXG5jb25zdCBzaGFwZVRpY2tUb3AgPSB7XG4gIGRyYXcoY29udGV4dCwgbCkge1xuICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1sKTtcbiAgfVxufTtcblxuY29uc3Qgc2hhcGVUaWNrTGVmdCA9IHtcbiAgZHJhdyhjb250ZXh0LCBsKSB7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oLWwsIDApO1xuICB9XG59O1xuXG5jb25zdCBzaGFwZVRpY2tSaWdodCA9IHtcbiAgZHJhdyhjb250ZXh0LCBsKSB7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8obCwgMCk7XG4gIH1cbn07XG5cbi8vIFRPRE8gVW5pZnkgdGhpcyB3aXRoIHRoZSBvdGhlciBpbmZlckZvbnRWYXJpYW50OyBoZXJlIHdlIG9ubHkgaGF2ZSBhIHNjYWxlXG4vLyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhIHNjYWxlIGRlc2NyaXB0b3IuXG5mdW5jdGlvbiBpbmZlckZvbnRWYXJpYW50KHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5iYW5kd2lkdGggJiYgIXNjYWxlLmludGVydmFsID8gdW5kZWZpbmVkIDogXCJ0YWJ1bGFyLW51bXNcIjtcbn1cblxuLy8gVGFrZXMgdGhlIHNjYWxlIGxhYmVsLCBhbmQgaWYgdGhpcyBpcyBub3QgYW4gb3JkaW5hbCBzY2FsZSBhbmQgdGhlIGxhYmVsIHdhc1xuLy8gaW5mZXJyZWQgZnJvbSBhbiBhc3NvY2lhdGVkIGNoYW5uZWwsIGFkZHMgYW4gb3JpZW50YXRpb24tYXBwcm9wcmlhdGUgYXJyb3cuXG5mdW5jdGlvbiBmb3JtYXRBeGlzTGFiZWwoaywgc2NhbGUsIHthbmNob3IsIGxhYmVsID0gc2NhbGUubGFiZWwsIGxhYmVsQW5jaG9yLCBsYWJlbEFycm93fSA9IHt9KSB7XG4gIGlmIChsYWJlbCA9PSBudWxsIHx8IChsYWJlbC5pbmZlcnJlZCAmJiBoYXNUZW1wb3JhbERvbWFpbihzY2FsZSkgJiYgL14oZGF0ZXx0aW1lfHllYXIpJC9pLnRlc3QobGFiZWwpKSkgcmV0dXJuO1xuICBsYWJlbCA9IFN0cmluZyhsYWJlbCk7IC8vIGNvZXJjZSB0byBhIHN0cmluZyBhZnRlciBjaGVja2luZyBpZiBpbmZlcnJlZFxuICBpZiAobGFiZWxBcnJvdyA9PT0gXCJhdXRvXCIpIGxhYmVsQXJyb3cgPSAoIXNjYWxlLmJhbmR3aWR0aCB8fCBzY2FsZS5pbnRlcnZhbCkgJiYgIS9b4oaR4oaT4oaS4oaQXS8udGVzdChsYWJlbCk7XG4gIGlmICghbGFiZWxBcnJvdykgcmV0dXJuIGxhYmVsO1xuICBpZiAobGFiZWxBcnJvdyA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IG9yZGVyID0gaW5mZXJTY2FsZU9yZGVyKHNjYWxlKTtcbiAgICBpZiAob3JkZXIpXG4gICAgICBsYWJlbEFycm93ID1cbiAgICAgICAgL3gkLy50ZXN0KGspIHx8IGxhYmVsQW5jaG9yID09PSBcImNlbnRlclwiXG4gICAgICAgICAgPyAveCQvLnRlc3QoaykgPT09IG9yZGVyIDwgMFxuICAgICAgICAgICAgPyBcImxlZnRcIlxuICAgICAgICAgICAgOiBcInJpZ2h0XCJcbiAgICAgICAgICA6IG9yZGVyIDwgMFxuICAgICAgICAgID8gXCJ1cFwiXG4gICAgICAgICAgOiBcImRvd25cIjtcbiAgfVxuICBzd2l0Y2ggKGxhYmVsQXJyb3cpIHtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIGDihpAgJHtsYWJlbH1gO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIGAke2xhYmVsfSDihpJgO1xuICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgcmV0dXJuIGFuY2hvciA9PT0gXCJyaWdodFwiID8gYCR7bGFiZWx9IOKGkWAgOiBg4oaRICR7bGFiZWx9YDtcbiAgICBjYXNlIFwiZG93blwiOlxuICAgICAgcmV0dXJuIGFuY2hvciA9PT0gXCJyaWdodFwiID8gYCR7bGFiZWx9IOKGk2AgOiBg4oaTICR7bGFiZWx9YDtcbiAgfVxuICByZXR1cm4gbGFiZWw7XG59XG5cbmZ1bmN0aW9uIG1heWJlTGFiZWxBcnJvdyhsYWJlbEFycm93ID0gXCJhdXRvXCIpIHtcbiAgcmV0dXJuIGlzTm9uZWlzaChsYWJlbEFycm93KVxuICAgID8gZmFsc2VcbiAgICA6IHR5cGVvZiBsYWJlbEFycm93ID09PSBcImJvb2xlYW5cIlxuICAgID8gbGFiZWxBcnJvd1xuICAgIDoga2V5d29yZChsYWJlbEFycm93LCBcImxhYmVsQXJyb3dcIiwgW1wiYXV0b1wiLCBcInVwXCIsIFwicmlnaHRcIiwgXCJkb3duXCIsIFwibGVmdFwiXSk7XG59XG5cbmZ1bmN0aW9uIGhhc1RlbXBvcmFsRG9tYWluKHNjYWxlKSB7XG4gIHJldHVybiBpc1RlbXBvcmFsKHNjYWxlLmRvbWFpbigpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js":
/*!**********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/bar.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractBar: () => (/* binding */ AbstractBar),\n/* harmony export */   BarX: () => (/* binding */ BarX),\n/* harmony export */   BarY: () => (/* binding */ BarY),\n/* harmony export */   barX: () => (/* binding */ barX),\n/* harmony export */   barY: () => (/* binding */ barY)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transforms/identity.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n/* harmony import */ var _transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/stack.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\");\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js\");\n\n\n\n\n\n\n\n\n\n\nconst barDefaults = {\n  ariaLabel: \"bar\"\n};\n\nclass AbstractBar extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, channels, options = {}, defaults = barDefaults) {\n    super(data, channels, options, defaults);\n    (0,_rect_js__WEBPACK_IMPORTED_MODULE_1__.rectInsets)(this, options);\n    (0,_rect_js__WEBPACK_IMPORTED_MODULE_1__.rectRadii)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {rx, ry, rx1y1, rx1y2, rx2y1, rx2y2} = this;\n    const x = this._x(scales, channels, dimensions);\n    const y = this._y(scales, channels, dimensions);\n    const w = this._width(scales, channels, dimensions);\n    const h = this._height(scales, channels, dimensions);\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(this._transform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .call(\n            rx1y1 || rx1y2 || rx2y1 || rx2y2\n              ? (g) =>\n                  g\n                    .append(\"path\")\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n                    .call(_rect_js__WEBPACK_IMPORTED_MODULE_1__.applyRoundedRect, x, y, add(x, w), add(y, h), this)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n              : (g) =>\n                  g\n                    .append(\"rect\")\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n                    .attr(\"x\", x)\n                    .attr(\"width\", w)\n                    .attr(\"y\", y)\n                    .attr(\"height\", h)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyAttr, \"rx\", rx)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyAttr, \"ry\", ry)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n          )\n      )\n      .node();\n  }\n  _x(scales, {x: X}, {marginLeft}) {\n    const {insetLeft} = this;\n    return X ? (i) => X[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _y(scales, {y: Y}, {marginTop}) {\n    const {insetTop} = this;\n    return Y ? (i) => Y[i] + insetTop : marginTop + insetTop;\n  }\n  _width({x}, {x: X}, {marginRight, marginLeft, width}) {\n    const {insetLeft, insetRight} = this;\n    const bandwidth = X && x ? x.bandwidth() : width - marginRight - marginLeft;\n    return Math.max(0, bandwidth - insetLeft - insetRight);\n  }\n  _height({y}, {y: Y}, {marginTop, marginBottom, height}) {\n    const {insetTop, insetBottom} = this;\n    const bandwidth = Y && y ? y.bandwidth() : height - marginTop - marginBottom;\n    return Math.max(0, bandwidth - insetTop - insetBottom);\n  }\n}\n\nfunction add(a, b) {\n  return typeof a === \"function\" && typeof b === \"function\"\n    ? (i) => a(i) + b(i)\n    : typeof a === \"function\"\n    ? (i) => a(i) + b\n    : typeof b === \"function\"\n    ? (i) => a + b(i)\n    : a + b;\n}\n\nclass BarX extends AbstractBar {\n  constructor(data, options = {}, defaults) {\n    const {x1, x2, y} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        x2: {value: x2, scale: \"x\"},\n        y: {value: y, scale: \"y\", type: \"band\", optional: true}\n      },\n      options,\n      defaults\n    );\n  }\n  _transform(selection, mark, {x}) {\n    selection.call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, mark, {x}, 0, 0);\n  }\n  _x({x}, {x1: X1, x2: X2}, {marginLeft}) {\n    const {insetLeft} = this;\n    return (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.isCollapsed)(x) ? marginLeft + insetLeft : (i) => Math.min(X1[i], X2[i]) + insetLeft;\n  }\n  _width({x}, {x1: X1, x2: X2}, {marginRight, marginLeft, width}) {\n    const {insetLeft, insetRight} = this;\n    return (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.isCollapsed)(x)\n      ? width - marginRight - marginLeft - insetLeft - insetRight\n      : (i) => Math.max(0, Math.abs(X2[i] - X1[i]) - insetLeft - insetRight);\n  }\n}\n\nclass BarY extends AbstractBar {\n  constructor(data, options = {}, defaults) {\n    const {x, y1, y2} = options;\n    super(\n      data,\n      {\n        y1: {value: y1, scale: \"y\"},\n        y2: {value: y2, scale: \"y\"},\n        x: {value: x, scale: \"x\", type: \"band\", optional: true}\n      },\n      options,\n      defaults\n    );\n  }\n  _transform(selection, mark, {y}) {\n    selection.call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, mark, {y}, 0, 0);\n  }\n  _y({y}, {y1: Y1, y2: Y2}, {marginTop}) {\n    const {insetTop} = this;\n    return (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.isCollapsed)(y) ? marginTop + insetTop : (i) => Math.min(Y1[i], Y2[i]) + insetTop;\n  }\n  _height({y}, {y1: Y1, y2: Y2}, {marginTop, marginBottom, height}) {\n    const {insetTop, insetBottom} = this;\n    return (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.isCollapsed)(y)\n      ? height - marginTop - marginBottom - insetTop - insetBottom\n      : (i) => Math.max(0, Math.abs(Y2[i] - Y1[i]) - insetTop - insetBottom);\n  }\n}\n\nfunction barX(data, options = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_5__.hasXY)(options)) options = {...options, y: _options_js__WEBPACK_IMPORTED_MODULE_5__.indexOf, x2: _options_js__WEBPACK_IMPORTED_MODULE_5__.identity};\n  return new BarX(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__.maybeStackX)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_7__.maybeIntervalX)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__.maybeIdentityX)(options))));\n}\n\nfunction barY(data, options = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_5__.hasXY)(options)) options = {...options, x: _options_js__WEBPACK_IMPORTED_MODULE_5__.indexOf, y2: _options_js__WEBPACK_IMPORTED_MODULE_5__.identity};\n  return new BarY(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__.maybeStackY)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_7__.maybeIntervalY)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_8__.maybeIdentityY)(options))));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9iYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDTDtBQUN1QjtBQUNkO0FBQ3lFO0FBQ3pDO0FBQ0E7QUFDVDtBQUNFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRU8sMEJBQTBCLDBDQUFJO0FBQ3JDLDBDQUEwQztBQUMxQztBQUNBLElBQUksb0RBQVU7QUFDZCxJQUFJLG1EQUFTO0FBQ2I7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFpQjtBQUMzQywwQkFBMEIsc0RBQWdCO0FBQzFDLDBCQUEwQix5REFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBUztBQUNuQywwQkFBMEIsZ0RBQVM7QUFDbkMsMEJBQTBCLHlEQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxHQUFHLFdBQVc7QUFDakMsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLEtBQUssR0FBRyxVQUFVO0FBQ2hDLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsVUFBVSxFQUFFLEdBQUcsS0FBSyxHQUFHLCtCQUErQjtBQUN0RCxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUUsR0FBRyxLQUFLLEdBQUcsZ0NBQWdDO0FBQ3hELFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGdDQUFnQztBQUNoQyxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsWUFBWTtBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDLG1CQUFtQixxREFBYyxTQUFTLEVBQUU7QUFDNUM7QUFDQSxNQUFNLEVBQUUsR0FBRyxlQUFlLEdBQUcsV0FBVztBQUN4QyxXQUFXLFdBQVc7QUFDdEIsV0FBVyx1REFBVztBQUN0QjtBQUNBLFVBQVUsRUFBRSxHQUFHLGVBQWUsR0FBRywrQkFBK0I7QUFDaEUsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx1REFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGdDQUFnQztBQUNoQyxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxzQkFBc0I7QUFDbkMsWUFBWTtBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDLG1CQUFtQixxREFBYyxTQUFTLEVBQUU7QUFDNUM7QUFDQSxNQUFNLEVBQUUsR0FBRyxlQUFlLEdBQUcsVUFBVTtBQUN2QyxXQUFXLFVBQVU7QUFDckIsV0FBVyx1REFBVztBQUN0QjtBQUNBLFdBQVcsRUFBRSxHQUFHLGVBQWUsR0FBRyxnQ0FBZ0M7QUFDbEUsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx1REFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxnQ0FBZ0M7QUFDdkMsT0FBTyxrREFBSyxzQkFBc0IsZUFBZSxnREFBTyxNQUFNLGlEQUFRO0FBQ3RFLHdCQUF3QixpRUFBVyxDQUFDLHVFQUFjLENBQUMsdUVBQWM7QUFDakU7O0FBRU8sZ0NBQWdDO0FBQ3ZDLE9BQU8sa0RBQUssc0JBQXNCLGVBQWUsZ0RBQU8sTUFBTSxpREFBUTtBQUN0RSx3QkFBd0IsaUVBQVcsQ0FBQyx1RUFBYyxDQUFDLHVFQUFjO0FBQ2pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9iYXIuanM/YTFjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7aGFzWFksIGlkZW50aXR5LCBpbmRleE9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtpc0NvbGxhcHNlZH0gZnJvbSBcIi4uL3NjYWxlcy5qc1wiO1xuaW1wb3J0IHthcHBseUF0dHIsIGFwcGx5Q2hhbm5lbFN0eWxlcywgYXBwbHlEaXJlY3RTdHlsZXMsIGFwcGx5SW5kaXJlY3RTdHlsZXMsIGFwcGx5VHJhbnNmb3JtfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7bWF5YmVJZGVudGl0eVgsIG1heWJlSWRlbnRpdHlZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHttYXliZUludGVydmFsWCwgbWF5YmVJbnRlcnZhbFl9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge21heWJlU3RhY2tYLCBtYXliZVN0YWNrWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvc3RhY2suanNcIjtcbmltcG9ydCB7YXBwbHlSb3VuZGVkUmVjdCwgcmVjdEluc2V0cywgcmVjdFJhZGlpfSBmcm9tIFwiLi9yZWN0LmpzXCI7XG5cbmNvbnN0IGJhckRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiYmFyXCJcbn07XG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdEJhciBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBjaGFubmVscywgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cyA9IGJhckRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGF0YSwgY2hhbm5lbHMsIG9wdGlvbnMsIGRlZmF1bHRzKTtcbiAgICByZWN0SW5zZXRzKHRoaXMsIG9wdGlvbnMpO1xuICAgIHJlY3RSYWRpaSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7cngsIHJ5LCByeDF5MSwgcngxeTIsIHJ4MnkxLCByeDJ5Mn0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSB0aGlzLl94KHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IHkgPSB0aGlzLl95KHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IHcgPSB0aGlzLl93aWR0aChzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zKTtcbiAgICBjb25zdCBoID0gdGhpcy5faGVpZ2h0KHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMpO1xuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKHRoaXMuX3RyYW5zZm9ybSwgdGhpcywgc2NhbGVzKVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAuZGF0YShpbmRleClcbiAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5jYWxsKFxuICAgICAgICAgICAgcngxeTEgfHwgcngxeTIgfHwgcngyeTEgfHwgcngyeTJcbiAgICAgICAgICAgICAgPyAoZykgPT5cbiAgICAgICAgICAgICAgICAgIGdcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5Um91bmRlZFJlY3QsIHgsIHksIGFkZCh4LCB3KSwgYWRkKHksIGgpLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgICAgICAgICA6IChnKSA9PlxuICAgICAgICAgICAgICAgICAgZ1xuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgdylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGgpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5QXR0ciwgXCJyeFwiLCByeClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXBwbHlBdHRyLCBcInJ5XCIsIHJ5KVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgICAgIClcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbiAgX3goc2NhbGVzLCB7eDogWH0sIHttYXJnaW5MZWZ0fSkge1xuICAgIGNvbnN0IHtpbnNldExlZnR9ID0gdGhpcztcbiAgICByZXR1cm4gWCA/IChpKSA9PiBYW2ldICsgaW5zZXRMZWZ0IDogbWFyZ2luTGVmdCArIGluc2V0TGVmdDtcbiAgfVxuICBfeShzY2FsZXMsIHt5OiBZfSwge21hcmdpblRvcH0pIHtcbiAgICBjb25zdCB7aW5zZXRUb3B9ID0gdGhpcztcbiAgICByZXR1cm4gWSA/IChpKSA9PiBZW2ldICsgaW5zZXRUb3AgOiBtYXJnaW5Ub3AgKyBpbnNldFRvcDtcbiAgfVxuICBfd2lkdGgoe3h9LCB7eDogWH0sIHttYXJnaW5SaWdodCwgbWFyZ2luTGVmdCwgd2lkdGh9KSB7XG4gICAgY29uc3Qge2luc2V0TGVmdCwgaW5zZXRSaWdodH0gPSB0aGlzO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IFggJiYgeCA/IHguYmFuZHdpZHRoKCkgOiB3aWR0aCAtIG1hcmdpblJpZ2h0IC0gbWFyZ2luTGVmdDtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgYmFuZHdpZHRoIC0gaW5zZXRMZWZ0IC0gaW5zZXRSaWdodCk7XG4gIH1cbiAgX2hlaWdodCh7eX0sIHt5OiBZfSwge21hcmdpblRvcCwgbWFyZ2luQm90dG9tLCBoZWlnaHR9KSB7XG4gICAgY29uc3Qge2luc2V0VG9wLCBpbnNldEJvdHRvbX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IFkgJiYgeSA/IHkuYmFuZHdpZHRoKCkgOiBoZWlnaHQgLSBtYXJnaW5Ub3AgLSBtYXJnaW5Cb3R0b207XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGJhbmR3aWR0aCAtIGluc2V0VG9wIC0gaW5zZXRCb3R0b20pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IChpKSA9PiBhKGkpICsgYihpKVxuICAgIDogdHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIlxuICAgID8gKGkpID0+IGEoaSkgKyBiXG4gICAgOiB0eXBlb2YgYiA9PT0gXCJmdW5jdGlvblwiXG4gICAgPyAoaSkgPT4gYSArIGIoaSlcbiAgICA6IGEgKyBiO1xufVxuXG5leHBvcnQgY2xhc3MgQmFyWCBleHRlbmRzIEFic3RyYWN0QmFyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHt4MSwgeDIsIHl9ID0gb3B0aW9ucztcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHgxOiB7dmFsdWU6IHgxLCBzY2FsZTogXCJ4XCJ9LFxuICAgICAgICB4Mjoge3ZhbHVlOiB4Miwgc2NhbGU6IFwieFwifSxcbiAgICAgICAgeToge3ZhbHVlOiB5LCBzY2FsZTogXCJ5XCIsIHR5cGU6IFwiYmFuZFwiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICB9XG4gIF90cmFuc2Zvcm0oc2VsZWN0aW9uLCBtYXJrLCB7eH0pIHtcbiAgICBzZWxlY3Rpb24uY2FsbChhcHBseVRyYW5zZm9ybSwgbWFyaywge3h9LCAwLCAwKTtcbiAgfVxuICBfeCh7eH0sIHt4MTogWDEsIHgyOiBYMn0sIHttYXJnaW5MZWZ0fSkge1xuICAgIGNvbnN0IHtpbnNldExlZnR9ID0gdGhpcztcbiAgICByZXR1cm4gaXNDb2xsYXBzZWQoeCkgPyBtYXJnaW5MZWZ0ICsgaW5zZXRMZWZ0IDogKGkpID0+IE1hdGgubWluKFgxW2ldLCBYMltpXSkgKyBpbnNldExlZnQ7XG4gIH1cbiAgX3dpZHRoKHt4fSwge3gxOiBYMSwgeDI6IFgyfSwge21hcmdpblJpZ2h0LCBtYXJnaW5MZWZ0LCB3aWR0aH0pIHtcbiAgICBjb25zdCB7aW5zZXRMZWZ0LCBpbnNldFJpZ2h0fSA9IHRoaXM7XG4gICAgcmV0dXJuIGlzQ29sbGFwc2VkKHgpXG4gICAgICA/IHdpZHRoIC0gbWFyZ2luUmlnaHQgLSBtYXJnaW5MZWZ0IC0gaW5zZXRMZWZ0IC0gaW5zZXRSaWdodFxuICAgICAgOiAoaSkgPT4gTWF0aC5tYXgoMCwgTWF0aC5hYnMoWDJbaV0gLSBYMVtpXSkgLSBpbnNldExlZnQgLSBpbnNldFJpZ2h0KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFyWSBleHRlbmRzIEFic3RyYWN0QmFyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHt4LCB5MSwgeTJ9ID0gb3B0aW9ucztcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHkxOiB7dmFsdWU6IHkxLCBzY2FsZTogXCJ5XCJ9LFxuICAgICAgICB5Mjoge3ZhbHVlOiB5Miwgc2NhbGU6IFwieVwifSxcbiAgICAgICAgeDoge3ZhbHVlOiB4LCBzY2FsZTogXCJ4XCIsIHR5cGU6IFwiYmFuZFwiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICB9XG4gIF90cmFuc2Zvcm0oc2VsZWN0aW9uLCBtYXJrLCB7eX0pIHtcbiAgICBzZWxlY3Rpb24uY2FsbChhcHBseVRyYW5zZm9ybSwgbWFyaywge3l9LCAwLCAwKTtcbiAgfVxuICBfeSh7eX0sIHt5MTogWTEsIHkyOiBZMn0sIHttYXJnaW5Ub3B9KSB7XG4gICAgY29uc3Qge2luc2V0VG9wfSA9IHRoaXM7XG4gICAgcmV0dXJuIGlzQ29sbGFwc2VkKHkpID8gbWFyZ2luVG9wICsgaW5zZXRUb3AgOiAoaSkgPT4gTWF0aC5taW4oWTFbaV0sIFkyW2ldKSArIGluc2V0VG9wO1xuICB9XG4gIF9oZWlnaHQoe3l9LCB7eTE6IFkxLCB5MjogWTJ9LCB7bWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIGhlaWdodH0pIHtcbiAgICBjb25zdCB7aW5zZXRUb3AsIGluc2V0Qm90dG9tfSA9IHRoaXM7XG4gICAgcmV0dXJuIGlzQ29sbGFwc2VkKHkpXG4gICAgICA/IGhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbSAtIGluc2V0VG9wIC0gaW5zZXRCb3R0b21cbiAgICAgIDogKGkpID0+IE1hdGgubWF4KDAsIE1hdGguYWJzKFkyW2ldIC0gWTFbaV0pIC0gaW5zZXRUb3AgLSBpbnNldEJvdHRvbSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhclgoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghaGFzWFkob3B0aW9ucykpIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgeTogaW5kZXhPZiwgeDI6IGlkZW50aXR5fTtcbiAgcmV0dXJuIG5ldyBCYXJYKGRhdGEsIG1heWJlU3RhY2tYKG1heWJlSW50ZXJ2YWxYKG1heWJlSWRlbnRpdHlYKG9wdGlvbnMpKSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFyWShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFoYXNYWShvcHRpb25zKSkgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCB4OiBpbmRleE9mLCB5MjogaWRlbnRpdHl9O1xuICByZXR1cm4gbmV3IEJhclkoZGF0YSwgbWF5YmVTdGFja1kobWF5YmVJbnRlcnZhbFkobWF5YmVJZGVudGl0eVkob3B0aW9ucykpKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/bollinger.js":
/*!****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/bollinger.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bollinger: () => (/* binding */ bollinger),\n/* harmony export */   bollingerX: () => (/* binding */ bollingerX),\n/* harmony export */   bollingerY: () => (/* binding */ bollingerY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _transforms_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transforms/map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n/* harmony import */ var _transforms_window_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/window.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/window.js\");\n/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./area.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/area.js\");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/line.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  n: 20,\n  k: 2,\n  color: \"currentColor\",\n  opacity: 0.2,\n  strict: true,\n  anchor: \"end\"\n};\n\nfunction bollingerX(\n  data,\n  {\n    x = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    y,\n    k = defaults.k,\n    color = defaults.color,\n    opacity = defaults.opacity,\n    fill = color,\n    fillOpacity = opacity,\n    stroke = color,\n    strokeOpacity,\n    strokeWidth,\n    ...options\n  } = {}\n) {\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.marks)(\n    (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill)\n      ? null\n      : (0,_area_js__WEBPACK_IMPORTED_MODULE_3__.areaX)(\n          data,\n          (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_4__.map)(\n            {x1: bollinger({k: -k, ...options}), x2: bollinger({k, ...options})},\n            {x1: x, x2: x, y, fill, fillOpacity, ...options}\n          )\n        ),\n    (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(stroke)\n      ? null\n      : (0,_line_js__WEBPACK_IMPORTED_MODULE_5__.lineX)(data, (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_4__.map)({x: bollinger(options)}, {x, y, stroke, strokeOpacity, strokeWidth, ...options}))\n  );\n}\n\nfunction bollingerY(\n  data,\n  {\n    x,\n    y = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    k = defaults.k,\n    color = defaults.color,\n    opacity = defaults.opacity,\n    fill = color,\n    fillOpacity = opacity,\n    stroke = color,\n    strokeOpacity,\n    strokeWidth,\n    ...options\n  } = {}\n) {\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.marks)(\n    (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill)\n      ? null\n      : (0,_area_js__WEBPACK_IMPORTED_MODULE_3__.areaY)(\n          data,\n          (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_4__.map)(\n            {y1: bollinger({k: -k, ...options}), y2: bollinger({k, ...options})},\n            {x, y1: y, y2: y, fill, fillOpacity, ...options}\n          )\n        ),\n    (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(stroke)\n      ? null\n      : (0,_line_js__WEBPACK_IMPORTED_MODULE_5__.lineY)(data, (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_4__.map)({y: bollinger(options)}, {x, y, stroke, strokeOpacity, strokeWidth, ...options}))\n  );\n}\n\nfunction bollinger({n = defaults.n, k = 0, strict = defaults.strict, anchor = defaults.anchor} = {}) {\n  return (0,_transforms_window_js__WEBPACK_IMPORTED_MODULE_6__.window)({k: n, reduce: (Y) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.mean)(Y) + k * ((0,d3__WEBPACK_IMPORTED_MODULE_0__.deviation)(Y) || 0), strict, anchor});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9ib2xsaW5nZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNGO0FBQ2lCO0FBQ1Q7QUFDTTtBQUNSO0FBQ0E7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsUUFBUSxpREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsK0NBQUs7QUFDZCxJQUFJLHNEQUFTO0FBQ2I7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQSxVQUFVLHVEQUFHO0FBQ2IsYUFBYSxlQUFlLGtCQUFrQixrQkFBa0IsY0FBYyxFQUFFO0FBQ2hGLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxzREFBUztBQUNiO0FBQ0EsUUFBUSwrQ0FBSyxPQUFPLHVEQUFHLEVBQUUsc0JBQXNCLEdBQUcscURBQXFEO0FBQ3ZHO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsK0NBQUs7QUFDZCxJQUFJLHNEQUFTO0FBQ2I7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQSxVQUFVLHVEQUFHO0FBQ2IsYUFBYSxlQUFlLGtCQUFrQixrQkFBa0IsY0FBYyxFQUFFO0FBQ2hGLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxzREFBUztBQUNiO0FBQ0EsUUFBUSwrQ0FBSyxPQUFPLHVEQUFHLEVBQUUsc0JBQXNCLEdBQUcscURBQXFEO0FBQ3ZHO0FBQ0E7O0FBRU8sb0JBQW9CLDJFQUEyRSxJQUFJO0FBQzFHLFNBQVMsNkRBQU0sRUFBRSxxQkFBcUIsd0NBQUksV0FBVyw2Q0FBUywwQkFBMEI7QUFDeEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2JvbGxpbmdlci5qcz9iOTM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZGV2aWF0aW9uLCBtZWFufSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7bWFya3N9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2lkZW50aXR5LCBpc05vbmVpc2h9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvbWFwLmpzXCI7XG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uL3RyYW5zZm9ybXMvd2luZG93LmpzXCI7XG5pbXBvcnQge2FyZWFYLCBhcmVhWX0gZnJvbSBcIi4vYXJlYS5qc1wiO1xuaW1wb3J0IHtsaW5lWCwgbGluZVl9IGZyb20gXCIuL2xpbmUuanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIG46IDIwLFxuICBrOiAyLFxuICBjb2xvcjogXCJjdXJyZW50Q29sb3JcIixcbiAgb3BhY2l0eTogMC4yLFxuICBzdHJpY3Q6IHRydWUsXG4gIGFuY2hvcjogXCJlbmRcIlxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJvbGxpbmdlclgoXG4gIGRhdGEsXG4gIHtcbiAgICB4ID0gaWRlbnRpdHksXG4gICAgeSxcbiAgICBrID0gZGVmYXVsdHMuayxcbiAgICBjb2xvciA9IGRlZmF1bHRzLmNvbG9yLFxuICAgIG9wYWNpdHkgPSBkZWZhdWx0cy5vcGFjaXR5LFxuICAgIGZpbGwgPSBjb2xvcixcbiAgICBmaWxsT3BhY2l0eSA9IG9wYWNpdHksXG4gICAgc3Ryb2tlID0gY29sb3IsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBzdHJva2VXaWR0aCxcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fVxuKSB7XG4gIHJldHVybiBtYXJrcyhcbiAgICBpc05vbmVpc2goZmlsbClcbiAgICAgID8gbnVsbFxuICAgICAgOiBhcmVhWChcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIG1hcChcbiAgICAgICAgICAgIHt4MTogYm9sbGluZ2VyKHtrOiAtaywgLi4ub3B0aW9uc30pLCB4MjogYm9sbGluZ2VyKHtrLCAuLi5vcHRpb25zfSl9LFxuICAgICAgICAgICAge3gxOiB4LCB4MjogeCwgeSwgZmlsbCwgZmlsbE9wYWNpdHksIC4uLm9wdGlvbnN9XG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgIGlzTm9uZWlzaChzdHJva2UpXG4gICAgICA/IG51bGxcbiAgICAgIDogbGluZVgoZGF0YSwgbWFwKHt4OiBib2xsaW5nZXIob3B0aW9ucyl9LCB7eCwgeSwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgLi4ub3B0aW9uc30pKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9sbGluZ2VyWShcbiAgZGF0YSxcbiAge1xuICAgIHgsXG4gICAgeSA9IGlkZW50aXR5LFxuICAgIGsgPSBkZWZhdWx0cy5rLFxuICAgIGNvbG9yID0gZGVmYXVsdHMuY29sb3IsXG4gICAgb3BhY2l0eSA9IGRlZmF1bHRzLm9wYWNpdHksXG4gICAgZmlsbCA9IGNvbG9yLFxuICAgIGZpbGxPcGFjaXR5ID0gb3BhY2l0eSxcbiAgICBzdHJva2UgPSBjb2xvcixcbiAgICBzdHJva2VPcGFjaXR5LFxuICAgIHN0cm9rZVdpZHRoLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHt9XG4pIHtcbiAgcmV0dXJuIG1hcmtzKFxuICAgIGlzTm9uZWlzaChmaWxsKVxuICAgICAgPyBudWxsXG4gICAgICA6IGFyZWFZKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgbWFwKFxuICAgICAgICAgICAge3kxOiBib2xsaW5nZXIoe2s6IC1rLCAuLi5vcHRpb25zfSksIHkyOiBib2xsaW5nZXIoe2ssIC4uLm9wdGlvbnN9KX0sXG4gICAgICAgICAgICB7eCwgeTE6IHksIHkyOiB5LCBmaWxsLCBmaWxsT3BhY2l0eSwgLi4ub3B0aW9uc31cbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgaXNOb25laXNoKHN0cm9rZSlcbiAgICAgID8gbnVsbFxuICAgICAgOiBsaW5lWShkYXRhLCBtYXAoe3k6IGJvbGxpbmdlcihvcHRpb25zKX0sIHt4LCB5LCBzdHJva2UsIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoLCAuLi5vcHRpb25zfSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib2xsaW5nZXIoe24gPSBkZWZhdWx0cy5uLCBrID0gMCwgc3RyaWN0ID0gZGVmYXVsdHMuc3RyaWN0LCBhbmNob3IgPSBkZWZhdWx0cy5hbmNob3J9ID0ge30pIHtcbiAgcmV0dXJuIHdpbmRvdyh7azogbiwgcmVkdWNlOiAoWSkgPT4gbWVhbihZKSArIGsgKiAoZGV2aWF0aW9uKFkpIHx8IDApLCBzdHJpY3QsIGFuY2hvcn0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/bollinger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/box.js":
/*!**********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/box.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boxX: () => (/* binding */ boxX),\n/* harmony export */   boxY: () => (/* binding */ boxY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _transforms_group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transforms/group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n/* harmony import */ var _transforms_map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transforms/map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bar.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rule.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\");\n/* harmony import */ var _tick_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tick.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/tick.js\");\n\n\n\n\n\n\n\n\n\n\n// Returns a composite mark for producing a horizontal box plot, applying the\n// necessary statistical transforms. The boxes are grouped by y, if present.\nfunction boxX(\n  data,\n  {\n    x = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    y = null,\n    r,\n    fill = \"#ccc\",\n    fillOpacity,\n    stroke = \"currentColor\",\n    strokeOpacity,\n    strokeWidth = 2,\n    sort,\n    ...options\n  } = {}\n) {\n  const group = y != null ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_2__.groupY : _transforms_group_js__WEBPACK_IMPORTED_MODULE_2__.groupZ;\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_3__.marks)(\n    (0,_rule_js__WEBPACK_IMPORTED_MODULE_4__.ruleY)(data, group({x1: loqr1, x2: hiqr2}, {x, y, stroke, strokeOpacity, ...options})),\n    (0,_bar_js__WEBPACK_IMPORTED_MODULE_5__.barX)(data, group({x1: \"p25\", x2: \"p75\"}, {x, y, fill, fillOpacity, ...options})),\n    (0,_tick_js__WEBPACK_IMPORTED_MODULE_6__.tickX)(data, group({x: \"p50\"}, {x, y, stroke, strokeOpacity, strokeWidth, sort, ...options})),\n    (0,_dot_js__WEBPACK_IMPORTED_MODULE_7__.dot)(data, (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_8__.map)({x: oqr}, {x, y, z: y, r, stroke, strokeOpacity, ...options}))\n  );\n}\n\n// Returns a composite mark for producing a vertical box plot, applying the\n// necessary statistical transforms. The boxes are grouped by x, if present.\nfunction boxY(\n  data,\n  {\n    y = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    x = null,\n    r,\n    fill = \"#ccc\",\n    fillOpacity,\n    stroke = \"currentColor\",\n    strokeOpacity,\n    strokeWidth = 2,\n    sort,\n    ...options\n  } = {}\n) {\n  const group = x != null ? _transforms_group_js__WEBPACK_IMPORTED_MODULE_2__.groupX : _transforms_group_js__WEBPACK_IMPORTED_MODULE_2__.groupZ;\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_3__.marks)(\n    (0,_rule_js__WEBPACK_IMPORTED_MODULE_4__.ruleX)(data, group({y1: loqr1, y2: hiqr2}, {x, y, stroke, strokeOpacity, ...options})),\n    (0,_bar_js__WEBPACK_IMPORTED_MODULE_5__.barY)(data, group({y1: \"p25\", y2: \"p75\"}, {x, y, fill, fillOpacity, ...options})),\n    (0,_tick_js__WEBPACK_IMPORTED_MODULE_6__.tickY)(data, group({y: \"p50\"}, {x, y, stroke, strokeOpacity, strokeWidth, sort, ...options})),\n    (0,_dot_js__WEBPACK_IMPORTED_MODULE_7__.dot)(data, (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_8__.map)({y: oqr}, {x, y, z: x, r, stroke, strokeOpacity, ...options}))\n  );\n}\n\n// A map function that returns only outliers, returning NaN for non-outliers\nfunction oqr(values) {\n  const r1 = loqr1(values);\n  const r2 = hiqr2(values);\n  return values.map((v) => (v < r1 || v > r2 ? v : NaN));\n}\n\nfunction loqr1(values) {\n  const lo = quartile1(values) * 2.5 - quartile3(values) * 1.5;\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(values, (d) => (d >= lo ? d : NaN));\n}\n\nfunction hiqr2(values) {\n  const hi = quartile3(values) * 2.5 - quartile1(values) * 1.5;\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(values, (d) => (d <= hi ? d : NaN));\n}\n\nfunction quartile1(values) {\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantile)(values, 0.25);\n}\n\nfunction quartile3(values) {\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantile)(values, 0.75);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9ib3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDTDtBQUNNO0FBQ3VCO0FBQ3JCO0FBQ0w7QUFDUDtBQUNVO0FBQ0E7O0FBRXZDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0Qix3REFBTSxHQUFHLHdEQUFNO0FBQzNDLFNBQVMsK0NBQUs7QUFDZCxJQUFJLCtDQUFLLGNBQWMscUJBQXFCLEdBQUcsd0NBQXdDO0FBQ3ZGLElBQUksNkNBQUksY0FBYyxxQkFBcUIsR0FBRyxvQ0FBb0M7QUFDbEYsSUFBSSwrQ0FBSyxjQUFjLFNBQVMsR0FBRywyREFBMkQ7QUFDOUYsSUFBSSw0Q0FBRyxPQUFPLHVEQUFHLEVBQUUsT0FBTyxHQUFHLGlEQUFpRDtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0Qix3REFBTSxHQUFHLHdEQUFNO0FBQzNDLFNBQVMsK0NBQUs7QUFDZCxJQUFJLCtDQUFLLGNBQWMscUJBQXFCLEdBQUcsd0NBQXdDO0FBQ3ZGLElBQUksNkNBQUksY0FBYyxxQkFBcUIsR0FBRyxvQ0FBb0M7QUFDbEYsSUFBSSwrQ0FBSyxjQUFjLFNBQVMsR0FBRywyREFBMkQ7QUFDOUYsSUFBSSw0Q0FBRyxPQUFPLHVEQUFHLEVBQUUsT0FBTyxHQUFHLGlEQUFpRDtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBRztBQUNaOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHVDQUFHO0FBQ1o7O0FBRUE7QUFDQSxTQUFTLDRDQUFRO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUyw0Q0FBUTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvYm94LmpzP2RlYjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHttYXgsIG1pbiwgcXVhbnRpbGV9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHttYXJrc30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7aWRlbnRpdHl9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2dyb3VwWCwgZ3JvdXBZLCBncm91cFp9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2dyb3VwLmpzXCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvbWFwLmpzXCI7XG5pbXBvcnQge2JhclgsIGJhcll9IGZyb20gXCIuL2Jhci5qc1wiO1xuaW1wb3J0IHtkb3R9IGZyb20gXCIuL2RvdC5qc1wiO1xuaW1wb3J0IHtydWxlWCwgcnVsZVl9IGZyb20gXCIuL3J1bGUuanNcIjtcbmltcG9ydCB7dGlja1gsIHRpY2tZfSBmcm9tIFwiLi90aWNrLmpzXCI7XG5cbi8vIFJldHVybnMgYSBjb21wb3NpdGUgbWFyayBmb3IgcHJvZHVjaW5nIGEgaG9yaXpvbnRhbCBib3ggcGxvdCwgYXBwbHlpbmcgdGhlXG4vLyBuZWNlc3Nhcnkgc3RhdGlzdGljYWwgdHJhbnNmb3Jtcy4gVGhlIGJveGVzIGFyZSBncm91cGVkIGJ5IHksIGlmIHByZXNlbnQuXG5leHBvcnQgZnVuY3Rpb24gYm94WChcbiAgZGF0YSxcbiAge1xuICAgIHggPSBpZGVudGl0eSxcbiAgICB5ID0gbnVsbCxcbiAgICByLFxuICAgIGZpbGwgPSBcIiNjY2NcIixcbiAgICBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2UgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZU9wYWNpdHksXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIHNvcnQsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge31cbikge1xuICBjb25zdCBncm91cCA9IHkgIT0gbnVsbCA/IGdyb3VwWSA6IGdyb3VwWjtcbiAgcmV0dXJuIG1hcmtzKFxuICAgIHJ1bGVZKGRhdGEsIGdyb3VwKHt4MTogbG9xcjEsIHgyOiBoaXFyMn0sIHt4LCB5LCBzdHJva2UsIHN0cm9rZU9wYWNpdHksIC4uLm9wdGlvbnN9KSksXG4gICAgYmFyWChkYXRhLCBncm91cCh7eDE6IFwicDI1XCIsIHgyOiBcInA3NVwifSwge3gsIHksIGZpbGwsIGZpbGxPcGFjaXR5LCAuLi5vcHRpb25zfSkpLFxuICAgIHRpY2tYKGRhdGEsIGdyb3VwKHt4OiBcInA1MFwifSwge3gsIHksIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGgsIHNvcnQsIC4uLm9wdGlvbnN9KSksXG4gICAgZG90KGRhdGEsIG1hcCh7eDogb3FyfSwge3gsIHksIHo6IHksIHIsIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgLi4ub3B0aW9uc30pKVxuICApO1xufVxuXG4vLyBSZXR1cm5zIGEgY29tcG9zaXRlIG1hcmsgZm9yIHByb2R1Y2luZyBhIHZlcnRpY2FsIGJveCBwbG90LCBhcHBseWluZyB0aGVcbi8vIG5lY2Vzc2FyeSBzdGF0aXN0aWNhbCB0cmFuc2Zvcm1zLiBUaGUgYm94ZXMgYXJlIGdyb3VwZWQgYnkgeCwgaWYgcHJlc2VudC5cbmV4cG9ydCBmdW5jdGlvbiBib3hZKFxuICBkYXRhLFxuICB7XG4gICAgeSA9IGlkZW50aXR5LFxuICAgIHggPSBudWxsLFxuICAgIHIsXG4gICAgZmlsbCA9IFwiI2NjY1wiLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZSA9IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgc29ydCxcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGdyb3VwID0geCAhPSBudWxsID8gZ3JvdXBYIDogZ3JvdXBaO1xuICByZXR1cm4gbWFya3MoXG4gICAgcnVsZVgoZGF0YSwgZ3JvdXAoe3kxOiBsb3FyMSwgeTI6IGhpcXIyfSwge3gsIHksIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSwgLi4ub3B0aW9uc30pKSxcbiAgICBiYXJZKGRhdGEsIGdyb3VwKHt5MTogXCJwMjVcIiwgeTI6IFwicDc1XCJ9LCB7eCwgeSwgZmlsbCwgZmlsbE9wYWNpdHksIC4uLm9wdGlvbnN9KSksXG4gICAgdGlja1koZGF0YSwgZ3JvdXAoe3k6IFwicDUwXCJ9LCB7eCwgeSwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgc29ydCwgLi4ub3B0aW9uc30pKSxcbiAgICBkb3QoZGF0YSwgbWFwKHt5OiBvcXJ9LCB7eCwgeSwgejogeCwgciwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5LCAuLi5vcHRpb25zfSkpXG4gICk7XG59XG5cbi8vIEEgbWFwIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmx5IG91dGxpZXJzLCByZXR1cm5pbmcgTmFOIGZvciBub24tb3V0bGllcnNcbmZ1bmN0aW9uIG9xcih2YWx1ZXMpIHtcbiAgY29uc3QgcjEgPSBsb3FyMSh2YWx1ZXMpO1xuICBjb25zdCByMiA9IGhpcXIyKHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiAodiA8IHIxIHx8IHYgPiByMiA/IHYgOiBOYU4pKTtcbn1cblxuZnVuY3Rpb24gbG9xcjEodmFsdWVzKSB7XG4gIGNvbnN0IGxvID0gcXVhcnRpbGUxKHZhbHVlcykgKiAyLjUgLSBxdWFydGlsZTModmFsdWVzKSAqIDEuNTtcbiAgcmV0dXJuIG1pbih2YWx1ZXMsIChkKSA9PiAoZCA+PSBsbyA/IGQgOiBOYU4pKTtcbn1cblxuZnVuY3Rpb24gaGlxcjIodmFsdWVzKSB7XG4gIGNvbnN0IGhpID0gcXVhcnRpbGUzKHZhbHVlcykgKiAyLjUgLSBxdWFydGlsZTEodmFsdWVzKSAqIDEuNTtcbiAgcmV0dXJuIG1heCh2YWx1ZXMsIChkKSA9PiAoZCA8PSBoaSA/IGQgOiBOYU4pKTtcbn1cblxuZnVuY3Rpb24gcXVhcnRpbGUxKHZhbHVlcykge1xuICByZXR1cm4gcXVhbnRpbGUodmFsdWVzLCAwLjI1KTtcbn1cblxuZnVuY3Rpb24gcXVhcnRpbGUzKHZhbHVlcykge1xuICByZXR1cm4gcXVhbnRpbGUodmFsdWVzLCAwLjc1KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/box.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/cell.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/cell.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ Cell),\n/* harmony export */   cell: () => (/* binding */ cell),\n/* harmony export */   cellX: () => (/* binding */ cellX),\n/* harmony export */   cellY: () => (/* binding */ cellY)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bar.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\");\n\n\n\n\nconst defaults = {\n  ariaLabel: \"cell\"\n};\n\nclass Cell extends _bar_js__WEBPACK_IMPORTED_MODULE_0__.AbstractBar {\n  constructor(data, {x, y, ...options} = {}) {\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", type: \"band\", optional: true},\n        y: {value: y, scale: \"y\", type: \"band\", optional: true}\n      },\n      options,\n      defaults\n    );\n  }\n  _transform(selection, mark) {\n    // apply dx, dy\n    selection.call(_style_js__WEBPACK_IMPORTED_MODULE_1__.applyTransform, mark, {}, 0, 0);\n  }\n}\n\nfunction cell(data, {x, y, ...options} = {}) {\n  [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Cell(data, {...options, x, y});\n}\n\nfunction cellX(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, fill, stroke, ...options} = {}) {\n  if (fill === undefined && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeColorChannel)(stroke)[0] === undefined) fill = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity;\n  return new Cell(data, {...options, x, fill, stroke});\n}\n\nfunction cellY(data, {y = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, fill, stroke, ...options} = {}) {\n  if (fill === undefined && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeColorChannel)(stroke)[0] === undefined) fill = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity;\n  return new Cell(data, {...options, y, fill, stroke});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9jZWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0U7QUFDcEM7QUFDTjs7QUFFckM7QUFDQTtBQUNBOztBQUVPLG1CQUFtQixnREFBVztBQUNyQyxxQkFBcUIsa0JBQWtCLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0QsWUFBWTtBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQWMsVUFBVTtBQUMzQztBQUNBOztBQUVPLHFCQUFxQixrQkFBa0IsSUFBSTtBQUNsRCxXQUFXLHVEQUFVO0FBQ3JCLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRU8sc0JBQXNCLElBQUksZ0RBQU8sNEJBQTRCLElBQUk7QUFDeEUsNEJBQTRCLDhEQUFpQixrQ0FBa0MsaURBQVE7QUFDdkYseUJBQXlCLDRCQUE0QjtBQUNyRDs7QUFFTyxzQkFBc0IsSUFBSSxnREFBTyw0QkFBNEIsSUFBSTtBQUN4RSw0QkFBNEIsOERBQWlCLGtDQUFrQyxpREFBUTtBQUN2Rix5QkFBeUIsNEJBQTRCO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9jZWxsLmpzPzliZGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpZGVudGl0eSwgaW5kZXhPZiwgbWF5YmVDb2xvckNoYW5uZWwsIG1heWJlVHVwbGV9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2FwcGx5VHJhbnNmb3JtfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7QWJzdHJhY3RCYXJ9IGZyb20gXCIuL2Jhci5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcImNlbGxcIlxufTtcblxuZXhwb3J0IGNsYXNzIENlbGwgZXh0ZW5kcyBBYnN0cmFjdEJhciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHt4LCB5LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgdHlwZTogXCJiYW5kXCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeToge3ZhbHVlOiB5LCBzY2FsZTogXCJ5XCIsIHR5cGU6IFwiYmFuZFwiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICB9XG4gIF90cmFuc2Zvcm0oc2VsZWN0aW9uLCBtYXJrKSB7XG4gICAgLy8gYXBwbHkgZHgsIGR5XG4gICAgc2VsZWN0aW9uLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIG1hcmssIHt9LCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2VsbChkYXRhLCB7eCwgeSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICByZXR1cm4gbmV3IENlbGwoZGF0YSwgey4uLm9wdGlvbnMsIHgsIHl9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNlbGxYKGRhdGEsIHt4ID0gaW5kZXhPZiwgZmlsbCwgc3Ryb2tlLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQgJiYgbWF5YmVDb2xvckNoYW5uZWwoc3Ryb2tlKVswXSA9PT0gdW5kZWZpbmVkKSBmaWxsID0gaWRlbnRpdHk7XG4gIHJldHVybiBuZXcgQ2VsbChkYXRhLCB7Li4ub3B0aW9ucywgeCwgZmlsbCwgc3Ryb2tlfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjZWxsWShkYXRhLCB7eSA9IGluZGV4T2YsIGZpbGwsIHN0cm9rZSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkICYmIG1heWJlQ29sb3JDaGFubmVsKHN0cm9rZSlbMF0gPT09IHVuZGVmaW5lZCkgZmlsbCA9IGlkZW50aXR5O1xuICByZXR1cm4gbmV3IENlbGwoZGF0YSwgey4uLm9wdGlvbnMsIHksIGZpbGwsIHN0cm9rZX0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/contour.js":
/*!**************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/contour.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Contour: () => (/* binding */ Contour),\n/* harmony export */   contour: () => (/* binding */ contour)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n/* harmony import */ var _raster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raster.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/raster.js\");\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\n\nclass Contour extends _raster_js__WEBPACK_IMPORTED_MODULE_1__.AbstractRaster {\n  constructor(data, {smooth = true, value, ...options} = {}) {\n    const channels = (0,_style_js__WEBPACK_IMPORTED_MODULE_2__.styles)({}, options, defaults);\n\n    // If value is not specified explicitly, look for a channel to promote. If\n    // more than one channel is present, throw an error. (To disambiguate,\n    // specify the value option explicitly.)\n    if (value === undefined) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== undefined) throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n\n    // For any channel specified as the literal (contour threshold) \"value\"\n    // (maybe because of the promotion above), propagate the label from the\n    // original value definition.\n    if (value != null) {\n      const v = {transform: (D) => D.map((d) => d.value), label: (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.labelof)(value)};\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v;\n        }\n      }\n    }\n\n    // If the data is null, then we’ll construct the raster grid by evaluating a\n    // function for each point in a dense grid. The value channel is populated\n    // by the sampler initializer, and hence is not passed to super to avoid\n    // computing it before there’s data.\n    if (data == null) {\n      if (value == null) throw new Error(\"missing contour value\");\n      options = (0,_raster_js__WEBPACK_IMPORTED_MODULE_1__.sampler)(\"value\", {value, ...options});\n      value = null;\n    }\n\n    // Otherwise if data was provided, it represents a discrete set of spatial\n    // samples (often a grid, but not necessarily). If no interpolation method\n    // was specified, default to nearest.\n    else {\n      let {interpolate} = options;\n      if (value === undefined) value = _options_js__WEBPACK_IMPORTED_MODULE_3__.identity;\n      if (interpolate === undefined) options.interpolate = \"nearest\";\n    }\n\n    // Wrap the options in our initializer that computes the contour geometries;\n    // this runs after any other initializers (and transforms).\n    super(data, {value: {value, optional: true}}, contourGeometry(options), defaults);\n\n    // With the exception of the x, y, x1, y1, x2, y2, and value channels, this\n    // mark’s channels are not evaluated on the initial data but rather on the\n    // contour multipolygons generated in the initializer.\n    const contourChannels = {geometry: {value: _options_js__WEBPACK_IMPORTED_MODULE_3__.identity}};\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const {scale} = channel;\n      if (scale === \"x\" || scale === \"y\" || key === \"value\") continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index, {x, y, value, ...channels}, values) {\n    // Only filter channels constructed by the contourGeometry initializer; the\n    // x, y, and value channels must be filtered by the initializer itself.\n    return super.filter(index, channels, values);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {geometry: G} = channels;\n    const path = (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoPath)();\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_2__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_2__.applyTransform, this, scales)\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_2__.applyDirectStyles, this)\n          .attr(\"d\", (i) => path(G[i]))\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_2__.applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\nfunction contourGeometry({thresholds, interval, ...options}) {\n  thresholds = (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_5__.maybeThresholds)(thresholds, interval, d3__WEBPACK_IMPORTED_MODULE_0__.thresholdSturges);\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_6__.initializer)(options, function (data, facets, channels, scales, dimensions, context) {\n    const [x1, y1, x2, y2] = (0,_raster_js__WEBPACK_IMPORTED_MODULE_1__.rasterBounds)(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = this;\n    const kx = w / dx;\n    const ky = h / dy;\n    const V = channels.value.value;\n    const VV = []; // V per facet\n\n    // Interpolate the raster grid, as needed.\n    if (this.interpolate) {\n      const {x: X, y: Y} = (0,_projection_js__WEBPACK_IMPORTED_MODULE_7__.applyPosition)(channels, scales, context);\n      // Convert scaled (screen) coordinates to grid (canvas) coordinates.\n      const IX = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.map)(X, (x) => (x - x1) * kx, Float64Array);\n      const IY = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.map)(Y, (y) => (y - y1) * ky, Float64Array);\n      // The contour mark normally skips filtering on x, y, and value, so here\n      // we’re careful to use different names (0, 1, 2) when filtering.\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index, w, h, IX, IY, V));\n      }\n    }\n\n    // Otherwise, chop up the existing dense raster grid into facets, if needed.\n    // V must be a dense grid in projected coordinates; if there are multiple\n    // facets, then V must be laid out vertically as facet 0, 1, 2… etc.\n    else if (facets) {\n      const n = w * h;\n      const m = facets.length;\n      for (let i = 0; i < m; ++i) VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n\n    // Blur the raster grid, if desired.\n    if (this.blur > 0) for (const V of VV) (0,d3__WEBPACK_IMPORTED_MODULE_0__.blur2)({data: V, width: w, height: h}, this.blur);\n\n    // Compute the contour thresholds.\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null) throw new Error(`unsupported thresholds: ${thresholds}`);\n\n    // Compute the (maybe faceted) contours.\n    const {contour} = (0,d3__WEBPACK_IMPORTED_MODULE_0__.contours)().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V of VV) {\n      contourFacets.push((0,d3__WEBPACK_IMPORTED_MODULE_0__.range)(contourData.length, contourData.push(...(0,_options_js__WEBPACK_IMPORTED_MODULE_3__.map)(T, (t) => contour(V, t)))));\n    }\n\n    // Rescale the contour multipolygon from grid to screen coordinates.\n    for (const {coordinates} of contourData) {\n      for (const rings of coordinates) {\n        for (const ring of rings) {\n          for (const point of ring) {\n            point[0] = point[0] / kx + x1;\n            point[1] = point[1] / ky + y1;\n          }\n        }\n      }\n    }\n\n    // Compute the deferred channels.\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: (0,_channel_js__WEBPACK_IMPORTED_MODULE_8__.createChannels)(this.contourChannels, contourData)\n    };\n  });\n}\n\n// Apply the thresholds interval, function, or count, and return an array of\n// ticks. d3-contour unlike d3-array doesn’t pass the min and max automatically,\n// so we do that here to normalize, and also so we can share consistent\n// thresholds across facets. When an interval is used, note that the lowest\n// threshold should be below (or equal) to the lowest value, or else some data\n// will be missing.\nfunction maybeTicks(thresholds, V, min, max) {\n  if (typeof thresholds?.range === \"function\") return thresholds.range(thresholds.floor(min), max);\n  if (typeof thresholds === \"function\") thresholds = thresholds(V, min, max);\n  if (typeof thresholds !== \"number\") return (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.arrayify)(thresholds);\n  const tz = (0,d3__WEBPACK_IMPORTED_MODULE_0__.ticks)(...(0,d3__WEBPACK_IMPORTED_MODULE_0__.nice)(min, max, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max) tz.pop();\n  while (tz[1] < min) tz.shift();\n  return tz;\n}\n\nfunction contour() {\n  return new Contour(...(0,_raster_js__WEBPACK_IMPORTED_MODULE_1__.maybeTuples)(\"value\", ...arguments));\n}\n\nfunction finiteExtent(VV) {\n  return [(0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(VV, (V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(V, finite)), (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(VV, (V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(V, finite))];\n}\n\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9jb250b3VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQy9DO0FBQ1I7QUFDMEI7QUFDaEI7QUFDZ0U7QUFDNUQ7QUFDRTtBQUMwQjs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sc0JBQXNCLHNEQUFjO0FBQzNDLHFCQUFxQixrQ0FBa0MsSUFBSTtBQUMzRCxxQkFBcUIsaURBQU0sR0FBRzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFnRCxvREFBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFPLFdBQVcsa0JBQWtCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsdUNBQXVDLGlEQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRLHVCQUF1Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsT0FBTyxpREFBUTtBQUN2RDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQyw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsaUJBQWlCLDJDQUFPO0FBQ3hCLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBLGdCQUFnQix5REFBa0I7QUFDbEMsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaUNBQWlDO0FBQzNELGVBQWUsbUVBQWUsdUJBQXVCLGdEQUFnQjtBQUNyRSxTQUFTLGlFQUFXO0FBQ3BCLDZCQUE2Qix3REFBWTtBQUN6QztBQUNBO0FBQ0EsV0FBVyxpR0FBaUc7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsYUFBYSxZQUFZLEVBQUUsNkRBQWE7QUFDeEM7QUFDQSxpQkFBaUIsZ0RBQUc7QUFDcEIsaUJBQWlCLGdEQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLHlDQUFLLEVBQUUsNkJBQTZCOztBQUUvRTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7O0FBRTFFO0FBQ0EsV0FBVyxTQUFTLEVBQUUsNENBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlDQUFLLHlDQUF5QyxnREFBRztBQUMxRTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBYztBQUM5QjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscURBQVE7QUFDckQsYUFBYSx5Q0FBSyxJQUFJLHdDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asd0JBQXdCLHVEQUFXO0FBQ25DOztBQUVBO0FBQ0EsVUFBVSx1Q0FBRyxZQUFZLHVDQUFHLGNBQWMsdUNBQUcsWUFBWSx1Q0FBRztBQUM1RDs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2NvbnRvdXIuanM/ZDZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2JsdXIyLCBjb250b3VycywgZ2VvUGF0aCwgbWF4LCBtaW4sIG5pY2UsIHJhbmdlLCB0aWNrcywgdGhyZXNob2xkU3R1cmdlc30gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZUNoYW5uZWxzfSBmcm9tIFwiLi4vY2hhbm5lbC5qc1wiO1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge2xhYmVsb2YsIGlkZW50aXR5LCBhcnJheWlmeSwgbWFwfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseVBvc2l0aW9ufSBmcm9tIFwiLi4vcHJvamVjdGlvbi5qc1wiO1xuaW1wb3J0IHthcHBseUNoYW5uZWxTdHlsZXMsIGFwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybSwgc3R5bGVzfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7aW5pdGlhbGl6ZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2Jhc2ljLmpzXCI7XG5pbXBvcnQge21heWJlVGhyZXNob2xkc30gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmluLmpzXCI7XG5pbXBvcnQge0Fic3RyYWN0UmFzdGVyLCBtYXliZVR1cGxlcywgcmFzdGVyQm91bmRzLCBzYW1wbGVyfSBmcm9tIFwiLi9yYXN0ZXIuanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJjb250b3VyXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHBpeGVsU2l6ZTogMlxufTtcblxuZXhwb3J0IGNsYXNzIENvbnRvdXIgZXh0ZW5kcyBBYnN0cmFjdFJhc3RlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHtzbW9vdGggPSB0cnVlLCB2YWx1ZSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICAgIGNvbnN0IGNoYW5uZWxzID0gc3R5bGVzKHt9LCBvcHRpb25zLCBkZWZhdWx0cyk7XG5cbiAgICAvLyBJZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkIGV4cGxpY2l0bHksIGxvb2sgZm9yIGEgY2hhbm5lbCB0byBwcm9tb3RlLiBJZlxuICAgIC8vIG1vcmUgdGhhbiBvbmUgY2hhbm5lbCBpcyBwcmVzZW50LCB0aHJvdyBhbiBlcnJvci4gKFRvIGRpc2FtYmlndWF0ZSxcbiAgICAvLyBzcGVjaWZ5IHRoZSB2YWx1ZSBvcHRpb24gZXhwbGljaXRseS4pXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChjaGFubmVsc1trZXldLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzIGNvbnRvdXIgdmFsdWVcIik7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgb3B0aW9uc1trZXldID0gXCJ2YWx1ZVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIGFueSBjaGFubmVsIHNwZWNpZmllZCBhcyB0aGUgbGl0ZXJhbCAoY29udG91ciB0aHJlc2hvbGQpIFwidmFsdWVcIlxuICAgIC8vIChtYXliZSBiZWNhdXNlIG9mIHRoZSBwcm9tb3Rpb24gYWJvdmUpLCBwcm9wYWdhdGUgdGhlIGxhYmVsIGZyb20gdGhlXG4gICAgLy8gb3JpZ2luYWwgdmFsdWUgZGVmaW5pdGlvbi5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdiA9IHt0cmFuc2Zvcm06IChEKSA9PiBELm1hcCgoZCkgPT4gZC52YWx1ZSksIGxhYmVsOiBsYWJlbG9mKHZhbHVlKX07XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFubmVscykge1xuICAgICAgICBpZiAob3B0aW9uc1trZXldID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBvcHRpb25zW2tleV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRhdGEgaXMgbnVsbCwgdGhlbiB3ZeKAmWxsIGNvbnN0cnVjdCB0aGUgcmFzdGVyIGdyaWQgYnkgZXZhbHVhdGluZyBhXG4gICAgLy8gZnVuY3Rpb24gZm9yIGVhY2ggcG9pbnQgaW4gYSBkZW5zZSBncmlkLiBUaGUgdmFsdWUgY2hhbm5lbCBpcyBwb3B1bGF0ZWRcbiAgICAvLyBieSB0aGUgc2FtcGxlciBpbml0aWFsaXplciwgYW5kIGhlbmNlIGlzIG5vdCBwYXNzZWQgdG8gc3VwZXIgdG8gYXZvaWRcbiAgICAvLyBjb21wdXRpbmcgaXQgYmVmb3JlIHRoZXJl4oCZcyBkYXRhLlxuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGNvbnRvdXIgdmFsdWVcIik7XG4gICAgICBvcHRpb25zID0gc2FtcGxlcihcInZhbHVlXCIsIHt2YWx1ZSwgLi4ub3B0aW9uc30pO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBpZiBkYXRhIHdhcyBwcm92aWRlZCwgaXQgcmVwcmVzZW50cyBhIGRpc2NyZXRlIHNldCBvZiBzcGF0aWFsXG4gICAgLy8gc2FtcGxlcyAob2Z0ZW4gYSBncmlkLCBidXQgbm90IG5lY2Vzc2FyaWx5KS4gSWYgbm8gaW50ZXJwb2xhdGlvbiBtZXRob2RcbiAgICAvLyB3YXMgc3BlY2lmaWVkLCBkZWZhdWx0IHRvIG5lYXJlc3QuXG4gICAgZWxzZSB7XG4gICAgICBsZXQge2ludGVycG9sYXRlfSA9IG9wdGlvbnM7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSBpZGVudGl0eTtcbiAgICAgIGlmIChpbnRlcnBvbGF0ZSA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLmludGVycG9sYXRlID0gXCJuZWFyZXN0XCI7XG4gICAgfVxuXG4gICAgLy8gV3JhcCB0aGUgb3B0aW9ucyBpbiBvdXIgaW5pdGlhbGl6ZXIgdGhhdCBjb21wdXRlcyB0aGUgY29udG91ciBnZW9tZXRyaWVzO1xuICAgIC8vIHRoaXMgcnVucyBhZnRlciBhbnkgb3RoZXIgaW5pdGlhbGl6ZXJzIChhbmQgdHJhbnNmb3JtcykuXG4gICAgc3VwZXIoZGF0YSwge3ZhbHVlOiB7dmFsdWUsIG9wdGlvbmFsOiB0cnVlfX0sIGNvbnRvdXJHZW9tZXRyeShvcHRpb25zKSwgZGVmYXVsdHMpO1xuXG4gICAgLy8gV2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgYW5kIHZhbHVlIGNoYW5uZWxzLCB0aGlzXG4gICAgLy8gbWFya+KAmXMgY2hhbm5lbHMgYXJlIG5vdCBldmFsdWF0ZWQgb24gdGhlIGluaXRpYWwgZGF0YSBidXQgcmF0aGVyIG9uIHRoZVxuICAgIC8vIGNvbnRvdXIgbXVsdGlwb2x5Z29ucyBnZW5lcmF0ZWQgaW4gdGhlIGluaXRpYWxpemVyLlxuICAgIGNvbnN0IGNvbnRvdXJDaGFubmVscyA9IHtnZW9tZXRyeToge3ZhbHVlOiBpZGVudGl0eX19O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2tleV07XG4gICAgICBjb25zdCB7c2NhbGV9ID0gY2hhbm5lbDtcbiAgICAgIGlmIChzY2FsZSA9PT0gXCJ4XCIgfHwgc2NhbGUgPT09IFwieVwiIHx8IGtleSA9PT0gXCJ2YWx1ZVwiKSBjb250aW51ZTtcbiAgICAgIGNvbnRvdXJDaGFubmVsc1trZXldID0gY2hhbm5lbDtcbiAgICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWxzW2tleV07XG4gICAgfVxuICAgIHRoaXMuY29udG91ckNoYW5uZWxzID0gY29udG91ckNoYW5uZWxzO1xuICAgIHRoaXMuc21vb3RoID0gISFzbW9vdGg7XG4gIH1cbiAgZmlsdGVyKGluZGV4LCB7eCwgeSwgdmFsdWUsIC4uLmNoYW5uZWxzfSwgdmFsdWVzKSB7XG4gICAgLy8gT25seSBmaWx0ZXIgY2hhbm5lbHMgY29uc3RydWN0ZWQgYnkgdGhlIGNvbnRvdXJHZW9tZXRyeSBpbml0aWFsaXplcjsgdGhlXG4gICAgLy8geCwgeSwgYW5kIHZhbHVlIGNoYW5uZWxzIG11c3QgYmUgZmlsdGVyZWQgYnkgdGhlIGluaXRpYWxpemVyIGl0c2VsZi5cbiAgICByZXR1cm4gc3VwZXIuZmlsdGVyKGluZGV4LCBjaGFubmVscywgdmFsdWVzKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnk6IEd9ID0gY2hhbm5lbHM7XG4gICAgY29uc3QgcGF0aCA9IGdlb1BhdGgoKTtcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywgc2NhbGVzKVxuICAgICAgLmNhbGwoKGcpID0+IHtcbiAgICAgICAgZy5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcImRcIiwgKGkpID0+IHBhdGgoR1tpXSkpXG4gICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscyk7XG4gICAgICB9KVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb250b3VyR2VvbWV0cnkoe3RocmVzaG9sZHMsIGludGVydmFsLCAuLi5vcHRpb25zfSkge1xuICB0aHJlc2hvbGRzID0gbWF5YmVUaHJlc2hvbGRzKHRocmVzaG9sZHMsIGludGVydmFsLCB0aHJlc2hvbGRTdHVyZ2VzKTtcbiAgcmV0dXJuIGluaXRpYWxpemVyKG9wdGlvbnMsIGZ1bmN0aW9uIChkYXRhLCBmYWNldHMsIGNoYW5uZWxzLCBzY2FsZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmFzdGVyQm91bmRzKGNoYW5uZWxzLCBzY2FsZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgICBjb25zdCBkeSA9IHkyIC0geTE7XG4gICAgY29uc3Qge3BpeGVsU2l6ZTogaywgd2lkdGg6IHcgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGR4KSAvIGspLCBoZWlnaHQ6IGggPSBNYXRoLnJvdW5kKE1hdGguYWJzKGR5KSAvIGspfSA9IHRoaXM7XG4gICAgY29uc3Qga3ggPSB3IC8gZHg7XG4gICAgY29uc3Qga3kgPSBoIC8gZHk7XG4gICAgY29uc3QgViA9IGNoYW5uZWxzLnZhbHVlLnZhbHVlO1xuICAgIGNvbnN0IFZWID0gW107IC8vIFYgcGVyIGZhY2V0XG5cbiAgICAvLyBJbnRlcnBvbGF0ZSB0aGUgcmFzdGVyIGdyaWQsIGFzIG5lZWRlZC5cbiAgICBpZiAodGhpcy5pbnRlcnBvbGF0ZSkge1xuICAgICAgY29uc3Qge3g6IFgsIHk6IFl9ID0gYXBwbHlQb3NpdGlvbihjaGFubmVscywgc2NhbGVzLCBjb250ZXh0KTtcbiAgICAgIC8vIENvbnZlcnQgc2NhbGVkIChzY3JlZW4pIGNvb3JkaW5hdGVzIHRvIGdyaWQgKGNhbnZhcykgY29vcmRpbmF0ZXMuXG4gICAgICBjb25zdCBJWCA9IG1hcChYLCAoeCkgPT4gKHggLSB4MSkgKiBreCwgRmxvYXQ2NEFycmF5KTtcbiAgICAgIGNvbnN0IElZID0gbWFwKFksICh5KSA9PiAoeSAtIHkxKSAqIGt5LCBGbG9hdDY0QXJyYXkpO1xuICAgICAgLy8gVGhlIGNvbnRvdXIgbWFyayBub3JtYWxseSBza2lwcyBmaWx0ZXJpbmcgb24geCwgeSwgYW5kIHZhbHVlLCBzbyBoZXJlXG4gICAgICAvLyB3ZeKAmXJlIGNhcmVmdWwgdG8gdXNlIGRpZmZlcmVudCBuYW1lcyAoMCwgMSwgMikgd2hlbiBmaWx0ZXJpbmcuXG4gICAgICBjb25zdCBpY2hhbm5lbHMgPSBbY2hhbm5lbHMueCwgY2hhbm5lbHMueSwgY2hhbm5lbHMudmFsdWVdO1xuICAgICAgY29uc3QgaXZhbHVlcyA9IFtJWCwgSVksIFZdO1xuICAgICAgZm9yIChjb25zdCBmYWNldCBvZiBmYWNldHMpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbHRlcihmYWNldCwgaWNoYW5uZWxzLCBpdmFsdWVzKTtcbiAgICAgICAgVlYucHVzaCh0aGlzLmludGVycG9sYXRlKGluZGV4LCB3LCBoLCBJWCwgSVksIFYpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGNob3AgdXAgdGhlIGV4aXN0aW5nIGRlbnNlIHJhc3RlciBncmlkIGludG8gZmFjZXRzLCBpZiBuZWVkZWQuXG4gICAgLy8gViBtdXN0IGJlIGEgZGVuc2UgZ3JpZCBpbiBwcm9qZWN0ZWQgY29vcmRpbmF0ZXM7IGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgIC8vIGZhY2V0cywgdGhlbiBWIG11c3QgYmUgbGFpZCBvdXQgdmVydGljYWxseSBhcyBmYWNldCAwLCAxLCAy4oCmIGV0Yy5cbiAgICBlbHNlIGlmIChmYWNldHMpIHtcbiAgICAgIGNvbnN0IG4gPSB3ICogaDtcbiAgICAgIGNvbnN0IG0gPSBmYWNldHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyArK2kpIFZWLnB1c2goVi5zbGljZShpICogbiwgaSAqIG4gKyBuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFZWLnB1c2goVik7XG4gICAgfVxuXG4gICAgLy8gQmx1ciB0aGUgcmFzdGVyIGdyaWQsIGlmIGRlc2lyZWQuXG4gICAgaWYgKHRoaXMuYmx1ciA+IDApIGZvciAoY29uc3QgViBvZiBWVikgYmx1cjIoe2RhdGE6IFYsIHdpZHRoOiB3LCBoZWlnaHQ6IGh9LCB0aGlzLmJsdXIpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY29udG91ciB0aHJlc2hvbGRzLlxuICAgIGNvbnN0IFQgPSBtYXliZVRpY2tzKHRocmVzaG9sZHMsIFYsIC4uLmZpbml0ZUV4dGVudChWVikpO1xuICAgIGlmIChUID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHRocmVzaG9sZHM6ICR7dGhyZXNob2xkc31gKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIChtYXliZSBmYWNldGVkKSBjb250b3Vycy5cbiAgICBjb25zdCB7Y29udG91cn0gPSBjb250b3VycygpLnNpemUoW3csIGhdKS5zbW9vdGgodGhpcy5zbW9vdGgpO1xuICAgIGNvbnN0IGNvbnRvdXJEYXRhID0gW107XG4gICAgY29uc3QgY29udG91ckZhY2V0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgViBvZiBWVikge1xuICAgICAgY29udG91ckZhY2V0cy5wdXNoKHJhbmdlKGNvbnRvdXJEYXRhLmxlbmd0aCwgY29udG91ckRhdGEucHVzaCguLi5tYXAoVCwgKHQpID0+IGNvbnRvdXIoViwgdCkpKSkpO1xuICAgIH1cblxuICAgIC8vIFJlc2NhbGUgdGhlIGNvbnRvdXIgbXVsdGlwb2x5Z29uIGZyb20gZ3JpZCB0byBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgZm9yIChjb25zdCB7Y29vcmRpbmF0ZXN9IG9mIGNvbnRvdXJEYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IHJpbmdzIG9mIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmluZyBvZiByaW5ncykge1xuICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcmluZykge1xuICAgICAgICAgICAgcG9pbnRbMF0gPSBwb2ludFswXSAvIGt4ICsgeDE7XG4gICAgICAgICAgICBwb2ludFsxXSA9IHBvaW50WzFdIC8ga3kgKyB5MTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBkZWZlcnJlZCBjaGFubmVscy5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY29udG91ckRhdGEsXG4gICAgICBmYWNldHM6IGNvbnRvdXJGYWNldHMsXG4gICAgICBjaGFubmVsczogY3JlYXRlQ2hhbm5lbHModGhpcy5jb250b3VyQ2hhbm5lbHMsIGNvbnRvdXJEYXRhKVxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBBcHBseSB0aGUgdGhyZXNob2xkcyBpbnRlcnZhbCwgZnVuY3Rpb24sIG9yIGNvdW50LCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mXG4vLyB0aWNrcy4gZDMtY29udG91ciB1bmxpa2UgZDMtYXJyYXkgZG9lc27igJl0IHBhc3MgdGhlIG1pbiBhbmQgbWF4IGF1dG9tYXRpY2FsbHksXG4vLyBzbyB3ZSBkbyB0aGF0IGhlcmUgdG8gbm9ybWFsaXplLCBhbmQgYWxzbyBzbyB3ZSBjYW4gc2hhcmUgY29uc2lzdGVudFxuLy8gdGhyZXNob2xkcyBhY3Jvc3MgZmFjZXRzLiBXaGVuIGFuIGludGVydmFsIGlzIHVzZWQsIG5vdGUgdGhhdCB0aGUgbG93ZXN0XG4vLyB0aHJlc2hvbGQgc2hvdWxkIGJlIGJlbG93IChvciBlcXVhbCkgdG8gdGhlIGxvd2VzdCB2YWx1ZSwgb3IgZWxzZSBzb21lIGRhdGFcbi8vIHdpbGwgYmUgbWlzc2luZy5cbmZ1bmN0aW9uIG1heWJlVGlja3ModGhyZXNob2xkcywgViwgbWluLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGRzPy5yYW5nZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhyZXNob2xkcy5yYW5nZSh0aHJlc2hvbGRzLmZsb29yKG1pbiksIG1heCk7XG4gIGlmICh0eXBlb2YgdGhyZXNob2xkcyA9PT0gXCJmdW5jdGlvblwiKSB0aHJlc2hvbGRzID0gdGhyZXNob2xkcyhWLCBtaW4sIG1heCk7XG4gIGlmICh0eXBlb2YgdGhyZXNob2xkcyAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGFycmF5aWZ5KHRocmVzaG9sZHMpO1xuICBjb25zdCB0eiA9IHRpY2tzKC4uLm5pY2UobWluLCBtYXgsIHRocmVzaG9sZHMpLCB0aHJlc2hvbGRzKTtcbiAgd2hpbGUgKHR6W3R6Lmxlbmd0aCAtIDFdID49IG1heCkgdHoucG9wKCk7XG4gIHdoaWxlICh0elsxXSA8IG1pbikgdHouc2hpZnQoKTtcbiAgcmV0dXJuIHR6O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udG91cigpIHtcbiAgcmV0dXJuIG5ldyBDb250b3VyKC4uLm1heWJlVHVwbGVzKFwidmFsdWVcIiwgLi4uYXJndW1lbnRzKSk7XG59XG5cbmZ1bmN0aW9uIGZpbml0ZUV4dGVudChWVikge1xuICByZXR1cm4gW21pbihWViwgKFYpID0+IG1pbihWLCBmaW5pdGUpKSwgbWF4KFZWLCAoVikgPT4gbWF4KFYsIGZpbml0ZSkpXTtcbn1cblxuZnVuY3Rpb24gZmluaXRlKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8geCA6IE5hTjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/contour.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/crosshair.js":
/*!****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/crosshair.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crosshair: () => (/* binding */ crosshair),\n/* harmony export */   crosshairX: () => (/* binding */ crosshairX),\n/* harmony export */   crosshairY: () => (/* binding */ crosshairY)\n/* harmony export */ });\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interactions/pointer.js */ \"(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rule.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\");\n\n\n\n\n\n\n\nfunction crosshair(data, options) {\n  return crosshairK(_interactions_pointer_js__WEBPACK_IMPORTED_MODULE_0__.pointer, data, options);\n}\n\nfunction crosshairX(data, options = {}) {\n  return crosshairK(_interactions_pointer_js__WEBPACK_IMPORTED_MODULE_0__.pointerX, data, options);\n}\n\nfunction crosshairY(data, options = {}) {\n  return crosshairK(_interactions_pointer_js__WEBPACK_IMPORTED_MODULE_0__.pointerY, data, options);\n}\n\nfunction crosshairK(pointer, data, options = {}) {\n  const {x, y, maxRadius} = options;\n  const p = pointer({px: x, py: y, maxRadius});\n  const M = [];\n  if (x != null) M.push((0,_rule_js__WEBPACK_IMPORTED_MODULE_1__.ruleX)(data, ruleOptions(\"x\", {...p, inset: -6}, options)));\n  if (y != null) M.push((0,_rule_js__WEBPACK_IMPORTED_MODULE_1__.ruleY)(data, ruleOptions(\"y\", {...p, inset: -6}, options)));\n  if (x != null) M.push((0,_text_js__WEBPACK_IMPORTED_MODULE_2__.text)(data, textOptions(\"x\", {...p, dy: 9, frameAnchor: \"bottom\", lineAnchor: \"top\"}, options)));\n  if (y != null) M.push((0,_text_js__WEBPACK_IMPORTED_MODULE_2__.text)(data, textOptions(\"y\", {...p, dx: -9, frameAnchor: \"left\", textAnchor: \"end\"}, options)));\n  for (const m of M) m.ariaLabel = `crosshair ${m.ariaLabel}`;\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_3__.marks)(...M);\n}\n\nfunction markOptions(\n  k,\n  {channels: pointerChannels, ...pointerOptions},\n  {facet, facetAnchor, fx, fy, [k]: p, channels, transform, initializer}\n) {\n  return {\n    ...pointerOptions,\n    facet,\n    facetAnchor,\n    fx,\n    fy,\n    [k]: p,\n    channels: {...pointerChannels, ...channels},\n    transform,\n    initializer: pxpy(k, initializer)\n  };\n}\n\n// Wrap the initializer, if any, mapping px and py to x and y temporarily (e.g.,\n// for hexbin) then mapping back to px and py for rendering.\nfunction pxpy(k, i) {\n  if (i == null) return i;\n  return function (data, facets, {x: x1, y: y1, px, py, ...c1}, ...args) {\n    const {channels: {x, y, ...c} = {}, ...rest} = i.call(this, data, facets, {...c1, x: px, y: py}, ...args);\n    return {\n      channels: {\n        ...c,\n        ...(x && {px: x, ...(k === \"x\" && {x})}),\n        ...(y && {py: y, ...(k === \"y\" && {y})})\n      },\n      ...rest\n    };\n  };\n}\n\nfunction ruleOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    opacity = 0.2,\n    ruleStroke: stroke = color,\n    ruleStrokeOpacity: strokeOpacity = opacity,\n    ruleStrokeWidth: strokeWidth\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, options),\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\n\nfunction textOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    textFill: fill = color,\n    textFillOpacity: fillOpacity,\n    textStroke: stroke = \"var(--plot-background)\",\n    textStrokeOpacity: strokeOpacity,\n    textStrokeWidth: strokeWidth = 5\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, textChannel(k, options)),\n    fill,\n    fillOpacity,\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\n\n// Rather than aliasing text to have the same definition as x and y, we use an\n// initializer to alias the channel values, such that the text channel can be\n// derived by an initializer such as hexbin.\nfunction textChannel(source, options) {\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_4__.initializer)(options, (data, facets, channels) => {\n    return {channels: {text: {value: (0,_channel_js__WEBPACK_IMPORTED_MODULE_5__.getSource)(channels, source)?.value}}};\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9jcm9zc2hhaXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQytCO0FBQ3RDO0FBQ2tCO0FBQ1o7QUFDUjs7QUFFeEI7QUFDUCxvQkFBb0IsNkRBQU87QUFDM0I7O0FBRU8sc0NBQXNDO0FBQzdDLG9CQUFvQiw4REFBUTtBQUM1Qjs7QUFFTyxzQ0FBc0M7QUFDN0Msb0JBQW9CLDhEQUFRO0FBQzVCOztBQUVBLCtDQUErQztBQUMvQyxTQUFTLGlCQUFpQjtBQUMxQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0Esd0JBQXdCLCtDQUFLLHlCQUF5QixnQkFBZ0I7QUFDdEUsd0JBQXdCLCtDQUFLLHlCQUF5QixnQkFBZ0I7QUFDdEUsd0JBQXdCLDhDQUFJLHlCQUF5QixzREFBc0Q7QUFDM0csd0JBQXdCLDhDQUFJLHlCQUF5QixxREFBcUQ7QUFDMUcsZ0RBQWdELFlBQVk7QUFDNUQsU0FBUywrQ0FBSztBQUNkOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDZDQUE2QztBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RCxXQUFXLFdBQVcsWUFBWSxJQUFJLFdBQVcsOEJBQThCLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCLEVBQUUsRUFBRTtBQUMvQyxrQkFBa0IseUJBQXlCLEVBQUUsRUFBRTtBQUMvQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFXO0FBQ3BCLFlBQVksV0FBVyxPQUFPLE9BQU8sc0RBQVM7QUFDOUMsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9jcm9zc2hhaXIuanM/M2U2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldFNvdXJjZX0gZnJvbSBcIi4uL2NoYW5uZWwuanNcIjtcbmltcG9ydCB7cG9pbnRlciwgcG9pbnRlclgsIHBvaW50ZXJZfSBmcm9tIFwiLi4vaW50ZXJhY3Rpb25zL3BvaW50ZXIuanNcIjtcbmltcG9ydCB7bWFya3N9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2luaXRpYWxpemVyfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9iYXNpYy5qc1wiO1xuaW1wb3J0IHtydWxlWCwgcnVsZVl9IGZyb20gXCIuL3J1bGUuanNcIjtcbmltcG9ydCB7dGV4dH0gZnJvbSBcIi4vdGV4dC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NoYWlyKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyb3NzaGFpcksocG9pbnRlciwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2hhaXJYKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3Jvc3NoYWlySyhwb2ludGVyWCwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2hhaXJZKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3Jvc3NoYWlySyhwb2ludGVyWSwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyb3NzaGFpcksocG9pbnRlciwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHt4LCB5LCBtYXhSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3QgcCA9IHBvaW50ZXIoe3B4OiB4LCBweTogeSwgbWF4UmFkaXVzfSk7XG4gIGNvbnN0IE0gPSBbXTtcbiAgaWYgKHggIT0gbnVsbCkgTS5wdXNoKHJ1bGVYKGRhdGEsIHJ1bGVPcHRpb25zKFwieFwiLCB7Li4ucCwgaW5zZXQ6IC02fSwgb3B0aW9ucykpKTtcbiAgaWYgKHkgIT0gbnVsbCkgTS5wdXNoKHJ1bGVZKGRhdGEsIHJ1bGVPcHRpb25zKFwieVwiLCB7Li4ucCwgaW5zZXQ6IC02fSwgb3B0aW9ucykpKTtcbiAgaWYgKHggIT0gbnVsbCkgTS5wdXNoKHRleHQoZGF0YSwgdGV4dE9wdGlvbnMoXCJ4XCIsIHsuLi5wLCBkeTogOSwgZnJhbWVBbmNob3I6IFwiYm90dG9tXCIsIGxpbmVBbmNob3I6IFwidG9wXCJ9LCBvcHRpb25zKSkpO1xuICBpZiAoeSAhPSBudWxsKSBNLnB1c2godGV4dChkYXRhLCB0ZXh0T3B0aW9ucyhcInlcIiwgey4uLnAsIGR4OiAtOSwgZnJhbWVBbmNob3I6IFwibGVmdFwiLCB0ZXh0QW5jaG9yOiBcImVuZFwifSwgb3B0aW9ucykpKTtcbiAgZm9yIChjb25zdCBtIG9mIE0pIG0uYXJpYUxhYmVsID0gYGNyb3NzaGFpciAke20uYXJpYUxhYmVsfWA7XG4gIHJldHVybiBtYXJrcyguLi5NKTtcbn1cblxuZnVuY3Rpb24gbWFya09wdGlvbnMoXG4gIGssXG4gIHtjaGFubmVsczogcG9pbnRlckNoYW5uZWxzLCAuLi5wb2ludGVyT3B0aW9uc30sXG4gIHtmYWNldCwgZmFjZXRBbmNob3IsIGZ4LCBmeSwgW2tdOiBwLCBjaGFubmVscywgdHJhbnNmb3JtLCBpbml0aWFsaXplcn1cbikge1xuICByZXR1cm4ge1xuICAgIC4uLnBvaW50ZXJPcHRpb25zLFxuICAgIGZhY2V0LFxuICAgIGZhY2V0QW5jaG9yLFxuICAgIGZ4LFxuICAgIGZ5LFxuICAgIFtrXTogcCxcbiAgICBjaGFubmVsczogey4uLnBvaW50ZXJDaGFubmVscywgLi4uY2hhbm5lbHN9LFxuICAgIHRyYW5zZm9ybSxcbiAgICBpbml0aWFsaXplcjogcHhweShrLCBpbml0aWFsaXplcilcbiAgfTtcbn1cblxuLy8gV3JhcCB0aGUgaW5pdGlhbGl6ZXIsIGlmIGFueSwgbWFwcGluZyBweCBhbmQgcHkgdG8geCBhbmQgeSB0ZW1wb3JhcmlseSAoZS5nLixcbi8vIGZvciBoZXhiaW4pIHRoZW4gbWFwcGluZyBiYWNrIHRvIHB4IGFuZCBweSBmb3IgcmVuZGVyaW5nLlxuZnVuY3Rpb24gcHhweShrLCBpKSB7XG4gIGlmIChpID09IG51bGwpIHJldHVybiBpO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIGZhY2V0cywge3g6IHgxLCB5OiB5MSwgcHgsIHB5LCAuLi5jMX0sIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7Y2hhbm5lbHM6IHt4LCB5LCAuLi5jfSA9IHt9LCAuLi5yZXN0fSA9IGkuY2FsbCh0aGlzLCBkYXRhLCBmYWNldHMsIHsuLi5jMSwgeDogcHgsIHk6IHB5fSwgLi4uYXJncyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIC4uLih4ICYmIHtweDogeCwgLi4uKGsgPT09IFwieFwiICYmIHt4fSl9KSxcbiAgICAgICAgLi4uKHkgJiYge3B5OiB5LCAuLi4oayA9PT0gXCJ5XCIgJiYge3l9KX0pXG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bGVPcHRpb25zKGssIHBvaW50ZXJPcHRpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBjb2xvciA9IFwiY3VycmVudENvbG9yXCIsXG4gICAgb3BhY2l0eSA9IDAuMixcbiAgICBydWxlU3Ryb2tlOiBzdHJva2UgPSBjb2xvcixcbiAgICBydWxlU3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eSA9IG9wYWNpdHksXG4gICAgcnVsZVN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICAuLi5tYXJrT3B0aW9ucyhrLCBwb2ludGVyT3B0aW9ucywgb3B0aW9ucyksXG4gICAgc3Ryb2tlLFxuICAgIHN0cm9rZU9wYWNpdHksXG4gICAgc3Ryb2tlV2lkdGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dE9wdGlvbnMoaywgcG9pbnRlck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICB0ZXh0RmlsbDogZmlsbCA9IGNvbG9yLFxuICAgIHRleHRGaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgdGV4dFN0cm9rZTogc3Ryb2tlID0gXCJ2YXIoLS1wbG90LWJhY2tncm91bmQpXCIsXG4gICAgdGV4dFN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHksXG4gICAgdGV4dFN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA9IDVcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgLi4ubWFya09wdGlvbnMoaywgcG9pbnRlck9wdGlvbnMsIHRleHRDaGFubmVsKGssIG9wdGlvbnMpKSxcbiAgICBmaWxsLFxuICAgIGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZSxcbiAgICBzdHJva2VPcGFjaXR5LFxuICAgIHN0cm9rZVdpZHRoXG4gIH07XG59XG5cbi8vIFJhdGhlciB0aGFuIGFsaWFzaW5nIHRleHQgdG8gaGF2ZSB0aGUgc2FtZSBkZWZpbml0aW9uIGFzIHggYW5kIHksIHdlIHVzZSBhblxuLy8gaW5pdGlhbGl6ZXIgdG8gYWxpYXMgdGhlIGNoYW5uZWwgdmFsdWVzLCBzdWNoIHRoYXQgdGhlIHRleHQgY2hhbm5lbCBjYW4gYmVcbi8vIGRlcml2ZWQgYnkgYW4gaW5pdGlhbGl6ZXIgc3VjaCBhcyBoZXhiaW4uXG5mdW5jdGlvbiB0ZXh0Q2hhbm5lbChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGluaXRpYWxpemVyKG9wdGlvbnMsIChkYXRhLCBmYWNldHMsIGNoYW5uZWxzKSA9PiB7XG4gICAgcmV0dXJuIHtjaGFubmVsczoge3RleHQ6IHt2YWx1ZTogZ2V0U291cmNlKGNoYW5uZWxzLCBzb3VyY2UpPy52YWx1ZX19fTtcbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/crosshair.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/delaunay.js":
/*!***************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/delaunay.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   delaunayLink: () => (/* binding */ delaunayLink),\n/* harmony export */   delaunayMesh: () => (/* binding */ delaunayMesh),\n/* harmony export */   hull: () => (/* binding */ hull),\n/* harmony export */   voronoi: () => (/* binding */ voronoi),\n/* harmony export */   voronoiMesh: () => (/* binding */ voronoiMesh)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../curve.js */ \"(ssr)/./node_modules/@observablehq/plot/src/curve.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../marker.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marker.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _transforms_exclusiveFacets_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../transforms/exclusiveFacets.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js\");\n/* harmony import */ var _transforms_group_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transforms/group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nconst delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\n\nconst hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\n\nconst voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nconst voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\n\nclass DelaunayLink extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: z, optional: true}\n      },\n      options,\n      delaunayLinkDefaults\n    );\n    this.curve = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.maybeCurve)(curve, tension);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_3__.markers)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, z: Z} = channels;\n    const {curve} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n    const xi = X ? (i) => X[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cx);\n    const yi = Y ? (i) => Y[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cy);\n    const mark = this;\n\n    function links(index) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k in channels) newChannels[k] = [];\n      const X1 = [];\n      const X2 = [];\n      const Y1 = [];\n      const Y2 = [];\n\n      function link(ti, tj) {\n        ti = index[ti];\n        tj = index[tj];\n        newIndex.push(++i);\n        X1[i] = xi(ti);\n        Y1[i] = yi(ti);\n        X2[i] = xi(tj);\n        Y2[i] = yi(tj);\n        for (const k in channels) newChannels[k].push(channels[k][tj]);\n      }\n\n      const {halfedges, hull, triangles} = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(index, xi, yi);\n      for (let i = 0; i < halfedges.length; ++i) {\n        // inner edges\n        const j = halfedges[i];\n        if (j > i) link(triangles[i], triangles[j]);\n      }\n      for (let i = 0; i < hull.length; ++i) {\n        // convex hull\n        link(hull[i], hull[(i + 1) % hull.length]);\n      }\n\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(this)\n        .selectAll()\n        .data(newIndex)\n        .enter()\n        .append(\"path\")\n        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, mark)\n        .attr(\"d\", (i) => {\n          const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n          const c = curve(p);\n          c.lineStart();\n          c.point(X1[i], Y1[i]);\n          c.point(X2[i], Y2[i]);\n          c.lineEnd();\n          return p;\n        })\n        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, mark, newChannels)\n        .call(_marker_js__WEBPACK_IMPORTED_MODULE_3__.applyMarkers, mark, newChannels, context);\n    }\n\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x, y: Y && y})\n      .call(\n        Z\n          ? (g) =>\n              g\n                .selectAll()\n                .data((0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(index, (i) => Z[i]).values())\n                .enter()\n                .append(\"g\")\n                .each(links)\n          : (g) => g.datum(index).each(links)\n      )\n      .node();\n  }\n}\n\nclass AbstractDelaunayMark extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}, defaults, zof = ({z}) => z) {\n    const {x, y} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: zof(options), optional: true}\n      },\n      options,\n      defaults\n    );\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, z: Z} = channels;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n    const xi = X ? (i) => X[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cx);\n    const yi = Y ? (i) => Y[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cy);\n    const mark = this;\n\n    function mesh(index) {\n      const delaunay = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(index, xi, yi);\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(this)\n        .append(\"path\")\n        .datum(index[0])\n        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, mark)\n        .attr(\"d\", mark._render(delaunay, dimensions))\n        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, mark, channels);\n    }\n\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x, y: Y && y})\n      .call(\n        Z\n          ? (g) =>\n              g\n                .selectAll()\n                .data((0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(index, (i) => Z[i]).values())\n                .enter()\n                .append(\"g\")\n                .each(mesh)\n          : (g) => g.datum(index).each(mesh)\n      )\n      .node();\n  }\n}\n\nclass DelaunayMesh extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n}\n\nclass Hull extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, _options_js__WEBPACK_IMPORTED_MODULE_5__.maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n}\n\nclass Voronoi extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, z} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: z, optional: true}\n      },\n      (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_7__.initializer)(options, function (data, facets, channels, scales, dimensions, context) {\n        let {x: X, y: Y, z: Z} = channels;\n        ({x: X, y: Y} = (0,_projection_js__WEBPACK_IMPORTED_MODULE_8__.applyPosition)(channels, scales, context));\n        Z = Z?.value;\n        const C = new Array((X ?? Y).length).fill(null);\n        const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n        const xi = X ? (i) => X[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cx);\n        const yi = Y ? (i) => Y[i] : (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.constant)(cy);\n        for (let I of facets) {\n          if (X) I = I.filter((i) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__.defined)(xi(i)));\n          if (Y) I = I.filter((i) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__.defined)(yi(i)));\n          for (const [, J] of (0,_transforms_group_js__WEBPACK_IMPORTED_MODULE_10__.maybeGroup)(I, Z)) {\n            const delaunay = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(J, xi, yi);\n            const voronoi = voronoiof(delaunay, dimensions);\n            for (let i = 0, n = J.length; i < n; ++i) {\n              C[J[i]] = voronoi.renderCell(i);\n            }\n          }\n        }\n        return {data, facets, channels: {cells: {value: C}}};\n      }),\n      voronoiDefaults\n    );\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, cells: C} = channels;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .attr(\"d\", (i) => C[i])\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\nclass VoronoiMesh extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n}\n\nfunction voronoiof(delaunay, dimensions) {\n  const {width, height, marginTop, marginRight, marginBottom, marginLeft} = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\n\nfunction delaunayMark(DelaunayMark, data, {x, y, ...options} = {}) {\n  [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_5__.maybeTuple)(x, y);\n  return new DelaunayMark(data, {...options, x, y});\n}\n\nfunction delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\n\nfunction delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\n\nfunction hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\n\nfunction voronoi(data, {x, y, initializer, ...options} = {}) {\n  return delaunayMark(Voronoi, data, {...(0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_7__.basic)({...options, x, y}, _transforms_exclusiveFacets_js__WEBPACK_IMPORTED_MODULE_11__.exclusiveFacets), initializer});\n}\n\nfunction voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kZWxhdW5heS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN6QjtBQUNFO0FBQ0Q7QUFDTjtBQUNtQjtBQUNRO0FBQ1o7QUFDYztBQUMwQjtBQUM3QjtBQUNPO0FBQ2Y7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMENBQUk7QUFDL0IsZ0NBQWdDO0FBQ2hDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pELFlBQVkscUNBQXFDO0FBQ2pELFlBQVk7QUFDWixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCLElBQUksbURBQU87QUFDWDtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsT0FBTztBQUNsQixxQkFBcUIsMkRBQWdCO0FBQ3JDLGlDQUFpQyxxREFBUTtBQUN6QyxpQ0FBaUMscURBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsNEJBQTRCLEVBQUUsd0NBQVE7QUFDbkQsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBLE1BQU0sMENBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0RBQWlCO0FBQy9CO0FBQ0Esb0JBQW9CLDZDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjLHlEQUFrQjtBQUNoQyxjQUFjLG9EQUFZO0FBQzFCOztBQUVBLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYyxTQUFTLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLDBDQUFJO0FBQ3ZDLGdDQUFnQyxvQkFBb0IsRUFBRTtBQUN0RCxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWTtBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsa0JBQWtCO0FBQzdCLHFCQUFxQiwyREFBZ0I7QUFDckMsaUNBQWlDLHFEQUFRO0FBQ3pDLGlDQUFpQyxxREFBUTtBQUN6Qzs7QUFFQTtBQUNBLHVCQUF1Qix3Q0FBUTtBQUMvQixNQUFNLDBDQUFNO0FBQ1o7QUFDQTtBQUNBLGNBQWMsd0RBQWlCO0FBQy9CO0FBQ0EsY0FBYyx5REFBa0I7QUFDaEM7O0FBRUEsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFNBQVMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQyx1Q0FBdUMsK0NBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMENBQUk7QUFDMUIsZ0NBQWdDO0FBQ2hDLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxZQUFZLHFDQUFxQztBQUNqRCxZQUFZO0FBQ1osT0FBTztBQUNQLE1BQU0saUVBQVc7QUFDakIsYUFBYSxrQkFBa0I7QUFDL0IsVUFBVSxZQUFZLEVBQUUsNkRBQWE7QUFDckM7QUFDQTtBQUNBLHlCQUF5QiwyREFBZ0I7QUFDekMscUNBQXFDLHFEQUFRO0FBQzdDLHFDQUFxQyxxREFBUTtBQUM3QztBQUNBLHFDQUFxQyxvREFBTztBQUM1QyxxQ0FBcUMsb0RBQU87QUFDNUMsOEJBQThCLGlFQUFVO0FBQ3hDLDZCQUE2Qix3Q0FBUTtBQUNyQztBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QixRQUFRO0FBQ2pELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWMsU0FBUyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakM7QUFDQSxnQkFBZ0IseURBQWtCO0FBQ2xDLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxpRUFBaUU7QUFDMUU7QUFDQTs7QUFFQSwyQ0FBMkMsa0JBQWtCLElBQUk7QUFDakUsV0FBVyx1REFBVTtBQUNyQixpQ0FBaUMsaUJBQWlCO0FBQ2xEOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPLHdCQUF3QiwrQkFBK0IsSUFBSTtBQUNsRSxzQ0FBc0MsR0FBRywyREFBSyxFQUFFLGlCQUFpQixFQUFFLDRFQUFlLGVBQWU7QUFDakc7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kZWxhdW5heS5qcz80YjUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z3JvdXAsIHBhdGhSb3VuZCBhcyBwYXRoLCBzZWxlY3QsIERlbGF1bmF5fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHttYXliZUN1cnZlfSBmcm9tIFwiLi4vY3VydmUuanNcIjtcbmltcG9ydCB7ZGVmaW5lZH0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7bWFya2VycywgYXBwbHlNYXJrZXJzfSBmcm9tIFwiLi4vbWFya2VyLmpzXCI7XG5pbXBvcnQge2NvbnN0YW50LCBtYXliZVR1cGxlLCBtYXliZVp9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2FwcGx5UG9zaXRpb259IGZyb20gXCIuLi9wcm9qZWN0aW9uLmpzXCI7XG5pbXBvcnQge2FwcGx5RnJhbWVBbmNob3IsIGFwcGx5VHJhbnNmb3JtfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7YXBwbHlDaGFubmVsU3R5bGVzLCBhcHBseURpcmVjdFN0eWxlcywgYXBwbHlJbmRpcmVjdFN0eWxlc30gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge2Jhc2ljLCBpbml0aWFsaXplcn0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmFzaWMuanNcIjtcbmltcG9ydCB7ZXhjbHVzaXZlRmFjZXRzfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9leGNsdXNpdmVGYWNldHMuanNcIjtcbmltcG9ydCB7bWF5YmVHcm91cH0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvZ3JvdXAuanNcIjtcblxuY29uc3QgZGVsYXVuYXlMaW5rRGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJkZWxhdW5heSBsaW5rXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDFcbn07XG5cbmNvbnN0IGRlbGF1bmF5TWVzaERlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiZGVsYXVuYXkgbWVzaFwiLFxuICBmaWxsOiBudWxsLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZU9wYWNpdHk6IDAuMlxufTtcblxuY29uc3QgaHVsbERlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiaHVsbFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMS41LFxuICBzdHJva2VNaXRlcmxpbWl0OiAxXG59O1xuXG5jb25zdCB2b3Jvbm9pRGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJ2b3Jvbm9pXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDFcbn07XG5cbmNvbnN0IHZvcm9ub2lNZXNoRGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJ2b3Jvbm9pIG1lc2hcIixcbiAgZmlsbDogbnVsbCxcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VPcGFjaXR5OiAwLjJcbn07XG5cbmNsYXNzIERlbGF1bmF5TGluayBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7eCwgeSwgeiwgY3VydmUsIHRlbnNpb259ID0gb3B0aW9ucztcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IHt2YWx1ZTogeCwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHk6IHt2YWx1ZTogeSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHo6IHt2YWx1ZTogeiwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlbGF1bmF5TGlua0RlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLmN1cnZlID0gbWF5YmVDdXJ2ZShjdXJ2ZSwgdGVuc2lvbik7XG4gICAgbWFya2Vycyh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBzY2FsZXM7XG4gICAgY29uc3Qge3g6IFgsIHk6IFksIHo6IFp9ID0gY2hhbm5lbHM7XG4gICAgY29uc3Qge2N1cnZlfSA9IHRoaXM7XG4gICAgY29uc3QgW2N4LCBjeV0gPSBhcHBseUZyYW1lQW5jaG9yKHRoaXMsIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IHhpID0gWCA/IChpKSA9PiBYW2ldIDogY29uc3RhbnQoY3gpO1xuICAgIGNvbnN0IHlpID0gWSA/IChpKSA9PiBZW2ldIDogY29uc3RhbnQoY3kpO1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gbGlua3MoaW5kZXgpIHtcbiAgICAgIGxldCBpID0gLTE7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IFtdO1xuICAgICAgY29uc3QgbmV3Q2hhbm5lbHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBjaGFubmVscykgbmV3Q2hhbm5lbHNba10gPSBbXTtcbiAgICAgIGNvbnN0IFgxID0gW107XG4gICAgICBjb25zdCBYMiA9IFtdO1xuICAgICAgY29uc3QgWTEgPSBbXTtcbiAgICAgIGNvbnN0IFkyID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmsodGksIHRqKSB7XG4gICAgICAgIHRpID0gaW5kZXhbdGldO1xuICAgICAgICB0aiA9IGluZGV4W3RqXTtcbiAgICAgICAgbmV3SW5kZXgucHVzaCgrK2kpO1xuICAgICAgICBYMVtpXSA9IHhpKHRpKTtcbiAgICAgICAgWTFbaV0gPSB5aSh0aSk7XG4gICAgICAgIFgyW2ldID0geGkodGopO1xuICAgICAgICBZMltpXSA9IHlpKHRqKTtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIGNoYW5uZWxzKSBuZXdDaGFubmVsc1trXS5wdXNoKGNoYW5uZWxzW2tdW3RqXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtoYWxmZWRnZXMsIGh1bGwsIHRyaWFuZ2xlc30gPSBEZWxhdW5heS5mcm9tKGluZGV4LCB4aSwgeWkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gaW5uZXIgZWRnZXNcbiAgICAgICAgY29uc3QgaiA9IGhhbGZlZGdlc1tpXTtcbiAgICAgICAgaWYgKGogPiBpKSBsaW5rKHRyaWFuZ2xlc1tpXSwgdHJpYW5nbGVzW2pdKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBjb252ZXggaHVsbFxuICAgICAgICBsaW5rKGh1bGxbaV0sIGh1bGxbKGkgKyAxKSAlIGh1bGwubGVuZ3RoXSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdCh0aGlzKVxuICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgLmRhdGEobmV3SW5kZXgpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCBtYXJrKVxuICAgICAgICAuYXR0cihcImRcIiwgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBwID0gcGF0aCgpO1xuICAgICAgICAgIGNvbnN0IGMgPSBjdXJ2ZShwKTtcbiAgICAgICAgICBjLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGMucG9pbnQoWDFbaV0sIFkxW2ldKTtcbiAgICAgICAgICBjLnBvaW50KFgyW2ldLCBZMltpXSk7XG4gICAgICAgICAgYy5saW5lRW5kKCk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgbWFyaywgbmV3Q2hhbm5lbHMpXG4gICAgICAgIC5jYWxsKGFwcGx5TWFya2VycywgbWFyaywgbmV3Q2hhbm5lbHMsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCB7eDogWCAmJiB4LCB5OiBZICYmIHl9KVxuICAgICAgLmNhbGwoXG4gICAgICAgIFpcbiAgICAgICAgICA/IChnKSA9PlxuICAgICAgICAgICAgICBnXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgICAgICAgLmRhdGEoZ3JvdXAoaW5kZXgsIChpKSA9PiBaW2ldKS52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmVhY2gobGlua3MpXG4gICAgICAgICAgOiAoZykgPT4gZy5kYXR1bShpbmRleCkuZWFjaChsaW5rcylcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuY2xhc3MgQWJzdHJhY3REZWxhdW5heU1hcmsgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cywgem9mID0gKHt6fSkgPT4geikge1xuICAgIGNvbnN0IHt4LCB5fSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB6OiB7dmFsdWU6IHpvZihvcHRpb25zKSwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBzY2FsZXM7XG4gICAgY29uc3Qge3g6IFgsIHk6IFksIHo6IFp9ID0gY2hhbm5lbHM7XG4gICAgY29uc3QgW2N4LCBjeV0gPSBhcHBseUZyYW1lQW5jaG9yKHRoaXMsIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IHhpID0gWCA/IChpKSA9PiBYW2ldIDogY29uc3RhbnQoY3gpO1xuICAgIGNvbnN0IHlpID0gWSA/IChpKSA9PiBZW2ldIDogY29uc3RhbnQoY3kpO1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gbWVzaChpbmRleCkge1xuICAgICAgY29uc3QgZGVsYXVuYXkgPSBEZWxhdW5heS5mcm9tKGluZGV4LCB4aSwgeWkpO1xuICAgICAgc2VsZWN0KHRoaXMpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bShpbmRleFswXSlcbiAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIG1hcmspXG4gICAgICAgIC5hdHRyKFwiZFwiLCBtYXJrLl9yZW5kZXIoZGVsYXVuYXksIGRpbWVuc2lvbnMpKVxuICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIG1hcmssIGNoYW5uZWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywge3g6IFggJiYgeCwgeTogWSAmJiB5fSlcbiAgICAgIC5jYWxsKFxuICAgICAgICBaXG4gICAgICAgICAgPyAoZykgPT5cbiAgICAgICAgICAgICAgZ1xuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgICAgICAgIC5kYXRhKGdyb3VwKGluZGV4LCAoaSkgPT4gWltpXSkudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5lYWNoKG1lc2gpXG4gICAgICAgICAgOiAoZykgPT4gZy5kYXR1bShpbmRleCkuZWFjaChtZXNoKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5jbGFzcyBEZWxhdW5heU1lc2ggZXh0ZW5kcyBBYnN0cmFjdERlbGF1bmF5TWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMsIGRlbGF1bmF5TWVzaERlZmF1bHRzKTtcbiAgICB0aGlzLmZpbGwgPSBcIm5vbmVcIjtcbiAgfVxuICBfcmVuZGVyKGRlbGF1bmF5KSB7XG4gICAgcmV0dXJuIGRlbGF1bmF5LnJlbmRlcigpO1xuICB9XG59XG5cbmNsYXNzIEh1bGwgZXh0ZW5kcyBBYnN0cmFjdERlbGF1bmF5TWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMsIGh1bGxEZWZhdWx0cywgbWF5YmVaKTtcbiAgfVxuICBfcmVuZGVyKGRlbGF1bmF5KSB7XG4gICAgcmV0dXJuIGRlbGF1bmF5LnJlbmRlckh1bGwoKTtcbiAgfVxufVxuXG5jbGFzcyBWb3Jvbm9pIGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt4LCB5LCB6fSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB6OiB7dmFsdWU6IHosIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVyKG9wdGlvbnMsIGZ1bmN0aW9uIChkYXRhLCBmYWNldHMsIGNoYW5uZWxzLCBzY2FsZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHt4OiBYLCB5OiBZLCB6OiBafSA9IGNoYW5uZWxzO1xuICAgICAgICAoe3g6IFgsIHk6IFl9ID0gYXBwbHlQb3NpdGlvbihjaGFubmVscywgc2NhbGVzLCBjb250ZXh0KSk7XG4gICAgICAgIFogPSBaPy52YWx1ZTtcbiAgICAgICAgY29uc3QgQyA9IG5ldyBBcnJheSgoWCA/PyBZKS5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gYXBwbHlGcmFtZUFuY2hvcih0aGlzLCBkaW1lbnNpb25zKTtcbiAgICAgICAgY29uc3QgeGkgPSBYID8gKGkpID0+IFhbaV0gOiBjb25zdGFudChjeCk7XG4gICAgICAgIGNvbnN0IHlpID0gWSA/IChpKSA9PiBZW2ldIDogY29uc3RhbnQoY3kpO1xuICAgICAgICBmb3IgKGxldCBJIG9mIGZhY2V0cykge1xuICAgICAgICAgIGlmIChYKSBJID0gSS5maWx0ZXIoKGkpID0+IGRlZmluZWQoeGkoaSkpKTtcbiAgICAgICAgICBpZiAoWSkgSSA9IEkuZmlsdGVyKChpKSA9PiBkZWZpbmVkKHlpKGkpKSk7XG4gICAgICAgICAgZm9yIChjb25zdCBbLCBKXSBvZiBtYXliZUdyb3VwKEksIFopKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxhdW5heSA9IERlbGF1bmF5LmZyb20oSiwgeGksIHlpKTtcbiAgICAgICAgICAgIGNvbnN0IHZvcm9ub2kgPSB2b3Jvbm9pb2YoZGVsYXVuYXksIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBKLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBDW0pbaV1dID0gdm9yb25vaS5yZW5kZXJDZWxsKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2RhdGEsIGZhY2V0cywgY2hhbm5lbHM6IHtjZWxsczoge3ZhbHVlOiBDfX19O1xuICAgICAgfSksXG4gICAgICB2b3Jvbm9pRGVmYXVsdHNcbiAgICApO1xuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4LCB5fSA9IHNjYWxlcztcbiAgICBjb25zdCB7eDogWCwgeTogWSwgY2VsbHM6IEN9ID0gY2hhbm5lbHM7XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt4OiBYICYmIHgsIHk6IFkgJiYgeX0pXG4gICAgICAuY2FsbCgoZykgPT4ge1xuICAgICAgICBnLnNlbGVjdEFsbCgpXG4gICAgICAgICAgLmRhdGEoaW5kZXgpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCB0aGlzKVxuICAgICAgICAgIC5hdHRyKFwiZFwiLCAoaSkgPT4gQ1tpXSlcbiAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKTtcbiAgICAgIH0pXG4gICAgICAubm9kZSgpO1xuICB9XG59XG5cbmNsYXNzIFZvcm9ub2lNZXNoIGV4dGVuZHMgQWJzdHJhY3REZWxhdW5heU1hcmsge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoZGF0YSwgb3B0aW9ucywgdm9yb25vaU1lc2hEZWZhdWx0cyk7XG4gICAgdGhpcy5maWxsID0gXCJub25lXCI7XG4gIH1cbiAgX3JlbmRlcihkZWxhdW5heSwgZGltZW5zaW9ucykge1xuICAgIHJldHVybiB2b3Jvbm9pb2YoZGVsYXVuYXksIGRpbWVuc2lvbnMpLnJlbmRlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZvcm9ub2lvZihkZWxhdW5heSwgZGltZW5zaW9ucykge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0fSA9IGRpbWVuc2lvbnM7XG4gIHJldHVybiBkZWxhdW5heS52b3Jvbm9pKFttYXJnaW5MZWZ0LCBtYXJnaW5Ub3AsIHdpZHRoIC0gbWFyZ2luUmlnaHQsIGhlaWdodCAtIG1hcmdpbkJvdHRvbV0pO1xufVxuXG5mdW5jdGlvbiBkZWxhdW5heU1hcmsoRGVsYXVuYXlNYXJrLCBkYXRhLCB7eCwgeSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICByZXR1cm4gbmV3IERlbGF1bmF5TWFyayhkYXRhLCB7Li4ub3B0aW9ucywgeCwgeX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsYXVuYXlMaW5rKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlbGF1bmF5TWFyayhEZWxhdW5heUxpbmssIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsYXVuYXlNZXNoKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlbGF1bmF5TWFyayhEZWxhdW5heU1lc2gsIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVsbChkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBkZWxhdW5heU1hcmsoSHVsbCwgZGF0YSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2b3Jvbm9pKGRhdGEsIHt4LCB5LCBpbml0aWFsaXplciwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4gZGVsYXVuYXlNYXJrKFZvcm9ub2ksIGRhdGEsIHsuLi5iYXNpYyh7Li4ub3B0aW9ucywgeCwgeX0sIGV4Y2x1c2l2ZUZhY2V0cyksIGluaXRpYWxpemVyfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2b3Jvbm9pTWVzaChkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBkZWxhdW5heU1hcmsoVm9yb25vaU1lc2gsIGRhdGEsIG9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/delaunay.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/density.js":
/*!**************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/density.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Density: () => (/* binding */ Density),\n/* harmony export */   density: () => (/* binding */ density)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nclass Density extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, {x, y, z, weight, fill, stroke, ...options} = {}) {\n    // If fill or stroke is specified as “density”, then temporarily treat these\n    // as a literal color when computing defaults and maybeZ; below, we’ll unset\n    // these constant colors back to undefined since they will instead be\n    // populated by a channel generated by the initializer.\n    const fillDensity = isDensity(fill) && ((fill = \"currentColor\"), true);\n    const strokeDensity = isDensity(stroke) && ((stroke = \"currentColor\"), true);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeZ)({z, fill, stroke}), optional: true},\n        weight: {value: weight, optional: true}\n      },\n      densityInitializer({...options, fill, stroke}, fillDensity, strokeDensity),\n      defaults\n    );\n    if (fillDensity) this.fill = undefined;\n    if (strokeDensity) this.stroke = undefined;\n    this.z = z;\n  }\n  filter(index) {\n    return index; // don’t filter contours constructed by initializer\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {contours} = channels;\n    const path = (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoPath)();\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n          .attr(\"d\", (i) => path(contours[i]))\n      )\n      .node();\n  }\n}\n\nfunction density(data, {x, y, ...options} = {}) {\n  [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Density(data, {...options, x, y});\n}\n\nconst dropChannels = new Set([\"x\", \"y\", \"z\", \"weight\"]);\n\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k = 100; // arbitrary scale factor for readability\n  let {bandwidth, thresholds} = options;\n  bandwidth = bandwidth === undefined ? 20 : +bandwidth;\n  thresholds =\n    thresholds === undefined\n      ? 20\n      : typeof thresholds?.[Symbol.iterator] === \"function\"\n      ? (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers)(thresholds)\n      : +thresholds;\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_5__.initializer)(options, function (data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers)(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const {z} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n    const {width, height} = dimensions;\n\n    // Get the (either scaled or projected) xy channels.\n    const {x: X, y: Y} = (0,_projection_js__WEBPACK_IMPORTED_MODULE_6__.applyPosition)(channels, scales, context);\n\n    // Group any of the input channels according to the first index associated\n    // with each z-series or facet. Drop any channels not be needed for\n    // rendering after the contours are computed.\n    const newChannels = Object.fromEntries(\n      Object.entries(channels)\n        .filter(([key]) => !dropChannels.has(key))\n        .map(([key, channel]) => [key, {...channel, value: []}])\n    );\n\n    // If the fill or stroke encodes density, construct new output channels.\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n\n    const density = (0,d3__WEBPACK_IMPORTED_MODULE_0__.contourDensity)()\n      .x(X ? (i) => X[i] : cx)\n      .y(Y ? (i) => Y[i] : cy)\n      .weight(W ? (i) => W[i] : 1)\n      .size([width, height])\n      .bandwidth(bandwidth);\n\n    // Compute the grid for each facet-series.\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index of Z ? (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.groupZ)(facet, Z, z) : [facet]) {\n        const contour = density.contours(index);\n        facetContours.push([index, contour]);\n      }\n    }\n\n    // If explicit thresholds were not specified, find the maximum density of\n    // all grids and use this to compute thresholds.\n    let T = thresholds;\n    if (!(T instanceof _options_js__WEBPACK_IMPORTED_MODULE_2__.TypedArray)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour] of facetContours) {\n          const max = contour.max;\n          if (max > maxValue) maxValue = max;\n        }\n      }\n      T = Float64Array.from({length: thresholds - 1}, (_, i) => (maxValue * k * (i + 1)) / thresholds);\n    }\n\n    // Generate contours for each facet-series.\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index, contour] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour(t / k));\n          if (FD) FD.push(t);\n          if (SD) SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index[0]]);\n          }\n        }\n      }\n    }\n\n    // If the fill or stroke encodes density, ensure that a zero value is\n    // included so that the default color scale domain starts at zero. Otherwise\n    // if the starting range value is the same as the background color, the\n    // first contour might not be visible.\n    if (FD) FD.push(0);\n    if (SD) SD.push(0);\n\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...(FD && {fill: {value: FD, scale: \"color\"}}),\n        ...(SD && {stroke: {value: SD, scale: \"color\"}}),\n        contours: {value: contours}\n      }\n    };\n  });\n}\n\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kZW5zaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEyQztBQUNOO0FBQ0w7QUFDNEM7QUFDN0I7QUFRMUI7QUFDOEI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxzQkFBc0IsMENBQUk7QUFDakMscUJBQXFCLDJDQUEyQyxJQUFJO0FBQ3BFO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxPQUFPLG1EQUFNLEVBQUUsZ0JBQWdCLGtCQUFrQjtBQUM3RCxpQkFBaUI7QUFDakIsT0FBTztBQUNQLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixpQkFBaUIsMkNBQU87QUFDeEIsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQyxnQkFBZ0IseURBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sd0JBQXdCLGtCQUFrQixJQUFJO0FBQ3JELFdBQVcsdURBQVU7QUFDckIsNEJBQTRCLGlCQUFpQjtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPLHVCQUF1QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBLFNBQVMsaUVBQVc7QUFDcEIsZ0NBQWdDLDBEQUFhO0FBQzdDO0FBQ0EsV0FBVyxHQUFHO0FBQ2QscUJBQXFCLDJEQUFnQjtBQUNyQyxXQUFXLGVBQWU7O0FBRTFCO0FBQ0EsV0FBVyxZQUFZLEVBQUUsNkRBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrREFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTywyQkFBMkI7QUFDckQsbUJBQW1CLFNBQVMsMkJBQTJCO0FBQ3ZELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvZGVuc2l0eS5qcz8wMGYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y29udG91ckRlbnNpdHksIGdlb1BhdGh9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge1R5cGVkQXJyYXksIGNvZXJjZU51bWJlcnMsIG1heWJlVHVwbGUsIG1heWJlWn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7YXBwbHlQb3NpdGlvbn0gZnJvbSBcIi4uL3Byb2plY3Rpb24uanNcIjtcbmltcG9ydCB7XG4gIGFwcGx5Q2hhbm5lbFN0eWxlcyxcbiAgYXBwbHlEaXJlY3RTdHlsZXMsXG4gIGFwcGx5RnJhbWVBbmNob3IsXG4gIGFwcGx5SW5kaXJlY3RTdHlsZXMsXG4gIGFwcGx5VHJhbnNmb3JtLFxuICBncm91cFpcbn0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge2luaXRpYWxpemVyfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9iYXNpYy5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcImRlbnNpdHlcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMVxufTtcblxuZXhwb3J0IGNsYXNzIERlbnNpdHkgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwge3gsIHksIHosIHdlaWdodCwgZmlsbCwgc3Ryb2tlLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gICAgLy8gSWYgZmlsbCBvciBzdHJva2UgaXMgc3BlY2lmaWVkIGFzIOKAnGRlbnNpdHnigJ0sIHRoZW4gdGVtcG9yYXJpbHkgdHJlYXQgdGhlc2VcbiAgICAvLyBhcyBhIGxpdGVyYWwgY29sb3Igd2hlbiBjb21wdXRpbmcgZGVmYXVsdHMgYW5kIG1heWJlWjsgYmVsb3csIHdl4oCZbGwgdW5zZXRcbiAgICAvLyB0aGVzZSBjb25zdGFudCBjb2xvcnMgYmFjayB0byB1bmRlZmluZWQgc2luY2UgdGhleSB3aWxsIGluc3RlYWQgYmVcbiAgICAvLyBwb3B1bGF0ZWQgYnkgYSBjaGFubmVsIGdlbmVyYXRlZCBieSB0aGUgaW5pdGlhbGl6ZXIuXG4gICAgY29uc3QgZmlsbERlbnNpdHkgPSBpc0RlbnNpdHkoZmlsbCkgJiYgKChmaWxsID0gXCJjdXJyZW50Q29sb3JcIiksIHRydWUpO1xuICAgIGNvbnN0IHN0cm9rZURlbnNpdHkgPSBpc0RlbnNpdHkoc3Ryb2tlKSAmJiAoKHN0cm9rZSA9IFwiY3VycmVudENvbG9yXCIpLCB0cnVlKTtcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IHt2YWx1ZTogeCwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHk6IHt2YWx1ZTogeSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHo6IHt2YWx1ZTogbWF5YmVaKHt6LCBmaWxsLCBzdHJva2V9KSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB3ZWlnaHQ6IHt2YWx1ZTogd2VpZ2h0LCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBkZW5zaXR5SW5pdGlhbGl6ZXIoey4uLm9wdGlvbnMsIGZpbGwsIHN0cm9rZX0sIGZpbGxEZW5zaXR5LCBzdHJva2VEZW5zaXR5KSxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICBpZiAoZmlsbERlbnNpdHkpIHRoaXMuZmlsbCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc3Ryb2tlRGVuc2l0eSkgdGhpcy5zdHJva2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy56ID0gejtcbiAgfVxuICBmaWx0ZXIoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXg7IC8vIGRvbuKAmXQgZmlsdGVyIGNvbnRvdXJzIGNvbnN0cnVjdGVkIGJ5IGluaXRpYWxpemVyXG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3Qge2NvbnRvdXJzfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHBhdGggPSBnZW9QYXRoKCk7XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt9KVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAuZGF0YShpbmRleClcbiAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscylcbiAgICAgICAgICAuYXR0cihcImRcIiwgKGkpID0+IHBhdGgoY29udG91cnNbaV0pKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eShkYXRhLCB7eCwgeSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICByZXR1cm4gbmV3IERlbnNpdHkoZGF0YSwgey4uLm9wdGlvbnMsIHgsIHl9KTtcbn1cblxuY29uc3QgZHJvcENoYW5uZWxzID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJ3ZWlnaHRcIl0pO1xuXG5mdW5jdGlvbiBkZW5zaXR5SW5pdGlhbGl6ZXIob3B0aW9ucywgZmlsbERlbnNpdHksIHN0cm9rZURlbnNpdHkpIHtcbiAgY29uc3QgayA9IDEwMDsgLy8gYXJiaXRyYXJ5IHNjYWxlIGZhY3RvciBmb3IgcmVhZGFiaWxpdHlcbiAgbGV0IHtiYW5kd2lkdGgsIHRocmVzaG9sZHN9ID0gb3B0aW9ucztcbiAgYmFuZHdpZHRoID0gYmFuZHdpZHRoID09PSB1bmRlZmluZWQgPyAyMCA6ICtiYW5kd2lkdGg7XG4gIHRocmVzaG9sZHMgPVxuICAgIHRocmVzaG9sZHMgPT09IHVuZGVmaW5lZFxuICAgICAgPyAyMFxuICAgICAgOiB0eXBlb2YgdGhyZXNob2xkcz8uW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjb2VyY2VOdW1iZXJzKHRocmVzaG9sZHMpXG4gICAgICA6ICt0aHJlc2hvbGRzO1xuICByZXR1cm4gaW5pdGlhbGl6ZXIob3B0aW9ucywgZnVuY3Rpb24gKGRhdGEsIGZhY2V0cywgY2hhbm5lbHMsIHNjYWxlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IFcgPSBjaGFubmVscy53ZWlnaHQgPyBjb2VyY2VOdW1iZXJzKGNoYW5uZWxzLndlaWdodC52YWx1ZSkgOiBudWxsO1xuICAgIGNvbnN0IFogPSBjaGFubmVscy56Py52YWx1ZTtcbiAgICBjb25zdCB7en0gPSB0aGlzO1xuICAgIGNvbnN0IFtjeCwgY3ldID0gYXBwbHlGcmFtZUFuY2hvcih0aGlzLCBkaW1lbnNpb25zKTtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBkaW1lbnNpb25zO1xuXG4gICAgLy8gR2V0IHRoZSAoZWl0aGVyIHNjYWxlZCBvciBwcm9qZWN0ZWQpIHh5IGNoYW5uZWxzLlxuICAgIGNvbnN0IHt4OiBYLCB5OiBZfSA9IGFwcGx5UG9zaXRpb24oY2hhbm5lbHMsIHNjYWxlcywgY29udGV4dCk7XG5cbiAgICAvLyBHcm91cCBhbnkgb2YgdGhlIGlucHV0IGNoYW5uZWxzIGFjY29yZGluZyB0byB0aGUgZmlyc3QgaW5kZXggYXNzb2NpYXRlZFxuICAgIC8vIHdpdGggZWFjaCB6LXNlcmllcyBvciBmYWNldC4gRHJvcCBhbnkgY2hhbm5lbHMgbm90IGJlIG5lZWRlZCBmb3JcbiAgICAvLyByZW5kZXJpbmcgYWZ0ZXIgdGhlIGNvbnRvdXJzIGFyZSBjb21wdXRlZC5cbiAgICBjb25zdCBuZXdDaGFubmVscyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNoYW5uZWxzKVxuICAgICAgICAuZmlsdGVyKChba2V5XSkgPT4gIWRyb3BDaGFubmVscy5oYXMoa2V5KSlcbiAgICAgICAgLm1hcCgoW2tleSwgY2hhbm5lbF0pID0+IFtrZXksIHsuLi5jaGFubmVsLCB2YWx1ZTogW119XSlcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIGZpbGwgb3Igc3Ryb2tlIGVuY29kZXMgZGVuc2l0eSwgY29uc3RydWN0IG5ldyBvdXRwdXQgY2hhbm5lbHMuXG4gICAgY29uc3QgRkQgPSBmaWxsRGVuc2l0eSAmJiBbXTtcbiAgICBjb25zdCBTRCA9IHN0cm9rZURlbnNpdHkgJiYgW107XG5cbiAgICBjb25zdCBkZW5zaXR5ID0gY29udG91ckRlbnNpdHkoKVxuICAgICAgLngoWCA/IChpKSA9PiBYW2ldIDogY3gpXG4gICAgICAueShZID8gKGkpID0+IFlbaV0gOiBjeSlcbiAgICAgIC53ZWlnaHQoVyA/IChpKSA9PiBXW2ldIDogMSlcbiAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgIC5iYW5kd2lkdGgoYmFuZHdpZHRoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGdyaWQgZm9yIGVhY2ggZmFjZXQtc2VyaWVzLlxuICAgIGNvbnN0IGZhY2V0c0NvbnRvdXJzID0gW107XG4gICAgZm9yIChjb25zdCBmYWNldCBvZiBmYWNldHMpIHtcbiAgICAgIGNvbnN0IGZhY2V0Q29udG91cnMgPSBbXTtcbiAgICAgIGZhY2V0c0NvbnRvdXJzLnB1c2goZmFjZXRDb250b3Vycyk7XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIFogPyBncm91cFooZmFjZXQsIFosIHopIDogW2ZhY2V0XSkge1xuICAgICAgICBjb25zdCBjb250b3VyID0gZGVuc2l0eS5jb250b3VycyhpbmRleCk7XG4gICAgICAgIGZhY2V0Q29udG91cnMucHVzaChbaW5kZXgsIGNvbnRvdXJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBleHBsaWNpdCB0aHJlc2hvbGRzIHdlcmUgbm90IHNwZWNpZmllZCwgZmluZCB0aGUgbWF4aW11bSBkZW5zaXR5IG9mXG4gICAgLy8gYWxsIGdyaWRzIGFuZCB1c2UgdGhpcyB0byBjb21wdXRlIHRocmVzaG9sZHMuXG4gICAgbGV0IFQgPSB0aHJlc2hvbGRzO1xuICAgIGlmICghKFQgaW5zdGFuY2VvZiBUeXBlZEFycmF5KSkge1xuICAgICAgbGV0IG1heFZhbHVlID0gMDtcbiAgICAgIGZvciAoY29uc3QgZmFjZXRDb250b3VycyBvZiBmYWNldHNDb250b3Vycykge1xuICAgICAgICBmb3IgKGNvbnN0IFssIGNvbnRvdXJdIG9mIGZhY2V0Q29udG91cnMpIHtcbiAgICAgICAgICBjb25zdCBtYXggPSBjb250b3VyLm1heDtcbiAgICAgICAgICBpZiAobWF4ID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBUID0gRmxvYXQ2NEFycmF5LmZyb20oe2xlbmd0aDogdGhyZXNob2xkcyAtIDF9LCAoXywgaSkgPT4gKG1heFZhbHVlICogayAqIChpICsgMSkpIC8gdGhyZXNob2xkcyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgY29udG91cnMgZm9yIGVhY2ggZmFjZXQtc2VyaWVzLlxuICAgIGNvbnN0IG5ld0ZhY2V0cyA9IFtdO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgZm9yIChjb25zdCBmYWNldENvbnRvdXJzIG9mIGZhY2V0c0NvbnRvdXJzKSB7XG4gICAgICBjb25zdCBuZXdGYWNldCA9IFtdO1xuICAgICAgbmV3RmFjZXRzLnB1c2gobmV3RmFjZXQpO1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNvbnRvdXJdIG9mIGZhY2V0Q29udG91cnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFQpIHtcbiAgICAgICAgICBuZXdGYWNldC5wdXNoKGNvbnRvdXJzLmxlbmd0aCk7XG4gICAgICAgICAgY29udG91cnMucHVzaChjb250b3VyKHQgLyBrKSk7XG4gICAgICAgICAgaWYgKEZEKSBGRC5wdXNoKHQpO1xuICAgICAgICAgIGlmIChTRCkgU0QucHVzaCh0KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdDaGFubmVscykge1xuICAgICAgICAgICAgbmV3Q2hhbm5lbHNba2V5XS52YWx1ZS5wdXNoKGNoYW5uZWxzW2tleV0udmFsdWVbaW5kZXhbMF1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmlsbCBvciBzdHJva2UgZW5jb2RlcyBkZW5zaXR5LCBlbnN1cmUgdGhhdCBhIHplcm8gdmFsdWUgaXNcbiAgICAvLyBpbmNsdWRlZCBzbyB0aGF0IHRoZSBkZWZhdWx0IGNvbG9yIHNjYWxlIGRvbWFpbiBzdGFydHMgYXQgemVyby4gT3RoZXJ3aXNlXG4gICAgLy8gaWYgdGhlIHN0YXJ0aW5nIHJhbmdlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLCB0aGVcbiAgICAvLyBmaXJzdCBjb250b3VyIG1pZ2h0IG5vdCBiZSB2aXNpYmxlLlxuICAgIGlmIChGRCkgRkQucHVzaCgwKTtcbiAgICBpZiAoU0QpIFNELnB1c2goMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGZhY2V0czogbmV3RmFjZXRzLFxuICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgLi4ubmV3Q2hhbm5lbHMsXG4gICAgICAgIC4uLihGRCAmJiB7ZmlsbDoge3ZhbHVlOiBGRCwgc2NhbGU6IFwiY29sb3JcIn19KSxcbiAgICAgICAgLi4uKFNEICYmIHtzdHJva2U6IHt2YWx1ZTogU0QsIHNjYWxlOiBcImNvbG9yXCJ9fSksXG4gICAgICAgIGNvbnRvdXJzOiB7dmFsdWU6IGNvbnRvdXJzfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0RlbnNpdHkodmFsdWUpIHtcbiAgcmV0dXJuIC9eZGVuc2l0eSQvaS50ZXN0KHZhbHVlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/density.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/difference.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/difference.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   differenceX: () => (/* binding */ differenceX),\n/* harmony export */   differenceY: () => (/* binding */ differenceY)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/area.js\");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/line.js\");\n\n\n\n\n\n\n\n\nfunction differenceX(data, options) {\n  return differenceK(\"x\", data, options);\n}\n\nfunction differenceY(data, options) {\n  return differenceK(\"y\", data, options);\n}\n\nfunction differenceK(\n  k,\n  data,\n  {\n    x1,\n    x2,\n    y1,\n    y2,\n    x = x1 === undefined && x2 === undefined ? (k === \"y\" ? _options_js__WEBPACK_IMPORTED_MODULE_0__.indexOf : _options_js__WEBPACK_IMPORTED_MODULE_0__.identity) : undefined,\n    y = y1 === undefined && y2 === undefined ? (k === \"x\" ? _options_js__WEBPACK_IMPORTED_MODULE_0__.indexOf : _options_js__WEBPACK_IMPORTED_MODULE_0__.identity) : undefined,\n    fill, // ignored\n    positiveFill = \"#3ca951\",\n    negativeFill = \"#4269d0\",\n    fillOpacity = 1,\n    positiveFillOpacity = fillOpacity,\n    negativeFillOpacity = fillOpacity,\n    stroke,\n    strokeOpacity,\n    z = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeColorChannel)(stroke)[0],\n    clip, // optional additional clip for area\n    tip,\n    render,\n    ...options\n  } = {}\n) {\n  [x1, x2] = memoTuple(x, x1, x2);\n  [y1, y2] = memoTuple(y, y1, y2);\n  if (x1 === x2 && y1 === y2) {\n    if (k === \"y\") y1 = memo(0);\n    else x1 = memo(0);\n  }\n  ({tip} = (0,_mark_js__WEBPACK_IMPORTED_MODULE_1__.withTip)({tip}, k === \"y\" ? \"x\" : \"y\"));\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_1__.marks)(\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isNoneish)(positiveFill)\n      ? Object.assign(\n          (0,_area_js__WEBPACK_IMPORTED_MODULE_2__.area)(data, {\n            x1,\n            x2,\n            y1,\n            y2,\n            z,\n            fill: positiveFill,\n            fillOpacity: positiveFillOpacity,\n            render: (0,_mark_js__WEBPACK_IMPORTED_MODULE_1__.composeRender)(render, clipDifference(k, true)),\n            clip,\n            ...options\n          }),\n          {ariaLabel: \"positive difference\"}\n        )\n      : null,\n    !(0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isNoneish)(negativeFill)\n      ? Object.assign(\n          (0,_area_js__WEBPACK_IMPORTED_MODULE_2__.area)(data, {\n            x1,\n            x2,\n            y1,\n            y2,\n            z,\n            fill: negativeFill,\n            fillOpacity: negativeFillOpacity,\n            render: (0,_mark_js__WEBPACK_IMPORTED_MODULE_1__.composeRender)(render, clipDifference(k, false)),\n            clip,\n            ...options\n          }),\n          {ariaLabel: \"negative difference\"}\n        )\n      : null,\n    (0,_line_js__WEBPACK_IMPORTED_MODULE_3__.line)(data, {\n      x: x2,\n      y: y2,\n      z,\n      stroke,\n      strokeOpacity,\n      tip,\n      clip: true,\n      ...options\n    })\n  );\n}\n\nfunction memoTuple(x, x1, x2) {\n  if (x1 === undefined && x2 === undefined) {\n    // {x} → [x, x]\n    x1 = x2 = memo(x);\n  } else if (x1 === undefined) {\n    // {x2} → [x2, x2]\n    // {x, x2} → [x, x2]\n    x2 = memo(x2);\n    x1 = x === undefined ? x2 : memo(x);\n  } else if (x2 === undefined) {\n    // {x1} → [x1, x1]\n    // {x, x1} → [x1, x]\n    x1 = memo(x1);\n    x2 = x === undefined ? x1 : memo(x);\n  } else {\n    // {x1, x2} → [x1, x2]\n    x1 = memo(x1);\n    x2 = memo(x2);\n  }\n  return [x1, x2];\n}\n\nfunction memo(v) {\n  let V;\n  const {value, label = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.labelof)(value)} = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeValue)(v);\n  return {transform: (data) => V || (V = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.valueof)(data, value)), label};\n}\n\nfunction clipDifference(k, positive) {\n  const f = k === \"x\" ? \"y\" : \"x\"; // f is the flipped dimension\n  const f1 = `${f}1`;\n  const f2 = `${f}2`;\n  const k1 = `${k}1`;\n  const k2 = `${k}2`;\n  return (index, scales, channels, dimensions, context, next) => {\n    const {[f1]: F1, [f2]: F2} = channels;\n    const K1 = new Float32Array(F1.length);\n    const K2 = new Float32Array(F2.length);\n    const m = dimensions[k === \"y\" ? \"height\" : \"width\"];\n    (positive === (0,_scales_js__WEBPACK_IMPORTED_MODULE_4__.inferScaleOrder)(scales[k]) < 0 ? K1 : K2).fill(m);\n    const oc = next(index, scales, {...channels, [f2]: F1, [k2]: K2}, dimensions, context);\n    const og = next(index, scales, {...channels, [f1]: F2, [k1]: K1}, dimensions, context);\n    const c = oc.querySelector(\"g\") ?? oc; // applyClip\n    const g = og.querySelector(\"g\") ?? og; // applyClip\n    for (let i = 0; c.firstChild; i += 2) {\n      const id = (0,_style_js__WEBPACK_IMPORTED_MODULE_5__.getClipId)();\n      const clipPath = (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:clipPath\", context).attr(\"id\", id).node();\n      clipPath.appendChild(c.firstChild);\n      g.childNodes[i].setAttribute(\"clip-path\", `url(#${id})`);\n      g.insertBefore(clipPath, g.childNodes[i]);\n    }\n    return og;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kaWZmZXJlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxQztBQUNvQjtBQUNtRDtBQUMvRDtBQUNQO0FBQ1A7QUFDQTs7QUFFeEI7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdEQUFPLEdBQUcsaURBQVE7QUFDOUUsNERBQTRELGdEQUFPLEdBQUcsaURBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaURBQU8sRUFBRSxJQUFJO0FBQ3hCLFNBQVMsK0NBQUs7QUFDZCxLQUFLLHNEQUFTO0FBQ2Q7QUFDQSxVQUFVLDhDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQWE7QUFDakM7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUssc0RBQVM7QUFDZDtBQUNBLFVBQVUsOENBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBYTtBQUNqQztBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0EsSUFBSSw4Q0FBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxHQUFHO0FBQ1g7QUFDQSxJQUFJO0FBQ0osUUFBUSxJQUFJO0FBQ1osUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLElBQUk7QUFDWixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGVBQWUsb0RBQU8sU0FBUyxFQUFFLHVEQUFVO0FBQ3BELFVBQVUsK0JBQStCLG9EQUFPO0FBQ2hEOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLGdCQUFnQixFQUFFO0FBQ2xCLGdCQUFnQixFQUFFO0FBQ2xCLGdCQUFnQixFQUFFO0FBQ2xCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsb0NBQW9DLGdDQUFnQztBQUNwRSwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLG9CQUFvQixjQUFjO0FBQ2xDLGlCQUFpQixvREFBUztBQUMxQix1QkFBdUIsbURBQU07QUFDN0I7QUFDQSx3REFBd0QsR0FBRztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kaWZmZXJlbmNlLmpzP2M4MDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge2NvbXBvc2VSZW5kZXIsIG1hcmtzLCB3aXRoVGlwfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtpZGVudGl0eSwgaW5kZXhPZiwgaXNOb25laXNoLCBsYWJlbG9mLCBtYXliZUNvbG9yQ2hhbm5lbCwgbWF5YmVWYWx1ZSwgdmFsdWVvZn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7aW5mZXJTY2FsZU9yZGVyfSBmcm9tIFwiLi4vc2NhbGVzLmpzXCI7XG5pbXBvcnQge2dldENsaXBJZH0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge2FyZWF9IGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCB7bGluZX0gZnJvbSBcIi4vbGluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZmVyZW5jZVgoZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gZGlmZmVyZW5jZUsoXCJ4XCIsIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZmVyZW5jZVkoZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gZGlmZmVyZW5jZUsoXCJ5XCIsIGRhdGEsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBkaWZmZXJlbmNlSyhcbiAgayxcbiAgZGF0YSxcbiAge1xuICAgIHgxLFxuICAgIHgyLFxuICAgIHkxLFxuICAgIHkyLFxuICAgIHggPSB4MSA9PT0gdW5kZWZpbmVkICYmIHgyID09PSB1bmRlZmluZWQgPyAoayA9PT0gXCJ5XCIgPyBpbmRleE9mIDogaWRlbnRpdHkpIDogdW5kZWZpbmVkLFxuICAgIHkgPSB5MSA9PT0gdW5kZWZpbmVkICYmIHkyID09PSB1bmRlZmluZWQgPyAoayA9PT0gXCJ4XCIgPyBpbmRleE9mIDogaWRlbnRpdHkpIDogdW5kZWZpbmVkLFxuICAgIGZpbGwsIC8vIGlnbm9yZWRcbiAgICBwb3NpdGl2ZUZpbGwgPSBcIiMzY2E5NTFcIixcbiAgICBuZWdhdGl2ZUZpbGwgPSBcIiM0MjY5ZDBcIixcbiAgICBmaWxsT3BhY2l0eSA9IDEsXG4gICAgcG9zaXRpdmVGaWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5LFxuICAgIG5lZ2F0aXZlRmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2UsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICB6ID0gbWF5YmVDb2xvckNoYW5uZWwoc3Ryb2tlKVswXSxcbiAgICBjbGlwLCAvLyBvcHRpb25hbCBhZGRpdGlvbmFsIGNsaXAgZm9yIGFyZWFcbiAgICB0aXAsXG4gICAgcmVuZGVyLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHt9XG4pIHtcbiAgW3gxLCB4Ml0gPSBtZW1vVHVwbGUoeCwgeDEsIHgyKTtcbiAgW3kxLCB5Ml0gPSBtZW1vVHVwbGUoeSwgeTEsIHkyKTtcbiAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICBpZiAoayA9PT0gXCJ5XCIpIHkxID0gbWVtbygwKTtcbiAgICBlbHNlIHgxID0gbWVtbygwKTtcbiAgfVxuICAoe3RpcH0gPSB3aXRoVGlwKHt0aXB9LCBrID09PSBcInlcIiA/IFwieFwiIDogXCJ5XCIpKTtcbiAgcmV0dXJuIG1hcmtzKFxuICAgICFpc05vbmVpc2gocG9zaXRpdmVGaWxsKVxuICAgICAgPyBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIGFyZWEoZGF0YSwge1xuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB4MixcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgZmlsbDogcG9zaXRpdmVGaWxsLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHBvc2l0aXZlRmlsbE9wYWNpdHksXG4gICAgICAgICAgICByZW5kZXI6IGNvbXBvc2VSZW5kZXIocmVuZGVyLCBjbGlwRGlmZmVyZW5jZShrLCB0cnVlKSksXG4gICAgICAgICAgICBjbGlwLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHthcmlhTGFiZWw6IFwicG9zaXRpdmUgZGlmZmVyZW5jZVwifVxuICAgICAgICApXG4gICAgICA6IG51bGwsXG4gICAgIWlzTm9uZWlzaChuZWdhdGl2ZUZpbGwpXG4gICAgICA/IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgYXJlYShkYXRhLCB7XG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB5MixcbiAgICAgICAgICAgIHosXG4gICAgICAgICAgICBmaWxsOiBuZWdhdGl2ZUZpbGwsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogbmVnYXRpdmVGaWxsT3BhY2l0eSxcbiAgICAgICAgICAgIHJlbmRlcjogY29tcG9zZVJlbmRlcihyZW5kZXIsIGNsaXBEaWZmZXJlbmNlKGssIGZhbHNlKSksXG4gICAgICAgICAgICBjbGlwLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHthcmlhTGFiZWw6IFwibmVnYXRpdmUgZGlmZmVyZW5jZVwifVxuICAgICAgICApXG4gICAgICA6IG51bGwsXG4gICAgbGluZShkYXRhLCB7XG4gICAgICB4OiB4MixcbiAgICAgIHk6IHkyLFxuICAgICAgeixcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICB0aXAsXG4gICAgICBjbGlwOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1lbW9UdXBsZSh4LCB4MSwgeDIpIHtcbiAgaWYgKHgxID09PSB1bmRlZmluZWQgJiYgeDIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHt4fSDihpIgW3gsIHhdXG4gICAgeDEgPSB4MiA9IG1lbW8oeCk7XG4gIH0gZWxzZSBpZiAoeDEgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHt4Mn0g4oaSIFt4MiwgeDJdXG4gICAgLy8ge3gsIHgyfSDihpIgW3gsIHgyXVxuICAgIHgyID0gbWVtbyh4Mik7XG4gICAgeDEgPSB4ID09PSB1bmRlZmluZWQgPyB4MiA6IG1lbW8oeCk7XG4gIH0gZWxzZSBpZiAoeDIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHt4MX0g4oaSIFt4MSwgeDFdXG4gICAgLy8ge3gsIHgxfSDihpIgW3gxLCB4XVxuICAgIHgxID0gbWVtbyh4MSk7XG4gICAgeDIgPSB4ID09PSB1bmRlZmluZWQgPyB4MSA6IG1lbW8oeCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ge3gxLCB4Mn0g4oaSIFt4MSwgeDJdXG4gICAgeDEgPSBtZW1vKHgxKTtcbiAgICB4MiA9IG1lbW8oeDIpO1xuICB9XG4gIHJldHVybiBbeDEsIHgyXTtcbn1cblxuZnVuY3Rpb24gbWVtbyh2KSB7XG4gIGxldCBWO1xuICBjb25zdCB7dmFsdWUsIGxhYmVsID0gbGFiZWxvZih2YWx1ZSl9ID0gbWF5YmVWYWx1ZSh2KTtcbiAgcmV0dXJuIHt0cmFuc2Zvcm06IChkYXRhKSA9PiBWIHx8IChWID0gdmFsdWVvZihkYXRhLCB2YWx1ZSkpLCBsYWJlbH07XG59XG5cbmZ1bmN0aW9uIGNsaXBEaWZmZXJlbmNlKGssIHBvc2l0aXZlKSB7XG4gIGNvbnN0IGYgPSBrID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7IC8vIGYgaXMgdGhlIGZsaXBwZWQgZGltZW5zaW9uXG4gIGNvbnN0IGYxID0gYCR7Zn0xYDtcbiAgY29uc3QgZjIgPSBgJHtmfTJgO1xuICBjb25zdCBrMSA9IGAke2t9MWA7XG4gIGNvbnN0IGsyID0gYCR7a30yYDtcbiAgcmV0dXJuIChpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtbZjFdOiBGMSwgW2YyXTogRjJ9ID0gY2hhbm5lbHM7XG4gICAgY29uc3QgSzEgPSBuZXcgRmxvYXQzMkFycmF5KEYxLmxlbmd0aCk7XG4gICAgY29uc3QgSzIgPSBuZXcgRmxvYXQzMkFycmF5KEYyLmxlbmd0aCk7XG4gICAgY29uc3QgbSA9IGRpbWVuc2lvbnNbayA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiXTtcbiAgICAocG9zaXRpdmUgPT09IGluZmVyU2NhbGVPcmRlcihzY2FsZXNba10pIDwgMCA/IEsxIDogSzIpLmZpbGwobSk7XG4gICAgY29uc3Qgb2MgPSBuZXh0KGluZGV4LCBzY2FsZXMsIHsuLi5jaGFubmVscywgW2YyXTogRjEsIFtrMl06IEsyfSwgZGltZW5zaW9ucywgY29udGV4dCk7XG4gICAgY29uc3Qgb2cgPSBuZXh0KGluZGV4LCBzY2FsZXMsIHsuLi5jaGFubmVscywgW2YxXTogRjIsIFtrMV06IEsxfSwgZGltZW5zaW9ucywgY29udGV4dCk7XG4gICAgY29uc3QgYyA9IG9jLnF1ZXJ5U2VsZWN0b3IoXCJnXCIpID8/IG9jOyAvLyBhcHBseUNsaXBcbiAgICBjb25zdCBnID0gb2cucXVlcnlTZWxlY3RvcihcImdcIikgPz8gb2c7IC8vIGFwcGx5Q2xpcFxuICAgIGZvciAobGV0IGkgPSAwOyBjLmZpcnN0Q2hpbGQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgaWQgPSBnZXRDbGlwSWQoKTtcbiAgICAgIGNvbnN0IGNsaXBQYXRoID0gY3JlYXRlKFwic3ZnOmNsaXBQYXRoXCIsIGNvbnRleHQpLmF0dHIoXCJpZFwiLCBpZCkubm9kZSgpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kQ2hpbGQoYy5maXJzdENoaWxkKTtcbiAgICAgIGcuY2hpbGROb2Rlc1tpXS5zZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIiwgYHVybCgjJHtpZH0pYCk7XG4gICAgICBnLmluc2VydEJlZm9yZShjbGlwUGF0aCwgZy5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9nO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/difference.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js":
/*!**********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/dot.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dot: () => (/* binding */ Dot),\n/* harmony export */   circle: () => (/* binding */ circle),\n/* harmony export */   dot: () => (/* binding */ dot),\n/* harmony export */   dotX: () => (/* binding */ dotX),\n/* harmony export */   dotY: () => (/* binding */ dotY),\n/* harmony export */   hexagon: () => (/* binding */ hexagon),\n/* harmony export */   withDefaultSort: () => (/* binding */ withDefaultSort)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../template.js */ \"(ssr)/./node_modules/@observablehq/plot/src/template.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\n\nfunction withDefaultSort(options) {\n  return options.sort === undefined && options.reverse === undefined ? (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_1__.sort)({channel: \"-r\"}, options) : options;\n}\n\nclass Dot extends _mark_js__WEBPACK_IMPORTED_MODULE_2__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, r, rotate, symbol = d3__WEBPACK_IMPORTED_MODULE_0__.symbolCircle, frameAnchor} = options;\n    const [vrotate, crotate] = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeNumberChannel)(rotate, 0);\n    const [vsymbol, csymbol] = (0,_symbol_js__WEBPACK_IMPORTED_MODULE_4__.maybeSymbolChannel)(symbol);\n    const [vr, cr] = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeNumberChannel)(r, vsymbol == null ? 3 : 4.5);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        r: {value: vr, scale: \"r\", filter: _defined_js__WEBPACK_IMPORTED_MODULE_5__.positive, optional: true},\n        rotate: {value: vrotate, optional: true},\n        symbol: {value: vsymbol, scale: \"auto\", optional: true}\n      },\n      withDefaultSort(options),\n      defaults\n    );\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeFrameAnchor)(frameAnchor);\n\n    // Give a hint to the symbol scale; this allows the symbol scale to choose\n    // appropriate default symbols based on whether the dots are filled or\n    // stroked, and for the symbol legend to match the appearance of the dots.\n    const {channels} = this;\n    const {symbol: symbolChannel} = channels;\n    if (symbolChannel) {\n      const {fill: fillChannel, stroke: strokeChannel} = channels;\n      symbolChannel.hint = {\n        fill: fillChannel\n          ? fillChannel.value === symbolChannel.value\n            ? \"color\"\n            : \"currentColor\"\n          : this.fill ?? \"currentColor\",\n        stroke: strokeChannel\n          ? strokeChannel.value === symbolChannel.value\n            ? \"color\"\n            : \"currentColor\"\n          : this.stroke ?? \"none\"\n      };\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, r: R, rotate: A, symbol: S} = channels;\n    const {r, rotate, symbol} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_6__.applyFrameAnchor)(this, dimensions);\n    const circle = symbol === d3__WEBPACK_IMPORTED_MODULE_0__.symbolCircle;\n    const size = R ? undefined : r * r * Math.PI;\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.negative)(r)) index = [];\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_7__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(circle ? \"circle\" : \"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyDirectStyles, this)\n          .call(\n            circle\n              ? (selection) => {\n                  selection\n                    .attr(\"cx\", X ? (i) => X[i] : cx)\n                    .attr(\"cy\", Y ? (i) => Y[i] : cy)\n                    .attr(\"r\", R ? (i) => R[i] : r);\n                }\n              : (selection) => {\n                  selection\n                    .attr(\n                      \"transform\",\n                      (0,_template_js__WEBPACK_IMPORTED_MODULE_8__.template)`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${\n                        A ? (i) => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``\n                      }`\n                    )\n                    .attr(\n                      \"d\",\n                      R && S\n                        ? (i) => {\n                            const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                            S[i].draw(p, R[i] * R[i] * Math.PI);\n                            return p;\n                          }\n                        : R\n                        ? (i) => {\n                            const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                            symbol.draw(p, R[i] * R[i] * Math.PI);\n                            return p;\n                          }\n                        : S\n                        ? (i) => {\n                            const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                            S[i].draw(p, size);\n                            return p;\n                          }\n                        : (() => {\n                            const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                            symbol.draw(p, size);\n                            return p;\n                          })()\n                    );\n                }\n          )\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nfunction dot(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeTuple)(x, y);\n  return new Dot(data, {...options, x, y});\n}\n\nfunction dotX(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_3__.identity, ...options} = {}) {\n  return new Dot(data, (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_9__.maybeIntervalMidY)({...options, x}));\n}\n\nfunction dotY(data, {y = _options_js__WEBPACK_IMPORTED_MODULE_3__.identity, ...options} = {}) {\n  return new Dot(data, (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_9__.maybeIntervalMidX)({...options, y}));\n}\n\nfunction circle(data, options) {\n  return dot(data, {...options, symbol: \"circle\"});\n}\n\nfunction hexagon(data, options) {\n  return dot(data, {...options, symbol: \"hexagon\"});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9kb3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDZDtBQUNZO0FBQ2pCO0FBQ3lEO0FBT3BFO0FBQzJCO0FBQ1I7QUFDSTtBQUNtQzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsdUVBQXVFLDBEQUFJLEVBQUUsY0FBYztBQUMzRjs7QUFFTyxrQkFBa0IsMENBQUk7QUFDN0IsZ0NBQWdDO0FBQ2hDLFdBQVcsMEJBQTBCLDRDQUFZLGVBQWU7QUFDaEUsK0JBQStCLCtEQUFrQjtBQUNqRCwrQkFBK0IsOERBQWtCO0FBQ2pELHFCQUFxQiwrREFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSwrQkFBK0IsaURBQVEsaUJBQWlCO0FBQ3BFLGlCQUFpQiwrQkFBK0I7QUFDaEQsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWdCOztBQUV2Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHdDQUF3QztBQUNuRCxXQUFXLG1CQUFtQjtBQUM5QixxQkFBcUIsMkRBQWdCO0FBQ3JDLDhCQUE4Qiw0Q0FBWTtBQUMxQztBQUNBLFFBQVEscURBQVE7QUFDaEIsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFNBQVMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFRLGFBQWEscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3hGLDhDQUE4QyxLQUFLLHlCQUF5QixPQUFPO0FBQ25GLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBSTtBQUMxQztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sb0JBQW9CLGtCQUFrQixJQUFJO0FBQ2pELGtEQUFrRCx1REFBVTtBQUM1RCx3QkFBd0IsaUJBQWlCO0FBQ3pDOztBQUVPLHFCQUFxQixJQUFJLGlEQUFRLGNBQWMsSUFBSTtBQUMxRCx1QkFBdUIsMEVBQWlCLEVBQUUsY0FBYztBQUN4RDs7QUFFTyxxQkFBcUIsSUFBSSxpREFBUSxjQUFjLElBQUk7QUFDMUQsdUJBQXVCLDBFQUFpQixFQUFFLGNBQWM7QUFDeEQ7O0FBRU87QUFDUCxvQkFBb0IsNkJBQTZCO0FBQ2pEOztBQUVPO0FBQ1Asb0JBQW9CLDhCQUE4QjtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvZG90LmpzP2E1NGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwYXRoUm91bmQgYXMgcGF0aCwgc3ltYm9sQ2lyY2xlfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtuZWdhdGl2ZSwgcG9zaXRpdmV9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2lkZW50aXR5LCBtYXliZUZyYW1lQW5jaG9yLCBtYXliZU51bWJlckNoYW5uZWwsIG1heWJlVHVwbGV9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge1xuICBhcHBseUNoYW5uZWxTdHlsZXMsXG4gIGFwcGx5RGlyZWN0U3R5bGVzLFxuICBhcHBseUZyYW1lQW5jaG9yLFxuICBhcHBseUluZGlyZWN0U3R5bGVzLFxuICBhcHBseVRyYW5zZm9ybVxufSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7bWF5YmVTeW1ib2xDaGFubmVsfSBmcm9tIFwiLi4vc3ltYm9sLmpzXCI7XG5pbXBvcnQge3RlbXBsYXRlfSBmcm9tIFwiLi4vdGVtcGxhdGUuanNcIjtcbmltcG9ydCB7c29ydH0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmFzaWMuanNcIjtcbmltcG9ydCB7bWF5YmVJbnRlcnZhbE1pZFgsIG1heWJlSW50ZXJ2YWxNaWRZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9pbnRlcnZhbC5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcImRvdFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMS41XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gd2l0aERlZmF1bHRTb3J0KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc29ydCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gc29ydCh7Y2hhbm5lbDogXCItclwifSwgb3B0aW9ucykgOiBvcHRpb25zO1xufVxuXG5leHBvcnQgY2xhc3MgRG90IGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt4LCB5LCByLCByb3RhdGUsIHN5bWJvbCA9IHN5bWJvbENpcmNsZSwgZnJhbWVBbmNob3J9ID0gb3B0aW9ucztcbiAgICBjb25zdCBbdnJvdGF0ZSwgY3JvdGF0ZV0gPSBtYXliZU51bWJlckNoYW5uZWwocm90YXRlLCAwKTtcbiAgICBjb25zdCBbdnN5bWJvbCwgY3N5bWJvbF0gPSBtYXliZVN5bWJvbENoYW5uZWwoc3ltYm9sKTtcbiAgICBjb25zdCBbdnIsIGNyXSA9IG1heWJlTnVtYmVyQ2hhbm5lbChyLCB2c3ltYm9sID09IG51bGwgPyAzIDogNC41KTtcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IHt2YWx1ZTogeCwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHk6IHt2YWx1ZTogeSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHI6IHt2YWx1ZTogdnIsIHNjYWxlOiBcInJcIiwgZmlsdGVyOiBwb3NpdGl2ZSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICByb3RhdGU6IHt2YWx1ZTogdnJvdGF0ZSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICBzeW1ib2w6IHt2YWx1ZTogdnN5bWJvbCwgc2NhbGU6IFwiYXV0b1wiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICB3aXRoRGVmYXVsdFNvcnQob3B0aW9ucyksXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgdGhpcy5yID0gY3I7XG4gICAgdGhpcy5yb3RhdGUgPSBjcm90YXRlO1xuICAgIHRoaXMuc3ltYm9sID0gY3N5bWJvbDtcbiAgICB0aGlzLmZyYW1lQW5jaG9yID0gbWF5YmVGcmFtZUFuY2hvcihmcmFtZUFuY2hvcik7XG5cbiAgICAvLyBHaXZlIGEgaGludCB0byB0aGUgc3ltYm9sIHNjYWxlOyB0aGlzIGFsbG93cyB0aGUgc3ltYm9sIHNjYWxlIHRvIGNob29zZVxuICAgIC8vIGFwcHJvcHJpYXRlIGRlZmF1bHQgc3ltYm9scyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBkb3RzIGFyZSBmaWxsZWQgb3JcbiAgICAvLyBzdHJva2VkLCBhbmQgZm9yIHRoZSBzeW1ib2wgbGVnZW5kIHRvIG1hdGNoIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkb3RzLlxuICAgIGNvbnN0IHtjaGFubmVsc30gPSB0aGlzO1xuICAgIGNvbnN0IHtzeW1ib2w6IHN5bWJvbENoYW5uZWx9ID0gY2hhbm5lbHM7XG4gICAgaWYgKHN5bWJvbENoYW5uZWwpIHtcbiAgICAgIGNvbnN0IHtmaWxsOiBmaWxsQ2hhbm5lbCwgc3Ryb2tlOiBzdHJva2VDaGFubmVsfSA9IGNoYW5uZWxzO1xuICAgICAgc3ltYm9sQ2hhbm5lbC5oaW50ID0ge1xuICAgICAgICBmaWxsOiBmaWxsQ2hhbm5lbFxuICAgICAgICAgID8gZmlsbENoYW5uZWwudmFsdWUgPT09IHN5bWJvbENoYW5uZWwudmFsdWVcbiAgICAgICAgICAgID8gXCJjb2xvclwiXG4gICAgICAgICAgICA6IFwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICA6IHRoaXMuZmlsbCA/PyBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgICBzdHJva2U6IHN0cm9rZUNoYW5uZWxcbiAgICAgICAgICA/IHN0cm9rZUNoYW5uZWwudmFsdWUgPT09IHN5bWJvbENoYW5uZWwudmFsdWVcbiAgICAgICAgICAgID8gXCJjb2xvclwiXG4gICAgICAgICAgICA6IFwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICA6IHRoaXMuc3Ryb2tlID8/IFwibm9uZVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBzY2FsZXM7XG4gICAgY29uc3Qge3g6IFgsIHk6IFksIHI6IFIsIHJvdGF0ZTogQSwgc3ltYm9sOiBTfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHtyLCByb3RhdGUsIHN5bWJvbH0gPSB0aGlzO1xuICAgIGNvbnN0IFtjeCwgY3ldID0gYXBwbHlGcmFtZUFuY2hvcih0aGlzLCBkaW1lbnNpb25zKTtcbiAgICBjb25zdCBjaXJjbGUgPSBzeW1ib2wgPT09IHN5bWJvbENpcmNsZTtcbiAgICBjb25zdCBzaXplID0gUiA/IHVuZGVmaW5lZCA6IHIgKiByICogTWF0aC5QSTtcbiAgICBpZiAobmVnYXRpdmUocikpIGluZGV4ID0gW107XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt4OiBYICYmIHgsIHk6IFkgJiYgeX0pXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChjaXJjbGUgPyBcImNpcmNsZVwiIDogXCJwYXRoXCIpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmNhbGwoXG4gICAgICAgICAgICBjaXJjbGVcbiAgICAgICAgICAgICAgPyAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBYID8gKGkpID0+IFhbaV0gOiBjeClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBZID8gKGkpID0+IFlbaV0gOiBjeSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIFIgPyAoaSkgPT4gUltpXSA6IHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZWB0cmFuc2xhdGUoJHtYID8gKGkpID0+IFhbaV0gOiBjeH0sJHtZID8gKGkpID0+IFlbaV0gOiBjeX0pJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEEgPyAoaSkgPT4gYCByb3RhdGUoJHtBW2ldfSlgIDogcm90YXRlID8gYCByb3RhdGUoJHtyb3RhdGV9KWAgOiBgYFxuICAgICAgICAgICAgICAgICAgICAgIH1gXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgUiAmJiBTXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTW2ldLmRyYXcocCwgUltpXSAqIFJbaV0gKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBSXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZHJhdyhwLCBSW2ldICogUltpXSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IFNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNbaV0uZHJhdyhwLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmRyYXcocCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICApXG4gICAgICAubm9kZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoZGF0YSwge3gsIHksIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgaWYgKG9wdGlvbnMuZnJhbWVBbmNob3IgPT09IHVuZGVmaW5lZCkgW3gsIHldID0gbWF5YmVUdXBsZSh4LCB5KTtcbiAgcmV0dXJuIG5ldyBEb3QoZGF0YSwgey4uLm9wdGlvbnMsIHgsIHl9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdFgoZGF0YSwge3ggPSBpZGVudGl0eSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4gbmV3IERvdChkYXRhLCBtYXliZUludGVydmFsTWlkWSh7Li4ub3B0aW9ucywgeH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdFkoZGF0YSwge3kgPSBpZGVudGl0eSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4gbmV3IERvdChkYXRhLCBtYXliZUludGVydmFsTWlkWCh7Li4ub3B0aW9ucywgeX0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBkb3QoZGF0YSwgey4uLm9wdGlvbnMsIHN5bWJvbDogXCJjaXJjbGVcIn0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4YWdvbihkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBkb3QoZGF0YSwgey4uLm9wdGlvbnMsIHN5bWJvbDogXCJoZXhhZ29uXCJ9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/frame.js":
/*!************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/frame.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Frame: () => (/* binding */ Frame),\n/* harmony export */   frame: () => (/* binding */ frame)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js\");\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"frame\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  clip: false\n};\n\nconst lineDefaults = {\n  ariaLabel: \"frame\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeLinecap: \"square\",\n  clip: false\n};\n\nclass Frame extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(options = {}) {\n    const {anchor = null} = options;\n    super(_options_js__WEBPACK_IMPORTED_MODULE_1__.singleton, undefined, options, anchor == null ? defaults : lineDefaults);\n    this.anchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeKeyword)(anchor, \"anchor\", [\"top\", \"right\", \"bottom\", \"left\"]);\n    (0,_rect_js__WEBPACK_IMPORTED_MODULE_2__.rectInsets)(this, options);\n    if (!anchor) (0,_rect_js__WEBPACK_IMPORTED_MODULE_2__.rectRadii)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {marginTop, marginRight, marginBottom, marginLeft, width, height} = dimensions;\n    const {anchor, insetTop, insetRight, insetBottom, insetLeft} = this;\n    const {rx, ry, rx1y1, rx1y2, rx2y1, rx2y2} = this;\n    const x1 = marginLeft + insetLeft;\n    const x2 = width - marginRight - insetRight;\n    const y1 = marginTop + insetTop;\n    const y2 = height - marginBottom - insetBottom;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.create)(anchor ? \"svg:line\" : rx1y1 || rx1y2 || rx2y1 || rx2y2 ? \"svg:path\" : \"svg:rect\", context)\n      .datum(0)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {})\n      .call(\n        anchor === \"left\"\n          ? (line) => line.attr(\"x1\", x1).attr(\"x2\", x1).attr(\"y1\", y1).attr(\"y2\", y2)\n          : anchor === \"right\"\n          ? (line) => line.attr(\"x1\", x2).attr(\"x2\", x2).attr(\"y1\", y1).attr(\"y2\", y2)\n          : anchor === \"top\"\n          ? (line) => line.attr(\"x1\", x1).attr(\"x2\", x2).attr(\"y1\", y1).attr(\"y2\", y1)\n          : anchor === \"bottom\"\n          ? (line) => line.attr(\"x1\", x1).attr(\"x2\", x2).attr(\"y1\", y2).attr(\"y2\", y2)\n          : rx1y1 || rx1y2 || rx2y1 || rx2y2\n          ? (path) => path.call(_rect_js__WEBPACK_IMPORTED_MODULE_2__.applyRoundedRect, x1, y1, x2, y2, this)\n          : (rect) =>\n              rect\n                .attr(\"x\", x1)\n                .attr(\"y\", y1)\n                .attr(\"width\", x2 - x1)\n                .attr(\"height\", y2 - y1)\n                .attr(\"rx\", rx)\n                .attr(\"ry\", ry)\n      )\n      .node();\n  }\n}\n\nfunction frame(options) {\n  return new Frame(options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9mcmFtZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ0w7QUFDc0I7QUFDaUQ7QUFDckM7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxvQkFBb0IsMENBQUk7QUFDL0IsMEJBQTBCO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixVQUFVLGtEQUFTO0FBQ25CLGtCQUFrQix5REFBWTtBQUM5QixJQUFJLG9EQUFVO0FBQ2QsaUJBQWlCLG1EQUFTO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLGlFQUFpRTtBQUM1RSxXQUFXLHNEQUFzRDtBQUNqRSxXQUFXLG9DQUFvQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQU07QUFDakI7QUFDQSxZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHdEQUFpQjtBQUM3QixZQUFZLHlEQUFrQjtBQUM5QixZQUFZLHFEQUFjLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2ZyYW1lLmpzP2NhYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge21heWJlS2V5d29yZCwgc2luZ2xldG9ufSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseUNoYW5uZWxTdHlsZXMsIGFwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybX0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge2FwcGx5Um91bmRlZFJlY3QsIHJlY3RJbnNldHMsIHJlY3RSYWRpaX0gZnJvbSBcIi4vcmVjdC5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcImZyYW1lXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIGNsaXA6IGZhbHNlXG59O1xuXG5jb25zdCBsaW5lRGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJmcmFtZVwiLFxuICBmaWxsOiBudWxsLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZUxpbmVjYXA6IFwic3F1YXJlXCIsXG4gIGNsaXA6IGZhbHNlXG59O1xuXG5leHBvcnQgY2xhc3MgRnJhbWUgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge2FuY2hvciA9IG51bGx9ID0gb3B0aW9ucztcbiAgICBzdXBlcihzaW5nbGV0b24sIHVuZGVmaW5lZCwgb3B0aW9ucywgYW5jaG9yID09IG51bGwgPyBkZWZhdWx0cyA6IGxpbmVEZWZhdWx0cyk7XG4gICAgdGhpcy5hbmNob3IgPSBtYXliZUtleXdvcmQoYW5jaG9yLCBcImFuY2hvclwiLCBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0pO1xuICAgIHJlY3RJbnNldHModGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKCFhbmNob3IpIHJlY3RSYWRpaSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7bWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0LCB3aWR0aCwgaGVpZ2h0fSA9IGRpbWVuc2lvbnM7XG4gICAgY29uc3Qge2FuY2hvciwgaW5zZXRUb3AsIGluc2V0UmlnaHQsIGluc2V0Qm90dG9tLCBpbnNldExlZnR9ID0gdGhpcztcbiAgICBjb25zdCB7cngsIHJ5LCByeDF5MSwgcngxeTIsIHJ4MnkxLCByeDJ5Mn0gPSB0aGlzO1xuICAgIGNvbnN0IHgxID0gbWFyZ2luTGVmdCArIGluc2V0TGVmdDtcbiAgICBjb25zdCB4MiA9IHdpZHRoIC0gbWFyZ2luUmlnaHQgLSBpbnNldFJpZ2h0O1xuICAgIGNvbnN0IHkxID0gbWFyZ2luVG9wICsgaW5zZXRUb3A7XG4gICAgY29uc3QgeTIgPSBoZWlnaHQgLSBtYXJnaW5Cb3R0b20gLSBpbnNldEJvdHRvbTtcbiAgICByZXR1cm4gY3JlYXRlKGFuY2hvciA/IFwic3ZnOmxpbmVcIiA6IHJ4MXkxIHx8IHJ4MXkyIHx8IHJ4MnkxIHx8IHJ4MnkyID8gXCJzdmc6cGF0aFwiIDogXCJzdmc6cmVjdFwiLCBjb250ZXh0KVxuICAgICAgLmRhdHVtKDApXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt9KVxuICAgICAgLmNhbGwoXG4gICAgICAgIGFuY2hvciA9PT0gXCJsZWZ0XCJcbiAgICAgICAgICA/IChsaW5lKSA9PiBsaW5lLmF0dHIoXCJ4MVwiLCB4MSkuYXR0cihcIngyXCIsIHgxKS5hdHRyKFwieTFcIiwgeTEpLmF0dHIoXCJ5MlwiLCB5MilcbiAgICAgICAgICA6IGFuY2hvciA9PT0gXCJyaWdodFwiXG4gICAgICAgICAgPyAobGluZSkgPT4gbGluZS5hdHRyKFwieDFcIiwgeDIpLmF0dHIoXCJ4MlwiLCB4MikuYXR0cihcInkxXCIsIHkxKS5hdHRyKFwieTJcIiwgeTIpXG4gICAgICAgICAgOiBhbmNob3IgPT09IFwidG9wXCJcbiAgICAgICAgICA/IChsaW5lKSA9PiBsaW5lLmF0dHIoXCJ4MVwiLCB4MSkuYXR0cihcIngyXCIsIHgyKS5hdHRyKFwieTFcIiwgeTEpLmF0dHIoXCJ5MlwiLCB5MSlcbiAgICAgICAgICA6IGFuY2hvciA9PT0gXCJib3R0b21cIlxuICAgICAgICAgID8gKGxpbmUpID0+IGxpbmUuYXR0cihcIngxXCIsIHgxKS5hdHRyKFwieDJcIiwgeDIpLmF0dHIoXCJ5MVwiLCB5MikuYXR0cihcInkyXCIsIHkyKVxuICAgICAgICAgIDogcngxeTEgfHwgcngxeTIgfHwgcngyeTEgfHwgcngyeTJcbiAgICAgICAgICA/IChwYXRoKSA9PiBwYXRoLmNhbGwoYXBwbHlSb3VuZGVkUmVjdCwgeDEsIHkxLCB4MiwgeTIsIHRoaXMpXG4gICAgICAgICAgOiAocmVjdCkgPT5cbiAgICAgICAgICAgICAgcmVjdFxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4MSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeTEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4MiAtIHgxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkyIC0geTEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCByeClcbiAgICAgICAgICAgICAgICAuYXR0cihcInJ5XCIsIHJ5KVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJhbWUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEZyYW1lKG9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/geo.js":
/*!**********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/geo.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geo: () => (/* binding */ Geo),\n/* harmony export */   geo: () => (/* binding */ geo),\n/* harmony export */   graticule: () => (/* binding */ graticule),\n/* harmony export */   sphere: () => (/* binding */ sphere)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_centroid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/centroid.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/centroid.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nclass Geo extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(options.r, 3);\n    super(\n      data,\n      {\n        x: {value: options.tip ? options.x : null, scale: \"x\", optional: true},\n        y: {value: options.tip ? options.y : null, scale: \"y\", optional: true},\n        r: {value: vr, scale: \"r\", filter: _defined_js__WEBPACK_IMPORTED_MODULE_3__.positive, optional: true},\n        geometry: {value: options.geometry, scale: \"projection\"}\n      },\n      (0,_dot_js__WEBPACK_IMPORTED_MODULE_4__.withDefaultSort)(options),\n      defaults\n    );\n    this.r = cr;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {geometry: G, r: R} = channels;\n    const path = context.path();\n    const {r} = this;\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_3__.negative)(r)) index = [];\n    else if (r !== undefined) path.pointRadius(r);\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform, this, scales)\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyDirectStyles, this)\n          .attr(\"d\", R ? (i) => path.pointRadius(R[i])(G[i]) : (i) => path(G[i]))\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\nfunction geo(data, options = {}) {\n  if (options.tip && options.x === undefined && options.y === undefined) options = (0,_transforms_centroid_js__WEBPACK_IMPORTED_MODULE_7__.centroid)(options);\n  else if (options.geometry === undefined) options = {...options, geometry: _options_js__WEBPACK_IMPORTED_MODULE_2__.identity};\n  return new Geo(data, options);\n}\n\nfunction sphere({strokeWidth = 1.5, ...options} = {}) {\n  return geo({type: \"Sphere\"}, {strokeWidth, ...options});\n}\n\nfunction graticule({strokeOpacity = 0.1, ...options} = {}) {\n  return geo((0,d3__WEBPACK_IMPORTED_MODULE_0__.geoGraticule10)(), {strokeOpacity, ...options});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9nZW8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0c7QUFDWTtBQUNqQjtBQUMyQjtBQUM0QztBQUNwRDtBQUNWOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sa0JBQWtCLDBDQUFJO0FBQzdCLGdDQUFnQztBQUNoQyxxQkFBcUIsK0RBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtFO0FBQzlFLFlBQVksa0VBQWtFO0FBQzlFLFlBQVksK0JBQStCLGlEQUFRLGlCQUFpQjtBQUNwRSxtQkFBbUI7QUFDbkIsT0FBTztBQUNQLE1BQU0sd0RBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsUUFBUSxxREFBUTtBQUNoQjtBQUNBLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBLGdCQUFnQix5REFBa0I7QUFDbEMsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFTywrQkFBK0I7QUFDdEMsbUZBQW1GLGlFQUFRO0FBQzNGLHNEQUFzRCxzQkFBc0IsaURBQVE7QUFDcEY7QUFDQTs7QUFFTyxpQkFBaUIsK0JBQStCLElBQUk7QUFDM0QsY0FBYyxlQUFlLEdBQUcsd0JBQXdCO0FBQ3hEOztBQUVPLG9CQUFvQixpQ0FBaUMsSUFBSTtBQUNoRSxhQUFhLGtEQUFjLEtBQUssMEJBQTBCO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9nZW8uanM/ZmNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dlb0dyYXRpY3VsZTEwfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtuZWdhdGl2ZSwgcG9zaXRpdmV9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2lkZW50aXR5LCBtYXliZU51bWJlckNoYW5uZWx9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2FwcGx5Q2hhbm5lbFN0eWxlcywgYXBwbHlEaXJlY3RTdHlsZXMsIGFwcGx5SW5kaXJlY3RTdHlsZXMsIGFwcGx5VHJhbnNmb3JtfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7Y2VudHJvaWR9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2NlbnRyb2lkLmpzXCI7XG5pbXBvcnQge3dpdGhEZWZhdWx0U29ydH0gZnJvbSBcIi4vZG90LmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiZ2VvXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDFcbn07XG5cbmV4cG9ydCBjbGFzcyBHZW8gZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgW3ZyLCBjcl0gPSBtYXliZU51bWJlckNoYW5uZWwob3B0aW9ucy5yLCAzKTtcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IHt2YWx1ZTogb3B0aW9ucy50aXAgPyBvcHRpb25zLnggOiBudWxsLCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeToge3ZhbHVlOiBvcHRpb25zLnRpcCA/IG9wdGlvbnMueSA6IG51bGwsIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICByOiB7dmFsdWU6IHZyLCBzY2FsZTogXCJyXCIsIGZpbHRlcjogcG9zaXRpdmUsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgZ2VvbWV0cnk6IHt2YWx1ZTogb3B0aW9ucy5nZW9tZXRyeSwgc2NhbGU6IFwicHJvamVjdGlvblwifVxuICAgICAgfSxcbiAgICAgIHdpdGhEZWZhdWx0U29ydChvcHRpb25zKSxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLnIgPSBjcjtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnk6IEcsIHI6IFJ9ID0gY2hhbm5lbHM7XG4gICAgY29uc3QgcGF0aCA9IGNvbnRleHQucGF0aCgpO1xuICAgIGNvbnN0IHtyfSA9IHRoaXM7XG4gICAgaWYgKG5lZ2F0aXZlKHIpKSBpbmRleCA9IFtdO1xuICAgIGVsc2UgaWYgKHIgIT09IHVuZGVmaW5lZCkgcGF0aC5wb2ludFJhZGl1cyhyKTtcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywgc2NhbGVzKVxuICAgICAgLmNhbGwoKGcpID0+IHtcbiAgICAgICAgZy5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcImRcIiwgUiA/IChpKSA9PiBwYXRoLnBvaW50UmFkaXVzKFJbaV0pKEdbaV0pIDogKGkpID0+IHBhdGgoR1tpXSkpXG4gICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscyk7XG4gICAgICB9KVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VvKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAob3B0aW9ucy50aXAgJiYgb3B0aW9ucy54ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy55ID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSBjZW50cm9pZChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy5nZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0gey4uLm9wdGlvbnMsIGdlb21ldHJ5OiBpZGVudGl0eX07XG4gIHJldHVybiBuZXcgR2VvKGRhdGEsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJlKHtzdHJva2VXaWR0aCA9IDEuNSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4gZ2VvKHt0eXBlOiBcIlNwaGVyZVwifSwge3N0cm9rZVdpZHRoLCAuLi5vcHRpb25zfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF0aWN1bGUoe3N0cm9rZU9wYWNpdHkgPSAwLjEsIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgcmV0dXJuIGdlbyhnZW9HcmF0aWN1bGUxMCgpLCB7c3Ryb2tlT3BhY2l0eSwgLi4ub3B0aW9uc30pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/geo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/hexgrid.js":
/*!**************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/hexgrid.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hexgrid: () => (/* binding */ Hexgrid),\n/* harmony export */   hexgrid: () => (/* binding */ hexgrid)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transforms/hexbin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/hexbin.js\");\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\n\nfunction hexgrid(options) {\n  return new Hexgrid(options);\n}\n\nclass Hexgrid extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor({binWidth = 20, clip = true, ...options} = {}) {\n    super(_options_js__WEBPACK_IMPORTED_MODULE_1__.singleton, undefined, {clip, ...options}, defaults);\n    this.binWidth = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(binWidth);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {binWidth} = this;\n    const {marginTop, marginRight, marginBottom, marginLeft, width, height} = dimensions;\n    const x0 = marginLeft - _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.ox,\n      x1 = width - marginRight - _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.ox,\n      y0 = marginTop - _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.oy,\n      y1 = height - marginBottom - _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.oy,\n      rx = binWidth / 2,\n      ry = rx * _symbol_js__WEBPACK_IMPORTED_MODULE_3__.sqrt4_3,\n      hy = ry / 2,\n      wx = rx * 2,\n      wy = ry * 1.5,\n      i0 = Math.floor(x0 / wx),\n      i1 = Math.ceil(x1 / wx),\n      j0 = Math.floor((y0 + hy) / wy),\n      j1 = Math.ceil((y1 - hy) / wy) + 1,\n      path = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path}`;\n      }\n    }\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .datum(0)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyTransform, this, {}, _style_js__WEBPACK_IMPORTED_MODULE_5__.offset + _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.ox, _style_js__WEBPACK_IMPORTED_MODULE_5__.offset + _transforms_hexbin_js__WEBPACK_IMPORTED_MODULE_2__.oy)\n      .call((g) => g.append(\"path\").call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyDirectStyles, this).call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyChannelStyles, this, channels).attr(\"d\", d))\n      .node();\n  }\n}\n\nfunction round(x) {\n  return Math.round(x * 1e3) / 1e3;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9oZXhncmlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0w7QUFDZ0I7QUFDK0Q7QUFDMUU7QUFDVTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTyxzQkFBc0IsMENBQUk7QUFDakMsZUFBZSx3Q0FBd0MsSUFBSTtBQUMzRCxVQUFVLGtEQUFTLGNBQWMsaUJBQWlCO0FBQ2xELG9CQUFvQixtREFBTTtBQUMxQjtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUVBQWlFO0FBQzVFLDRCQUE0QixxREFBRTtBQUM5QixpQ0FBaUMscURBQUU7QUFDbkMsdUJBQXVCLHFEQUFFO0FBQ3pCLG1DQUFtQyxxREFBRTtBQUNyQztBQUNBLGdCQUFnQiwrQ0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxVQUFVLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDaEc7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qix1QkFBdUIsUUFBUTtBQUMvQixpQkFBaUIsNkJBQTZCLEdBQUcsY0FBYyxFQUFFLEtBQUs7QUFDdEU7QUFDQTtBQUNBLFdBQVcsbURBQU07QUFDakI7QUFDQSxZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFVBQVUsRUFBRSw2Q0FBTSxHQUFHLHFEQUFFLEVBQUUsNkNBQU0sR0FBRyxxREFBRTtBQUM5RCx5Q0FBeUMsd0RBQWlCLGFBQWEseURBQWtCO0FBQ3pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2hleGdyaWQuanM/N2ZkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7bnVtYmVyLCBzaW5nbGV0b259IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2FwcGx5Q2hhbm5lbFN0eWxlcywgYXBwbHlEaXJlY3RTdHlsZXMsIGFwcGx5SW5kaXJlY3RTdHlsZXMsIGFwcGx5VHJhbnNmb3JtLCBvZmZzZXR9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHtzcXJ0NF8zfSBmcm9tIFwiLi4vc3ltYm9sLmpzXCI7XG5pbXBvcnQge294LCBveX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvaGV4YmluLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwiaGV4Z3JpZFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VPcGFjaXR5OiAwLjFcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhncmlkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBIZXhncmlkKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgY2xhc3MgSGV4Z3JpZCBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3Rvcih7YmluV2lkdGggPSAyMCwgY2xpcCA9IHRydWUsIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgICBzdXBlcihzaW5nbGV0b24sIHVuZGVmaW5lZCwge2NsaXAsIC4uLm9wdGlvbnN9LCBkZWZhdWx0cyk7XG4gICAgdGhpcy5iaW5XaWR0aCA9IG51bWJlcihiaW5XaWR0aCk7XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3Qge2JpbldpZHRofSA9IHRoaXM7XG4gICAgY29uc3Qge21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgd2lkdGgsIGhlaWdodH0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IHgwID0gbWFyZ2luTGVmdCAtIG94LFxuICAgICAgeDEgPSB3aWR0aCAtIG1hcmdpblJpZ2h0IC0gb3gsXG4gICAgICB5MCA9IG1hcmdpblRvcCAtIG95LFxuICAgICAgeTEgPSBoZWlnaHQgLSBtYXJnaW5Cb3R0b20gLSBveSxcbiAgICAgIHJ4ID0gYmluV2lkdGggLyAyLFxuICAgICAgcnkgPSByeCAqIHNxcnQ0XzMsXG4gICAgICBoeSA9IHJ5IC8gMixcbiAgICAgIHd4ID0gcnggKiAyLFxuICAgICAgd3kgPSByeSAqIDEuNSxcbiAgICAgIGkwID0gTWF0aC5mbG9vcih4MCAvIHd4KSxcbiAgICAgIGkxID0gTWF0aC5jZWlsKHgxIC8gd3gpLFxuICAgICAgajAgPSBNYXRoLmZsb29yKCh5MCArIGh5KSAvIHd5KSxcbiAgICAgIGoxID0gTWF0aC5jZWlsKCh5MSAtIGh5KSAvIHd5KSArIDEsXG4gICAgICBwYXRoID0gYG0wLCR7cm91bmQoLXJ5KX1sJHtyb3VuZChyeCl9LCR7cm91bmQoaHkpfXYke3JvdW5kKHJ5KX1sJHtyb3VuZCgtcngpfSwke3JvdW5kKGh5KX1gO1xuICAgIGxldCBkID0gcGF0aDtcbiAgICBmb3IgKGxldCBqID0gajA7IGogPCBqMTsgKytqKSB7XG4gICAgICBmb3IgKGxldCBpID0gaTA7IGkgPCBpMTsgKytpKSB7XG4gICAgICAgIGQgKz0gYE0ke3JvdW5kKGkgKiB3eCArIChqICYgMSkgKiByeCl9LCR7cm91bmQoaiAqIHd5KX0ke3BhdGh9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuZGF0dW0oMClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywge30sIG9mZnNldCArIG94LCBvZmZzZXQgKyBveSlcbiAgICAgIC5jYWxsKChnKSA9PiBnLmFwcGVuZChcInBhdGhcIikuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcykuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKS5hdHRyKFwiZFwiLCBkKSlcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91bmQoeCkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMWUzKSAvIDFlMztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/hexgrid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/image.js":
/*!************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/image.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Image: () => (/* binding */ Image),\n/* harmony export */   image: () => (/* binding */ image)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../template.js */ \"(ssr)/./node_modules/@observablehq/plot/src/template.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"image\",\n  fill: null,\n  stroke: null\n};\n\n// Tests if the given string is a path: does it start with a dot-slash\n// (./foo.png), dot-dot-slash (../foo.png), or slash (/foo.png)?\nfunction isPath(string) {\n  return /^\\.*\\//.test(string);\n}\n\n// Tests if the given string is a URL (e.g., https://placekitten.com/200/300).\n// The allowed protocols is overly restrictive, but we don’t want to allow any\n// scheme here because it would increase the likelihood of a false positive with\n// a field name that happens to contain a colon.\nfunction isUrl(string) {\n  return /^(blob|data|file|http|https):/i.test(string);\n}\n\n// Disambiguates a constant src definition from a channel. A path or URL string\n// is assumed to be a constant; any other string is assumed to be a field name.\nfunction maybePathChannel(value) {\n  return typeof value === \"string\" && (isPath(value) || isUrl(value)) ? [undefined, value] : [value, undefined];\n}\n\nclass Image extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, options = {}) {\n    let {x, y, r, width, height, rotate, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering} = options;\n    if (r == null) r = undefined;\n    if (r === undefined && width === undefined && height === undefined) width = height = 16;\n    else if (width === undefined && height !== undefined) width = height;\n    else if (height === undefined && width !== undefined) height = width;\n    const [vs, cs] = maybePathChannel(src);\n    const [vr, cr] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(r);\n    const [vw, cw] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(width, cr !== undefined ? cr * 2 : undefined);\n    const [vh, ch] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(height, cr !== undefined ? cr * 2 : undefined);\n    const [va, ca] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(rotate, 0);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        r: {value: vr, scale: \"r\", filter: _defined_js__WEBPACK_IMPORTED_MODULE_2__.positive, optional: true},\n        width: {value: vw, filter: _defined_js__WEBPACK_IMPORTED_MODULE_2__.positive, optional: true},\n        height: {value: vh, filter: _defined_js__WEBPACK_IMPORTED_MODULE_2__.positive, optional: true},\n        rotate: {value: va, optional: true},\n        src: {value: vs, optional: true}\n      },\n      (0,_dot_js__WEBPACK_IMPORTED_MODULE_3__.withDefaultSort)(options),\n      defaults\n    );\n    this.src = cs;\n    this.width = cw;\n    this.rotate = ca;\n    this.height = ch;\n    this.r = cr;\n    this.preserveAspectRatio = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.impliedString)(preserveAspectRatio, \"xMidYMid\");\n    this.crossOrigin = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(crossOrigin);\n    this.frameAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeFrameAnchor)(frameAnchor);\n    this.imageRendering = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.impliedString)(imageRendering, \"auto\");\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, width: W, height: H, r: R, rotate: A, src: S} = channels;\n    const {r, width, height, rotate} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"image\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .attr(\"x\", position(X, W, R, cx, width, r))\n          .attr(\"y\", position(Y, H, R, cy, height, r))\n          .attr(\"width\", W ? (i) => W[i] : width !== undefined ? width : R ? (i) => R[i] * 2 : r * 2)\n          .attr(\"height\", H ? (i) => H[i] : height !== undefined ? height : R ? (i) => R[i] * 2 : r * 2)\n          // TODO: combine x, y, rotate and transform-origin into a single transform\n          .attr(\"transform\", A ? (i) => `rotate(${A[i]})` : rotate ? `rotate(${rotate})` : null)\n          .attr(\"transform-origin\", A || rotate ? (0,_template_js__WEBPACK_IMPORTED_MODULE_6__.template)`${X ? (i) => X[i] : cx}px ${Y ? (i) => Y[i] : cy}px` : null)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"href\", S ? (i) => S[i] : this.src)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"preserveAspectRatio\", this.preserveAspectRatio)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"crossorigin\", this.crossOrigin)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"image-rendering\", this.imageRendering)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"clip-path\", R ? (i) => `circle(${R[i]}px)` : r !== undefined ? `circle(${r}px)` : null)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nfunction position(X, W, R, x, w, r) {\n  return W && X\n    ? (i) => X[i] - W[i] / 2\n    : W\n    ? (i) => x - W[i] / 2\n    : X && w !== undefined\n    ? (i) => X[i] - w / 2\n    : w !== undefined\n    ? x - w / 2\n    : R && X\n    ? (i) => X[i] - R[i]\n    : R\n    ? (i) => x - R[i]\n    : X\n    ? (i) => X[i] - r\n    : x - r;\n}\n\nfunction image(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeTuple)(x, y);\n  return new Image(data, {...options, x, y});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9pbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNQO0FBQ3VEO0FBU2xFO0FBQ29CO0FBQ0Q7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRU8sb0JBQW9CLDBDQUFJO0FBQy9CLGdDQUFnQztBQUNoQyxTQUFTLG9HQUFvRztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUFrQjtBQUN2QyxxQkFBcUIsK0RBQWtCO0FBQ3ZDLHFCQUFxQiwrREFBa0I7QUFDdkMscUJBQXFCLCtEQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxZQUFZLHFDQUFxQztBQUNqRCxZQUFZLCtCQUErQixpREFBUSxpQkFBaUI7QUFDcEUsZ0JBQWdCLG1CQUFtQixpREFBUSxpQkFBaUI7QUFDNUQsaUJBQWlCLG1CQUFtQixpREFBUSxpQkFBaUI7QUFDN0QsaUJBQWlCLDBCQUEwQjtBQUMzQyxjQUFjO0FBQ2QsT0FBTztBQUNQLE1BQU0sd0RBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQWE7QUFDNUMsdUJBQXVCLG1EQUFNO0FBQzdCLHVCQUF1Qiw2REFBZ0I7QUFDdkMsMEJBQTBCLHdEQUFhO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVywwREFBMEQ7QUFDckUsV0FBVywwQkFBMEI7QUFDckMscUJBQXFCLDJEQUFnQjtBQUNyQyxXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWMsU0FBUyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUssd0JBQXdCLE9BQU87QUFDdEYsa0RBQWtELHNEQUFRLEdBQUcscUJBQXFCLEtBQUsscUJBQXFCO0FBQzVHLGdCQUFnQixnREFBUztBQUN6QixnQkFBZ0IsZ0RBQVM7QUFDekIsZ0JBQWdCLGdEQUFTO0FBQ3pCLGdCQUFnQixnREFBUztBQUN6QixnQkFBZ0IsZ0RBQVMsb0NBQW9DLEtBQUssbUNBQW1DLEVBQUU7QUFDdkcsZ0JBQWdCLHlEQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHNCQUFzQixrQkFBa0IsSUFBSTtBQUNuRCxrREFBa0QsdURBQVU7QUFDNUQsMEJBQTBCLGlCQUFpQjtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvaW1hZ2UuanM/NzEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7cG9zaXRpdmV9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge21heWJlRnJhbWVBbmNob3IsIG1heWJlTnVtYmVyQ2hhbm5lbCwgbWF5YmVUdXBsZSwgc3RyaW5nfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtcbiAgYXBwbHlBdHRyLFxuICBhcHBseUNoYW5uZWxTdHlsZXMsXG4gIGFwcGx5RGlyZWN0U3R5bGVzLFxuICBhcHBseUZyYW1lQW5jaG9yLFxuICBhcHBseUluZGlyZWN0U3R5bGVzLFxuICBhcHBseVRyYW5zZm9ybSxcbiAgaW1wbGllZFN0cmluZ1xufSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7d2l0aERlZmF1bHRTb3J0fSBmcm9tIFwiLi9kb3QuanNcIjtcbmltcG9ydCB7dGVtcGxhdGV9IGZyb20gXCIuLi90ZW1wbGF0ZS5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcImltYWdlXCIsXG4gIGZpbGw6IG51bGwsXG4gIHN0cm9rZTogbnVsbFxufTtcblxuLy8gVGVzdHMgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHBhdGg6IGRvZXMgaXQgc3RhcnQgd2l0aCBhIGRvdC1zbGFzaFxuLy8gKC4vZm9vLnBuZyksIGRvdC1kb3Qtc2xhc2ggKC4uL2Zvby5wbmcpLCBvciBzbGFzaCAoL2Zvby5wbmcpP1xuZnVuY3Rpb24gaXNQYXRoKHN0cmluZykge1xuICByZXR1cm4gL15cXC4qXFwvLy50ZXN0KHN0cmluZyk7XG59XG5cbi8vIFRlc3RzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBVUkwgKGUuZy4sIGh0dHBzOi8vcGxhY2VraXR0ZW4uY29tLzIwMC8zMDApLlxuLy8gVGhlIGFsbG93ZWQgcHJvdG9jb2xzIGlzIG92ZXJseSByZXN0cmljdGl2ZSwgYnV0IHdlIGRvbuKAmXQgd2FudCB0byBhbGxvdyBhbnlcbi8vIHNjaGVtZSBoZXJlIGJlY2F1c2UgaXQgd291bGQgaW5jcmVhc2UgdGhlIGxpa2VsaWhvb2Qgb2YgYSBmYWxzZSBwb3NpdGl2ZSB3aXRoXG4vLyBhIGZpZWxkIG5hbWUgdGhhdCBoYXBwZW5zIHRvIGNvbnRhaW4gYSBjb2xvbi5cbmZ1bmN0aW9uIGlzVXJsKHN0cmluZykge1xuICByZXR1cm4gL14oYmxvYnxkYXRhfGZpbGV8aHR0cHxodHRwcyk6L2kudGVzdChzdHJpbmcpO1xufVxuXG4vLyBEaXNhbWJpZ3VhdGVzIGEgY29uc3RhbnQgc3JjIGRlZmluaXRpb24gZnJvbSBhIGNoYW5uZWwuIEEgcGF0aCBvciBVUkwgc3RyaW5nXG4vLyBpcyBhc3N1bWVkIHRvIGJlIGEgY29uc3RhbnQ7IGFueSBvdGhlciBzdHJpbmcgaXMgYXNzdW1lZCB0byBiZSBhIGZpZWxkIG5hbWUuXG5mdW5jdGlvbiBtYXliZVBhdGhDaGFubmVsKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKGlzUGF0aCh2YWx1ZSkgfHwgaXNVcmwodmFsdWUpKSA/IFt1bmRlZmluZWQsIHZhbHVlXSA6IFt2YWx1ZSwgdW5kZWZpbmVkXTtcbn1cblxuZXhwb3J0IGNsYXNzIEltYWdlIGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB7eCwgeSwgciwgd2lkdGgsIGhlaWdodCwgcm90YXRlLCBzcmMsIHByZXNlcnZlQXNwZWN0UmF0aW8sIGNyb3NzT3JpZ2luLCBmcmFtZUFuY2hvciwgaW1hZ2VSZW5kZXJpbmd9ID0gb3B0aW9ucztcbiAgICBpZiAociA9PSBudWxsKSByID0gdW5kZWZpbmVkO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQgJiYgd2lkdGggPT09IHVuZGVmaW5lZCAmJiBoZWlnaHQgPT09IHVuZGVmaW5lZCkgd2lkdGggPSBoZWlnaHQgPSAxNjtcbiAgICBlbHNlIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkICYmIGhlaWdodCAhPT0gdW5kZWZpbmVkKSB3aWR0aCA9IGhlaWdodDtcbiAgICBlbHNlIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCAmJiB3aWR0aCAhPT0gdW5kZWZpbmVkKSBoZWlnaHQgPSB3aWR0aDtcbiAgICBjb25zdCBbdnMsIGNzXSA9IG1heWJlUGF0aENoYW5uZWwoc3JjKTtcbiAgICBjb25zdCBbdnIsIGNyXSA9IG1heWJlTnVtYmVyQ2hhbm5lbChyKTtcbiAgICBjb25zdCBbdncsIGN3XSA9IG1heWJlTnVtYmVyQ2hhbm5lbCh3aWR0aCwgY3IgIT09IHVuZGVmaW5lZCA/IGNyICogMiA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgW3ZoLCBjaF0gPSBtYXliZU51bWJlckNoYW5uZWwoaGVpZ2h0LCBjciAhPT0gdW5kZWZpbmVkID8gY3IgKiAyIDogdW5kZWZpbmVkKTtcbiAgICBjb25zdCBbdmEsIGNhXSA9IG1heWJlTnVtYmVyQ2hhbm5lbChyb3RhdGUsIDApO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeDoge3ZhbHVlOiB4LCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeToge3ZhbHVlOiB5LCBzY2FsZTogXCJ5XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgcjoge3ZhbHVlOiB2ciwgc2NhbGU6IFwiclwiLCBmaWx0ZXI6IHBvc2l0aXZlLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHdpZHRoOiB7dmFsdWU6IHZ3LCBmaWx0ZXI6IHBvc2l0aXZlLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIGhlaWdodDoge3ZhbHVlOiB2aCwgZmlsdGVyOiBwb3NpdGl2ZSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICByb3RhdGU6IHt2YWx1ZTogdmEsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgc3JjOiB7dmFsdWU6IHZzLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICB3aXRoRGVmYXVsdFNvcnQob3B0aW9ucyksXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgdGhpcy5zcmMgPSBjcztcbiAgICB0aGlzLndpZHRoID0gY3c7XG4gICAgdGhpcy5yb3RhdGUgPSBjYTtcbiAgICB0aGlzLmhlaWdodCA9IGNoO1xuICAgIHRoaXMuciA9IGNyO1xuICAgIHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyA9IGltcGxpZWRTdHJpbmcocHJlc2VydmVBc3BlY3RSYXRpbywgXCJ4TWlkWU1pZFwiKTtcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gc3RyaW5nKGNyb3NzT3JpZ2luKTtcbiAgICB0aGlzLmZyYW1lQW5jaG9yID0gbWF5YmVGcmFtZUFuY2hvcihmcmFtZUFuY2hvcik7XG4gICAgdGhpcy5pbWFnZVJlbmRlcmluZyA9IGltcGxpZWRTdHJpbmcoaW1hZ2VSZW5kZXJpbmcsIFwiYXV0b1wiKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBzY2FsZXM7XG4gICAgY29uc3Qge3g6IFgsIHk6IFksIHdpZHRoOiBXLCBoZWlnaHQ6IEgsIHI6IFIsIHJvdGF0ZTogQSwgc3JjOiBTfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHtyLCB3aWR0aCwgaGVpZ2h0LCByb3RhdGV9ID0gdGhpcztcbiAgICBjb25zdCBbY3gsIGN5XSA9IGFwcGx5RnJhbWVBbmNob3IodGhpcywgZGltZW5zaW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt4OiBYICYmIHgsIHk6IFkgJiYgeX0pXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcImltYWdlXCIpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHBvc2l0aW9uKFgsIFcsIFIsIGN4LCB3aWR0aCwgcikpXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIHBvc2l0aW9uKFksIEgsIFIsIGN5LCBoZWlnaHQsIHIpKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgVyA/IChpKSA9PiBXW2ldIDogd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogUiA/IChpKSA9PiBSW2ldICogMiA6IHIgKiAyKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIEggPyAoaSkgPT4gSFtpXSA6IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogUiA/IChpKSA9PiBSW2ldICogMiA6IHIgKiAyKVxuICAgICAgICAgIC8vIFRPRE86IGNvbWJpbmUgeCwgeSwgcm90YXRlIGFuZCB0cmFuc2Zvcm0tb3JpZ2luIGludG8gYSBzaW5nbGUgdHJhbnNmb3JtXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgQSA/IChpKSA9PiBgcm90YXRlKCR7QVtpXX0pYCA6IHJvdGF0ZSA/IGByb3RhdGUoJHtyb3RhdGV9KWAgOiBudWxsKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtLW9yaWdpblwiLCBBIHx8IHJvdGF0ZSA/IHRlbXBsYXRlYCR7WCA/IChpKSA9PiBYW2ldIDogY3h9cHggJHtZID8gKGkpID0+IFlbaV0gOiBjeX1weGAgOiBudWxsKVxuICAgICAgICAgIC5jYWxsKGFwcGx5QXR0ciwgXCJocmVmXCIsIFMgPyAoaSkgPT4gU1tpXSA6IHRoaXMuc3JjKVxuICAgICAgICAgIC5jYWxsKGFwcGx5QXR0ciwgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbylcbiAgICAgICAgICAuY2FsbChhcHBseUF0dHIsIFwiY3Jvc3NvcmlnaW5cIiwgdGhpcy5jcm9zc09yaWdpbilcbiAgICAgICAgICAuY2FsbChhcHBseUF0dHIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIHRoaXMuaW1hZ2VSZW5kZXJpbmcpXG4gICAgICAgICAgLmNhbGwoYXBwbHlBdHRyLCBcImNsaXAtcGF0aFwiLCBSID8gKGkpID0+IGBjaXJjbGUoJHtSW2ldfXB4KWAgOiByICE9PSB1bmRlZmluZWQgPyBgY2lyY2xlKCR7cn1weClgIDogbnVsbClcbiAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3NpdGlvbihYLCBXLCBSLCB4LCB3LCByKSB7XG4gIHJldHVybiBXICYmIFhcbiAgICA/IChpKSA9PiBYW2ldIC0gV1tpXSAvIDJcbiAgICA6IFdcbiAgICA/IChpKSA9PiB4IC0gV1tpXSAvIDJcbiAgICA6IFggJiYgdyAhPT0gdW5kZWZpbmVkXG4gICAgPyAoaSkgPT4gWFtpXSAtIHcgLyAyXG4gICAgOiB3ICE9PSB1bmRlZmluZWRcbiAgICA/IHggLSB3IC8gMlxuICAgIDogUiAmJiBYXG4gICAgPyAoaSkgPT4gWFtpXSAtIFJbaV1cbiAgICA6IFJcbiAgICA/IChpKSA9PiB4IC0gUltpXVxuICAgIDogWFxuICAgID8gKGkpID0+IFhbaV0gLSByXG4gICAgOiB4IC0gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlKGRhdGEsIHt4LCB5LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIGlmIChvcHRpb25zLmZyYW1lQW5jaG9yID09PSB1bmRlZmluZWQpIFt4LCB5XSA9IG1heWJlVHVwbGUoeCwgeSk7XG4gIHJldHVybiBuZXcgSW1hZ2UoZGF0YSwgey4uLm9wdGlvbnMsIHgsIHl9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/image.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/line.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/line.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   line: () => (/* binding */ line),\n/* harmony export */   lineX: () => (/* binding */ lineX),\n/* harmony export */   lineY: () => (/* binding */ lineY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve.js */ \"(ssr)/./node_modules/@observablehq/plot/src/curve.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../marker.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marker.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nclass Line extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\"},\n        y: {value: y, scale: \"y\"},\n        z: {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeZ)(options), optional: true}\n      },\n      options,\n      defaults\n    );\n    this.z = z;\n    this.curve = (0,_curve_js__WEBPACK_IMPORTED_MODULE_3__.maybeCurveAuto)(curve, tension);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_4__.markers)(this, options);\n  }\n  filter(index) {\n    return index;\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== _curve_js__WEBPACK_IMPORTED_MODULE_3__.curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x: X, y: Y} = channels;\n    const {curve} = this;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data((0,_style_js__WEBPACK_IMPORTED_MODULE_6__.groupIndex)(index, [X, Y], this, channels))\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyDirectStyles, this)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_6__.applyGroupedChannelStyles, this, channels)\n          .call(_marker_js__WEBPACK_IMPORTED_MODULE_4__.applyGroupedMarkers, this, channels, context)\n          .attr(\n            \"d\",\n            curve === _curve_js__WEBPACK_IMPORTED_MODULE_3__.curveAuto && context.projection\n              ? sphereLine(context.path(), X, Y)\n              : (0,d3__WEBPACK_IMPORTED_MODULE_0__.line)()\n                  .curve(curve)\n                  .defined((i) => i >= 0)\n                  .x((i) => X[i])\n                  .y((i) => Y[i])\n          )\n      )\n      .node();\n  }\n}\n\nfunction sphereLine(path, X, Y) {\n  X = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers)(X);\n  Y = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers)(Y);\n  return (I) => {\n    let line = [];\n    const lines = [line];\n    for (const i of I) {\n      // Check for undefined value; see groupIndex.\n      if (i === -1) {\n        line = [];\n        lines.push(line);\n      } else {\n        line.push([X[i], Y[i]]);\n      }\n    }\n    return path({type: \"MultiLineString\", coordinates: lines});\n  };\n}\n\nfunction line(data, {x, y, ...options} = {}) {\n  [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Line(data, {...options, x, y});\n}\n\nfunction lineX(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, y = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, ...options} = {}) {\n  return new Line(data, (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_7__.maybeDenseIntervalY)({...options, x, y}));\n}\n\nfunction lineY(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, y = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, ...options} = {}) {\n  return new Line(data, (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_7__.maybeDenseIntervalX)({...options, x, y}));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9saW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNBO0FBQ2lCO0FBQ3RCO0FBQzBCO0FBQ3lCO0FBTzlEO0FBQ3lEOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sbUJBQW1CLDBDQUFJO0FBQzlCLGdDQUFnQztBQUNoQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLE9BQU8sbURBQU07QUFDekIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFjO0FBQy9CLElBQUksbURBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQVU7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakMsZ0JBQWdCLGdFQUF5QjtBQUN6QyxnQkFBZ0IsMkRBQW1CO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQVM7QUFDL0I7QUFDQSxnQkFBZ0Isd0NBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBYTtBQUNuQixNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQTRDO0FBQzdEO0FBQ0E7O0FBRU8scUJBQXFCLGtCQUFrQixJQUFJO0FBQ2xELFdBQVcsdURBQVU7QUFDckIseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFTyxzQkFBc0IsSUFBSSxpREFBUSxNQUFNLGdEQUFPLGNBQWMsSUFBSTtBQUN4RSx3QkFBd0IsdUVBQW1CLEVBQUUsaUJBQWlCO0FBQzlEOztBQUVPLHNCQUFzQixJQUFJLGdEQUFPLE1BQU0saURBQVEsY0FBYyxJQUFJO0FBQ3hFLHdCQUF3Qix1RUFBbUIsRUFBRSxpQkFBaUI7QUFDOUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2xpbmUuanM/NDBiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2xpbmUgYXMgc2hhcGVMaW5lfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtjdXJ2ZUF1dG8sIG1heWJlQ3VydmVBdXRvfSBmcm9tIFwiLi4vY3VydmUuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7YXBwbHlHcm91cGVkTWFya2VycywgbWFya2Vyc30gZnJvbSBcIi4uL21hcmtlci5qc1wiO1xuaW1wb3J0IHtjb2VyY2VOdW1iZXJzLCBpbmRleE9mLCBpZGVudGl0eSwgbWF5YmVUdXBsZSwgbWF5YmVafSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtcbiAgYXBwbHlEaXJlY3RTdHlsZXMsXG4gIGFwcGx5SW5kaXJlY3RTdHlsZXMsXG4gIGFwcGx5VHJhbnNmb3JtLFxuICBhcHBseUdyb3VwZWRDaGFubmVsU3R5bGVzLFxuICBncm91cEluZGV4XG59IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHttYXliZURlbnNlSW50ZXJ2YWxYLCBtYXliZURlbnNlSW50ZXJ2YWxZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9iaW4uanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJsaW5lXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZVdpZHRoOiAxLjUsXG4gIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMVxufTtcblxuZXhwb3J0IGNsYXNzIExpbmUgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gsIHksIHosIGN1cnZlLCB0ZW5zaW9ufSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIn0sXG4gICAgICAgIHk6IHt2YWx1ZTogeSwgc2NhbGU6IFwieVwifSxcbiAgICAgICAgejoge3ZhbHVlOiBtYXliZVoob3B0aW9ucyksIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLmN1cnZlID0gbWF5YmVDdXJ2ZUF1dG8oY3VydmUsIHRlbnNpb24pO1xuICAgIG1hcmtlcnModGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgZmlsdGVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHByb2plY3QoY2hhbm5lbHMsIHZhbHVlcywgY29udGV4dCkge1xuICAgIC8vIEZvciB0aGUgYXV0byBjdXJ2ZSwgcHJvamVjdGlvbiBpcyBoYW5kbGVkIGF0IHJlbmRlci5cbiAgICBpZiAodGhpcy5jdXJ2ZSAhPT0gY3VydmVBdXRvKSB7XG4gICAgICBzdXBlci5wcm9qZWN0KGNoYW5uZWxzLCB2YWx1ZXMsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eDogWCwgeTogWX0gPSBjaGFubmVscztcbiAgICBjb25zdCB7Y3VydmV9ID0gdGhpcztcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywgc2NhbGVzKVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAuZGF0YShncm91cEluZGV4KGluZGV4LCBbWCwgWV0sIHRoaXMsIGNoYW5uZWxzKSlcbiAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlHcm91cGVkQ2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlHcm91cGVkTWFya2VycywgdGhpcywgY2hhbm5lbHMsIGNvbnRleHQpXG4gICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICBcImRcIixcbiAgICAgICAgICAgIGN1cnZlID09PSBjdXJ2ZUF1dG8gJiYgY29udGV4dC5wcm9qZWN0aW9uXG4gICAgICAgICAgICAgID8gc3BoZXJlTGluZShjb250ZXh0LnBhdGgoKSwgWCwgWSlcbiAgICAgICAgICAgICAgOiBzaGFwZUxpbmUoKVxuICAgICAgICAgICAgICAgICAgLmN1cnZlKGN1cnZlKVxuICAgICAgICAgICAgICAgICAgLmRlZmluZWQoKGkpID0+IGkgPj0gMClcbiAgICAgICAgICAgICAgICAgIC54KChpKSA9PiBYW2ldKVxuICAgICAgICAgICAgICAgICAgLnkoKGkpID0+IFlbaV0pXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGhlcmVMaW5lKHBhdGgsIFgsIFkpIHtcbiAgWCA9IGNvZXJjZU51bWJlcnMoWCk7XG4gIFkgPSBjb2VyY2VOdW1iZXJzKFkpO1xuICByZXR1cm4gKEkpID0+IHtcbiAgICBsZXQgbGluZSA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gW2xpbmVdO1xuICAgIGZvciAoY29uc3QgaSBvZiBJKSB7XG4gICAgICAvLyBDaGVjayBmb3IgdW5kZWZpbmVkIHZhbHVlOyBzZWUgZ3JvdXBJbmRleC5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICBsaW5lID0gW107XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnB1c2goW1hbaV0sIFlbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGgoe3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBsaW5lc30pO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZShkYXRhLCB7eCwgeSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICByZXR1cm4gbmV3IExpbmUoZGF0YSwgey4uLm9wdGlvbnMsIHgsIHl9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVYKGRhdGEsIHt4ID0gaWRlbnRpdHksIHkgPSBpbmRleE9mLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIHJldHVybiBuZXcgTGluZShkYXRhLCBtYXliZURlbnNlSW50ZXJ2YWxZKHsuLi5vcHRpb25zLCB4LCB5fSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZVkoZGF0YSwge3ggPSBpbmRleE9mLCB5ID0gaWRlbnRpdHksIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBMaW5lKGRhdGEsIG1heWJlRGVuc2VJbnRlcnZhbFgoey4uLm9wdGlvbnMsIHgsIHl9KSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/line.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/linearRegression.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/linearRegression.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   linearRegressionX: () => (/* binding */ linearRegressionX),\n/* harmony export */   linearRegressionY: () => (/* binding */ linearRegressionY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../stats.js */ \"(ssr)/./node_modules/@observablehq/plot/src/stats.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_bin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transforms/bin.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"linear-regression\",\n  fill: \"currentColor\",\n  fillOpacity: 0.1,\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nclass LinearRegression extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, z, ci = 0.95, precision = 4} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\"},\n        y: {value: y, scale: \"y\"},\n        z: {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeZ)(options), optional: true}\n      },\n      options,\n      defaults\n    );\n    this.z = z;\n    this.ci = +ci;\n    this.precision = +precision;\n    if (!(0 <= this.ci && this.ci < 1)) throw new Error(`invalid ci; not in [0, 1): ${ci}`);\n    if (!(this.precision > 0)) throw new Error(`invalid precision: ${precision}`);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x: X, y: Y, z: Z} = channels;\n    const {ci} = this;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(Z ? (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.groupZ)(index, Z, this.z) : [index])\n          .enter()\n          .call((enter) =>\n            enter\n              .append(\"path\")\n              .attr(\"fill\", \"none\")\n              .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n              .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyGroupedChannelStyles, this, {...channels, fill: null, fillOpacity: null})\n              .attr(\"d\", (I) => this._renderLine(I, X, Y))\n              .call(\n                ci && !(0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNone)(this.fill)\n                  ? (path) =>\n                      path\n                        .select(pathBefore)\n                        .attr(\"stroke\", \"none\")\n                        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n                        .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyGroupedChannelStyles, this, {\n                          ...channels,\n                          stroke: null,\n                          strokeOpacity: null,\n                          strokeWidth: null\n                        })\n                        .attr(\"d\", (I) => this._renderBand(I, X, Y))\n                  : () => {}\n              )\n          )\n      )\n      .node();\n  }\n}\n\nfunction pathBefore() {\n  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"path\"), this);\n}\n\nclass LinearRegressionX extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X, Y) {\n    const {ci, precision} = this;\n    const [y1, y2] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(I, (i) => Y[i]);\n    const f = linearRegressionF(I, Y, X);\n    const g = confidenceIntervalF(I, Y, X, (1 - ci) / 2, f);\n    return (0,d3__WEBPACK_IMPORTED_MODULE_0__.area)()\n      .y((y) => y)\n      .x0((y) => g(y, -1))\n      .x1((y) => g(y, +1))((0,d3__WEBPACK_IMPORTED_MODULE_0__.range)(y1, y2 - precision / 2, precision).concat(y2));\n  }\n  _renderLine(I, X, Y) {\n    const [y1, y2] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(I, (i) => Y[i]);\n    const f = linearRegressionF(I, Y, X);\n    return `M${f(y1)},${y1}L${f(y2)},${y2}`;\n  }\n}\n\nclass LinearRegressionY extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X, Y) {\n    const {ci, precision} = this;\n    const [x1, x2] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(I, (i) => X[i]);\n    const f = linearRegressionF(I, X, Y);\n    const g = confidenceIntervalF(I, X, Y, (1 - ci) / 2, f);\n    return (0,d3__WEBPACK_IMPORTED_MODULE_0__.area)()\n      .x((x) => x)\n      .y0((x) => g(x, -1))\n      .y1((x) => g(x, +1))((0,d3__WEBPACK_IMPORTED_MODULE_0__.range)(x1, x2 - precision / 2, precision).concat(x2));\n  }\n  _renderLine(I, X, Y) {\n    const [x1, x2] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(I, (i) => X[i]);\n    const f = linearRegressionF(I, X, Y);\n    return `M${x1},${f(x1)}L${x2},${f(x2)}`;\n  }\n}\n\nfunction linearRegressionX(\n  data,\n  {y = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, x = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, stroke, fill = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNoneish)(stroke) ? \"currentColor\" : stroke, ...options} = {}\n) {\n  return new LinearRegressionX(data, (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_5__.maybeDenseIntervalY)({...options, x, y, fill, stroke}));\n}\n\nfunction linearRegressionY(\n  data,\n  {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf, y = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, stroke, fill = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNoneish)(stroke) ? \"currentColor\" : stroke, ...options} = {}\n) {\n  return new LinearRegressionY(data, (0,_transforms_bin_js__WEBPACK_IMPORTED_MODULE_5__.maybeDenseIntervalX)({...options, x, y, fill, stroke}));\n}\n\nfunction linearRegressionF(I, X, Y) {\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumX2 = 0;\n  for (const i of I) {\n    const xi = X[i];\n    const yi = Y[i];\n    sumX += xi;\n    sumY += yi;\n    sumXY += xi * yi;\n    sumX2 += xi * xi;\n  }\n  const n = I.length;\n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  return (x) => slope * x + intercept;\n}\n\nfunction confidenceIntervalF(I, X, Y, p, f) {\n  const mean = (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(I, (i) => X[i]) / I.length;\n  let a = 0,\n    b = 0;\n  for (const i of I) {\n    a += (X[i] - mean) ** 2;\n    b += (Y[i] - f(X[i])) ** 2;\n  }\n  const sy = Math.sqrt(b / (I.length - 2));\n  const t = (0,_stats_js__WEBPACK_IMPORTED_MODULE_6__.qt)(p, I.length - 2);\n  return (x, k) => {\n    const Y = f(x);\n    const se = sy * Math.sqrt(1 / I.length + (x - mean) ** 2 / a);\n    return Y + k * t * se;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9saW5lYXJSZWdyZXNzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxRTtBQUNoQztBQUNMO0FBQzJDO0FBQzVDO0FBQ3VGO0FBQ3hDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMENBQUk7QUFDbkMsZ0NBQWdDO0FBQ2hDLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksT0FBTyxtREFBTTtBQUN6QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixHQUFHO0FBQ3pGLHFFQUFxRSxVQUFVO0FBQy9FO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLElBQUk7QUFDZixXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQWlCO0FBQ3JDLG9CQUFvQixnRUFBeUIsU0FBUywyQ0FBMkM7QUFDakc7QUFDQTtBQUNBLHVCQUF1QixtREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBaUI7QUFDL0MsOEJBQThCLGdFQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLDBDQUFVO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIscUJBQXFCLDBDQUFNO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLHdDQUFTO0FBQ3BCO0FBQ0E7QUFDQSwyQkFBMkIseUNBQUs7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBLGVBQWUsTUFBTSxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsR0FBRztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIscUJBQXFCLDBDQUFNO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLHdDQUFTO0FBQ3BCO0FBQ0E7QUFDQSwyQkFBMkIseUNBQUs7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBLGVBQWUsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTTtBQUMxQztBQUNBOztBQUVPO0FBQ1A7QUFDQSxHQUFHLElBQUksZ0RBQU8sTUFBTSxpREFBUSxpQkFBaUIsc0RBQVMsZ0RBQWdEO0FBQ3RHO0FBQ0EscUNBQXFDLHVFQUFtQixFQUFFLCtCQUErQjtBQUN6Rjs7QUFFTztBQUNQO0FBQ0EsR0FBRyxJQUFJLGdEQUFPLE1BQU0saURBQVEsaUJBQWlCLHNEQUFTLGdEQUFnRDtBQUN0RztBQUNBLHFDQUFxQyx1RUFBbUIsRUFBRSwrQkFBK0I7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1Q0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL2xpbmVhclJlZ3Jlc3Npb24uanM/MjMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2V4dGVudCwgcmFuZ2UsIHN1bSwgYXJlYSBhcyBzaGFwZUFyZWEsIG5hbWVzcGFjZXN9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gXCIuLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2lkZW50aXR5LCBpbmRleE9mLCBpc05vbmUsIGlzTm9uZWlzaCwgbWF5YmVafSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtxdH0gZnJvbSBcIi4uL3N0YXRzLmpzXCI7XG5pbXBvcnQge2FwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUdyb3VwZWRDaGFubmVsU3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybSwgZ3JvdXBafSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7bWF5YmVEZW5zZUludGVydmFsWCwgbWF5YmVEZW5zZUludGVydmFsWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmluLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwibGluZWFyLXJlZ3Jlc3Npb25cIixcbiAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgZmlsbE9wYWNpdHk6IDAuMSxcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMS41LFxuICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDFcbn07XG5cbmNsYXNzIExpbmVhclJlZ3Jlc3Npb24gZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gsIHksIHosIGNpID0gMC45NSwgcHJlY2lzaW9uID0gNH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeDoge3ZhbHVlOiB4LCBzY2FsZTogXCJ4XCJ9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIn0sXG4gICAgICAgIHo6IHt2YWx1ZTogbWF5YmVaKG9wdGlvbnMpLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdHNcbiAgICApO1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy5jaSA9ICtjaTtcbiAgICB0aGlzLnByZWNpc2lvbiA9ICtwcmVjaXNpb247XG4gICAgaWYgKCEoMCA8PSB0aGlzLmNpICYmIHRoaXMuY2kgPCAxKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNpOyBub3QgaW4gWzAsIDEpOiAke2NpfWApO1xuICAgIGlmICghKHRoaXMucHJlY2lzaW9uID4gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcmVjaXNpb246ICR7cHJlY2lzaW9ufWApO1xuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4OiBYLCB5OiBZLCB6OiBafSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHtjaX0gPSB0aGlzO1xuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCBzY2FsZXMpXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKFogPyBncm91cFooaW5kZXgsIFosIHRoaXMueikgOiBbaW5kZXhdKVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmNhbGwoKGVudGVyKSA9PlxuICAgICAgICAgICAgZW50ZXJcbiAgICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAgICAgLmNhbGwoYXBwbHlHcm91cGVkQ2hhbm5lbFN0eWxlcywgdGhpcywgey4uLmNoYW5uZWxzLCBmaWxsOiBudWxsLCBmaWxsT3BhY2l0eTogbnVsbH0pXG4gICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCAoSSkgPT4gdGhpcy5fcmVuZGVyTGluZShJLCBYLCBZKSlcbiAgICAgICAgICAgICAgLmNhbGwoXG4gICAgICAgICAgICAgICAgY2kgJiYgIWlzTm9uZSh0aGlzLmZpbGwpXG4gICAgICAgICAgICAgICAgICA/IChwYXRoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QocGF0aEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseUdyb3VwZWRDaGFubmVsU3R5bGVzLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIChJKSA9PiB0aGlzLl9yZW5kZXJCYW5kKEksIFgsIFkpKVxuICAgICAgICAgICAgICAgICAgOiAoKSA9PiB7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoQmVmb3JlKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZXMuc3ZnLCBcInBhdGhcIiksIHRoaXMpO1xufVxuXG5jbGFzcyBMaW5lYXJSZWdyZXNzaW9uWCBleHRlbmRzIExpbmVhclJlZ3Jlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgX3JlbmRlckJhbmQoSSwgWCwgWSkge1xuICAgIGNvbnN0IHtjaSwgcHJlY2lzaW9ufSA9IHRoaXM7XG4gICAgY29uc3QgW3kxLCB5Ml0gPSBleHRlbnQoSSwgKGkpID0+IFlbaV0pO1xuICAgIGNvbnN0IGYgPSBsaW5lYXJSZWdyZXNzaW9uRihJLCBZLCBYKTtcbiAgICBjb25zdCBnID0gY29uZmlkZW5jZUludGVydmFsRihJLCBZLCBYLCAoMSAtIGNpKSAvIDIsIGYpO1xuICAgIHJldHVybiBzaGFwZUFyZWEoKVxuICAgICAgLnkoKHkpID0+IHkpXG4gICAgICAueDAoKHkpID0+IGcoeSwgLTEpKVxuICAgICAgLngxKCh5KSA9PiBnKHksICsxKSkocmFuZ2UoeTEsIHkyIC0gcHJlY2lzaW9uIC8gMiwgcHJlY2lzaW9uKS5jb25jYXQoeTIpKTtcbiAgfVxuICBfcmVuZGVyTGluZShJLCBYLCBZKSB7XG4gICAgY29uc3QgW3kxLCB5Ml0gPSBleHRlbnQoSSwgKGkpID0+IFlbaV0pO1xuICAgIGNvbnN0IGYgPSBsaW5lYXJSZWdyZXNzaW9uRihJLCBZLCBYKTtcbiAgICByZXR1cm4gYE0ke2YoeTEpfSwke3kxfUwke2YoeTIpfSwke3kyfWA7XG4gIH1cbn1cblxuY2xhc3MgTGluZWFyUmVncmVzc2lvblkgZXh0ZW5kcyBMaW5lYXJSZWdyZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIF9yZW5kZXJCYW5kKEksIFgsIFkpIHtcbiAgICBjb25zdCB7Y2ksIHByZWNpc2lvbn0gPSB0aGlzO1xuICAgIGNvbnN0IFt4MSwgeDJdID0gZXh0ZW50KEksIChpKSA9PiBYW2ldKTtcbiAgICBjb25zdCBmID0gbGluZWFyUmVncmVzc2lvbkYoSSwgWCwgWSk7XG4gICAgY29uc3QgZyA9IGNvbmZpZGVuY2VJbnRlcnZhbEYoSSwgWCwgWSwgKDEgLSBjaSkgLyAyLCBmKTtcbiAgICByZXR1cm4gc2hhcGVBcmVhKClcbiAgICAgIC54KCh4KSA9PiB4KVxuICAgICAgLnkwKCh4KSA9PiBnKHgsIC0xKSlcbiAgICAgIC55MSgoeCkgPT4gZyh4LCArMSkpKHJhbmdlKHgxLCB4MiAtIHByZWNpc2lvbiAvIDIsIHByZWNpc2lvbikuY29uY2F0KHgyKSk7XG4gIH1cbiAgX3JlbmRlckxpbmUoSSwgWCwgWSkge1xuICAgIGNvbnN0IFt4MSwgeDJdID0gZXh0ZW50KEksIChpKSA9PiBYW2ldKTtcbiAgICBjb25zdCBmID0gbGluZWFyUmVncmVzc2lvbkYoSSwgWCwgWSk7XG4gICAgcmV0dXJuIGBNJHt4MX0sJHtmKHgxKX1MJHt4Mn0sJHtmKHgyKX1gO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uWChcbiAgZGF0YSxcbiAge3kgPSBpbmRleE9mLCB4ID0gaWRlbnRpdHksIHN0cm9rZSwgZmlsbCA9IGlzTm9uZWlzaChzdHJva2UpID8gXCJjdXJyZW50Q29sb3JcIiA6IHN0cm9rZSwgLi4ub3B0aW9uc30gPSB7fVxuKSB7XG4gIHJldHVybiBuZXcgTGluZWFyUmVncmVzc2lvblgoZGF0YSwgbWF5YmVEZW5zZUludGVydmFsWSh7Li4ub3B0aW9ucywgeCwgeSwgZmlsbCwgc3Ryb2tlfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmVncmVzc2lvblkoXG4gIGRhdGEsXG4gIHt4ID0gaW5kZXhPZiwgeSA9IGlkZW50aXR5LCBzdHJva2UsIGZpbGwgPSBpc05vbmVpc2goc3Ryb2tlKSA/IFwiY3VycmVudENvbG9yXCIgOiBzdHJva2UsIC4uLm9wdGlvbnN9ID0ge31cbikge1xuICByZXR1cm4gbmV3IExpbmVhclJlZ3Jlc3Npb25ZKGRhdGEsIG1heWJlRGVuc2VJbnRlcnZhbFgoey4uLm9wdGlvbnMsIHgsIHksIGZpbGwsIHN0cm9rZX0pKTtcbn1cblxuZnVuY3Rpb24gbGluZWFyUmVncmVzc2lvbkYoSSwgWCwgWSkge1xuICBsZXQgc3VtWCA9IDAsXG4gICAgc3VtWSA9IDAsXG4gICAgc3VtWFkgPSAwLFxuICAgIHN1bVgyID0gMDtcbiAgZm9yIChjb25zdCBpIG9mIEkpIHtcbiAgICBjb25zdCB4aSA9IFhbaV07XG4gICAgY29uc3QgeWkgPSBZW2ldO1xuICAgIHN1bVggKz0geGk7XG4gICAgc3VtWSArPSB5aTtcbiAgICBzdW1YWSArPSB4aSAqIHlpO1xuICAgIHN1bVgyICs9IHhpICogeGk7XG4gIH1cbiAgY29uc3QgbiA9IEkubGVuZ3RoO1xuICBjb25zdCBzbG9wZSA9IChuICogc3VtWFkgLSBzdW1YICogc3VtWSkgLyAobiAqIHN1bVgyIC0gc3VtWCAqIHN1bVgpO1xuICBjb25zdCBpbnRlcmNlcHQgPSAoc3VtWSAtIHNsb3BlICogc3VtWCkgLyBuO1xuICByZXR1cm4gKHgpID0+IHNsb3BlICogeCArIGludGVyY2VwdDtcbn1cblxuZnVuY3Rpb24gY29uZmlkZW5jZUludGVydmFsRihJLCBYLCBZLCBwLCBmKSB7XG4gIGNvbnN0IG1lYW4gPSBzdW0oSSwgKGkpID0+IFhbaV0pIC8gSS5sZW5ndGg7XG4gIGxldCBhID0gMCxcbiAgICBiID0gMDtcbiAgZm9yIChjb25zdCBpIG9mIEkpIHtcbiAgICBhICs9IChYW2ldIC0gbWVhbikgKiogMjtcbiAgICBiICs9IChZW2ldIC0gZihYW2ldKSkgKiogMjtcbiAgfVxuICBjb25zdCBzeSA9IE1hdGguc3FydChiIC8gKEkubGVuZ3RoIC0gMikpO1xuICBjb25zdCB0ID0gcXQocCwgSS5sZW5ndGggLSAyKTtcbiAgcmV0dXJuICh4LCBrKSA9PiB7XG4gICAgY29uc3QgWSA9IGYoeCk7XG4gICAgY29uc3Qgc2UgPSBzeSAqIE1hdGguc3FydCgxIC8gSS5sZW5ndGggKyAoeCAtIG1lYW4pICoqIDIgLyBhKTtcbiAgICByZXR1cm4gWSArIGsgKiB0ICogc2U7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/linearRegression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/link.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/link.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   link: () => (/* binding */ link),\n/* harmony export */   maybeSameValue: () => (/* binding */ maybeSameValue)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../curve.js */ \"(ssr)/./node_modules/@observablehq/plot/src/curve.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../marker.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marker.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nclass Link extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2, curve, tension} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    this.curve = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.maybeCurveAuto)(curve, tension);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_3__.markers)(this, options);\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== _curve_js__WEBPACK_IMPORTED_MODULE_2__.curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1} = channels;\n    const {curve} = this;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyDirectStyles, this)\n          .attr(\n            \"d\",\n            curve === _curve_js__WEBPACK_IMPORTED_MODULE_2__.curveAuto && context.projection\n              ? sphereLink(context.path(), X1, Y1, X2, Y2)\n              : (i) => {\n                  const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                  const c = curve(p);\n                  c.lineStart();\n                  c.point(X1[i], Y1[i]);\n                  c.point(X2[i], Y2[i]);\n                  c.lineEnd();\n                  return p;\n                }\n          )\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyChannelStyles, this, channels)\n          .call(_marker_js__WEBPACK_IMPORTED_MODULE_3__.applyMarkers, this, channels, context)\n      )\n      .node();\n  }\n}\n\nfunction sphereLink(path, X1, Y1, X2, Y2) {\n  X1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.coerceNumbers)(X1);\n  Y1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.coerceNumbers)(Y1);\n  X2 = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.coerceNumbers)(X2);\n  Y2 = (0,_options_js__WEBPACK_IMPORTED_MODULE_6__.coerceNumbers)(Y2);\n  return (i) =>\n    path({\n      type: \"LineString\",\n      coordinates: [\n        [X1[i], Y1[i]],\n        [X2[i], Y2[i]]\n      ]\n    });\n}\n\nfunction link(data, {x, x1, x2, y, y1, y2, ...options} = {}) {\n  [x1, x2] = maybeSameValue(x, x1, x2);\n  [y1, y2] = maybeSameValue(y, y1, y2);\n  return new Link(data, {...options, x1, x2, y1, y2});\n}\n\n// If x1 and x2 are specified, return them as {x1, x2}.\n// If x and x1 and specified, or x and x2 are specified, return them as {x1, x2}.\n// If only x, x1, or x2 are specified, return it as {x1}.\nfunction maybeSameValue(x, x1, x2) {\n  if (x === undefined) {\n    if (x1 === undefined) {\n      if (x2 !== undefined) return [x2];\n    } else {\n      if (x2 === undefined) return [x1];\n    }\n  } else if (x1 === undefined) {\n    return x2 === undefined ? [x] : [x, x2];\n  } else if (x2 === undefined) {\n    return [x, x1];\n  }\n  return [x1, x2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNpQjtBQUN0QjtBQUNtQjtBQUNQO0FBQzJEOztBQUV2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sbUJBQW1CLDBDQUFJO0FBQzlCLGdDQUFnQztBQUNoQyxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBYztBQUMvQixJQUFJLG1EQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0IsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQVM7QUFDL0I7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFrQjtBQUNsQyxnQkFBZ0Isb0RBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLDBEQUFhO0FBQ3BCLE9BQU8sMERBQWE7QUFDcEIsT0FBTywwREFBYTtBQUNwQixPQUFPLDBEQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVPLHFCQUFxQixrQ0FBa0MsSUFBSTtBQUNsRTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDs7QUFFQSwrQ0FBK0MsT0FBTztBQUN0RCx5RUFBeUUsT0FBTztBQUNoRixxREFBcUQsR0FBRztBQUNqRDtBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9saW5rLmpzP2MyYTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwYXRoUm91bmQgYXMgcGF0aH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7Y3VydmVBdXRvLCBtYXliZUN1cnZlQXV0b30gZnJvbSBcIi4uL2N1cnZlLmpzXCI7XG5pbXBvcnQge01hcmt9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge21hcmtlcnMsIGFwcGx5TWFya2Vyc30gZnJvbSBcIi4uL21hcmtlci5qc1wiO1xuaW1wb3J0IHtjb2VyY2VOdW1iZXJzfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseUNoYW5uZWxTdHlsZXMsIGFwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybX0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwibGlua1wiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxXG59O1xuXG5leHBvcnQgY2xhc3MgTGluayBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7eDEsIHkxLCB4MiwgeTIsIGN1cnZlLCB0ZW5zaW9ufSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4MToge3ZhbHVlOiB4MSwgc2NhbGU6IFwieFwifSxcbiAgICAgICAgeTE6IHt2YWx1ZTogeTEsIHNjYWxlOiBcInlcIn0sXG4gICAgICAgIHgyOiB7dmFsdWU6IHgyLCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeTI6IHt2YWx1ZTogeTIsIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLmN1cnZlID0gbWF5YmVDdXJ2ZUF1dG8oY3VydmUsIHRlbnNpb24pO1xuICAgIG1hcmtlcnModGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgcHJvamVjdChjaGFubmVscywgdmFsdWVzLCBjb250ZXh0KSB7XG4gICAgLy8gRm9yIHRoZSBhdXRvIGN1cnZlLCBwcm9qZWN0aW9uIGlzIGhhbmRsZWQgYXQgcmVuZGVyLlxuICAgIGlmICh0aGlzLmN1cnZlICE9PSBjdXJ2ZUF1dG8pIHtcbiAgICAgIHN1cGVyLnByb2plY3QoY2hhbm5lbHMsIHZhbHVlcywgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4MTogWDEsIHkxOiBZMSwgeDI6IFgyID0gWDEsIHkyOiBZMiA9IFkxfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHtjdXJ2ZX0gPSB0aGlzO1xuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCBzY2FsZXMpXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgIFwiZFwiLFxuICAgICAgICAgICAgY3VydmUgPT09IGN1cnZlQXV0byAmJiBjb250ZXh0LnByb2plY3Rpb25cbiAgICAgICAgICAgICAgPyBzcGhlcmVMaW5rKGNvbnRleHQucGF0aCgpLCBYMSwgWTEsIFgyLCBZMilcbiAgICAgICAgICAgICAgOiAoaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjdXJ2ZShwKTtcbiAgICAgICAgICAgICAgICAgIGMubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICBjLnBvaW50KFgxW2ldLCBZMVtpXSk7XG4gICAgICAgICAgICAgICAgICBjLnBvaW50KFgyW2ldLCBZMltpXSk7XG4gICAgICAgICAgICAgICAgICBjLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscylcbiAgICAgICAgICAuY2FsbChhcHBseU1hcmtlcnMsIHRoaXMsIGNoYW5uZWxzLCBjb250ZXh0KVxuICAgICAgKVxuICAgICAgLm5vZGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGhlcmVMaW5rKHBhdGgsIFgxLCBZMSwgWDIsIFkyKSB7XG4gIFgxID0gY29lcmNlTnVtYmVycyhYMSk7XG4gIFkxID0gY29lcmNlTnVtYmVycyhZMSk7XG4gIFgyID0gY29lcmNlTnVtYmVycyhYMik7XG4gIFkyID0gY29lcmNlTnVtYmVycyhZMik7XG4gIHJldHVybiAoaSkgPT5cbiAgICBwYXRoKHtcbiAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgW1gxW2ldLCBZMVtpXV0sXG4gICAgICAgIFtYMltpXSwgWTJbaV1dXG4gICAgICBdXG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rKGRhdGEsIHt4LCB4MSwgeDIsIHksIHkxLCB5MiwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBbeDEsIHgyXSA9IG1heWJlU2FtZVZhbHVlKHgsIHgxLCB4Mik7XG4gIFt5MSwgeTJdID0gbWF5YmVTYW1lVmFsdWUoeSwgeTEsIHkyKTtcbiAgcmV0dXJuIG5ldyBMaW5rKGRhdGEsIHsuLi5vcHRpb25zLCB4MSwgeDIsIHkxLCB5Mn0pO1xufVxuXG4vLyBJZiB4MSBhbmQgeDIgYXJlIHNwZWNpZmllZCwgcmV0dXJuIHRoZW0gYXMge3gxLCB4Mn0uXG4vLyBJZiB4IGFuZCB4MSBhbmQgc3BlY2lmaWVkLCBvciB4IGFuZCB4MiBhcmUgc3BlY2lmaWVkLCByZXR1cm4gdGhlbSBhcyB7eDEsIHgyfS5cbi8vIElmIG9ubHkgeCwgeDEsIG9yIHgyIGFyZSBzcGVjaWZpZWQsIHJldHVybiBpdCBhcyB7eDF9LlxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlU2FtZVZhbHVlKHgsIHgxLCB4Mikge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHgxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh4MiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gW3gyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHJldHVybiBbeDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHgyID09PSB1bmRlZmluZWQgPyBbeF0gOiBbeCwgeDJdO1xuICB9IGVsc2UgaWYgKHgyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3gsIHgxXTtcbiAgfVxuICByZXR1cm4gW3gxLCB4Ml07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/link.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/raster.js":
/*!*************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/raster.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractRaster: () => (/* binding */ AbstractRaster),\n/* harmony export */   Raster: () => (/* binding */ Raster),\n/* harmony export */   interpolateNearest: () => (/* binding */ interpolateNearest),\n/* harmony export */   interpolateNone: () => (/* binding */ interpolateNone),\n/* harmony export */   interpolatorBarycentric: () => (/* binding */ interpolatorBarycentric),\n/* harmony export */   interpolatorRandomWalk: () => (/* binding */ interpolatorRandomWalk),\n/* harmony export */   maybeTuples: () => (/* binding */ maybeTuples),\n/* harmony export */   raster: () => (/* binding */ raster),\n/* harmony export */   rasterBounds: () => (/* binding */ rasterBounds),\n/* harmony export */   sampler: () => (/* binding */ sampler)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\n\nfunction number(input, name) {\n  const x = +input;\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\n\nfunction integer(input, name) {\n  const x = Math.floor(input);\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\n\nclass AbstractRaster extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, channels, options = {}, defaults) {\n    let {\n      width,\n      height,\n      x,\n      y,\n      x1 = x == null ? 0 : undefined,\n      y1 = y == null ? 0 : undefined,\n      x2 = x == null ? width : undefined,\n      y2 = y == null ? height : undefined,\n      pixelSize = defaults.pixelSize,\n      blur = 0,\n      interpolate\n    } = options;\n    if (width != null) width = integer(width, \"width\");\n    if (height != null) height = integer(height, \"height\");\n    // These represent the (minimum) bounds of the raster; they are not\n    // evaluated for each datum. Also, if x and y are not specified explicitly,\n    // then these bounds are used to compute the dense linear grid.\n    if (x1 != null) x1 = number(x1, \"x1\");\n    if (y1 != null) y1 = number(y1, \"y1\");\n    if (x2 != null) x2 = number(x2, \"x2\");\n    if (y2 != null) y2 = number(y2, \"y2\");\n    if (x == null && (x1 == null || x2 == null)) throw new Error(\"missing x\");\n    if (y == null && (y1 == null || y2 == null)) throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      // If x and y are not given, assume the data is a dense array of samples\n      // covering the entire grid in row-major order. These defaults allow\n      // further shorthand where x and y represent grid column and row index.\n      // TODO If we know that the x and y scales are linear, then we could avoid\n      // materializing these columns to improve performance.\n      if (x === undefined && x1 != null && x2 != null) x = denseX(x1, x2, width, height);\n      if (y === undefined && y1 != null && y2 != null) y = denseY(y1, y2, width, height);\n    }\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        x1: {value: x1 == null ? null : [x1], scale: \"x\", optional: true, filter: null},\n        y1: {value: y1 == null ? null : [y1], scale: \"y\", optional: true, filter: null},\n        x2: {value: x2 == null ? null : [x2], scale: \"x\", optional: true, filter: null},\n        y2: {value: y2 == null ? null : [y2], scale: \"y\", optional: true, filter: null},\n        ...channels\n      },\n      options,\n      defaults\n    );\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number(pixelSize, \"pixelSize\");\n    this.blur = number(blur, \"blur\");\n    this.interpolate = x == null || y == null ? null : maybeInterpolate(interpolate); // interpolation requires x & y\n  }\n}\n\nclass Raster extends AbstractRaster {\n  constructor(data, options = {}) {\n    const {imageRendering} = options;\n    if (data == null) {\n      const {fill, fillOpacity} = options;\n      if ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(fillOpacity)[0] !== undefined) options = sampler(\"fillOpacity\", options);\n      if ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeColorChannel)(fill)[0] !== undefined) options = sampler(\"fill\", options);\n    }\n    super(data, undefined, options, defaults);\n    this.imageRendering = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.impliedString)(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, {color, ...scales}, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index, scales, values, dimensions, context) {\n    const color = scales[values.channels.fill?.scale] ?? ((x) => x);\n    const {x: X, y: Y} = values;\n    const {document} = context;\n    const [x1, y1, x2, y2] = renderBounds(values, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = this;\n    const n = w * h;\n\n    // Interpolate the samples to fill the raster grid. If interpolate is null,\n    // then a continuous function is being sampled, and the raster grid is\n    // already aligned with the canvas.\n    let {fill: F, fillOpacity: FO} = values;\n    let offset = 0;\n    if (this.interpolate) {\n      const kx = w / dx;\n      const ky = h / dy;\n      const IX = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.map)(X, (x) => (x - x1) * kx, Float64Array);\n      const IY = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.map)(Y, (y) => (y - y1) * ky, Float64Array);\n      if (F) F = this.interpolate(index, w, h, IX, IY, F);\n      if (FO) FO = this.interpolate(index, w, h, IX, IY, FO);\n    }\n\n    // When faceting without interpolation, as when sampling a continuous\n    // function, offset into the dense grid based on the current facet index.\n    else if (this.data == null && index) offset = index.fi * n;\n\n    // Render the raster grid to the canvas, blurring if needed.\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image = context2d.createImageData(w, h);\n    const imageData = image.data;\n    let {r, g, b} = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rgb)(this.fill) ?? {r: 0, g: 0, b: 0};\n    let a = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color(F[i + offset]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({r, g, b} = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rgb)(fi));\n      }\n      if (FO) a = FO[i + offset] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a;\n    }\n    if (this.blur > 0) (0,d3__WEBPACK_IMPORTED_MODULE_0__.blurImage)(image, this.blur);\n    context2d.putImageData(image, 0, 0);\n\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, this, scales)\n      .call((g) =>\n        g\n          .append(\"image\")\n          .attr(\"transform\", `translate(${x1},${y1}) scale(${Math.sign(x2 - x1)},${Math.sign(y2 - y1)})`)\n          .attr(\"width\", Math.abs(dx))\n          .attr(\"height\", Math.abs(dy))\n          .attr(\"preserveAspectRatio\", \"none\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyAttr, \"image-rendering\", this.imageRendering)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n          .attr(\"xlink:href\", canvas.toDataURL())\n      )\n      .node();\n  }\n}\n\nfunction maybeTuples(k, data, options) {\n  if (arguments.length < 3) (options = data), (data = null);\n  let {x, y, [k]: z, ...rest} = options;\n  // Because we use implicit x and y when z is a function of (x, y), and when\n  // data is a dense grid, we must further disambiguate by testing whether data\n  // contains [x, y, z?] tuples. Hence you can’t use this shorthand with a\n  // transform that lazily generates tuples, but that seems reasonable since\n  // this is just for convenience anyway.\n  if (x === undefined && y === undefined && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTuples)(data)) {\n    (x = _options_js__WEBPACK_IMPORTED_MODULE_2__.first), (y = _options_js__WEBPACK_IMPORTED_MODULE_2__.second);\n    if (z === undefined) z = _options_js__WEBPACK_IMPORTED_MODULE_2__.third;\n  }\n  return [data, {...rest, x, y, [k]: z}];\n}\n\nfunction raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(\n    data,\n    data == null || options.fill !== undefined || options.fillOpacity !== undefined\n      ? options\n      : {...options, fill: _options_js__WEBPACK_IMPORTED_MODULE_2__.identity}\n  );\n}\n\n// See rasterBounds; this version is called during render.\nfunction renderBounds({x1, y1, x2, y2}, dimensions, {projection}) {\n  const {width, height, marginTop, marginRight, marginBottom, marginLeft} = dimensions;\n  return [\n    x1 && projection == null ? x1[0] : marginLeft,\n    y1 && projection == null ? y1[0] : marginTop,\n    x2 && projection == null ? x2[0] : width - marginRight,\n    y2 && projection == null ? y2[0] : height - marginBottom\n  ];\n}\n\n// If x1, y1, x2, y2 were specified, and no projection is in use (and thus the\n// raster grid is necessarily an axis-aligned rectangle), then we can compute\n// tighter bounds for the image, improving resolution.\nfunction rasterBounds({x1, y1, x2, y2}, scales, dimensions, context) {\n  const channels = {};\n  if (x1) channels.x1 = x1;\n  if (y1) channels.y1 = y1;\n  if (x2) channels.x2 = x2;\n  if (y2) channels.y2 = y2;\n  return renderBounds((0,_channel_js__WEBPACK_IMPORTED_MODULE_5__.valueObject)(channels, scales), dimensions, context);\n}\n\n// Evaluates the function with the given name, if it exists, on the raster grid,\n// generating a channel of the same name.\nfunction sampler(name, options = {}) {\n  const {[name]: value} = options;\n  if (typeof value !== \"function\") throw new Error(`invalid ${name}: not a function`);\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_6__.initializer)({...options, [name]: undefined}, function (data, facets, channels, scales, dimensions, context) {\n    const {x, y} = scales;\n    // TODO Allow projections, if invertible.\n    if (!x) throw new Error(\"missing scale: x\");\n    if (!y) throw new Error(\"missing scale: y\");\n    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k} = this;\n    // Note: this must exactly match the defaults in render above!\n    const {width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = options;\n    // TODO Hint to use a typed array when possible?\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx = dx / w;\n    const ky = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [undefined]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x.invert(x1 + xi * kx), y.invert(y1 + yi * ky), facet);\n        }\n      }\n    }\n    return {data: V, facets, channels: {[name]: {value: V, scale: \"auto\"}}};\n  });\n}\n\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\") return interpolate;\n  if (interpolate == null) return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\n\n// Applies a simple forward mapping of samples, binning them into pixels without\n// any blending or interpolation. Note: if multiple samples map to the same\n// pixel, the last one wins; this can introduce bias if the points are not in\n// random order, so use Plot.shuffle to randomize the input if needed.\nfunction interpolateNone(index, width, height, X, Y, V) {\n  const W = new Array(width * height);\n  for (const i of index) {\n    if (X[i] < 0 || X[i] >= width || Y[i] < 0 || Y[i] >= height) continue;\n    W[Math.floor(Y[i]) * width + Math.floor(X[i])] = V[i];\n  }\n  return W;\n}\n\nfunction interpolatorBarycentric({random = (0,d3__WEBPACK_IMPORTED_MODULE_0__.randomLcg)(42)} = {}) {\n  return (index, width, height, X, Y, V) => {\n    // Interpolate the interior of all triangles with barycentric coordinates\n    const {points, triangles, hull} = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(\n      index,\n      (i) => X[i],\n      (i) => Y[i]\n    );\n    const W = new V.constructor(width * height).fill(NaN);\n    const S = new Uint8Array(width * height); // 1 if pixel has been seen.\n    const mix = mixer(V, random);\n\n    for (let i = 0; i < triangles.length; i += 3) {\n      const ta = triangles[i];\n      const tb = triangles[i + 1];\n      const tc = triangles[i + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x1 = Math.min(Ax, Bx, Cx);\n      const x2 = Math.max(Ax, Bx, Cx);\n      const y1 = Math.min(Ay, By, Cy);\n      const y2 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z) continue;\n      const va = V[index[ta]];\n      const vb = V[index[tb]];\n      const vc = V[index[tc]];\n      for (let x = Math.floor(x1); x < x2; ++x) {\n        for (let y = Math.floor(y1); y < y2; ++y) {\n          if (x < 0 || x >= width || y < 0 || y >= height) continue;\n          const xp = x + 0.5; // sample pixel centroids\n          const yp = y + 0.5;\n          const s = Math.sign(z);\n          const ga = (By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx);\n          if (ga * s < 0) continue;\n          const gb = (Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx);\n          if (gb * s < 0) continue;\n          const gc = z - (ga + gb);\n          if (gc * s < 0) continue;\n          const i = x + width * y;\n          W[i] = mix(va, ga / z, vb, gb / z, vc, gc / z, x, y);\n          S[i] = 1;\n        }\n      }\n    }\n    extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix);\n    return W;\n  };\n}\n\n// Extrapolate by finding the closest point on the hull.\nfunction extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix) {\n  X = Float64Array.from(hull, (i) => X[index[i]]);\n  Y = Float64Array.from(hull, (i) => Y[index[i]]);\n  V = Array.from(hull, (i) => V[index[i]]);\n  const n = X.length;\n  const rays = Array.from({length: n}, (_, j) => ray(j, X, Y));\n  let k = 0;\n  for (let y = 0; y < height; ++y) {\n    const yp = y + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const i = x + width * y;\n      if (!S[i]) {\n        const xp = x + 0.5;\n        for (let l = 0; l < n; ++l) {\n          const j = (n + k + (l % 2 ? (l + 1) / 2 : -l / 2)) % n;\n          if (rays[j](xp, yp)) {\n            const t = segmentProject(X.at(j - 1), Y.at(j - 1), X[j], Y[j], xp, yp);\n            W[i] = mix(V.at(j - 1), t, V[j], 1 - t, V[j], 0, x, y);\n            k = j;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Projects a point p = [x, y] onto the line segment [p1, p2], returning the\n// projected coordinates p’ as t in [0, 1] with p’ = t p1 + (1 - t) p2.\nfunction segmentProject(x1, y1, x2, y2, x, y) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const a = dx * (x2 - x) + dy * (y2 - y);\n  const b = dx * (x - x1) + dy * (y - y1);\n  return a > 0 && b > 0 ? a / (a + b) : +(a > b);\n}\n\nfunction cross(xa, ya, xb, yb) {\n  return xa * yb - xb * ya;\n}\n\nfunction ray(j, X, Y) {\n  const n = X.length;\n  const xc = X.at(j - 2);\n  const yc = Y.at(j - 2);\n  const xa = X.at(j - 1);\n  const ya = Y.at(j - 1);\n  const xb = X[j];\n  const yb = Y[j];\n  const xd = X.at(j + 1 - n);\n  const yd = Y.at(j + 1 - n);\n  const dxab = xa - xb;\n  const dyab = ya - yb;\n  const dxca = xc - xa;\n  const dyca = yc - ya;\n  const dxbd = xb - xd;\n  const dybd = yb - yd;\n  const hab = Math.hypot(dxab, dyab);\n  const hca = Math.hypot(dxca, dyca);\n  const hbd = Math.hypot(dxbd, dybd);\n  return (x, y) => {\n    const dxa = x - xa;\n    const dya = y - ya;\n    const dxb = x - xb;\n    const dyb = y - yb;\n    return (\n      cross(dxa, dya, dxb, dyb) > -1e-6 &&\n      cross(dxa, dya, dxab, dyab) * hca - cross(dxa, dya, dxca, dyca) * hab > -1e-6 &&\n      cross(dxb, dyb, dxbd, dybd) * hab - cross(dxb, dyb, dxab, dyab) * hbd <= 0\n    );\n  };\n}\n\nfunction interpolateNearest(index, width, height, X, Y, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(\n    index,\n    (i) => X[i],\n    (i) => Y[i]\n  );\n  // memoization of delaunay.find for the line start (iy) and pixel (ix)\n  let iy, ix;\n  for (let y = 0.5, k = 0; y < height; ++y) {\n    ix = iy;\n    for (let x = 0.5; x < width; ++x, ++k) {\n      ix = delaunay.find(x, y, ix);\n      if (x === 0.5) iy = ix;\n      W[k] = V[index[ix]];\n    }\n  }\n  return W;\n}\n\n// https://observablehq.com/@observablehq/walk-on-spheres-precision\nfunction interpolatorRandomWalk({random = (0,d3__WEBPACK_IMPORTED_MODULE_0__.randomLcg)(42), minDistance = 0.5, maxSteps = 2} = {}) {\n  return (index, width, height, X, Y, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = d3__WEBPACK_IMPORTED_MODULE_0__.Delaunay.from(\n      index,\n      (i) => X[i],\n      (i) => Y[i]\n    );\n    // memoization of delaunay.find for the line start (iy), pixel (ix), and wos step (iw)\n    let iy, ix, iw;\n    for (let y = 0.5, k = 0; y < height; ++y) {\n      ix = iy;\n      for (let x = 0.5; x < width; ++x, ++k) {\n        let cx = x;\n        let cy = y;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x === 0.5) iy = ix;\n        let distance; // distance to closest sample\n        let step = 0; // count of steps for this walk\n        while ((distance = Math.hypot(X[index[iw]] - cx, Y[index[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle = random(x, y, step) * 2 * Math.PI;\n          cx += Math.cos(angle) * distance;\n          cy += Math.sin(angle) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k] = V[index[iw]];\n      }\n    }\n    return W;\n  };\n}\n\nfunction blend(a, ca, b, cb, c, cc) {\n  return ca * a + cb * b + cc * c;\n}\n\nfunction pick(random) {\n  return (a, ca, b, cb, c, cc, x, y) => {\n    const u = random(x, y);\n    return u < ca ? a : u < ca + cb ? b : c;\n  };\n}\n\nfunction mixer(F, random) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(F) || (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal)(F) ? blend : pick(random);\n}\n\nfunction denseX(x1, x2, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X = new Float64Array(n);\n      const kx = (x2 - x1) / width;\n      const x0 = x1 + kx / 2;\n      for (let i = 0; i < n; ++i) X[i] = (i % width) * kx + x0;\n      return X;\n    }\n  };\n}\n\nfunction denseY(y1, y2, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y = new Float64Array(n);\n      const ky = (y2 - y1) / height;\n      const y0 = y1 + ky / 2;\n      for (let i = 0; i < n; ++i) Y[i] = (Math.floor(i / width) % height) * ky + y0;\n      return Y;\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9yYXN0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDYjtBQUNMO0FBQzhEO0FBQy9CO0FBQ3BDO0FBQzZFO0FBQzFEOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyxJQUFJLE1BQU07QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUssSUFBSSxNQUFNO0FBQzFEO0FBQ0E7O0FBRU8sNkJBQTZCLDBDQUFJO0FBQ3hDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxxQ0FBcUM7QUFDakQsYUFBYSwwRUFBMEU7QUFDdkYsYUFBYSwwRUFBMEU7QUFDdkYsYUFBYSwwRUFBMEU7QUFDdkYsYUFBYSwwRUFBMEU7QUFDdkY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTs7QUFFTztBQUNQLGdDQUFnQztBQUNoQyxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLFVBQVUsK0RBQWtCO0FBQzVCLFVBQVUsOERBQWlCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQWE7QUFDdkM7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUdBQWlHO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFHO0FBQ3BCLGlCQUFpQixnREFBRztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLEVBQUUsdUNBQUcsZ0JBQWdCO0FBQ3ZDO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsRUFBRSx1Q0FBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBUztBQUNoQzs7QUFFQSxXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEdBQUcsR0FBRyxHQUFHLFVBQVUsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBUztBQUN6QixnQkFBZ0Isd0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLE9BQU8sdUJBQXVCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscURBQVE7QUFDcEQsU0FBUyw4Q0FBSyxRQUFRLCtDQUFNO0FBQzVCLDZCQUE2Qiw4Q0FBSztBQUNsQztBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrQkFBa0IsaURBQVE7QUFDbkM7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsdUJBQXVCLGVBQWUsZUFBZSxXQUFXO0FBQ2hFLFNBQVMsaUVBQWlFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQVc7QUFDakM7O0FBRUE7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxTQUFTLGVBQWU7QUFDeEIsOERBQThELEtBQUs7QUFDbkUsU0FBUyxpRUFBVyxFQUFFLDhCQUE4QjtBQUNwRCxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxtRkFBbUY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QixTQUFTO0FBQ2pELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sa0NBQWtDLFNBQVMsNkNBQVMsTUFBTSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QixFQUFFLHdDQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxtQkFBbUIsd0NBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLGlDQUFpQyxTQUFTLDZDQUFTLHVDQUF1QyxJQUFJO0FBQ3JHO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsc0RBQVMsT0FBTyx1REFBVTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL3Jhc3Rlci5qcz85NThjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Ymx1ckltYWdlLCBEZWxhdW5heSwgcmFuZG9tTGNnLCByZ2J9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHt2YWx1ZU9iamVjdH0gZnJvbSBcIi4uL2NoYW5uZWwuanNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHttYXAsIGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBpc1R1cGxlcywgaXNOdW1lcmljLCBpc1RlbXBvcmFsLCBpZGVudGl0eX0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7bWF5YmVDb2xvckNoYW5uZWwsIG1heWJlTnVtYmVyQ2hhbm5lbH0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7YXBwbHlBdHRyLCBhcHBseURpcmVjdFN0eWxlcywgYXBwbHlJbmRpcmVjdFN0eWxlcywgYXBwbHlUcmFuc2Zvcm0sIGltcGxpZWRTdHJpbmd9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHtpbml0aWFsaXplcn0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmFzaWMuanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJyYXN0ZXJcIixcbiAgc3Ryb2tlOiBudWxsLFxuICBwaXhlbFNpemU6IDFcbn07XG5cbmZ1bmN0aW9uIG51bWJlcihpbnB1dCwgbmFtZSkge1xuICBjb25zdCB4ID0gK2lucHV0O1xuICBpZiAoaXNOYU4oeCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCAke25hbWV9OiAke2lucHV0fWApO1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gaW50ZWdlcihpbnB1dCwgbmFtZSkge1xuICBjb25zdCB4ID0gTWF0aC5mbG9vcihpbnB1dCk7XG4gIGlmIChpc05hTih4KSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkICR7bmFtZX06ICR7aW5wdXR9YCk7XG4gIHJldHVybiB4O1xufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RSYXN0ZXIgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgY2hhbm5lbHMsIG9wdGlvbnMgPSB7fSwgZGVmYXVsdHMpIHtcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHgxID0geCA9PSBudWxsID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIHkxID0geSA9PSBudWxsID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIHgyID0geCA9PSBudWxsID8gd2lkdGggOiB1bmRlZmluZWQsXG4gICAgICB5MiA9IHkgPT0gbnVsbCA/IGhlaWdodCA6IHVuZGVmaW5lZCxcbiAgICAgIHBpeGVsU2l6ZSA9IGRlZmF1bHRzLnBpeGVsU2l6ZSxcbiAgICAgIGJsdXIgPSAwLFxuICAgICAgaW50ZXJwb2xhdGVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAod2lkdGggIT0gbnVsbCkgd2lkdGggPSBpbnRlZ2VyKHdpZHRoLCBcIndpZHRoXCIpO1xuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkgaGVpZ2h0ID0gaW50ZWdlcihoZWlnaHQsIFwiaGVpZ2h0XCIpO1xuICAgIC8vIFRoZXNlIHJlcHJlc2VudCB0aGUgKG1pbmltdW0pIGJvdW5kcyBvZiB0aGUgcmFzdGVyOyB0aGV5IGFyZSBub3RcbiAgICAvLyBldmFsdWF0ZWQgZm9yIGVhY2ggZGF0dW0uIEFsc28sIGlmIHggYW5kIHkgYXJlIG5vdCBzcGVjaWZpZWQgZXhwbGljaXRseSxcbiAgICAvLyB0aGVuIHRoZXNlIGJvdW5kcyBhcmUgdXNlZCB0byBjb21wdXRlIHRoZSBkZW5zZSBsaW5lYXIgZ3JpZC5cbiAgICBpZiAoeDEgIT0gbnVsbCkgeDEgPSBudW1iZXIoeDEsIFwieDFcIik7XG4gICAgaWYgKHkxICE9IG51bGwpIHkxID0gbnVtYmVyKHkxLCBcInkxXCIpO1xuICAgIGlmICh4MiAhPSBudWxsKSB4MiA9IG51bWJlcih4MiwgXCJ4MlwiKTtcbiAgICBpZiAoeTIgIT0gbnVsbCkgeTIgPSBudW1iZXIoeTIsIFwieTJcIik7XG4gICAgaWYgKHggPT0gbnVsbCAmJiAoeDEgPT0gbnVsbCB8fCB4MiA9PSBudWxsKSkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyB4XCIpO1xuICAgIGlmICh5ID09IG51bGwgJiYgKHkxID09IG51bGwgfHwgeTIgPT0gbnVsbCkpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgeVwiKTtcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmIHdpZHRoICE9IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHggYW5kIHkgYXJlIG5vdCBnaXZlbiwgYXNzdW1lIHRoZSBkYXRhIGlzIGEgZGVuc2UgYXJyYXkgb2Ygc2FtcGxlc1xuICAgICAgLy8gY292ZXJpbmcgdGhlIGVudGlyZSBncmlkIGluIHJvdy1tYWpvciBvcmRlci4gVGhlc2UgZGVmYXVsdHMgYWxsb3dcbiAgICAgIC8vIGZ1cnRoZXIgc2hvcnRoYW5kIHdoZXJlIHggYW5kIHkgcmVwcmVzZW50IGdyaWQgY29sdW1uIGFuZCByb3cgaW5kZXguXG4gICAgICAvLyBUT0RPIElmIHdlIGtub3cgdGhhdCB0aGUgeCBhbmQgeSBzY2FsZXMgYXJlIGxpbmVhciwgdGhlbiB3ZSBjb3VsZCBhdm9pZFxuICAgICAgLy8gbWF0ZXJpYWxpemluZyB0aGVzZSBjb2x1bW5zIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkICYmIHgxICE9IG51bGwgJiYgeDIgIT0gbnVsbCkgeCA9IGRlbnNlWCh4MSwgeDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCAmJiB5MSAhPSBudWxsICYmIHkyICE9IG51bGwpIHkgPSBkZW5zZVkoeTEsIHkyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB4MToge3ZhbHVlOiB4MSA9PSBudWxsID8gbnVsbCA6IFt4MV0sIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWUsIGZpbHRlcjogbnVsbH0sXG4gICAgICAgIHkxOiB7dmFsdWU6IHkxID09IG51bGwgPyBudWxsIDogW3kxXSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZSwgZmlsdGVyOiBudWxsfSxcbiAgICAgICAgeDI6IHt2YWx1ZTogeDIgPT0gbnVsbCA/IG51bGwgOiBbeDJdLCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlLCBmaWx0ZXI6IG51bGx9LFxuICAgICAgICB5Mjoge3ZhbHVlOiB5MiA9PSBudWxsID8gbnVsbCA6IFt5Ml0sIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWUsIGZpbHRlcjogbnVsbH0sXG4gICAgICAgIC4uLmNoYW5uZWxzXG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5waXhlbFNpemUgPSBudW1iZXIocGl4ZWxTaXplLCBcInBpeGVsU2l6ZVwiKTtcbiAgICB0aGlzLmJsdXIgPSBudW1iZXIoYmx1ciwgXCJibHVyXCIpO1xuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSB4ID09IG51bGwgfHwgeSA9PSBudWxsID8gbnVsbCA6IG1heWJlSW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpOyAvLyBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIHggJiB5XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJhc3RlciBleHRlbmRzIEFic3RyYWN0UmFzdGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge2ltYWdlUmVuZGVyaW5nfSA9IG9wdGlvbnM7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgY29uc3Qge2ZpbGwsIGZpbGxPcGFjaXR5fSA9IG9wdGlvbnM7XG4gICAgICBpZiAobWF5YmVOdW1iZXJDaGFubmVsKGZpbGxPcGFjaXR5KVswXSAhPT0gdW5kZWZpbmVkKSBvcHRpb25zID0gc2FtcGxlcihcImZpbGxPcGFjaXR5XCIsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1heWJlQ29sb3JDaGFubmVsKGZpbGwpWzBdICE9PSB1bmRlZmluZWQpIG9wdGlvbnMgPSBzYW1wbGVyKFwiZmlsbFwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3VwZXIoZGF0YSwgdW5kZWZpbmVkLCBvcHRpb25zLCBkZWZhdWx0cyk7XG4gICAgdGhpcy5pbWFnZVJlbmRlcmluZyA9IGltcGxpZWRTdHJpbmcoaW1hZ2VSZW5kZXJpbmcsIFwiYXV0b1wiKTtcbiAgfVxuICAvLyBJZ25vcmUgdGhlIGNvbG9yIHNjYWxlLCBzbyB0aGUgZmlsbCBjaGFubmVsIGlzIHJldHVybmVkIHVuc2NhbGVkLlxuICBzY2FsZShjaGFubmVscywge2NvbG9yLCAuLi5zY2FsZXN9LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLnNjYWxlKGNoYW5uZWxzLCBzY2FsZXMsIGNvbnRleHQpO1xuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCB2YWx1ZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2xvciA9IHNjYWxlc1t2YWx1ZXMuY2hhbm5lbHMuZmlsbD8uc2NhbGVdID8/ICgoeCkgPT4geCk7XG4gICAgY29uc3Qge3g6IFgsIHk6IFl9ID0gdmFsdWVzO1xuICAgIGNvbnN0IHtkb2N1bWVudH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZW5kZXJCb3VuZHModmFsdWVzLCBkaW1lbnNpb25zLCBjb250ZXh0KTtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IHtwaXhlbFNpemU6IGssIHdpZHRoOiB3ID0gTWF0aC5yb3VuZChNYXRoLmFicyhkeCkgLyBrKSwgaGVpZ2h0OiBoID0gTWF0aC5yb3VuZChNYXRoLmFicyhkeSkgLyBrKX0gPSB0aGlzO1xuICAgIGNvbnN0IG4gPSB3ICogaDtcblxuICAgIC8vIEludGVycG9sYXRlIHRoZSBzYW1wbGVzIHRvIGZpbGwgdGhlIHJhc3RlciBncmlkLiBJZiBpbnRlcnBvbGF0ZSBpcyBudWxsLFxuICAgIC8vIHRoZW4gYSBjb250aW51b3VzIGZ1bmN0aW9uIGlzIGJlaW5nIHNhbXBsZWQsIGFuZCB0aGUgcmFzdGVyIGdyaWQgaXNcbiAgICAvLyBhbHJlYWR5IGFsaWduZWQgd2l0aCB0aGUgY2FudmFzLlxuICAgIGxldCB7ZmlsbDogRiwgZmlsbE9wYWNpdHk6IEZPfSA9IHZhbHVlcztcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy5pbnRlcnBvbGF0ZSkge1xuICAgICAgY29uc3Qga3ggPSB3IC8gZHg7XG4gICAgICBjb25zdCBreSA9IGggLyBkeTtcbiAgICAgIGNvbnN0IElYID0gbWFwKFgsICh4KSA9PiAoeCAtIHgxKSAqIGt4LCBGbG9hdDY0QXJyYXkpO1xuICAgICAgY29uc3QgSVkgPSBtYXAoWSwgKHkpID0+ICh5IC0geTEpICoga3ksIEZsb2F0NjRBcnJheSk7XG4gICAgICBpZiAoRikgRiA9IHRoaXMuaW50ZXJwb2xhdGUoaW5kZXgsIHcsIGgsIElYLCBJWSwgRik7XG4gICAgICBpZiAoRk8pIEZPID0gdGhpcy5pbnRlcnBvbGF0ZShpbmRleCwgdywgaCwgSVgsIElZLCBGTyk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBmYWNldGluZyB3aXRob3V0IGludGVycG9sYXRpb24sIGFzIHdoZW4gc2FtcGxpbmcgYSBjb250aW51b3VzXG4gICAgLy8gZnVuY3Rpb24sIG9mZnNldCBpbnRvIHRoZSBkZW5zZSBncmlkIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZhY2V0IGluZGV4LlxuICAgIGVsc2UgaWYgKHRoaXMuZGF0YSA9PSBudWxsICYmIGluZGV4KSBvZmZzZXQgPSBpbmRleC5maSAqIG47XG5cbiAgICAvLyBSZW5kZXIgdGhlIHJhc3RlciBncmlkIHRvIHRoZSBjYW52YXMsIGJsdXJyaW5nIGlmIG5lZWRlZC5cbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgY29uc3QgY29udGV4dDJkID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGNvbnRleHQyZC5jcmVhdGVJbWFnZURhdGEodywgaCk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2UuZGF0YTtcbiAgICBsZXQge3IsIGcsIGJ9ID0gcmdiKHRoaXMuZmlsbCkgPz8ge3I6IDAsIGc6IDAsIGI6IDB9O1xuICAgIGxldCBhID0gKHRoaXMuZmlsbE9wYWNpdHkgPz8gMSkgKiAyNTU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGogPSBpIDw8IDI7XG4gICAgICBpZiAoRikge1xuICAgICAgICBjb25zdCBmaSA9IGNvbG9yKEZbaSArIG9mZnNldF0pO1xuICAgICAgICBpZiAoZmkgPT0gbnVsbCkge1xuICAgICAgICAgIGltYWdlRGF0YVtqICsgM10gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgICh7ciwgZywgYn0gPSByZ2IoZmkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChGTykgYSA9IEZPW2kgKyBvZmZzZXRdICogMjU1O1xuICAgICAgaW1hZ2VEYXRhW2ogKyAwXSA9IHI7XG4gICAgICBpbWFnZURhdGFbaiArIDFdID0gZztcbiAgICAgIGltYWdlRGF0YVtqICsgMl0gPSBiO1xuICAgICAgaW1hZ2VEYXRhW2ogKyAzXSA9IGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmJsdXIgPiAwKSBibHVySW1hZ2UoaW1hZ2UsIHRoaXMuYmx1cik7XG4gICAgY29udGV4dDJkLnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG5cbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywgc2NhbGVzKVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuYXBwZW5kKFwiaW1hZ2VcIilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eDF9LCR7eTF9KSBzY2FsZSgke01hdGguc2lnbih4MiAtIHgxKX0sJHtNYXRoLnNpZ24oeTIgLSB5MSl9KWApXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBNYXRoLmFicyhkeCkpXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgTWF0aC5hYnMoZHkpKVxuICAgICAgICAgIC5hdHRyKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIilcbiAgICAgICAgICAuY2FsbChhcHBseUF0dHIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIHRoaXMuaW1hZ2VSZW5kZXJpbmcpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGNhbnZhcy50b0RhdGFVUkwoKSlcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVHVwbGVzKGssIGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSAob3B0aW9ucyA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBsZXQge3gsIHksIFtrXTogeiwgLi4ucmVzdH0gPSBvcHRpb25zO1xuICAvLyBCZWNhdXNlIHdlIHVzZSBpbXBsaWNpdCB4IGFuZCB5IHdoZW4geiBpcyBhIGZ1bmN0aW9uIG9mICh4LCB5KSwgYW5kIHdoZW5cbiAgLy8gZGF0YSBpcyBhIGRlbnNlIGdyaWQsIHdlIG11c3QgZnVydGhlciBkaXNhbWJpZ3VhdGUgYnkgdGVzdGluZyB3aGV0aGVyIGRhdGFcbiAgLy8gY29udGFpbnMgW3gsIHksIHo/XSB0dXBsZXMuIEhlbmNlIHlvdSBjYW7igJl0IHVzZSB0aGlzIHNob3J0aGFuZCB3aXRoIGFcbiAgLy8gdHJhbnNmb3JtIHRoYXQgbGF6aWx5IGdlbmVyYXRlcyB0dXBsZXMsIGJ1dCB0aGF0IHNlZW1zIHJlYXNvbmFibGUgc2luY2VcbiAgLy8gdGhpcyBpcyBqdXN0IGZvciBjb252ZW5pZW5jZSBhbnl3YXkuXG4gIGlmICh4ID09PSB1bmRlZmluZWQgJiYgeSA9PT0gdW5kZWZpbmVkICYmIGlzVHVwbGVzKGRhdGEpKSB7XG4gICAgKHggPSBmaXJzdCksICh5ID0gc2Vjb25kKTtcbiAgICBpZiAoeiA9PT0gdW5kZWZpbmVkKSB6ID0gdGhpcmQ7XG4gIH1cbiAgcmV0dXJuIFtkYXRhLCB7Li4ucmVzdCwgeCwgeSwgW2tdOiB6fV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYXN0ZXIoKSB7XG4gIGNvbnN0IFtkYXRhLCBvcHRpb25zXSA9IG1heWJlVHVwbGVzKFwiZmlsbFwiLCAuLi5hcmd1bWVudHMpO1xuICByZXR1cm4gbmV3IFJhc3RlcihcbiAgICBkYXRhLFxuICAgIGRhdGEgPT0gbnVsbCB8fCBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZpbGxPcGFjaXR5ICE9PSB1bmRlZmluZWRcbiAgICAgID8gb3B0aW9uc1xuICAgICAgOiB7Li4ub3B0aW9ucywgZmlsbDogaWRlbnRpdHl9XG4gICk7XG59XG5cbi8vIFNlZSByYXN0ZXJCb3VuZHM7IHRoaXMgdmVyc2lvbiBpcyBjYWxsZWQgZHVyaW5nIHJlbmRlci5cbmZ1bmN0aW9uIHJlbmRlckJvdW5kcyh7eDEsIHkxLCB4MiwgeTJ9LCBkaW1lbnNpb25zLCB7cHJvamVjdGlvbn0pIHtcbiAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdH0gPSBkaW1lbnNpb25zO1xuICByZXR1cm4gW1xuICAgIHgxICYmIHByb2plY3Rpb24gPT0gbnVsbCA/IHgxWzBdIDogbWFyZ2luTGVmdCxcbiAgICB5MSAmJiBwcm9qZWN0aW9uID09IG51bGwgPyB5MVswXSA6IG1hcmdpblRvcCxcbiAgICB4MiAmJiBwcm9qZWN0aW9uID09IG51bGwgPyB4MlswXSA6IHdpZHRoIC0gbWFyZ2luUmlnaHQsXG4gICAgeTIgJiYgcHJvamVjdGlvbiA9PSBudWxsID8geTJbMF0gOiBoZWlnaHQgLSBtYXJnaW5Cb3R0b21cbiAgXTtcbn1cblxuLy8gSWYgeDEsIHkxLCB4MiwgeTIgd2VyZSBzcGVjaWZpZWQsIGFuZCBubyBwcm9qZWN0aW9uIGlzIGluIHVzZSAoYW5kIHRodXMgdGhlXG4vLyByYXN0ZXIgZ3JpZCBpcyBuZWNlc3NhcmlseSBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlKSwgdGhlbiB3ZSBjYW4gY29tcHV0ZVxuLy8gdGlnaHRlciBib3VuZHMgZm9yIHRoZSBpbWFnZSwgaW1wcm92aW5nIHJlc29sdXRpb24uXG5leHBvcnQgZnVuY3Rpb24gcmFzdGVyQm91bmRzKHt4MSwgeTEsIHgyLCB5Mn0sIHNjYWxlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICBjb25zdCBjaGFubmVscyA9IHt9O1xuICBpZiAoeDEpIGNoYW5uZWxzLngxID0geDE7XG4gIGlmICh5MSkgY2hhbm5lbHMueTEgPSB5MTtcbiAgaWYgKHgyKSBjaGFubmVscy54MiA9IHgyO1xuICBpZiAoeTIpIGNoYW5uZWxzLnkyID0geTI7XG4gIHJldHVybiByZW5kZXJCb3VuZHModmFsdWVPYmplY3QoY2hhbm5lbHMsIHNjYWxlcyksIGRpbWVuc2lvbnMsIGNvbnRleHQpO1xufVxuXG4vLyBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWUsIGlmIGl0IGV4aXN0cywgb24gdGhlIHJhc3RlciBncmlkLFxuLy8gZ2VuZXJhdGluZyBhIGNoYW5uZWwgb2YgdGhlIHNhbWUgbmFtZS5cbmV4cG9ydCBmdW5jdGlvbiBzYW1wbGVyKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7W25hbWVdOiB2YWx1ZX0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCAke25hbWV9OiBub3QgYSBmdW5jdGlvbmApO1xuICByZXR1cm4gaW5pdGlhbGl6ZXIoey4uLm9wdGlvbnMsIFtuYW1lXTogdW5kZWZpbmVkfSwgZnVuY3Rpb24gKGRhdGEsIGZhY2V0cywgY2hhbm5lbHMsIHNjYWxlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4LCB5fSA9IHNjYWxlcztcbiAgICAvLyBUT0RPIEFsbG93IHByb2plY3Rpb25zLCBpZiBpbnZlcnRpYmxlLlxuICAgIGlmICgheCkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzY2FsZTogeFwiKTtcbiAgICBpZiAoIXkpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2NhbGU6IHlcIik7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJhc3RlckJvdW5kcyhjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zLCBjb250ZXh0KTtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IHtwaXhlbFNpemU6IGt9ID0gdGhpcztcbiAgICAvLyBOb3RlOiB0aGlzIG11c3QgZXhhY3RseSBtYXRjaCB0aGUgZGVmYXVsdHMgaW4gcmVuZGVyIGFib3ZlIVxuICAgIGNvbnN0IHt3aWR0aDogdyA9IE1hdGgucm91bmQoTWF0aC5hYnMoZHgpIC8gayksIGhlaWdodDogaCA9IE1hdGgucm91bmQoTWF0aC5hYnMoZHkpIC8gayl9ID0gb3B0aW9ucztcbiAgICAvLyBUT0RPIEhpbnQgdG8gdXNlIGEgdHlwZWQgYXJyYXkgd2hlbiBwb3NzaWJsZT9cbiAgICBjb25zdCBWID0gbmV3IEFycmF5KHcgKiBoICogKGZhY2V0cyA/IGZhY2V0cy5sZW5ndGggOiAxKSk7XG4gICAgY29uc3Qga3ggPSBkeCAvIHc7XG4gICAgY29uc3Qga3kgPSBkeSAvIGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzID8/IFt1bmRlZmluZWRdKSB7XG4gICAgICBmb3IgKGxldCB5aSA9IDAuNTsgeWkgPCBoOyArK3lpKSB7XG4gICAgICAgIGZvciAobGV0IHhpID0gMC41OyB4aSA8IHc7ICsreGksICsraSkge1xuICAgICAgICAgIFZbaV0gPSB2YWx1ZSh4LmludmVydCh4MSArIHhpICoga3gpLCB5LmludmVydCh5MSArIHlpICoga3kpLCBmYWNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtkYXRhOiBWLCBmYWNldHMsIGNoYW5uZWxzOiB7W25hbWVdOiB7dmFsdWU6IFYsIHNjYWxlOiBcImF1dG9cIn19fTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlSW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpIHtcbiAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW50ZXJwb2xhdGU7XG4gIGlmIChpbnRlcnBvbGF0ZSA9PSBudWxsKSByZXR1cm4gaW50ZXJwb2xhdGVOb25lO1xuICBzd2l0Y2ggKGAke2ludGVycG9sYXRlfWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdGVOb25lO1xuICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdGVOZWFyZXN0O1xuICAgIGNhc2UgXCJiYXJ5Y2VudHJpY1wiOlxuICAgICAgcmV0dXJuIGludGVycG9sYXRvckJhcnljZW50cmljKCk7XG4gICAgY2FzZSBcInJhbmRvbS13YWxrXCI6XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdG9yUmFuZG9tV2FsaygpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnRlcnBvbGF0ZTogJHtpbnRlcnBvbGF0ZX1gKTtcbn1cblxuLy8gQXBwbGllcyBhIHNpbXBsZSBmb3J3YXJkIG1hcHBpbmcgb2Ygc2FtcGxlcywgYmlubmluZyB0aGVtIGludG8gcGl4ZWxzIHdpdGhvdXRcbi8vIGFueSBibGVuZGluZyBvciBpbnRlcnBvbGF0aW9uLiBOb3RlOiBpZiBtdWx0aXBsZSBzYW1wbGVzIG1hcCB0byB0aGUgc2FtZVxuLy8gcGl4ZWwsIHRoZSBsYXN0IG9uZSB3aW5zOyB0aGlzIGNhbiBpbnRyb2R1Y2UgYmlhcyBpZiB0aGUgcG9pbnRzIGFyZSBub3QgaW5cbi8vIHJhbmRvbSBvcmRlciwgc28gdXNlIFBsb3Quc2h1ZmZsZSB0byByYW5kb21pemUgdGhlIGlucHV0IGlmIG5lZWRlZC5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZU5vbmUoaW5kZXgsIHdpZHRoLCBoZWlnaHQsIFgsIFksIFYpIHtcbiAgY29uc3QgVyA9IG5ldyBBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIGZvciAoY29uc3QgaSBvZiBpbmRleCkge1xuICAgIGlmIChYW2ldIDwgMCB8fCBYW2ldID49IHdpZHRoIHx8IFlbaV0gPCAwIHx8IFlbaV0gPj0gaGVpZ2h0KSBjb250aW51ZTtcbiAgICBXW01hdGguZmxvb3IoWVtpXSkgKiB3aWR0aCArIE1hdGguZmxvb3IoWFtpXSldID0gVltpXTtcbiAgfVxuICByZXR1cm4gVztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRvckJhcnljZW50cmljKHtyYW5kb20gPSByYW5kb21MY2coNDIpfSA9IHt9KSB7XG4gIHJldHVybiAoaW5kZXgsIHdpZHRoLCBoZWlnaHQsIFgsIFksIFYpID0+IHtcbiAgICAvLyBJbnRlcnBvbGF0ZSB0aGUgaW50ZXJpb3Igb2YgYWxsIHRyaWFuZ2xlcyB3aXRoIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgY29uc3Qge3BvaW50cywgdHJpYW5nbGVzLCBodWxsfSA9IERlbGF1bmF5LmZyb20oXG4gICAgICBpbmRleCxcbiAgICAgIChpKSA9PiBYW2ldLFxuICAgICAgKGkpID0+IFlbaV1cbiAgICApO1xuICAgIGNvbnN0IFcgPSBuZXcgVi5jb25zdHJ1Y3Rvcih3aWR0aCAqIGhlaWdodCkuZmlsbChOYU4pO1xuICAgIGNvbnN0IFMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7IC8vIDEgaWYgcGl4ZWwgaGFzIGJlZW4gc2Vlbi5cbiAgICBjb25zdCBtaXggPSBtaXhlcihWLCByYW5kb20pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IHRhID0gdHJpYW5nbGVzW2ldO1xuICAgICAgY29uc3QgdGIgPSB0cmlhbmdsZXNbaSArIDFdO1xuICAgICAgY29uc3QgdGMgPSB0cmlhbmdsZXNbaSArIDJdO1xuICAgICAgY29uc3QgQXggPSBwb2ludHNbMiAqIHRhXTtcbiAgICAgIGNvbnN0IEJ4ID0gcG9pbnRzWzIgKiB0Yl07XG4gICAgICBjb25zdCBDeCA9IHBvaW50c1syICogdGNdO1xuICAgICAgY29uc3QgQXkgPSBwb2ludHNbMiAqIHRhICsgMV07XG4gICAgICBjb25zdCBCeSA9IHBvaW50c1syICogdGIgKyAxXTtcbiAgICAgIGNvbnN0IEN5ID0gcG9pbnRzWzIgKiB0YyArIDFdO1xuICAgICAgY29uc3QgeDEgPSBNYXRoLm1pbihBeCwgQngsIEN4KTtcbiAgICAgIGNvbnN0IHgyID0gTWF0aC5tYXgoQXgsIEJ4LCBDeCk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWluKEF5LCBCeSwgQ3kpO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLm1heChBeSwgQnksIEN5KTtcbiAgICAgIGNvbnN0IHogPSAoQnkgLSBDeSkgKiAoQXggLSBDeCkgKyAoQXkgLSBDeSkgKiAoQ3ggLSBCeCk7XG4gICAgICBpZiAoIXopIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmEgPSBWW2luZGV4W3RhXV07XG4gICAgICBjb25zdCB2YiA9IFZbaW5kZXhbdGJdXTtcbiAgICAgIGNvbnN0IHZjID0gVltpbmRleFt0Y11dO1xuICAgICAgZm9yIChsZXQgeCA9IE1hdGguZmxvb3IoeDEpOyB4IDwgeDI7ICsreCkge1xuICAgICAgICBmb3IgKGxldCB5ID0gTWF0aC5mbG9vcih5MSk7IHkgPCB5MjsgKyt5KSB7XG4gICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gd2lkdGggfHwgeSA8IDAgfHwgeSA+PSBoZWlnaHQpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHhwID0geCArIDAuNTsgLy8gc2FtcGxlIHBpeGVsIGNlbnRyb2lkc1xuICAgICAgICAgIGNvbnN0IHlwID0geSArIDAuNTtcbiAgICAgICAgICBjb25zdCBzID0gTWF0aC5zaWduKHopO1xuICAgICAgICAgIGNvbnN0IGdhID0gKEJ5IC0gQ3kpICogKHhwIC0gQ3gpICsgKHlwIC0gQ3kpICogKEN4IC0gQngpO1xuICAgICAgICAgIGlmIChnYSAqIHMgPCAwKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBnYiA9IChDeSAtIEF5KSAqICh4cCAtIEN4KSArICh5cCAtIEN5KSAqIChBeCAtIEN4KTtcbiAgICAgICAgICBpZiAoZ2IgKiBzIDwgMCkgY29udGludWU7XG4gICAgICAgICAgY29uc3QgZ2MgPSB6IC0gKGdhICsgZ2IpO1xuICAgICAgICAgIGlmIChnYyAqIHMgPCAwKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBpID0geCArIHdpZHRoICogeTtcbiAgICAgICAgICBXW2ldID0gbWl4KHZhLCBnYSAvIHosIHZiLCBnYiAvIHosIHZjLCBnYyAvIHosIHgsIHkpO1xuICAgICAgICAgIFNbaV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dHJhcG9sYXRlQmFyeWNlbnRyaWMoVywgUywgWCwgWSwgViwgd2lkdGgsIGhlaWdodCwgaHVsbCwgaW5kZXgsIG1peCk7XG4gICAgcmV0dXJuIFc7XG4gIH07XG59XG5cbi8vIEV4dHJhcG9sYXRlIGJ5IGZpbmRpbmcgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGh1bGwuXG5mdW5jdGlvbiBleHRyYXBvbGF0ZUJhcnljZW50cmljKFcsIFMsIFgsIFksIFYsIHdpZHRoLCBoZWlnaHQsIGh1bGwsIGluZGV4LCBtaXgpIHtcbiAgWCA9IEZsb2F0NjRBcnJheS5mcm9tKGh1bGwsIChpKSA9PiBYW2luZGV4W2ldXSk7XG4gIFkgPSBGbG9hdDY0QXJyYXkuZnJvbShodWxsLCAoaSkgPT4gWVtpbmRleFtpXV0pO1xuICBWID0gQXJyYXkuZnJvbShodWxsLCAoaSkgPT4gVltpbmRleFtpXV0pO1xuICBjb25zdCBuID0gWC5sZW5ndGg7XG4gIGNvbnN0IHJheXMgPSBBcnJheS5mcm9tKHtsZW5ndGg6IG59LCAoXywgaikgPT4gcmF5KGosIFgsIFkpKTtcbiAgbGV0IGsgPSAwO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgY29uc3QgeXAgPSB5ICsgMC41O1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgaSA9IHggKyB3aWR0aCAqIHk7XG4gICAgICBpZiAoIVNbaV0pIHtcbiAgICAgICAgY29uc3QgeHAgPSB4ICsgMC41O1xuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICAgIGNvbnN0IGogPSAobiArIGsgKyAobCAlIDIgPyAobCArIDEpIC8gMiA6IC1sIC8gMikpICUgbjtcbiAgICAgICAgICBpZiAocmF5c1tqXSh4cCwgeXApKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gc2VnbWVudFByb2plY3QoWC5hdChqIC0gMSksIFkuYXQoaiAtIDEpLCBYW2pdLCBZW2pdLCB4cCwgeXApO1xuICAgICAgICAgICAgV1tpXSA9IG1peChWLmF0KGogLSAxKSwgdCwgVltqXSwgMSAtIHQsIFZbal0sIDAsIHgsIHkpO1xuICAgICAgICAgICAgayA9IGo7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gUHJvamVjdHMgYSBwb2ludCBwID0gW3gsIHldIG9udG8gdGhlIGxpbmUgc2VnbWVudCBbcDEsIHAyXSwgcmV0dXJuaW5nIHRoZVxuLy8gcHJvamVjdGVkIGNvb3JkaW5hdGVzIHDigJkgYXMgdCBpbiBbMCwgMV0gd2l0aCBw4oCZID0gdCBwMSArICgxIC0gdCkgcDIuXG5mdW5jdGlvbiBzZWdtZW50UHJvamVjdCh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgY29uc3QgYSA9IGR4ICogKHgyIC0geCkgKyBkeSAqICh5MiAtIHkpO1xuICBjb25zdCBiID0gZHggKiAoeCAtIHgxKSArIGR5ICogKHkgLSB5MSk7XG4gIHJldHVybiBhID4gMCAmJiBiID4gMCA/IGEgLyAoYSArIGIpIDogKyhhID4gYik7XG59XG5cbmZ1bmN0aW9uIGNyb3NzKHhhLCB5YSwgeGIsIHliKSB7XG4gIHJldHVybiB4YSAqIHliIC0geGIgKiB5YTtcbn1cblxuZnVuY3Rpb24gcmF5KGosIFgsIFkpIHtcbiAgY29uc3QgbiA9IFgubGVuZ3RoO1xuICBjb25zdCB4YyA9IFguYXQoaiAtIDIpO1xuICBjb25zdCB5YyA9IFkuYXQoaiAtIDIpO1xuICBjb25zdCB4YSA9IFguYXQoaiAtIDEpO1xuICBjb25zdCB5YSA9IFkuYXQoaiAtIDEpO1xuICBjb25zdCB4YiA9IFhbal07XG4gIGNvbnN0IHliID0gWVtqXTtcbiAgY29uc3QgeGQgPSBYLmF0KGogKyAxIC0gbik7XG4gIGNvbnN0IHlkID0gWS5hdChqICsgMSAtIG4pO1xuICBjb25zdCBkeGFiID0geGEgLSB4YjtcbiAgY29uc3QgZHlhYiA9IHlhIC0geWI7XG4gIGNvbnN0IGR4Y2EgPSB4YyAtIHhhO1xuICBjb25zdCBkeWNhID0geWMgLSB5YTtcbiAgY29uc3QgZHhiZCA9IHhiIC0geGQ7XG4gIGNvbnN0IGR5YmQgPSB5YiAtIHlkO1xuICBjb25zdCBoYWIgPSBNYXRoLmh5cG90KGR4YWIsIGR5YWIpO1xuICBjb25zdCBoY2EgPSBNYXRoLmh5cG90KGR4Y2EsIGR5Y2EpO1xuICBjb25zdCBoYmQgPSBNYXRoLmh5cG90KGR4YmQsIGR5YmQpO1xuICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICBjb25zdCBkeGEgPSB4IC0geGE7XG4gICAgY29uc3QgZHlhID0geSAtIHlhO1xuICAgIGNvbnN0IGR4YiA9IHggLSB4YjtcbiAgICBjb25zdCBkeWIgPSB5IC0geWI7XG4gICAgcmV0dXJuIChcbiAgICAgIGNyb3NzKGR4YSwgZHlhLCBkeGIsIGR5YikgPiAtMWUtNiAmJlxuICAgICAgY3Jvc3MoZHhhLCBkeWEsIGR4YWIsIGR5YWIpICogaGNhIC0gY3Jvc3MoZHhhLCBkeWEsIGR4Y2EsIGR5Y2EpICogaGFiID4gLTFlLTYgJiZcbiAgICAgIGNyb3NzKGR4YiwgZHliLCBkeGJkLCBkeWJkKSAqIGhhYiAtIGNyb3NzKGR4YiwgZHliLCBkeGFiLCBkeWFiKSAqIGhiZCA8PSAwXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlTmVhcmVzdChpbmRleCwgd2lkdGgsIGhlaWdodCwgWCwgWSwgVikge1xuICBjb25zdCBXID0gbmV3IFYuY29uc3RydWN0b3Iod2lkdGggKiBoZWlnaHQpO1xuICBjb25zdCBkZWxhdW5heSA9IERlbGF1bmF5LmZyb20oXG4gICAgaW5kZXgsXG4gICAgKGkpID0+IFhbaV0sXG4gICAgKGkpID0+IFlbaV1cbiAgKTtcbiAgLy8gbWVtb2l6YXRpb24gb2YgZGVsYXVuYXkuZmluZCBmb3IgdGhlIGxpbmUgc3RhcnQgKGl5KSBhbmQgcGl4ZWwgKGl4KVxuICBsZXQgaXksIGl4O1xuICBmb3IgKGxldCB5ID0gMC41LCBrID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgaXggPSBpeTtcbiAgICBmb3IgKGxldCB4ID0gMC41OyB4IDwgd2lkdGg7ICsreCwgKytrKSB7XG4gICAgICBpeCA9IGRlbGF1bmF5LmZpbmQoeCwgeSwgaXgpO1xuICAgICAgaWYgKHggPT09IDAuNSkgaXkgPSBpeDtcbiAgICAgIFdba10gPSBWW2luZGV4W2l4XV07XG4gICAgfVxuICB9XG4gIHJldHVybiBXO1xufVxuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG9ic2VydmFibGVocS93YWxrLW9uLXNwaGVyZXMtcHJlY2lzaW9uXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdG9yUmFuZG9tV2Fsayh7cmFuZG9tID0gcmFuZG9tTGNnKDQyKSwgbWluRGlzdGFuY2UgPSAwLjUsIG1heFN0ZXBzID0gMn0gPSB7fSkge1xuICByZXR1cm4gKGluZGV4LCB3aWR0aCwgaGVpZ2h0LCBYLCBZLCBWKSA9PiB7XG4gICAgY29uc3QgVyA9IG5ldyBWLmNvbnN0cnVjdG9yKHdpZHRoICogaGVpZ2h0KTtcbiAgICBjb25zdCBkZWxhdW5heSA9IERlbGF1bmF5LmZyb20oXG4gICAgICBpbmRleCxcbiAgICAgIChpKSA9PiBYW2ldLFxuICAgICAgKGkpID0+IFlbaV1cbiAgICApO1xuICAgIC8vIG1lbW9pemF0aW9uIG9mIGRlbGF1bmF5LmZpbmQgZm9yIHRoZSBsaW5lIHN0YXJ0IChpeSksIHBpeGVsIChpeCksIGFuZCB3b3Mgc3RlcCAoaXcpXG4gICAgbGV0IGl5LCBpeCwgaXc7XG4gICAgZm9yIChsZXQgeSA9IDAuNSwgayA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgaXggPSBpeTtcbiAgICAgIGZvciAobGV0IHggPSAwLjU7IHggPCB3aWR0aDsgKyt4LCArK2spIHtcbiAgICAgICAgbGV0IGN4ID0geDtcbiAgICAgICAgbGV0IGN5ID0geTtcbiAgICAgICAgaXcgPSBpeCA9IGRlbGF1bmF5LmZpbmQoY3gsIGN5LCBpeCk7XG4gICAgICAgIGlmICh4ID09PSAwLjUpIGl5ID0gaXg7XG4gICAgICAgIGxldCBkaXN0YW5jZTsgLy8gZGlzdGFuY2UgdG8gY2xvc2VzdCBzYW1wbGVcbiAgICAgICAgbGV0IHN0ZXAgPSAwOyAvLyBjb3VudCBvZiBzdGVwcyBmb3IgdGhpcyB3YWxrXG4gICAgICAgIHdoaWxlICgoZGlzdGFuY2UgPSBNYXRoLmh5cG90KFhbaW5kZXhbaXddXSAtIGN4LCBZW2luZGV4W2l3XV0gLSBjeSkpID4gbWluRGlzdGFuY2UgJiYgc3RlcCA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgY29uc3QgYW5nbGUgPSByYW5kb20oeCwgeSwgc3RlcCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjeCArPSBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZTtcbiAgICAgICAgICBjeSArPSBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZTtcbiAgICAgICAgICBpdyA9IGRlbGF1bmF5LmZpbmQoY3gsIGN5LCBpdyk7XG4gICAgICAgICAgKytzdGVwO1xuICAgICAgICB9XG4gICAgICAgIFdba10gPSBWW2luZGV4W2l3XV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBXO1xuICB9O1xufVxuXG5mdW5jdGlvbiBibGVuZChhLCBjYSwgYiwgY2IsIGMsIGNjKSB7XG4gIHJldHVybiBjYSAqIGEgKyBjYiAqIGIgKyBjYyAqIGM7XG59XG5cbmZ1bmN0aW9uIHBpY2socmFuZG9tKSB7XG4gIHJldHVybiAoYSwgY2EsIGIsIGNiLCBjLCBjYywgeCwgeSkgPT4ge1xuICAgIGNvbnN0IHUgPSByYW5kb20oeCwgeSk7XG4gICAgcmV0dXJuIHUgPCBjYSA/IGEgOiB1IDwgY2EgKyBjYiA/IGIgOiBjO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtaXhlcihGLCByYW5kb20pIHtcbiAgcmV0dXJuIGlzTnVtZXJpYyhGKSB8fCBpc1RlbXBvcmFsKEYpID8gYmxlbmQgOiBwaWNrKHJhbmRvbSk7XG59XG5cbmZ1bmN0aW9uIGRlbnNlWCh4MSwgeDIsIHdpZHRoKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtKGRhdGEpIHtcbiAgICAgIGNvbnN0IG4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IFggPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgY29uc3Qga3ggPSAoeDIgLSB4MSkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHgwID0geDEgKyBreCAvIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgWFtpXSA9IChpICUgd2lkdGgpICoga3ggKyB4MDtcbiAgICAgIHJldHVybiBYO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVuc2VZKHkxLCB5Miwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybShkYXRhKSB7XG4gICAgICBjb25zdCBuID0gZGF0YS5sZW5ndGg7XG4gICAgICBjb25zdCBZID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgIGNvbnN0IGt5ID0gKHkyIC0geTEpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgeTAgPSB5MSArIGt5IC8gMjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBZW2ldID0gKE1hdGguZmxvb3IoaSAvIHdpZHRoKSAlIGhlaWdodCkgKiBreSArIHkwO1xuICAgICAgcmV0dXJuIFk7XG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/raster.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/rect.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   applyRoundedRect: () => (/* binding */ applyRoundedRect),\n/* harmony export */   rect: () => (/* binding */ rect),\n/* harmony export */   rectInsets: () => (/* binding */ rectInsets),\n/* harmony export */   rectRadii: () => (/* binding */ rectRadii),\n/* harmony export */   rectX: () => (/* binding */ rectX),\n/* harmony export */   rectY: () => (/* binding */ rectY)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_identity_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transforms/identity.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n/* harmony import */ var _transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/stack.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\");\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"rect\"\n};\n\nclass Rect extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\", type: x1 != null && x2 == null ? \"band\" : undefined, optional: true},\n        y1: {value: y1, scale: \"y\", type: y1 != null && y2 == null ? \"band\" : undefined, optional: true},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    rectInsets(this, options);\n    rectRadii(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    let {x1: X1, y1: Y1, x2: X2, y2: Y2} = channels;\n    const {marginTop, marginRight, marginBottom, marginLeft, width, height} = dimensions;\n    const {projection} = context;\n    const {insetTop, insetRight, insetBottom, insetLeft} = this;\n    const {rx, ry, rx1y1, rx1y2, rx2y1, rx2y2} = this;\n    if ((X1 || X2) && !projection && (0,_scales_js__WEBPACK_IMPORTED_MODULE_1__.isCollapsed)(x)) X1 = X2 = null; // ignore if collapsed\n    if ((Y1 || Y2) && !projection && (0,_scales_js__WEBPACK_IMPORTED_MODULE_1__.isCollapsed)(y)) Y1 = Y2 = null; // ignore if collapsed\n    const bx = x?.bandwidth ? x.bandwidth() : 0;\n    const by = y?.bandwidth ? y.bandwidth() : 0;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, this, {}, 0, 0)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .call(\n            rx1y1 || rx1y2 || rx2y1 || rx2y2\n              ? (g) =>\n                  g\n                    .append(\"path\")\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n                    .call(\n                      applyRoundedRect,\n                      X1 && X2\n                        ? (i) => X1[i] + (X2[i] < X1[i] ? -insetRight : insetLeft)\n                        : X1\n                        ? (i) => X1[i] + insetLeft\n                        : marginLeft + insetLeft,\n                      Y1 && Y2\n                        ? (i) => Y1[i] + (Y2[i] < Y1[i] ? -insetBottom : insetTop)\n                        : Y1\n                        ? (i) => Y1[i] + insetTop\n                        : marginTop + insetTop,\n                      X1 && X2\n                        ? (i) => X2[i] - (X2[i] < X1[i] ? -insetLeft : insetRight)\n                        : X1\n                        ? (i) => X1[i] + bx - insetRight\n                        : width - marginRight - insetRight,\n                      Y1 && Y2\n                        ? (i) => Y2[i] - (Y2[i] < Y1[i] ? -insetTop : insetBottom)\n                        : Y1\n                        ? (i) => Y1[i] + by - insetBottom\n                        : height - marginBottom - insetBottom,\n                      this\n                    )\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n              : (g) =>\n                  g\n                    .append(\"rect\")\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n                    .attr(\n                      \"x\",\n                      X1\n                        ? X2\n                          ? (i) => Math.min(X1[i], X2[i]) + insetLeft\n                          : (i) => X1[i] + insetLeft\n                        : marginLeft + insetLeft\n                    )\n                    .attr(\n                      \"y\",\n                      Y1\n                        ? Y2\n                          ? (i) => Math.min(Y1[i], Y2[i]) + insetTop\n                          : (i) => Y1[i] + insetTop\n                        : marginTop + insetTop\n                    )\n                    .attr(\n                      \"width\",\n                      X1\n                        ? X2\n                          ? (i) => Math.max(0, Math.abs(X2[i] - X1[i]) + bx - insetLeft - insetRight)\n                          : bx - insetLeft - insetRight\n                        : width - marginRight - marginLeft - insetRight - insetLeft\n                    )\n                    .attr(\n                      \"height\",\n                      Y1\n                        ? Y2\n                          ? (i) => Math.max(0, Math.abs(Y1[i] - Y2[i]) + by - insetTop - insetBottom)\n                          : by - insetTop - insetBottom\n                        : height - marginTop - marginBottom - insetTop - insetBottom\n                    )\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyAttr, \"rx\", rx)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyAttr, \"ry\", ry)\n                    .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n          )\n      )\n      .node();\n  }\n}\n\nfunction rectInsets(\n  mark,\n  {inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset} = {}\n) {\n  mark.insetTop = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetTop);\n  mark.insetRight = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetRight);\n  mark.insetBottom = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetBottom);\n  mark.insetLeft = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetLeft);\n}\n\nfunction rectRadii(\n  mark,\n  {\n    r,\n    rx, // for elliptic corners\n    ry, // for elliptic corners\n    rx1 = r,\n    ry1 = r,\n    rx2 = r,\n    ry2 = r,\n    rx1y1 = rx1 !== undefined ? +rx1 : ry1 !== undefined ? +ry1 : 0,\n    rx1y2 = rx1 !== undefined ? +rx1 : ry2 !== undefined ? +ry2 : 0,\n    rx2y1 = rx2 !== undefined ? +rx2 : ry1 !== undefined ? +ry1 : 0,\n    rx2y2 = rx2 !== undefined ? +rx2 : ry2 !== undefined ? +ry2 : 0\n  } = {}\n) {\n  if (rx1y1 || rx1y2 || rx2y1 || rx2y2) {\n    mark.rx1y1 = rx1y1;\n    mark.rx1y2 = rx1y2;\n    mark.rx2y1 = rx2y1;\n    mark.rx2y2 = rx2y2;\n  } else {\n    mark.rx = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.impliedString)(rx, \"auto\"); // number or percentage\n    mark.ry = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.impliedString)(ry, \"auto\");\n  }\n}\n\nfunction applyRoundedRect(selection, X1, Y1, X2, Y2, mark) {\n  const {rx1y1: r11, rx1y2: r12, rx2y1: r21, rx2y2: r22} = mark;\n  if (typeof X1 !== \"function\") X1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.constant)(X1);\n  if (typeof Y1 !== \"function\") Y1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.constant)(Y1);\n  if (typeof X2 !== \"function\") X2 = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.constant)(X2);\n  if (typeof Y2 !== \"function\") Y2 = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.constant)(Y2);\n  const rx = Math.max(Math.abs(r11 + r21), Math.abs(r12 + r22));\n  const ry = Math.max(Math.abs(r11 + r12), Math.abs(r21 + r22));\n  selection.attr(\"d\", (i) => {\n    const x1 = X1(i);\n    const y1 = Y1(i);\n    const x2 = X2(i);\n    const y2 = Y2(i);\n    const ix = x1 > x2;\n    const iy = y1 > y2;\n    const l = ix ? x2 : x1;\n    const r = ix ? x1 : x2;\n    const t = iy ? y2 : y1;\n    const b = iy ? y1 : y2;\n    const k = Math.min(1, (r - l) / rx, (b - t) / ry);\n    const tl = k * (ix ? (iy ? r22 : r21) : iy ? r12 : r11);\n    const tr = k * (ix ? (iy ? r12 : r11) : iy ? r22 : r21);\n    const br = k * (ix ? (iy ? r11 : r12) : iy ? r21 : r22);\n    const bl = k * (ix ? (iy ? r21 : r22) : iy ? r11 : r12);\n    return (\n      `M${l},${t + biasY(tl, bl)}A${tl},${tl} 0 0 ${tl < 0 ? 0 : 1} ${l + biasX(tl, bl)},${t}` +\n      `H${r - biasX(tr, br)}A${tr},${tr} 0 0 ${tr < 0 ? 0 : 1} ${r},${t + biasY(tr, br)}` +\n      `V${b - biasY(br, tr)}A${br},${br} 0 0 ${br < 0 ? 0 : 1} ${r - biasX(br, tr)},${b}` +\n      `H${l + biasX(bl, tl)}A${bl},${bl} 0 0 ${bl < 0 ? 0 : 1} ${l},${b - biasY(bl, tl)}` +\n      `Z`\n    );\n  });\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasX(r1, r2) {\n  return r2 < 0 ? r1 : Math.abs(r1);\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasY(r1, r2) {\n  return r2 < 0 ? Math.abs(r1) : r1;\n}\n\nfunction rect(data, options) {\n  return new Rect(data, (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_5__.maybeTrivialIntervalX)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_5__.maybeTrivialIntervalY)(options)));\n}\n\nfunction rectX(data, options = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.hasXY)(options)) options = {...options, y: _options_js__WEBPACK_IMPORTED_MODULE_4__.indexOf, x2: _options_js__WEBPACK_IMPORTED_MODULE_4__.identity, interval: 1};\n  return new Rect(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__.maybeStackX)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_5__.maybeTrivialIntervalY)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_7__.maybeIdentityX)(options))));\n}\n\nfunction rectY(data, options = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.hasXY)(options)) options = {...options, x: _options_js__WEBPACK_IMPORTED_MODULE_4__.indexOf, y2: _options_js__WEBPACK_IMPORTED_MODULE_4__.identity, interval: 1};\n  return new Rect(data, (0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_6__.maybeStackY)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_5__.maybeTrivialIntervalX)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_7__.maybeIdentityY)(options))));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9yZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNMO0FBQ3lDO0FBQ2hDO0FBQ3lFO0FBQ3hFO0FBQytCO0FBQ2M7QUFDdkI7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFTyxtQkFBbUIsMENBQUk7QUFDOUIsZ0NBQWdDO0FBQ2hDLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkZBQTJGO0FBQ3hHLGFBQWEsMkZBQTJGO0FBQ3hHLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWE7QUFDYixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsU0FBUyxnQ0FBZ0M7QUFDekMsV0FBVyxpRUFBaUU7QUFDNUUsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsOENBQThDO0FBQ3pELFdBQVcsb0NBQW9DO0FBQy9DLHFDQUFxQyx1REFBVyxxQkFBcUI7QUFDckUscUNBQXFDLHVEQUFXLHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0EsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5REFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFTO0FBQ25DLDBCQUEwQixnREFBUztBQUNuQywwQkFBMEIseURBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLEdBQUcseUZBQXlGO0FBQzVGO0FBQ0Esa0JBQWtCLG1EQUFNO0FBQ3hCLG9CQUFvQixtREFBTTtBQUMxQixxQkFBcUIsbURBQU07QUFDM0IsbUJBQW1CLG1EQUFNO0FBQ3pCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsd0RBQWEsY0FBYztBQUN6QyxjQUFjLHdEQUFhO0FBQzNCO0FBQ0E7O0FBRU87QUFDUCxTQUFTLGdEQUFnRDtBQUN6RCxxQ0FBcUMscURBQVE7QUFDN0MscUNBQXFDLHFEQUFRO0FBQzdDLHFDQUFxQyxxREFBUTtBQUM3QyxxQ0FBcUMscURBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUUsR0FBRyxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxNQUFNLGdCQUFnQixFQUFFLGtCQUFrQixHQUFHLEVBQUU7QUFDN0YsVUFBVSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxNQUFNLGdCQUFnQixFQUFFLEVBQUUsR0FBRyxrQkFBa0I7QUFDeEYsVUFBVSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxNQUFNLGdCQUFnQixFQUFFLGtCQUFrQixHQUFHLEVBQUU7QUFDeEYsVUFBVSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxNQUFNLGdCQUFnQixFQUFFLEVBQUUsR0FBRyxrQkFBa0I7QUFDeEY7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCx3QkFBd0IsOEVBQXFCLENBQUMsOEVBQXFCO0FBQ25FOztBQUVPLGlDQUFpQztBQUN4QyxPQUFPLGtEQUFLLHNCQUFzQixlQUFlLGdEQUFPLE1BQU0saURBQVE7QUFDdEUsd0JBQXdCLGlFQUFXLENBQUMsOEVBQXFCLENBQUMsdUVBQWM7QUFDeEU7O0FBRU8saUNBQWlDO0FBQ3hDLE9BQU8sa0RBQUssc0JBQXNCLGVBQWUsZ0RBQU8sTUFBTSxpREFBUTtBQUN0RSx3QkFBd0IsaUVBQVcsQ0FBQyw4RUFBcUIsQ0FBQyx1RUFBYztBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvcmVjdC5qcz8yMDE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtNYXJrfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtjb25zdGFudCwgaGFzWFksIGlkZW50aXR5LCBpbmRleE9mLCBudW1iZXJ9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2lzQ29sbGFwc2VkfSBmcm9tIFwiLi4vc2NhbGVzLmpzXCI7XG5pbXBvcnQge2FwcGx5QXR0ciwgYXBwbHlDaGFubmVsU3R5bGVzLCBhcHBseURpcmVjdFN0eWxlcywgYXBwbHlJbmRpcmVjdFN0eWxlcywgYXBwbHlUcmFuc2Zvcm19IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHtpbXBsaWVkU3RyaW5nfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7bWF5YmVJZGVudGl0eVgsIG1heWJlSWRlbnRpdHlZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHttYXliZVRyaXZpYWxJbnRlcnZhbFgsIG1heWJlVHJpdmlhbEludGVydmFsWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7bWF5YmVTdGFja1gsIG1heWJlU3RhY2tZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9zdGFjay5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcInJlY3RcIlxufTtcblxuZXhwb3J0IGNsYXNzIFJlY3QgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gxLCB5MSwgeDIsIHkyfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4MToge3ZhbHVlOiB4MSwgc2NhbGU6IFwieFwiLCB0eXBlOiB4MSAhPSBudWxsICYmIHgyID09IG51bGwgPyBcImJhbmRcIiA6IHVuZGVmaW5lZCwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5MToge3ZhbHVlOiB5MSwgc2NhbGU6IFwieVwiLCB0eXBlOiB5MSAhPSBudWxsICYmIHkyID09IG51bGwgPyBcImJhbmRcIiA6IHVuZGVmaW5lZCwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB4Mjoge3ZhbHVlOiB4Miwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHkyOiB7dmFsdWU6IHkyLCBzY2FsZTogXCJ5XCIsIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgcmVjdEluc2V0cyh0aGlzLCBvcHRpb25zKTtcbiAgICByZWN0UmFkaWkodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3Qge3gsIHl9ID0gc2NhbGVzO1xuICAgIGxldCB7eDE6IFgxLCB5MTogWTEsIHgyOiBYMiwgeTI6IFkyfSA9IGNoYW5uZWxzO1xuICAgIGNvbnN0IHttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnQsIHdpZHRoLCBoZWlnaHR9ID0gZGltZW5zaW9ucztcbiAgICBjb25zdCB7cHJvamVjdGlvbn0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHtpbnNldFRvcCwgaW5zZXRSaWdodCwgaW5zZXRCb3R0b20sIGluc2V0TGVmdH0gPSB0aGlzO1xuICAgIGNvbnN0IHtyeCwgcnksIHJ4MXkxLCByeDF5MiwgcngyeTEsIHJ4MnkyfSA9IHRoaXM7XG4gICAgaWYgKChYMSB8fCBYMikgJiYgIXByb2plY3Rpb24gJiYgaXNDb2xsYXBzZWQoeCkpIFgxID0gWDIgPSBudWxsOyAvLyBpZ25vcmUgaWYgY29sbGFwc2VkXG4gICAgaWYgKChZMSB8fCBZMikgJiYgIXByb2plY3Rpb24gJiYgaXNDb2xsYXBzZWQoeSkpIFkxID0gWTIgPSBudWxsOyAvLyBpZ25vcmUgaWYgY29sbGFwc2VkXG4gICAgY29uc3QgYnggPSB4Py5iYW5kd2lkdGggPyB4LmJhbmR3aWR0aCgpIDogMDtcbiAgICBjb25zdCBieSA9IHk/LmJhbmR3aWR0aCA/IHkuYmFuZHdpZHRoKCkgOiAwO1xuICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFN0eWxlcywgdGhpcywgZGltZW5zaW9ucywgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCB7fSwgMCwgMClcbiAgICAgIC5jYWxsKChnKSA9PlxuICAgICAgICBnXG4gICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgLmRhdGEoaW5kZXgpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuY2FsbChcbiAgICAgICAgICAgIHJ4MXkxIHx8IHJ4MXkyIHx8IHJ4MnkxIHx8IHJ4MnkyXG4gICAgICAgICAgICAgID8gKGcpID0+XG4gICAgICAgICAgICAgICAgICBnXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBhcHBseVJvdW5kZWRSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgIFgxICYmIFgyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBYMVtpXSArIChYMltpXSA8IFgxW2ldID8gLWluc2V0UmlnaHQgOiBpbnNldExlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFgxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBYMVtpXSArIGluc2V0TGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXJnaW5MZWZ0ICsgaW5zZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIFkxICYmIFkyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBZMVtpXSArIChZMltpXSA8IFkxW2ldID8gLWluc2V0Qm90dG9tIDogaW5zZXRUb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFkxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBZMVtpXSArIGluc2V0VG9wXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1hcmdpblRvcCArIGluc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgIFgxICYmIFgyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBYMltpXSAtIChYMltpXSA8IFgxW2ldID8gLWluc2V0TGVmdCA6IGluc2V0UmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFgxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChpKSA9PiBYMVtpXSArIGJ4IC0gaW5zZXRSaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB3aWR0aCAtIG1hcmdpblJpZ2h0IC0gaW5zZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICBZMSAmJiBZMlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gWTJbaV0gLSAoWTJbaV0gPCBZMVtpXSA/IC1pbnNldFRvcCA6IGluc2V0Qm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBZMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gWTFbaV0gKyBieSAtIGluc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGhlaWdodCAtIG1hcmdpbkJvdHRvbSAtIGluc2V0Qm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIGNoYW5uZWxzKVxuICAgICAgICAgICAgICA6IChnKSA9PlxuICAgICAgICAgICAgICAgICAgZ1xuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgWDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gTWF0aC5taW4oWDFbaV0sIFgyW2ldKSArIGluc2V0TGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IChpKSA9PiBYMVtpXSArIGluc2V0TGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXJnaW5MZWZ0ICsgaW5zZXRMZWZ0XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgXCJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgWTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gTWF0aC5taW4oWTFbaV0sIFkyW2ldKSArIGluc2V0VG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKGkpID0+IFkxW2ldICsgaW5zZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWFyZ2luVG9wICsgaW5zZXRUb3BcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgWDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gTWF0aC5tYXgoMCwgTWF0aC5hYnMoWDJbaV0gLSBYMVtpXSkgKyBieCAtIGluc2V0TGVmdCAtIGluc2V0UmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYnggLSBpbnNldExlZnQgLSBpbnNldFJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdpZHRoIC0gbWFyZ2luUmlnaHQgLSBtYXJnaW5MZWZ0IC0gaW5zZXRSaWdodCAtIGluc2V0TGVmdFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgWTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaSkgPT4gTWF0aC5tYXgoMCwgTWF0aC5hYnMoWTFbaV0gLSBZMltpXSkgKyBieSAtIGluc2V0VG9wIC0gaW5zZXRCb3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYnkgLSBpbnNldFRvcCAtIGluc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbSAtIGluc2V0VG9wIC0gaW5zZXRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChhcHBseUF0dHIsIFwicnhcIiwgcngpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5QXR0ciwgXCJyeVwiLCByeSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscylcbiAgICAgICAgICApXG4gICAgICApXG4gICAgICAubm9kZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0SW5zZXRzKFxuICBtYXJrLFxuICB7aW5zZXQgPSAwLCBpbnNldFRvcCA9IGluc2V0LCBpbnNldFJpZ2h0ID0gaW5zZXQsIGluc2V0Qm90dG9tID0gaW5zZXQsIGluc2V0TGVmdCA9IGluc2V0fSA9IHt9XG4pIHtcbiAgbWFyay5pbnNldFRvcCA9IG51bWJlcihpbnNldFRvcCk7XG4gIG1hcmsuaW5zZXRSaWdodCA9IG51bWJlcihpbnNldFJpZ2h0KTtcbiAgbWFyay5pbnNldEJvdHRvbSA9IG51bWJlcihpbnNldEJvdHRvbSk7XG4gIG1hcmsuaW5zZXRMZWZ0ID0gbnVtYmVyKGluc2V0TGVmdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0UmFkaWkoXG4gIG1hcmssXG4gIHtcbiAgICByLFxuICAgIHJ4LCAvLyBmb3IgZWxsaXB0aWMgY29ybmVyc1xuICAgIHJ5LCAvLyBmb3IgZWxsaXB0aWMgY29ybmVyc1xuICAgIHJ4MSA9IHIsXG4gICAgcnkxID0gcixcbiAgICByeDIgPSByLFxuICAgIHJ5MiA9IHIsXG4gICAgcngxeTEgPSByeDEgIT09IHVuZGVmaW5lZCA/ICtyeDEgOiByeTEgIT09IHVuZGVmaW5lZCA/ICtyeTEgOiAwLFxuICAgIHJ4MXkyID0gcngxICE9PSB1bmRlZmluZWQgPyArcngxIDogcnkyICE9PSB1bmRlZmluZWQgPyArcnkyIDogMCxcbiAgICByeDJ5MSA9IHJ4MiAhPT0gdW5kZWZpbmVkID8gK3J4MiA6IHJ5MSAhPT0gdW5kZWZpbmVkID8gK3J5MSA6IDAsXG4gICAgcngyeTIgPSByeDIgIT09IHVuZGVmaW5lZCA/ICtyeDIgOiByeTIgIT09IHVuZGVmaW5lZCA/ICtyeTIgOiAwXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChyeDF5MSB8fCByeDF5MiB8fCByeDJ5MSB8fCByeDJ5Mikge1xuICAgIG1hcmsucngxeTEgPSByeDF5MTtcbiAgICBtYXJrLnJ4MXkyID0gcngxeTI7XG4gICAgbWFyay5yeDJ5MSA9IHJ4MnkxO1xuICAgIG1hcmsucngyeTIgPSByeDJ5MjtcbiAgfSBlbHNlIHtcbiAgICBtYXJrLnJ4ID0gaW1wbGllZFN0cmluZyhyeCwgXCJhdXRvXCIpOyAvLyBudW1iZXIgb3IgcGVyY2VudGFnZVxuICAgIG1hcmsucnkgPSBpbXBsaWVkU3RyaW5nKHJ5LCBcImF1dG9cIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Um91bmRlZFJlY3Qoc2VsZWN0aW9uLCBYMSwgWTEsIFgyLCBZMiwgbWFyaykge1xuICBjb25zdCB7cngxeTE6IHIxMSwgcngxeTI6IHIxMiwgcngyeTE6IHIyMSwgcngyeTI6IHIyMn0gPSBtYXJrO1xuICBpZiAodHlwZW9mIFgxICE9PSBcImZ1bmN0aW9uXCIpIFgxID0gY29uc3RhbnQoWDEpO1xuICBpZiAodHlwZW9mIFkxICE9PSBcImZ1bmN0aW9uXCIpIFkxID0gY29uc3RhbnQoWTEpO1xuICBpZiAodHlwZW9mIFgyICE9PSBcImZ1bmN0aW9uXCIpIFgyID0gY29uc3RhbnQoWDIpO1xuICBpZiAodHlwZW9mIFkyICE9PSBcImZ1bmN0aW9uXCIpIFkyID0gY29uc3RhbnQoWTIpO1xuICBjb25zdCByeCA9IE1hdGgubWF4KE1hdGguYWJzKHIxMSArIHIyMSksIE1hdGguYWJzKHIxMiArIHIyMikpO1xuICBjb25zdCByeSA9IE1hdGgubWF4KE1hdGguYWJzKHIxMSArIHIxMiksIE1hdGguYWJzKHIyMSArIHIyMikpO1xuICBzZWxlY3Rpb24uYXR0cihcImRcIiwgKGkpID0+IHtcbiAgICBjb25zdCB4MSA9IFgxKGkpO1xuICAgIGNvbnN0IHkxID0gWTEoaSk7XG4gICAgY29uc3QgeDIgPSBYMihpKTtcbiAgICBjb25zdCB5MiA9IFkyKGkpO1xuICAgIGNvbnN0IGl4ID0geDEgPiB4MjtcbiAgICBjb25zdCBpeSA9IHkxID4geTI7XG4gICAgY29uc3QgbCA9IGl4ID8geDIgOiB4MTtcbiAgICBjb25zdCByID0gaXggPyB4MSA6IHgyO1xuICAgIGNvbnN0IHQgPSBpeSA/IHkyIDogeTE7XG4gICAgY29uc3QgYiA9IGl5ID8geTEgOiB5MjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oMSwgKHIgLSBsKSAvIHJ4LCAoYiAtIHQpIC8gcnkpO1xuICAgIGNvbnN0IHRsID0gayAqIChpeCA/IChpeSA/IHIyMiA6IHIyMSkgOiBpeSA/IHIxMiA6IHIxMSk7XG4gICAgY29uc3QgdHIgPSBrICogKGl4ID8gKGl5ID8gcjEyIDogcjExKSA6IGl5ID8gcjIyIDogcjIxKTtcbiAgICBjb25zdCBiciA9IGsgKiAoaXggPyAoaXkgPyByMTEgOiByMTIpIDogaXkgPyByMjEgOiByMjIpO1xuICAgIGNvbnN0IGJsID0gayAqIChpeCA/IChpeSA/IHIyMSA6IHIyMikgOiBpeSA/IHIxMSA6IHIxMik7XG4gICAgcmV0dXJuIChcbiAgICAgIGBNJHtsfSwke3QgKyBiaWFzWSh0bCwgYmwpfUEke3RsfSwke3RsfSAwIDAgJHt0bCA8IDAgPyAwIDogMX0gJHtsICsgYmlhc1godGwsIGJsKX0sJHt0fWAgK1xuICAgICAgYEgke3IgLSBiaWFzWCh0ciwgYnIpfUEke3RyfSwke3RyfSAwIDAgJHt0ciA8IDAgPyAwIDogMX0gJHtyfSwke3QgKyBiaWFzWSh0ciwgYnIpfWAgK1xuICAgICAgYFYke2IgLSBiaWFzWShiciwgdHIpfUEke2JyfSwke2JyfSAwIDAgJHticiA8IDAgPyAwIDogMX0gJHtyIC0gYmlhc1goYnIsIHRyKX0sJHtifWAgK1xuICAgICAgYEgke2wgKyBiaWFzWChibCwgdGwpfUEke2JsfSwke2JsfSAwIDAgJHtibCA8IDAgPyAwIDogMX0gJHtsfSwke2IgLSBiaWFzWShibCwgdGwpfWAgK1xuICAgICAgYFpgXG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSWYgdGhlIG9wcG9zaW5nIGNvcm5lciBoYXMgYSBuZWdhdGl2ZSByYWRpdXMgcjIsIGlmIHRoaXMgY29ybmVyIGhhcyBhXG4gKiBuZWdhdGl2ZSByYWRpdXMgcjEsIHRoaXMgY29ybmVy4oCZcyDigJx3aW5n4oCdIHdpbGwgZXh0ZW5kIGhvcml6b250YWxseSByYXRoZXIgdGhhblxuICogdmVydGljYWxseS5cbiAqL1xuZnVuY3Rpb24gYmlhc1gocjEsIHIyKSB7XG4gIHJldHVybiByMiA8IDAgPyByMSA6IE1hdGguYWJzKHIxKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgb3Bwb3NpbmcgY29ybmVyIGhhcyBhIG5lZ2F0aXZlIHJhZGl1cyByMiwgaWYgdGhpcyBjb3JuZXIgaGFzIGFcbiAqIG5lZ2F0aXZlIHJhZGl1cyByMSwgdGhpcyBjb3JuZXLigJlzIOKAnHdpbmfigJ0gd2lsbCBleHRlbmQgaG9yaXpvbnRhbGx5IHJhdGhlciB0aGFuXG4gKiB2ZXJ0aWNhbGx5LlxuICovXG5mdW5jdGlvbiBiaWFzWShyMSwgcjIpIHtcbiAgcmV0dXJuIHIyIDwgMCA/IE1hdGguYWJzKHIxKSA6IHIxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdChkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVjdChkYXRhLCBtYXliZVRyaXZpYWxJbnRlcnZhbFgobWF5YmVUcml2aWFsSW50ZXJ2YWxZKG9wdGlvbnMpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0WChkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFoYXNYWShvcHRpb25zKSkgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCB5OiBpbmRleE9mLCB4MjogaWRlbnRpdHksIGludGVydmFsOiAxfTtcbiAgcmV0dXJuIG5ldyBSZWN0KGRhdGEsIG1heWJlU3RhY2tYKG1heWJlVHJpdmlhbEludGVydmFsWShtYXliZUlkZW50aXR5WChvcHRpb25zKSkpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RZKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWhhc1hZKG9wdGlvbnMpKSBvcHRpb25zID0gey4uLm9wdGlvbnMsIHg6IGluZGV4T2YsIHkyOiBpZGVudGl0eSwgaW50ZXJ2YWw6IDF9O1xuICByZXR1cm4gbmV3IFJlY3QoZGF0YSwgbWF5YmVTdGFja1kobWF5YmVUcml2aWFsSW50ZXJ2YWxYKG1heWJlSWRlbnRpdHlZKG9wdGlvbnMpKSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/rect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/rule.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuleX: () => (/* binding */ RuleX),\n/* harmony export */   RuleY: () => (/* binding */ RuleY),\n/* harmony export */   ruleX: () => (/* binding */ ruleX),\n/* harmony export */   ruleY: () => (/* binding */ ruleY)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../marker.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marker.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"rule\",\n  fill: null,\n  stroke: \"currentColor\"\n};\n\nclass RuleX extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, options = {}) {\n    const {x, y1, y2, inset = 0, insetTop = inset, insetBottom = inset} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y1: {value: y1, scale: \"y\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      (0,_mark_js__WEBPACK_IMPORTED_MODULE_0__.withTip)(options, \"x\"),\n      defaults\n    );\n    this.insetTop = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(insetTop);\n    this.insetBottom = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(insetBottom);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_2__.markers)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y1: Y1, y2: Y2} = channels;\n    const {width, height, marginTop, marginRight, marginLeft, marginBottom} = dimensions;\n    const {insetTop, insetBottom} = this;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x}, _style_js__WEBPACK_IMPORTED_MODULE_4__.offset, 0)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"line\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .attr(\"x1\", X ? (i) => X[i] : (marginLeft + width - marginRight) / 2)\n          .attr(\"x2\", X ? (i) => X[i] : (marginLeft + width - marginRight) / 2)\n          .attr(\"y1\", Y1 && !(0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.isCollapsed)(y) ? (i) => Y1[i] + insetTop : marginTop + insetTop)\n          .attr(\n            \"y2\",\n            Y2 && !(0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.isCollapsed)(y)\n              ? y.bandwidth\n                ? (i) => Y2[i] + y.bandwidth() - insetBottom\n                : (i) => Y2[i] - insetBottom\n              : height - marginBottom - insetBottom\n          )\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n          .call(_marker_js__WEBPACK_IMPORTED_MODULE_2__.applyMarkers, this, channels, context)\n      )\n      .node();\n  }\n}\n\nclass RuleY extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, options = {}) {\n    const {x1, x2, y, inset = 0, insetRight = inset, insetLeft = inset} = options;\n    super(\n      data,\n      {\n        y: {value: y, scale: \"y\", optional: true},\n        x1: {value: x1, scale: \"x\", optional: true},\n        x2: {value: x2, scale: \"x\", optional: true}\n      },\n      (0,_mark_js__WEBPACK_IMPORTED_MODULE_0__.withTip)(options, \"y\"),\n      defaults\n    );\n    this.insetRight = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(insetRight);\n    this.insetLeft = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(insetLeft);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_2__.markers)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {y: Y, x1: X1, x2: X2} = channels;\n    const {width, height, marginTop, marginRight, marginLeft, marginBottom} = dimensions;\n    const {insetLeft, insetRight} = this;\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_3__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {y: Y && y}, 0, _style_js__WEBPACK_IMPORTED_MODULE_4__.offset)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"line\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .attr(\"x1\", X1 && !(0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.isCollapsed)(x) ? (i) => X1[i] + insetLeft : marginLeft + insetLeft)\n          .attr(\n            \"x2\",\n            X2 && !(0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.isCollapsed)(x)\n              ? x.bandwidth\n                ? (i) => X2[i] + x.bandwidth() - insetRight\n                : (i) => X2[i] - insetRight\n              : width - marginRight - insetRight\n          )\n          .attr(\"y1\", Y ? (i) => Y[i] : (marginTop + height - marginBottom) / 2)\n          .attr(\"y2\", Y ? (i) => Y[i] : (marginTop + height - marginBottom) / 2)\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n          .call(_marker_js__WEBPACK_IMPORTED_MODULE_2__.applyMarkers, this, channels, context)\n      )\n      .node();\n  }\n}\n\nfunction ruleX(data, options) {\n  let {x = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, y, y1, y2, ...rest} = (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_6__.maybeIntervalY)(options);\n  [y1, y2] = maybeOptionalZero(y, y1, y2);\n  return new RuleX(data, {...rest, x, y1, y2});\n}\n\nfunction ruleY(data, options) {\n  let {y = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, x, x1, x2, ...rest} = (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_6__.maybeIntervalX)(options);\n  [x1, x2] = maybeOptionalZero(x, x1, x2);\n  return new RuleY(data, {...rest, y, x1, x2});\n}\n\n// For marks specified either as [0, x] or [x1, x2], or nothing.\nfunction maybeOptionalZero(x, x1, x2) {\n  if (x == null) {\n    if (x1 === undefined) {\n      if (x2 !== undefined) return [0, x2];\n    } else {\n      if (x2 === undefined) return [0, x1];\n    }\n  } else if (x1 === undefined) {\n    return x2 === undefined ? [0, x] : [x, x2];\n  } else if (x2 === undefined) {\n    return [x, x1];\n  }\n  return [x1, x2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy9ydWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0k7QUFDVTtBQUNKO0FBQ047QUFDc0U7QUFDdEM7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sb0JBQW9CLDBDQUFJO0FBQy9CLGdDQUFnQztBQUNoQyxXQUFXLDZEQUE2RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2IsT0FBTztBQUNQLE1BQU0saURBQU87QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFNO0FBQzFCLHVCQUF1QixtREFBTTtBQUM3QixJQUFJLG1EQUFPO0FBQ1g7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGlFQUFpRTtBQUM1RSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWMsU0FBUyxVQUFVLEVBQUUsNkNBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0EsNkJBQTZCLHVEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBa0I7QUFDbEMsZ0JBQWdCLG9EQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVPLG9CQUFvQiwwQ0FBSTtBQUMvQixnQ0FBZ0M7QUFDaEMsV0FBVyw2REFBNkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYTtBQUNiLE9BQU87QUFDUCxNQUFNLGlEQUFPO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQixtREFBTTtBQUM1QixxQkFBcUIsbURBQU07QUFDM0IsSUFBSSxtREFBTztBQUNYO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxpRUFBaUU7QUFDNUUsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxtREFBTTtBQUNqQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLHFEQUFjLFNBQVMsVUFBVSxLQUFLLDZDQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakMsNkJBQTZCLHVEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQWtCO0FBQ2xDLGdCQUFnQixvREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLE9BQU8sSUFBSSxpREFBUSxzQkFBc0IsRUFBRSx1RUFBYztBQUN6RDtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7O0FBRU87QUFDUCxPQUFPLElBQUksaURBQVEsc0JBQXNCLEVBQUUsdUVBQWM7QUFDekQ7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvcnVsZS5qcz9hMDY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtNYXJrLCB3aXRoVGlwfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHthcHBseU1hcmtlcnMsIG1hcmtlcnN9IGZyb20gXCIuLi9tYXJrZXIuanNcIjtcbmltcG9ydCB7aWRlbnRpdHksIG51bWJlcn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7aXNDb2xsYXBzZWR9IGZyb20gXCIuLi9zY2FsZXMuanNcIjtcbmltcG9ydCB7YXBwbHlDaGFubmVsU3R5bGVzLCBhcHBseURpcmVjdFN0eWxlcywgYXBwbHlJbmRpcmVjdFN0eWxlcywgYXBwbHlUcmFuc2Zvcm0sIG9mZnNldH0gZnJvbSBcIi4uL3N0eWxlLmpzXCI7XG5pbXBvcnQge21heWJlSW50ZXJ2YWxYLCBtYXliZUludGVydmFsWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvaW50ZXJ2YWwuanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFyaWFMYWJlbDogXCJydWxlXCIsXG4gIGZpbGw6IG51bGwsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIlxufTtcblxuZXhwb3J0IGNsYXNzIFJ1bGVYIGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt4LCB5MSwgeTIsIGluc2V0ID0gMCwgaW5zZXRUb3AgPSBpbnNldCwgaW5zZXRCb3R0b20gPSBpbnNldH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeDoge3ZhbHVlOiB4LCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeTE6IHt2YWx1ZTogeTEsIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5Mjoge3ZhbHVlOiB5Miwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICB3aXRoVGlwKG9wdGlvbnMsIFwieFwiKSxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLmluc2V0VG9wID0gbnVtYmVyKGluc2V0VG9wKTtcbiAgICB0aGlzLmluc2V0Qm90dG9tID0gbnVtYmVyKGluc2V0Qm90dG9tKTtcbiAgICBtYXJrZXJzKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4LCB5fSA9IHNjYWxlcztcbiAgICBjb25zdCB7eDogWCwgeTE6IFkxLCB5MjogWTJ9ID0gY2hhbm5lbHM7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkxlZnQsIG1hcmdpbkJvdHRvbX0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IHtpbnNldFRvcCwgaW5zZXRCb3R0b219ID0gdGhpcztcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywge3g6IFggJiYgeH0sIG9mZnNldCwgMClcbiAgICAgIC5jYWxsKChnKSA9PlxuICAgICAgICBnXG4gICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgLmRhdGEoaW5kZXgpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCB0aGlzKVxuICAgICAgICAgIC5hdHRyKFwieDFcIiwgWCA/IChpKSA9PiBYW2ldIDogKG1hcmdpbkxlZnQgKyB3aWR0aCAtIG1hcmdpblJpZ2h0KSAvIDIpXG4gICAgICAgICAgLmF0dHIoXCJ4MlwiLCBYID8gKGkpID0+IFhbaV0gOiAobWFyZ2luTGVmdCArIHdpZHRoIC0gbWFyZ2luUmlnaHQpIC8gMilcbiAgICAgICAgICAuYXR0cihcInkxXCIsIFkxICYmICFpc0NvbGxhcHNlZCh5KSA/IChpKSA9PiBZMVtpXSArIGluc2V0VG9wIDogbWFyZ2luVG9wICsgaW5zZXRUb3ApXG4gICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICBcInkyXCIsXG4gICAgICAgICAgICBZMiAmJiAhaXNDb2xsYXBzZWQoeSlcbiAgICAgICAgICAgICAgPyB5LmJhbmR3aWR0aFxuICAgICAgICAgICAgICAgID8gKGkpID0+IFkyW2ldICsgeS5iYW5kd2lkdGgoKSAtIGluc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgOiAoaSkgPT4gWTJbaV0gLSBpbnNldEJvdHRvbVxuICAgICAgICAgICAgICA6IGhlaWdodCAtIG1hcmdpbkJvdHRvbSAtIGluc2V0Qm90dG9tXG4gICAgICAgICAgKVxuICAgICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlNYXJrZXJzLCB0aGlzLCBjaGFubmVscywgY29udGV4dClcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bGVZIGV4dGVuZHMgTWFyayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt4MSwgeDIsIHksIGluc2V0ID0gMCwgaW5zZXRSaWdodCA9IGluc2V0LCBpbnNldExlZnQgPSBpbnNldH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeToge3ZhbHVlOiB5LCBzY2FsZTogXCJ5XCIsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgeDE6IHt2YWx1ZTogeDEsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB4Mjoge3ZhbHVlOiB4Miwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0sXG4gICAgICB3aXRoVGlwKG9wdGlvbnMsIFwieVwiKSxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLmluc2V0UmlnaHQgPSBudW1iZXIoaW5zZXRSaWdodCk7XG4gICAgdGhpcy5pbnNldExlZnQgPSBudW1iZXIoaW5zZXRMZWZ0KTtcbiAgICBtYXJrZXJzKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJlbmRlcihpbmRleCwgc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHt4LCB5fSA9IHNjYWxlcztcbiAgICBjb25zdCB7eTogWSwgeDE6IFgxLCB4MjogWDJ9ID0gY2hhbm5lbHM7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkxlZnQsIG1hcmdpbkJvdHRvbX0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IHtpbnNldExlZnQsIGluc2V0UmlnaHR9ID0gdGhpcztcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywge3k6IFkgJiYgeX0sIDAsIG9mZnNldClcbiAgICAgIC5jYWxsKChnKSA9PlxuICAgICAgICBnXG4gICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgLmRhdGEoaW5kZXgpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgIC5jYWxsKGFwcGx5RGlyZWN0U3R5bGVzLCB0aGlzKVxuICAgICAgICAgIC5hdHRyKFwieDFcIiwgWDEgJiYgIWlzQ29sbGFwc2VkKHgpID8gKGkpID0+IFgxW2ldICsgaW5zZXRMZWZ0IDogbWFyZ2luTGVmdCArIGluc2V0TGVmdClcbiAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgIFwieDJcIixcbiAgICAgICAgICAgIFgyICYmICFpc0NvbGxhcHNlZCh4KVxuICAgICAgICAgICAgICA/IHguYmFuZHdpZHRoXG4gICAgICAgICAgICAgICAgPyAoaSkgPT4gWDJbaV0gKyB4LmJhbmR3aWR0aCgpIC0gaW5zZXRSaWdodFxuICAgICAgICAgICAgICAgIDogKGkpID0+IFgyW2ldIC0gaW5zZXRSaWdodFxuICAgICAgICAgICAgICA6IHdpZHRoIC0gbWFyZ2luUmlnaHQgLSBpbnNldFJpZ2h0XG4gICAgICAgICAgKVxuICAgICAgICAgIC5hdHRyKFwieTFcIiwgWSA/IChpKSA9PiBZW2ldIDogKG1hcmdpblRvcCArIGhlaWdodCAtIG1hcmdpbkJvdHRvbSkgLyAyKVxuICAgICAgICAgIC5hdHRyKFwieTJcIiwgWSA/IChpKSA9PiBZW2ldIDogKG1hcmdpblRvcCArIGhlaWdodCAtIG1hcmdpbkJvdHRvbSkgLyAyKVxuICAgICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlNYXJrZXJzLCB0aGlzLCBjaGFubmVscywgY29udGV4dClcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVYKGRhdGEsIG9wdGlvbnMpIHtcbiAgbGV0IHt4ID0gaWRlbnRpdHksIHksIHkxLCB5MiwgLi4ucmVzdH0gPSBtYXliZUludGVydmFsWShvcHRpb25zKTtcbiAgW3kxLCB5Ml0gPSBtYXliZU9wdGlvbmFsWmVybyh5LCB5MSwgeTIpO1xuICByZXR1cm4gbmV3IFJ1bGVYKGRhdGEsIHsuLi5yZXN0LCB4LCB5MSwgeTJ9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVZKGRhdGEsIG9wdGlvbnMpIHtcbiAgbGV0IHt5ID0gaWRlbnRpdHksIHgsIHgxLCB4MiwgLi4ucmVzdH0gPSBtYXliZUludGVydmFsWChvcHRpb25zKTtcbiAgW3gxLCB4Ml0gPSBtYXliZU9wdGlvbmFsWmVybyh4LCB4MSwgeDIpO1xuICByZXR1cm4gbmV3IFJ1bGVZKGRhdGEsIHsuLi5yZXN0LCB5LCB4MSwgeDJ9KTtcbn1cblxuLy8gRm9yIG1hcmtzIHNwZWNpZmllZCBlaXRoZXIgYXMgWzAsIHhdIG9yIFt4MSwgeDJdLCBvciBub3RoaW5nLlxuZnVuY3Rpb24gbWF5YmVPcHRpb25hbFplcm8oeCwgeDEsIHgyKSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHgyICE9PSB1bmRlZmluZWQpIHJldHVybiBbMCwgeDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFswLCB4MV07XG4gICAgfVxuICB9IGVsc2UgaWYgKHgxID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geDIgPT09IHVuZGVmaW5lZCA/IFswLCB4XSA6IFt4LCB4Ml07XG4gIH0gZWxzZSBpZiAoeDIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbeCwgeDFdO1xuICB9XG4gIHJldHVybiBbeDEsIHgyXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/rule.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   applyIndirectTextStyles: () => (/* binding */ applyIndirectTextStyles),\n/* harmony export */   clipEnd: () => (/* binding */ clipEnd),\n/* harmony export */   clipMiddle: () => (/* binding */ clipMiddle),\n/* harmony export */   clipStart: () => (/* binding */ clipStart),\n/* harmony export */   clipper: () => (/* binding */ clipper),\n/* harmony export */   cut: () => (/* binding */ cut),\n/* harmony export */   defaultWidth: () => (/* binding */ defaultWidth),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   maybeTextOverflow: () => (/* binding */ maybeTextOverflow),\n/* harmony export */   monospaceWidth: () => (/* binding */ monospaceWidth),\n/* harmony export */   readCharacter: () => (/* binding */ readCharacter),\n/* harmony export */   splitter: () => (/* binding */ splitter),\n/* harmony export */   text: () => (/* binding */ text),\n/* harmony export */   textX: () => (/* binding */ textX),\n/* harmony export */   textY: () => (/* binding */ textY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../format.js */ \"(ssr)/./node_modules/@observablehq/plot/src/format.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../template.js */ \"(ssr)/./node_modules/@observablehq/plot/src/template.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\n\nconst softHyphen = \"\\u00ad\";\n\nclass Text extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      text = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isIterable)(data) && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTextual)(data) ? _options_js__WEBPACK_IMPORTED_MODULE_2__.identity : _options_js__WEBPACK_IMPORTED_MODULE_2__.indexOf,\n      frameAnchor,\n      textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\",\n      lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\",\n      lineHeight = 1,\n      lineWidth = Infinity,\n      textOverflow,\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      rotate\n    } = options;\n    const [vrotate, crotate] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        fontSize: {value: vfontSize, optional: true},\n        rotate: {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.numberChannel)(vrotate), optional: true},\n        text: {value: text, filter: _defined_js__WEBPACK_IMPORTED_MODULE_3__.nonempty, optional: true}\n      },\n      options,\n      defaults\n    );\n    this.rotate = crotate;\n    this.textAnchor = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.impliedString)(textAnchor, \"middle\");\n    this.lineAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyword)(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontStyle);\n    this.fontVariant = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontVariant);\n    this.fontWeight = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontWeight);\n    this.frameAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeFrameAnchor)(frameAnchor);\n    if (!(this.lineWidth >= 0)) throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter(this);\n    this.clipLine = clipper(this);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, rotate: R, text: T, title: TL, fontSize: FS} = channels;\n    const {rotate} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyFrameAnchor)(this, dimensions);\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectStyles, this, dimensions, context)\n      .call(applyIndirectTextStyles, this, T, dimensions)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"text\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyDirectStyles, this)\n          .call(applyMultilineText, this, T, TL)\n          .attr(\n            \"transform\",\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_6__.template)`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${\n              R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``\n            }`\n          )\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr, \"font-size\", FS && ((i) => FS[i]))\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_4__.applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nfunction maybeTextOverflow(textOverflow) {\n  return textOverflow == null\n    ? null\n    : (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyword)(textOverflow, \"textOverflow\", [\n        \"clip\", // shorthand for clip-end\n        \"ellipsis\", // … ellipsis-end\n        \"clip-start\",\n        \"clip-end\",\n        \"ellipsis-start\",\n        \"ellipsis-middle\",\n        \"ellipsis-end\"\n      ]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\n\nfunction applyMultilineText(selection, mark, T, TL) {\n  if (!T) return;\n  const {lineAnchor, lineHeight, textOverflow, splitLines, clipLine} = mark;\n  selection.each(function (i) {\n    const lines = splitLines((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatDefault)(T[i]) ?? \"\").map(clipLine);\n    const n = lines.length;\n    const y = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      let m = 0;\n      for (let i = 0; i < n; ++i) {\n        ++m;\n        if (!lines[i]) continue;\n        const tspan = this.ownerDocument.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        if (i === m - 1) tspan.setAttribute(\"y\", `${(y + i) * lineHeight}em`);\n        else tspan.setAttribute(\"dy\", `${m * lineHeight}em`);\n        tspan.textContent = lines[i];\n        this.appendChild(tspan);\n        m = 0;\n      }\n    } else {\n      if (y) this.setAttribute(\"y\", `${y * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\n\nfunction text(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Text(data, {...options, x, y});\n}\n\nfunction textX(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, ...options} = {}) {\n  return new Text(data, (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_8__.maybeIntervalMidY)({...options, x}));\n}\n\nfunction textY(data, {y = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, ...options} = {}) {\n  return new Text(data, (0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_8__.maybeIntervalMidX)({...options, y}));\n}\n\nfunction applyIndirectTextStyles(selection, mark, T) {\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"text-anchor\", mark.textAnchor);\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"font-family\", mark.fontFamily);\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"font-size\", mark.fontSize);\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"font-style\", mark.fontStyle);\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"font-variant\", mark.fontVariant === undefined ? inferFontVariant(T) : mark.fontVariant);\n  (0,_style_js__WEBPACK_IMPORTED_MODULE_4__.applyAttr)(selection, \"font-weight\", mark.fontWeight);\n}\n\nfunction inferFontVariant(T) {\n  return T && ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(T) || (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal)(T)) ? \"tabular-nums\" : undefined;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\nconst fontSizes = new Set([\n  // global keywords\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n  // absolute keywords\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"xxx-large\",\n  // relative keywords\n  \"larger\",\n  \"smaller\"\n]);\n\n// The font size may be expressed as a constant in the following forms:\n// - number in pixels\n// - string keyword: see above\n// - string <length>: e.g., \"12px\"\n// - string <percentage>: e.g., \"80%\"\n// Anything else is assumed to be a channel definition.\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\") return [undefined, fontSize];\n  if (typeof fontSize !== \"string\") return [fontSize, undefined];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize)\n    ? [undefined, fontSize]\n    : [fontSize, undefined];\n}\n\n// This is a greedy algorithm for line wrapping. It would be better to use the\n// Knuth–Plass line breaking algorithm (but that would be much more complex).\n// https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart,\n    lineEnd = 0;\n  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {\n    // Record the start of a line. This isn’t the same as the previous line’s\n    // end because we often skip spaces between lines.\n    if (lineStart === undefined) lineStart = wordStart;\n\n    // If the current line is not empty, and if adding the current word would\n    // make the line longer than the allowed width, then break the line at the\n    // previous word end.\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n\n    // If this is a required break (a newline), emit the line and reset.\n    if (required) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = undefined;\n      continue;\n    }\n\n    // Extend the current line to include the new word.\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\n\n// This is a rudimentary (and U.S.-centric) algorithm for finding opportunities\n// to break lines between words. A better and far more comprehensive approach\n// would be to use the official Unicode Line Breaking Algorithm.\n// https://unicode.org/reports/tr14/\nfunction* lineBreaks(input) {\n  let i = 0,\n    j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\": // hyphen\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \"); // skip multiple spaces\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\") ++k; // falls through\n      case \"\\n\":\n        yield [i, j, true];\n        j += k;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\n\n// Computed as round(measureText(text).width * 10) at 10px system-ui. For\n// characters that are not represented in this map, we’d ideally want to use a\n// weighted average of what we expect to see. But since we don’t really know\n// what that is, using “e” seems reasonable.\nconst defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"‘\": 31,\n  \"’\": 31,\n  \"“\": 47,\n  \"”\": 47,\n  \"…\": 82\n};\n\n// This is a rudimentary (and U.S.-centric) algorithm for measuring the width of\n// a string based on a technique of Gregor Aisch; it assumes that individual\n// characters are laid out independently and does not implement the Unicode\n// grapheme cluster breaking algorithm. It does understand code points, though,\n// and so treats things like emoji as having the width of a lowercase e (and\n// should be equivalent to using for-of to iterate over code points, while also\n// being fast). TODO Optimize this by noting that we often re-measure characters\n// that were previously measured?\n// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n// https://exploringjs.com/impatient-js/ch_strings.html#atoms-of-text\nfunction defaultWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += defaultWidthMap[text[i]] ?? (isPictographic(text, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum;\n}\n\n// Even for monospaced text, we can’t assume that the number of UTF-16 code\n// points (i.e., the length of a string) corresponds to the number of visible\n// characters; we still have to count graphemes. And note that pictographic\n// characters such as emojis are typically not monospaced!\nfunction monospaceWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += isPictographic(text, i) ? 126 : 63;\n  }\n  return sum;\n}\n\nfunction splitter({monospace, lineWidth, textOverflow}) {\n  if (textOverflow != null || lineWidth == Infinity) return (text) => text.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return (text) => lineWrap(text, maxWidth, widthof);\n}\n\nfunction clipper({monospace, lineWidth, textOverflow}) {\n  if (textOverflow == null || lineWidth == Infinity) return (text) => text;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return (text) => clipStart(text, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return (text) => clipEnd(text, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return (text) => clipStart(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-middle\":\n      return (text) => clipMiddle(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-end\":\n      return (text) => clipEnd(text, maxWidth, widthof, ellipsis);\n  }\n}\n\nconst ellipsis = \"…\";\n\n// Cuts the given text to the given width, using the specified widthof function;\n// the returned [index, error] guarantees text.slice(0, index) fits within the\n// specified width with the given error. If the text fits naturally within the\n// given width, returns [-1, 0]. If the text needs cutting, the given inset\n// specifies how much space (in the same units as width and widthof) to reserve\n// for a possible ellipsis character.\nfunction cut(text, width, widthof, inset) {\n  const I = []; // indexes of read character boundaries\n  let w = 0; // current line width\n  for (let i = 0, j = 0, n = text.length; i < n; i = j) {\n    j = readCharacter(text, i); // read the next character\n    const l = widthof(text, i, j); // current character width\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0) (j = i), (i = I.pop()), (w -= widthof(text, i, j)); // remove excess\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\n\nfunction clipEnd(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const e = widthof(ellipsis);\n  const [i] = cut(text, width, widthof, e);\n  return i < 0 ? text : text.slice(0, i).trimEnd() + ellipsis;\n}\n\nfunction clipMiddle(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text, width / 2, widthof, e);\n  const [j] = cut(text, w - width / 2 - ei + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : text.slice(0, i).trimEnd() + ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\n\nfunction clipStart(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis);\n  const [j] = cut(text, w - width + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\n\nconst reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nconst rePictographic = /\\p{Extended_Pictographic}/uy;\n\n// Reads a single “character” element from the given text starting at the given\n// index, returning the index after the read character. Ideally, this implements\n// the Unicode text segmentation algorithm and understands grapheme cluster\n// boundaries, etc., but in practice this is only smart enough to detect UTF-16\n// surrogate pairs, combining marks, and zero-width joiner (zwj) sequences such\n// as emoji skin color modifiers. https://unicode.org/reports/tr29/\nfunction readCharacter(text, i) {\n  i += isSurrogatePair(text, i) ? 2 : 1;\n  if (isCombiner(text, i)) i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text, i)) return readCharacter(text, i + 1);\n  return i;\n}\n\n// We avoid more expensive regex tests involving Unicode property classes by\n// first checking for the common case of 7-bit ASCII characters.\nfunction isAscii(text, i) {\n  return text.charCodeAt(i) < 0x80;\n}\n\nfunction isSurrogatePair(text, i) {\n  const hi = text.charCodeAt(i);\n  if (hi >= 0xd800 && hi < 0xdc00) {\n    const lo = text.charCodeAt(i + 1);\n    return lo >= 0xdc00 && lo < 0xe000;\n  }\n  return false;\n}\n\nfunction isZeroWidthJoiner(text, i) {\n  return text.charCodeAt(i) === 0x200d;\n}\n\nfunction isCombiner(text, i) {\n  return isAscii(text, i) ? false : ((reCombiner.lastIndex = i), reCombiner.test(text));\n}\n\nfunction isPictographic(text, i) {\n  return isAscii(text, i) ? false : ((rePictographic.lastIndex = i), rePictographic.test(text));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy90ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEI7QUFDTztBQUNFO0FBQ0k7QUFDWDtBQWNUO0FBU0Y7QUFDbUI7QUFDdUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTyxtQkFBbUIsMENBQUk7QUFDOUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdURBQVUsVUFBVSxzREFBUyxTQUFTLGlEQUFRLEdBQUcsZ0RBQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0JBQStCLCtEQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pELFlBQVkscUNBQXFDO0FBQ2pELG1CQUFtQixpQ0FBaUM7QUFDcEQsaUJBQWlCLE9BQU8sMERBQWEsMEJBQTBCO0FBQy9ELGVBQWUscUJBQXFCLGlEQUFRO0FBQzVDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBYTtBQUNuQyxzQkFBc0Isb0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07QUFDNUI7QUFDQSxxQkFBcUIsbURBQU07QUFDM0IsdUJBQXVCLG1EQUFNO0FBQzdCLHNCQUFzQixtREFBTTtBQUM1Qix1QkFBdUIsNkRBQWdCO0FBQ3ZDLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcseURBQXlEO0FBQ3BFLFdBQVcsUUFBUTtBQUNuQixxQkFBcUIsMkRBQWdCO0FBQ3JDLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0I7QUFDQSxZQUFZLHFEQUFjLFNBQVMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUSxhQUFhLHFCQUFxQixHQUFHLHFCQUFxQjtBQUM5RSxvQ0FBb0MsS0FBSyx5QkFBeUIsT0FBTztBQUN6RSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekIsZ0JBQWdCLHlEQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxNQUFNLG9EQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDREQUE0RDtBQUNyRTtBQUNBLDZCQUE2Qix5REFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSx5REFBeUQsMENBQVU7QUFDbkU7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwQ0FBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU8scUJBQXFCLGtCQUFrQixJQUFJO0FBQ2xELGtEQUFrRCx1REFBVTtBQUM1RCx5QkFBeUIsaUJBQWlCO0FBQzFDOztBQUVPLHNCQUFzQixJQUFJLGlEQUFRLGNBQWMsSUFBSTtBQUMzRCx3QkFBd0IsMEVBQWlCLEVBQUUsY0FBYztBQUN6RDs7QUFFTyxzQkFBc0IsSUFBSSxpREFBUSxjQUFjLElBQUk7QUFDM0Qsd0JBQXdCLDBFQUFpQixFQUFFLGNBQWM7QUFDekQ7O0FBRU87QUFDUCxFQUFFLG9EQUFTO0FBQ1gsRUFBRSxvREFBUztBQUNYLEVBQUUsb0RBQVM7QUFDWCxFQUFFLG9EQUFTO0FBQ1gsRUFBRSxvREFBUztBQUNYLEVBQUUsb0RBQVM7QUFDWDs7QUFFQTtBQUNBLGVBQWUsc0RBQVMsT0FBTyx1REFBVTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sbUJBQW1CLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLGtCQUFrQixtQ0FBbUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLDBDQUEwQyxPQUFPO0FBQ2pELGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVPO0FBQ1Asc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLHdCQUF3QixlQUFlLEdBQUcsZUFBZTtBQUN6RCwyQkFBMkIsc0JBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy90ZXh0LmpzPzlmMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtuYW1lc3BhY2VzfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHtub25lbXB0eX0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7Zm9ybWF0RGVmYXVsdH0gZnJvbSBcIi4uL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHtNYXJrfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHtcbiAgaW5kZXhPZixcbiAgaWRlbnRpdHksXG4gIHN0cmluZyxcbiAgbWF5YmVOdW1iZXJDaGFubmVsLFxuICBtYXliZVR1cGxlLFxuICBudW1iZXJDaGFubmVsLFxuICBpc051bWVyaWMsXG4gIGlzVGVtcG9yYWwsXG4gIGtleXdvcmQsXG4gIG1heWJlRnJhbWVBbmNob3IsXG4gIGlzVGV4dHVhbCxcbiAgaXNJdGVyYWJsZVxufSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtcbiAgYXBwbHlDaGFubmVsU3R5bGVzLFxuICBhcHBseURpcmVjdFN0eWxlcyxcbiAgYXBwbHlJbmRpcmVjdFN0eWxlcyxcbiAgYXBwbHlBdHRyLFxuICBhcHBseVRyYW5zZm9ybSxcbiAgaW1wbGllZFN0cmluZyxcbiAgYXBwbHlGcmFtZUFuY2hvclxufSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7dGVtcGxhdGV9IGZyb20gXCIuLi90ZW1wbGF0ZS5qc1wiO1xuaW1wb3J0IHttYXliZUludGVydmFsTWlkWCwgbWF5YmVJbnRlcnZhbE1pZFl9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2ludGVydmFsLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwidGV4dFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICBzdHJva2VXaWR0aDogMyxcbiAgcGFpbnRPcmRlcjogXCJzdHJva2VcIlxufTtcblxuY29uc3Qgc29mdEh5cGhlbiA9IFwiXFx1MDBhZFwiO1xuXG5leHBvcnQgY2xhc3MgVGV4dCBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRleHQgPSBpc0l0ZXJhYmxlKGRhdGEpICYmIGlzVGV4dHVhbChkYXRhKSA/IGlkZW50aXR5IDogaW5kZXhPZixcbiAgICAgIGZyYW1lQW5jaG9yLFxuICAgICAgdGV4dEFuY2hvciA9IC9yaWdodCQvaS50ZXN0KGZyYW1lQW5jaG9yKSA/IFwiZW5kXCIgOiAvbGVmdCQvaS50ZXN0KGZyYW1lQW5jaG9yKSA/IFwic3RhcnRcIiA6IFwibWlkZGxlXCIsXG4gICAgICBsaW5lQW5jaG9yID0gL150b3AvaS50ZXN0KGZyYW1lQW5jaG9yKSA/IFwidG9wXCIgOiAvXmJvdHRvbS9pLnRlc3QoZnJhbWVBbmNob3IpID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCIsXG4gICAgICBsaW5lSGVpZ2h0ID0gMSxcbiAgICAgIGxpbmVXaWR0aCA9IEluZmluaXR5LFxuICAgICAgdGV4dE92ZXJmbG93LFxuICAgICAgbW9ub3NwYWNlLFxuICAgICAgZm9udEZhbWlseSA9IG1vbm9zcGFjZSA/IFwidWktbW9ub3NwYWNlLCBtb25vc3BhY2VcIiA6IHVuZGVmaW5lZCxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgcm90YXRlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgW3Zyb3RhdGUsIGNyb3RhdGVdID0gbWF5YmVOdW1iZXJDaGFubmVsKHJvdGF0ZSwgMCk7XG4gICAgY29uc3QgW3Zmb250U2l6ZSwgY2ZvbnRTaXplXSA9IG1heWJlRm9udFNpemVDaGFubmVsKGZvbnRTaXplKTtcbiAgICBzdXBlcihcbiAgICAgIGRhdGEsXG4gICAgICB7XG4gICAgICAgIHg6IHt2YWx1ZTogeCwgc2NhbGU6IFwieFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHk6IHt2YWx1ZTogeSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IHZmb250U2l6ZSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICByb3RhdGU6IHt2YWx1ZTogbnVtYmVyQ2hhbm5lbCh2cm90YXRlKSwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB0ZXh0OiB7dmFsdWU6IHRleHQsIGZpbHRlcjogbm9uZW1wdHksIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgdGhpcy5yb3RhdGUgPSBjcm90YXRlO1xuICAgIHRoaXMudGV4dEFuY2hvciA9IGltcGxpZWRTdHJpbmcodGV4dEFuY2hvciwgXCJtaWRkbGVcIik7XG4gICAgdGhpcy5saW5lQW5jaG9yID0ga2V5d29yZChsaW5lQW5jaG9yLCBcImxpbmVBbmNob3JcIiwgW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdKTtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSArbGluZUhlaWdodDtcbiAgICB0aGlzLmxpbmVXaWR0aCA9ICtsaW5lV2lkdGg7XG4gICAgdGhpcy50ZXh0T3ZlcmZsb3cgPSBtYXliZVRleHRPdmVyZmxvdyh0ZXh0T3ZlcmZsb3cpO1xuICAgIHRoaXMubW9ub3NwYWNlID0gISFtb25vc3BhY2U7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gc3RyaW5nKGZvbnRGYW1pbHkpO1xuICAgIHRoaXMuZm9udFNpemUgPSBjZm9udFNpemU7XG4gICAgdGhpcy5mb250U3R5bGUgPSBzdHJpbmcoZm9udFN0eWxlKTtcbiAgICB0aGlzLmZvbnRWYXJpYW50ID0gc3RyaW5nKGZvbnRWYXJpYW50KTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBzdHJpbmcoZm9udFdlaWdodCk7XG4gICAgdGhpcy5mcmFtZUFuY2hvciA9IG1heWJlRnJhbWVBbmNob3IoZnJhbWVBbmNob3IpO1xuICAgIGlmICghKHRoaXMubGluZVdpZHRoID49IDApKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbGluZVdpZHRoOiAke2xpbmVXaWR0aH1gKTtcbiAgICB0aGlzLnNwbGl0TGluZXMgPSBzcGxpdHRlcih0aGlzKTtcbiAgICB0aGlzLmNsaXBMaW5lID0gY2xpcHBlcih0aGlzKTtcbiAgfVxuICByZW5kZXIoaW5kZXgsIHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBzY2FsZXM7XG4gICAgY29uc3Qge3g6IFgsIHk6IFksIHJvdGF0ZTogUiwgdGV4dDogVCwgdGl0bGU6IFRMLCBmb250U2l6ZTogRlN9ID0gY2hhbm5lbHM7XG4gICAgY29uc3Qge3JvdGF0ZX0gPSB0aGlzO1xuICAgIGNvbnN0IFtjeCwgY3ldID0gYXBwbHlGcmFtZUFuY2hvcih0aGlzLCBkaW1lbnNpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlKFwic3ZnOmdcIiwgY29udGV4dClcbiAgICAgIC5jYWxsKGFwcGx5SW5kaXJlY3RTdHlsZXMsIHRoaXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0VGV4dFN0eWxlcywgdGhpcywgVCwgZGltZW5zaW9ucylcbiAgICAgIC5jYWxsKGFwcGx5VHJhbnNmb3JtLCB0aGlzLCB7eDogWCAmJiB4LCB5OiBZICYmIHl9KVxuICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgIGdcbiAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAuZGF0YShpbmRleClcbiAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlNdWx0aWxpbmVUZXh0LCB0aGlzLCBULCBUTClcbiAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICB0ZW1wbGF0ZWB0cmFuc2xhdGUoJHtYID8gKGkpID0+IFhbaV0gOiBjeH0sJHtZID8gKGkpID0+IFlbaV0gOiBjeX0pJHtcbiAgICAgICAgICAgICAgUiA/IChpKSA9PiBgIHJvdGF0ZSgke1JbaV19KWAgOiByb3RhdGUgPyBgIHJvdGF0ZSgke3JvdGF0ZX0pYCA6IGBgXG4gICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgICAuY2FsbChhcHBseUF0dHIsIFwiZm9udC1zaXplXCIsIEZTICYmICgoaSkgPT4gRlNbaV0pKVxuICAgICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICApXG4gICAgICAubm9kZSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVRleHRPdmVyZmxvdyh0ZXh0T3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHRleHRPdmVyZmxvdyA9PSBudWxsXG4gICAgPyBudWxsXG4gICAgOiBrZXl3b3JkKHRleHRPdmVyZmxvdywgXCJ0ZXh0T3ZlcmZsb3dcIiwgW1xuICAgICAgICBcImNsaXBcIiwgLy8gc2hvcnRoYW5kIGZvciBjbGlwLWVuZFxuICAgICAgICBcImVsbGlwc2lzXCIsIC8vIOKApiBlbGxpcHNpcy1lbmRcbiAgICAgICAgXCJjbGlwLXN0YXJ0XCIsXG4gICAgICAgIFwiY2xpcC1lbmRcIixcbiAgICAgICAgXCJlbGxpcHNpcy1zdGFydFwiLFxuICAgICAgICBcImVsbGlwc2lzLW1pZGRsZVwiLFxuICAgICAgICBcImVsbGlwc2lzLWVuZFwiXG4gICAgICBdKS5yZXBsYWNlKC9eKGNsaXB8ZWxsaXBzaXMpJC8sIFwiJDEtZW5kXCIpO1xufVxuXG5mdW5jdGlvbiBhcHBseU11bHRpbGluZVRleHQoc2VsZWN0aW9uLCBtYXJrLCBULCBUTCkge1xuICBpZiAoIVQpIHJldHVybjtcbiAgY29uc3Qge2xpbmVBbmNob3IsIGxpbmVIZWlnaHQsIHRleHRPdmVyZmxvdywgc3BsaXRMaW5lcywgY2xpcExpbmV9ID0gbWFyaztcbiAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoZm9ybWF0RGVmYXVsdChUW2ldKSA/PyBcIlwiKS5tYXAoY2xpcExpbmUpO1xuICAgIGNvbnN0IG4gPSBsaW5lcy5sZW5ndGg7XG4gICAgY29uc3QgeSA9IGxpbmVBbmNob3IgPT09IFwidG9wXCIgPyAwLjcxIDogbGluZUFuY2hvciA9PT0gXCJib3R0b21cIiA/IDEgLSBuIDogKDE2NCAtIG4gKiAxMDApIC8gMjAwO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgbGV0IG0gPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgKyttO1xuICAgICAgICBpZiAoIWxpbmVzW2ldKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdHNwYW4gPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZXMuc3ZnLCBcInRzcGFuXCIpO1xuICAgICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGUoXCJ4XCIsIDApO1xuICAgICAgICBpZiAoaSA9PT0gbSAtIDEpIHRzcGFuLnNldEF0dHJpYnV0ZShcInlcIiwgYCR7KHkgKyBpKSAqIGxpbmVIZWlnaHR9ZW1gKTtcbiAgICAgICAgZWxzZSB0c3Bhbi5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBgJHttICogbGluZUhlaWdodH1lbWApO1xuICAgICAgICB0c3Bhbi50ZXh0Q29udGVudCA9IGxpbmVzW2ldO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRzcGFuKTtcbiAgICAgICAgbSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5KSB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgYCR7eSAqIGxpbmVIZWlnaHR9ZW1gKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBsaW5lc1swXTtcbiAgICB9XG4gICAgaWYgKHRleHRPdmVyZmxvdyAmJiAhVEwgJiYgbGluZXNbMF0gIT09IFRbaV0pIHtcbiAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VzLnN2ZywgXCJ0aXRsZVwiKTtcbiAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gVFtpXTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KGRhdGEsIHt4LCB5LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIGlmIChvcHRpb25zLmZyYW1lQW5jaG9yID09PSB1bmRlZmluZWQpIFt4LCB5XSA9IG1heWJlVHVwbGUoeCwgeSk7XG4gIHJldHVybiBuZXcgVGV4dChkYXRhLCB7Li4ub3B0aW9ucywgeCwgeX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGV4dFgoZGF0YSwge3ggPSBpZGVudGl0eSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4gbmV3IFRleHQoZGF0YSwgbWF5YmVJbnRlcnZhbE1pZFkoey4uLm9wdGlvbnMsIHh9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0WShkYXRhLCB7eSA9IGlkZW50aXR5LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIHJldHVybiBuZXcgVGV4dChkYXRhLCBtYXliZUludGVydmFsTWlkWCh7Li4ub3B0aW9ucywgeX0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5SW5kaXJlY3RUZXh0U3R5bGVzKHNlbGVjdGlvbiwgbWFyaywgVCkge1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInRleHQtYW5jaG9yXCIsIG1hcmsudGV4dEFuY2hvcik7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZm9udC1mYW1pbHlcIiwgbWFyay5mb250RmFtaWx5KTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJmb250LXNpemVcIiwgbWFyay5mb250U2l6ZSk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZm9udC1zdHlsZVwiLCBtYXJrLmZvbnRTdHlsZSk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZm9udC12YXJpYW50XCIsIG1hcmsuZm9udFZhcmlhbnQgPT09IHVuZGVmaW5lZCA/IGluZmVyRm9udFZhcmlhbnQoVCkgOiBtYXJrLmZvbnRWYXJpYW50KTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJmb250LXdlaWdodFwiLCBtYXJrLmZvbnRXZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBpbmZlckZvbnRWYXJpYW50KFQpIHtcbiAgcmV0dXJuIFQgJiYgKGlzTnVtZXJpYyhUKSB8fCBpc1RlbXBvcmFsKFQpKSA/IFwidGFidWxhci1udW1zXCIgOiB1bmRlZmluZWQ7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXNpemVcbmNvbnN0IGZvbnRTaXplcyA9IG5ldyBTZXQoW1xuICAvLyBnbG9iYWwga2V5d29yZHNcbiAgXCJpbmhlcml0XCIsXG4gIFwiaW5pdGlhbFwiLFxuICBcInJldmVydFwiLFxuICBcInVuc2V0XCIsXG4gIC8vIGFic29sdXRlIGtleXdvcmRzXG4gIFwieHgtc21hbGxcIixcbiAgXCJ4LXNtYWxsXCIsXG4gIFwic21hbGxcIixcbiAgXCJtZWRpdW1cIixcbiAgXCJsYXJnZVwiLFxuICBcIngtbGFyZ2VcIixcbiAgXCJ4eC1sYXJnZVwiLFxuICBcInh4eC1sYXJnZVwiLFxuICAvLyByZWxhdGl2ZSBrZXl3b3Jkc1xuICBcImxhcmdlclwiLFxuICBcInNtYWxsZXJcIlxuXSk7XG5cbi8vIFRoZSBmb250IHNpemUgbWF5IGJlIGV4cHJlc3NlZCBhcyBhIGNvbnN0YW50IGluIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4vLyAtIG51bWJlciBpbiBwaXhlbHNcbi8vIC0gc3RyaW5nIGtleXdvcmQ6IHNlZSBhYm92ZVxuLy8gLSBzdHJpbmcgPGxlbmd0aD46IGUuZy4sIFwiMTJweFwiXG4vLyAtIHN0cmluZyA8cGVyY2VudGFnZT46IGUuZy4sIFwiODAlXCJcbi8vIEFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhIGNoYW5uZWwgZGVmaW5pdGlvbi5cbmZ1bmN0aW9uIG1heWJlRm9udFNpemVDaGFubmVsKGZvbnRTaXplKSB7XG4gIGlmIChmb250U2l6ZSA9PSBudWxsIHx8IHR5cGVvZiBmb250U2l6ZSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIFt1bmRlZmluZWQsIGZvbnRTaXplXTtcbiAgaWYgKHR5cGVvZiBmb250U2l6ZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIFtmb250U2l6ZSwgdW5kZWZpbmVkXTtcbiAgZm9udFNpemUgPSBmb250U2l6ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGZvbnRTaXplcy5oYXMoZm9udFNpemUpIHx8IC9eWystXT9cXGQqXFwuP1xcZCsoZVsrLV0/XFxkKyk/KFxcdyp8JSkkLy50ZXN0KGZvbnRTaXplKVxuICAgID8gW3VuZGVmaW5lZCwgZm9udFNpemVdXG4gICAgOiBbZm9udFNpemUsIHVuZGVmaW5lZF07XG59XG5cbi8vIFRoaXMgaXMgYSBncmVlZHkgYWxnb3JpdGhtIGZvciBsaW5lIHdyYXBwaW5nLiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdXNlIHRoZVxuLy8gS251dGjigJNQbGFzcyBsaW5lIGJyZWFraW5nIGFsZ29yaXRobSAoYnV0IHRoYXQgd291bGQgYmUgbXVjaCBtb3JlIGNvbXBsZXgpLlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZV93cmFwX2FuZF93b3JkX3dyYXBcbmZ1bmN0aW9uIGxpbmVXcmFwKGlucHV0LCBtYXhXaWR0aCwgd2lkdGhvZikge1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBsZXQgbGluZVN0YXJ0LFxuICAgIGxpbmVFbmQgPSAwO1xuICBmb3IgKGNvbnN0IFt3b3JkU3RhcnQsIHdvcmRFbmQsIHJlcXVpcmVkXSBvZiBsaW5lQnJlYWtzKGlucHV0KSkge1xuICAgIC8vIFJlY29yZCB0aGUgc3RhcnQgb2YgYSBsaW5lLiBUaGlzIGlzbuKAmXQgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGxpbmXigJlzXG4gICAgLy8gZW5kIGJlY2F1c2Ugd2Ugb2Z0ZW4gc2tpcCBzcGFjZXMgYmV0d2VlbiBsaW5lcy5cbiAgICBpZiAobGluZVN0YXJ0ID09PSB1bmRlZmluZWQpIGxpbmVTdGFydCA9IHdvcmRTdGFydDtcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IGxpbmUgaXMgbm90IGVtcHR5LCBhbmQgaWYgYWRkaW5nIHRoZSBjdXJyZW50IHdvcmQgd291bGRcbiAgICAvLyBtYWtlIHRoZSBsaW5lIGxvbmdlciB0aGFuIHRoZSBhbGxvd2VkIHdpZHRoLCB0aGVuIGJyZWFrIHRoZSBsaW5lIGF0IHRoZVxuICAgIC8vIHByZXZpb3VzIHdvcmQgZW5kLlxuICAgIGlmIChsaW5lRW5kID4gbGluZVN0YXJ0ICYmIHdpZHRob2YoaW5wdXQsIGxpbmVTdGFydCwgd29yZEVuZCkgPiBtYXhXaWR0aCkge1xuICAgICAgbGluZXMucHVzaChpbnB1dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQpICsgKGlucHV0W2xpbmVFbmQgLSAxXSA9PT0gc29mdEh5cGhlbiA/IFwiLVwiIDogXCJcIikpO1xuICAgICAgbGluZVN0YXJ0ID0gd29yZFN0YXJ0O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSByZXF1aXJlZCBicmVhayAoYSBuZXdsaW5lKSwgZW1pdCB0aGUgbGluZSBhbmQgcmVzZXQuXG4gICAgaWYgKHJlcXVpcmVkKSB7XG4gICAgICBsaW5lcy5wdXNoKGlucHV0LnNsaWNlKGxpbmVTdGFydCwgd29yZEVuZCkpO1xuICAgICAgbGluZVN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIHRoZSBjdXJyZW50IGxpbmUgdG8gaW5jbHVkZSB0aGUgbmV3IHdvcmQuXG4gICAgbGluZUVuZCA9IHdvcmRFbmQ7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuXG4vLyBUaGlzIGlzIGEgcnVkaW1lbnRhcnkgKGFuZCBVLlMuLWNlbnRyaWMpIGFsZ29yaXRobSBmb3IgZmluZGluZyBvcHBvcnR1bml0aWVzXG4vLyB0byBicmVhayBsaW5lcyBiZXR3ZWVuIHdvcmRzLiBBIGJldHRlciBhbmQgZmFyIG1vcmUgY29tcHJlaGVuc2l2ZSBhcHByb2FjaFxuLy8gd291bGQgYmUgdG8gdXNlIHRoZSBvZmZpY2lhbCBVbmljb2RlIExpbmUgQnJlYWtpbmcgQWxnb3JpdGhtLlxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTQvXG5mdW5jdGlvbiogbGluZUJyZWFrcyhpbnB1dCkge1xuICBsZXQgaSA9IDAsXG4gICAgaiA9IDA7XG4gIGNvbnN0IG4gPSBpbnB1dC5sZW5ndGg7XG4gIHdoaWxlIChqIDwgbikge1xuICAgIGxldCBrID0gMTtcbiAgICBzd2l0Y2ggKGlucHV0W2pdKSB7XG4gICAgICBjYXNlIHNvZnRIeXBoZW46XG4gICAgICBjYXNlIFwiLVwiOiAvLyBoeXBoZW5cbiAgICAgICAgKytqO1xuICAgICAgICB5aWVsZCBbaSwgaiwgZmFsc2VdO1xuICAgICAgICBpID0gajtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiIFwiOlxuICAgICAgICB5aWVsZCBbaSwgaiwgZmFsc2VdO1xuICAgICAgICB3aGlsZSAoaW5wdXRbKytqXSA9PT0gXCIgXCIpOyAvLyBza2lwIG11bHRpcGxlIHNwYWNlc1xuICAgICAgICBpID0gajtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgIGlmIChpbnB1dFtqICsgMV0gPT09IFwiXFxuXCIpICsrazsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICB5aWVsZCBbaSwgaiwgdHJ1ZV07XG4gICAgICAgIGogKz0gaztcbiAgICAgICAgaSA9IGo7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgKytqO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgeWllbGQgW2ksIGosIHRydWVdO1xufVxuXG4vLyBDb21wdXRlZCBhcyByb3VuZChtZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCAqIDEwKSBhdCAxMHB4IHN5c3RlbS11aS4gRm9yXG4vLyBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCByZXByZXNlbnRlZCBpbiB0aGlzIG1hcCwgd2XigJlkIGlkZWFsbHkgd2FudCB0byB1c2UgYVxuLy8gd2VpZ2h0ZWQgYXZlcmFnZSBvZiB3aGF0IHdlIGV4cGVjdCB0byBzZWUuIEJ1dCBzaW5jZSB3ZSBkb27igJl0IHJlYWxseSBrbm93XG4vLyB3aGF0IHRoYXQgaXMsIHVzaW5nIOKAnGXigJ0gc2VlbXMgcmVhc29uYWJsZS5cbmNvbnN0IGRlZmF1bHRXaWR0aE1hcCA9IHtcbiAgYTogNTYsXG4gIGI6IDYzLFxuICBjOiA1NyxcbiAgZDogNjMsXG4gIGU6IDU4LFxuICBmOiAzNyxcbiAgZzogNjIsXG4gIGg6IDYwLFxuICBpOiAyNixcbiAgajogMjYsXG4gIGs6IDU1LFxuICBsOiAyNixcbiAgbTogODgsXG4gIG46IDYwLFxuICBvOiA2MCxcbiAgcDogNjIsXG4gIHE6IDYyLFxuICByOiAzOSxcbiAgczogNTQsXG4gIHQ6IDM4LFxuICB1OiA2MCxcbiAgdjogNTUsXG4gIHc6IDc5LFxuICB4OiA1NCxcbiAgeTogNTUsXG4gIHo6IDU1LFxuICBBOiA2OSxcbiAgQjogNjcsXG4gIEM6IDczLFxuICBEOiA3NCxcbiAgRTogNjEsXG4gIEY6IDU4LFxuICBHOiA3NixcbiAgSDogNzUsXG4gIEk6IDI4LFxuICBKOiA1NSxcbiAgSzogNjcsXG4gIEw6IDU4LFxuICBNOiA4OSxcbiAgTjogNzUsXG4gIE86IDc4LFxuICBQOiA2NSxcbiAgUTogNzgsXG4gIFI6IDY3LFxuICBTOiA2NSxcbiAgVDogNjUsXG4gIFU6IDc1LFxuICBWOiA2OSxcbiAgVzogOTgsXG4gIFg6IDY5LFxuICBZOiA2NyxcbiAgWjogNjcsXG4gIDA6IDY0LFxuICAxOiA0OCxcbiAgMjogNjIsXG4gIDM6IDY0LFxuICA0OiA2NixcbiAgNTogNjMsXG4gIDY6IDY1LFxuICA3OiA1OCxcbiAgODogNjUsXG4gIDk6IDY1LFxuICBcIiBcIjogMjksXG4gIFwiIVwiOiAzMixcbiAgJ1wiJzogNDksXG4gIFwiJ1wiOiAzMSxcbiAgXCIoXCI6IDM5LFxuICBcIilcIjogMzksXG4gIFwiLFwiOiAzMSxcbiAgXCItXCI6IDQ4LFxuICBcIi5cIjogMzEsXG4gIFwiL1wiOiAzMixcbiAgXCI6XCI6IDMxLFxuICBcIjtcIjogMzEsXG4gIFwiP1wiOiA1MixcbiAgXCLigJhcIjogMzEsXG4gIFwi4oCZXCI6IDMxLFxuICBcIuKAnFwiOiA0NyxcbiAgXCLigJ1cIjogNDcsXG4gIFwi4oCmXCI6IDgyXG59O1xuXG4vLyBUaGlzIGlzIGEgcnVkaW1lbnRhcnkgKGFuZCBVLlMuLWNlbnRyaWMpIGFsZ29yaXRobSBmb3IgbWVhc3VyaW5nIHRoZSB3aWR0aCBvZlxuLy8gYSBzdHJpbmcgYmFzZWQgb24gYSB0ZWNobmlxdWUgb2YgR3JlZ29yIEFpc2NoOyBpdCBhc3N1bWVzIHRoYXQgaW5kaXZpZHVhbFxuLy8gY2hhcmFjdGVycyBhcmUgbGFpZCBvdXQgaW5kZXBlbmRlbnRseSBhbmQgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBVbmljb2RlXG4vLyBncmFwaGVtZSBjbHVzdGVyIGJyZWFraW5nIGFsZ29yaXRobS4gSXQgZG9lcyB1bmRlcnN0YW5kIGNvZGUgcG9pbnRzLCB0aG91Z2gsXG4vLyBhbmQgc28gdHJlYXRzIHRoaW5ncyBsaWtlIGVtb2ppIGFzIGhhdmluZyB0aGUgd2lkdGggb2YgYSBsb3dlcmNhc2UgZSAoYW5kXG4vLyBzaG91bGQgYmUgZXF1aXZhbGVudCB0byB1c2luZyBmb3Itb2YgdG8gaXRlcmF0ZSBvdmVyIGNvZGUgcG9pbnRzLCB3aGlsZSBhbHNvXG4vLyBiZWluZyBmYXN0KS4gVE9ETyBPcHRpbWl6ZSB0aGlzIGJ5IG5vdGluZyB0aGF0IHdlIG9mdGVuIHJlLW1lYXN1cmUgY2hhcmFjdGVyc1xuLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgbWVhc3VyZWQ/XG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jR3JhcGhlbWVfQ2x1c3Rlcl9Cb3VuZGFyaWVzXG4vLyBodHRwczovL2V4cGxvcmluZ2pzLmNvbS9pbXBhdGllbnQtanMvY2hfc3RyaW5ncy5odG1sI2F0b21zLW9mLXRleHRcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0V2lkdGgodGV4dCwgc3RhcnQgPSAwLCBlbmQgPSB0ZXh0Lmxlbmd0aCkge1xuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpID0gcmVhZENoYXJhY3Rlcih0ZXh0LCBpKSkge1xuICAgIHN1bSArPSBkZWZhdWx0V2lkdGhNYXBbdGV4dFtpXV0gPz8gKGlzUGljdG9ncmFwaGljKHRleHQsIGkpID8gMTIwIDogZGVmYXVsdFdpZHRoTWFwLmUpO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIEV2ZW4gZm9yIG1vbm9zcGFjZWQgdGV4dCwgd2UgY2Fu4oCZdCBhc3N1bWUgdGhhdCB0aGUgbnVtYmVyIG9mIFVURi0xNiBjb2RlXG4vLyBwb2ludHMgKGkuZS4sIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcpIGNvcnJlc3BvbmRzIHRvIHRoZSBudW1iZXIgb2YgdmlzaWJsZVxuLy8gY2hhcmFjdGVyczsgd2Ugc3RpbGwgaGF2ZSB0byBjb3VudCBncmFwaGVtZXMuIEFuZCBub3RlIHRoYXQgcGljdG9ncmFwaGljXG4vLyBjaGFyYWN0ZXJzIHN1Y2ggYXMgZW1vamlzIGFyZSB0eXBpY2FsbHkgbm90IG1vbm9zcGFjZWQhXG5leHBvcnQgZnVuY3Rpb24gbW9ub3NwYWNlV2lkdGgodGV4dCwgc3RhcnQgPSAwLCBlbmQgPSB0ZXh0Lmxlbmd0aCkge1xuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpID0gcmVhZENoYXJhY3Rlcih0ZXh0LCBpKSkge1xuICAgIHN1bSArPSBpc1BpY3RvZ3JhcGhpYyh0ZXh0LCBpKSA/IDEyNiA6IDYzO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdHRlcih7bW9ub3NwYWNlLCBsaW5lV2lkdGgsIHRleHRPdmVyZmxvd30pIHtcbiAgaWYgKHRleHRPdmVyZmxvdyAhPSBudWxsIHx8IGxpbmVXaWR0aCA9PSBJbmZpbml0eSkgcmV0dXJuICh0ZXh0KSA9PiB0ZXh0LnNwbGl0KC9cXHJcXG4/fFxcbi9nKTtcbiAgY29uc3Qgd2lkdGhvZiA9IG1vbm9zcGFjZSA/IG1vbm9zcGFjZVdpZHRoIDogZGVmYXVsdFdpZHRoO1xuICBjb25zdCBtYXhXaWR0aCA9IGxpbmVXaWR0aCAqIDEwMDtcbiAgcmV0dXJuICh0ZXh0KSA9PiBsaW5lV3JhcCh0ZXh0LCBtYXhXaWR0aCwgd2lkdGhvZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwcGVyKHttb25vc3BhY2UsIGxpbmVXaWR0aCwgdGV4dE92ZXJmbG93fSkge1xuICBpZiAodGV4dE92ZXJmbG93ID09IG51bGwgfHwgbGluZVdpZHRoID09IEluZmluaXR5KSByZXR1cm4gKHRleHQpID0+IHRleHQ7XG4gIGNvbnN0IHdpZHRob2YgPSBtb25vc3BhY2UgPyBtb25vc3BhY2VXaWR0aCA6IGRlZmF1bHRXaWR0aDtcbiAgY29uc3QgbWF4V2lkdGggPSBsaW5lV2lkdGggKiAxMDA7XG4gIHN3aXRjaCAodGV4dE92ZXJmbG93KSB7XG4gICAgY2FzZSBcImNsaXAtc3RhcnRcIjpcbiAgICAgIHJldHVybiAodGV4dCkgPT4gY2xpcFN0YXJ0KHRleHQsIG1heFdpZHRoLCB3aWR0aG9mLCBcIlwiKTtcbiAgICBjYXNlIFwiY2xpcC1lbmRcIjpcbiAgICAgIHJldHVybiAodGV4dCkgPT4gY2xpcEVuZCh0ZXh0LCBtYXhXaWR0aCwgd2lkdGhvZiwgXCJcIik7XG4gICAgY2FzZSBcImVsbGlwc2lzLXN0YXJ0XCI6XG4gICAgICByZXR1cm4gKHRleHQpID0+IGNsaXBTdGFydCh0ZXh0LCBtYXhXaWR0aCwgd2lkdGhvZiwgZWxsaXBzaXMpO1xuICAgIGNhc2UgXCJlbGxpcHNpcy1taWRkbGVcIjpcbiAgICAgIHJldHVybiAodGV4dCkgPT4gY2xpcE1pZGRsZSh0ZXh0LCBtYXhXaWR0aCwgd2lkdGhvZiwgZWxsaXBzaXMpO1xuICAgIGNhc2UgXCJlbGxpcHNpcy1lbmRcIjpcbiAgICAgIHJldHVybiAodGV4dCkgPT4gY2xpcEVuZCh0ZXh0LCBtYXhXaWR0aCwgd2lkdGhvZiwgZWxsaXBzaXMpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBlbGxpcHNpcyA9IFwi4oCmXCI7XG5cbi8vIEN1dHMgdGhlIGdpdmVuIHRleHQgdG8gdGhlIGdpdmVuIHdpZHRoLCB1c2luZyB0aGUgc3BlY2lmaWVkIHdpZHRob2YgZnVuY3Rpb247XG4vLyB0aGUgcmV0dXJuZWQgW2luZGV4LCBlcnJvcl0gZ3VhcmFudGVlcyB0ZXh0LnNsaWNlKDAsIGluZGV4KSBmaXRzIHdpdGhpbiB0aGVcbi8vIHNwZWNpZmllZCB3aWR0aCB3aXRoIHRoZSBnaXZlbiBlcnJvci4gSWYgdGhlIHRleHQgZml0cyBuYXR1cmFsbHkgd2l0aGluIHRoZVxuLy8gZ2l2ZW4gd2lkdGgsIHJldHVybnMgWy0xLCAwXS4gSWYgdGhlIHRleHQgbmVlZHMgY3V0dGluZywgdGhlIGdpdmVuIGluc2V0XG4vLyBzcGVjaWZpZXMgaG93IG11Y2ggc3BhY2UgKGluIHRoZSBzYW1lIHVuaXRzIGFzIHdpZHRoIGFuZCB3aWR0aG9mKSB0byByZXNlcnZlXG4vLyBmb3IgYSBwb3NzaWJsZSBlbGxpcHNpcyBjaGFyYWN0ZXIuXG5leHBvcnQgZnVuY3Rpb24gY3V0KHRleHQsIHdpZHRoLCB3aWR0aG9mLCBpbnNldCkge1xuICBjb25zdCBJID0gW107IC8vIGluZGV4ZXMgb2YgcmVhZCBjaGFyYWN0ZXIgYm91bmRhcmllc1xuICBsZXQgdyA9IDA7IC8vIGN1cnJlbnQgbGluZSB3aWR0aFxuICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIG4gPSB0ZXh0Lmxlbmd0aDsgaSA8IG47IGkgPSBqKSB7XG4gICAgaiA9IHJlYWRDaGFyYWN0ZXIodGV4dCwgaSk7IC8vIHJlYWQgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgY29uc3QgbCA9IHdpZHRob2YodGV4dCwgaSwgaik7IC8vIGN1cnJlbnQgY2hhcmFjdGVyIHdpZHRoXG4gICAgaWYgKHcgKyBsID4gd2lkdGgpIHtcbiAgICAgIHcgKz0gaW5zZXQ7XG4gICAgICB3aGlsZSAodyA+IHdpZHRoICYmIGkgPiAwKSAoaiA9IGkpLCAoaSA9IEkucG9wKCkpLCAodyAtPSB3aWR0aG9mKHRleHQsIGksIGopKTsgLy8gcmVtb3ZlIGV4Y2Vzc1xuICAgICAgcmV0dXJuIFtpLCB3aWR0aCAtIHddO1xuICAgIH1cbiAgICB3ICs9IGw7XG4gICAgSS5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBbLTEsIDBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpcEVuZCh0ZXh0LCB3aWR0aCwgd2lkdGhvZiwgZWxsaXBzaXMpIHtcbiAgdGV4dCA9IHRleHQudHJpbSgpOyAvLyBpZ25vcmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBjb25zdCBlID0gd2lkdGhvZihlbGxpcHNpcyk7XG4gIGNvbnN0IFtpXSA9IGN1dCh0ZXh0LCB3aWR0aCwgd2lkdGhvZiwgZSk7XG4gIHJldHVybiBpIDwgMCA/IHRleHQgOiB0ZXh0LnNsaWNlKDAsIGkpLnRyaW1FbmQoKSArIGVsbGlwc2lzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpcE1pZGRsZSh0ZXh0LCB3aWR0aCwgd2lkdGhvZiwgZWxsaXBzaXMpIHtcbiAgdGV4dCA9IHRleHQudHJpbSgpOyAvLyBpZ25vcmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBjb25zdCB3ID0gd2lkdGhvZih0ZXh0KTtcbiAgaWYgKHcgPD0gd2lkdGgpIHJldHVybiB0ZXh0O1xuICBjb25zdCBlID0gd2lkdGhvZihlbGxpcHNpcykgLyAyO1xuICBjb25zdCBbaSwgZWldID0gY3V0KHRleHQsIHdpZHRoIC8gMiwgd2lkdGhvZiwgZSk7XG4gIGNvbnN0IFtqXSA9IGN1dCh0ZXh0LCB3IC0gd2lkdGggLyAyIC0gZWkgKyBlLCB3aWR0aG9mLCAtZSk7IC8vIFRPRE8gcmVhZCBzcGFjZXM/XG4gIHJldHVybiBqIDwgMCA/IGVsbGlwc2lzIDogdGV4dC5zbGljZSgwLCBpKS50cmltRW5kKCkgKyBlbGxpcHNpcyArIHRleHQuc2xpY2UocmVhZENoYXJhY3Rlcih0ZXh0LCBqKSkudHJpbVN0YXJ0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwU3RhcnQodGV4dCwgd2lkdGgsIHdpZHRob2YsIGVsbGlwc2lzKSB7XG4gIHRleHQgPSB0ZXh0LnRyaW0oKTsgLy8gaWdub3JlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgY29uc3QgdyA9IHdpZHRob2YodGV4dCk7XG4gIGlmICh3IDw9IHdpZHRoKSByZXR1cm4gdGV4dDtcbiAgY29uc3QgZSA9IHdpZHRob2YoZWxsaXBzaXMpO1xuICBjb25zdCBbal0gPSBjdXQodGV4dCwgdyAtIHdpZHRoICsgZSwgd2lkdGhvZiwgLWUpOyAvLyBUT0RPIHJlYWQgc3BhY2VzP1xuICByZXR1cm4gaiA8IDAgPyBlbGxpcHNpcyA6IGVsbGlwc2lzICsgdGV4dC5zbGljZShyZWFkQ2hhcmFjdGVyKHRleHQsIGopKS50cmltU3RhcnQoKTtcbn1cblxuY29uc3QgcmVDb21iaW5lciA9IC9bXFxwe0NvbWJpbmluZ19NYXJrfVxccHtFbW9qaV9Nb2RpZmllcn1dKy91eTtcbmNvbnN0IHJlUGljdG9ncmFwaGljID0gL1xccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9L3V5O1xuXG4vLyBSZWFkcyBhIHNpbmdsZSDigJxjaGFyYWN0ZXLigJ0gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiB0ZXh0IHN0YXJ0aW5nIGF0IHRoZSBnaXZlblxuLy8gaW5kZXgsIHJldHVybmluZyB0aGUgaW5kZXggYWZ0ZXIgdGhlIHJlYWQgY2hhcmFjdGVyLiBJZGVhbGx5LCB0aGlzIGltcGxlbWVudHNcbi8vIHRoZSBVbmljb2RlIHRleHQgc2VnbWVudGF0aW9uIGFsZ29yaXRobSBhbmQgdW5kZXJzdGFuZHMgZ3JhcGhlbWUgY2x1c3RlclxuLy8gYm91bmRhcmllcywgZXRjLiwgYnV0IGluIHByYWN0aWNlIHRoaXMgaXMgb25seSBzbWFydCBlbm91Z2ggdG8gZGV0ZWN0IFVURi0xNlxuLy8gc3Vycm9nYXRlIHBhaXJzLCBjb21iaW5pbmcgbWFya3MsIGFuZCB6ZXJvLXdpZHRoIGpvaW5lciAoendqKSBzZXF1ZW5jZXMgc3VjaFxuLy8gYXMgZW1vamkgc2tpbiBjb2xvciBtb2RpZmllcnMuIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjI5L1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRDaGFyYWN0ZXIodGV4dCwgaSkge1xuICBpICs9IGlzU3Vycm9nYXRlUGFpcih0ZXh0LCBpKSA/IDIgOiAxO1xuICBpZiAoaXNDb21iaW5lcih0ZXh0LCBpKSkgaSA9IHJlQ29tYmluZXIubGFzdEluZGV4O1xuICBpZiAoaXNaZXJvV2lkdGhKb2luZXIodGV4dCwgaSkpIHJldHVybiByZWFkQ2hhcmFjdGVyKHRleHQsIGkgKyAxKTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vIFdlIGF2b2lkIG1vcmUgZXhwZW5zaXZlIHJlZ2V4IHRlc3RzIGludm9sdmluZyBVbmljb2RlIHByb3BlcnR5IGNsYXNzZXMgYnlcbi8vIGZpcnN0IGNoZWNraW5nIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgNy1iaXQgQVNDSUkgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGlzQXNjaWkodGV4dCwgaSkge1xuICByZXR1cm4gdGV4dC5jaGFyQ29kZUF0KGkpIDwgMHg4MDtcbn1cblxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKHRleHQsIGkpIHtcbiAgY29uc3QgaGkgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gIGlmIChoaSA+PSAweGQ4MDAgJiYgaGkgPCAweGRjMDApIHtcbiAgICBjb25zdCBsbyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgcmV0dXJuIGxvID49IDB4ZGMwMCAmJiBsbyA8IDB4ZTAwMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzWmVyb1dpZHRoSm9pbmVyKHRleHQsIGkpIHtcbiAgcmV0dXJuIHRleHQuY2hhckNvZGVBdChpKSA9PT0gMHgyMDBkO1xufVxuXG5mdW5jdGlvbiBpc0NvbWJpbmVyKHRleHQsIGkpIHtcbiAgcmV0dXJuIGlzQXNjaWkodGV4dCwgaSkgPyBmYWxzZSA6ICgocmVDb21iaW5lci5sYXN0SW5kZXggPSBpKSwgcmVDb21iaW5lci50ZXN0KHRleHQpKTtcbn1cblxuZnVuY3Rpb24gaXNQaWN0b2dyYXBoaWModGV4dCwgaSkge1xuICByZXR1cm4gaXNBc2NpaSh0ZXh0LCBpKSA/IGZhbHNlIDogKChyZVBpY3RvZ3JhcGhpYy5sYXN0SW5kZXggPSBpKSwgcmVQaWN0b2dyYXBoaWMudGVzdCh0ZXh0KSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/tick.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/tick.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TickX: () => (/* binding */ TickX),\n/* harmony export */   TickY: () => (/* binding */ TickY),\n/* harmony export */   tickX: () => (/* binding */ tickX),\n/* harmony export */   tickY: () => (/* binding */ tickY)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../marker.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marker.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"tick\",\n  fill: null,\n  stroke: \"currentColor\"\n};\n\nclass AbstractTick extends _mark_js__WEBPACK_IMPORTED_MODULE_0__.Mark {\n  constructor(data, channels, options) {\n    super(data, channels, options, defaults);\n    (0,_marker_js__WEBPACK_IMPORTED_MODULE_1__.markers)(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(this._transform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"line\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n          .attr(\"x1\", this._x1(scales, channels, dimensions))\n          .attr(\"x2\", this._x2(scales, channels, dimensions))\n          .attr(\"y1\", this._y1(scales, channels, dimensions))\n          .attr(\"y2\", this._y2(scales, channels, dimensions))\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n          .call(_marker_js__WEBPACK_IMPORTED_MODULE_1__.applyMarkers, this, channels, context)\n      )\n      .node();\n  }\n}\n\nclass TickX extends AbstractTick {\n  constructor(data, options = {}) {\n    const {x, y, inset = 0, insetTop = inset, insetBottom = inset} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\"},\n        y: {value: y, scale: \"y\", type: \"band\", optional: true}\n      },\n      options\n    );\n    this.insetTop = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetTop);\n    this.insetBottom = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetBottom);\n  }\n  _transform(selection, mark, {x}) {\n    selection.call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, mark, {x}, _style_js__WEBPACK_IMPORTED_MODULE_3__.offset, 0);\n  }\n  _x1(scales, {x: X}) {\n    return (i) => X[i];\n  }\n  _x2(scales, {x: X}) {\n    return (i) => X[i];\n  }\n  _y1({y}, {y: Y}, {marginTop}) {\n    const {insetTop} = this;\n    return Y && y ? (i) => Y[i] + insetTop : marginTop + insetTop;\n  }\n  _y2({y}, {y: Y}, {height, marginBottom}) {\n    const {insetBottom} = this;\n    return Y && y ? (i) => Y[i] + y.bandwidth() - insetBottom : height - marginBottom - insetBottom;\n  }\n}\n\nclass TickY extends AbstractTick {\n  constructor(data, options = {}) {\n    const {x, y, inset = 0, insetRight = inset, insetLeft = inset} = options;\n    super(\n      data,\n      {\n        y: {value: y, scale: \"y\"},\n        x: {value: x, scale: \"x\", type: \"band\", optional: true}\n      },\n      options\n    );\n    this.insetRight = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetRight);\n    this.insetLeft = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.number)(insetLeft);\n  }\n  _transform(selection, mark, {y}) {\n    selection.call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, mark, {y}, 0, _style_js__WEBPACK_IMPORTED_MODULE_3__.offset);\n  }\n  _x1({x}, {x: X}, {marginLeft}) {\n    const {insetLeft} = this;\n    return X && x ? (i) => X[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _x2({x}, {x: X}, {width, marginRight}) {\n    const {insetRight} = this;\n    return X && x ? (i) => X[i] + x.bandwidth() - insetRight : width - marginRight - insetRight;\n  }\n  _y1(scales, {y: Y}) {\n    return (i) => Y[i];\n  }\n  _y2(scales, {y: Y}) {\n    return (i) => Y[i];\n  }\n}\n\nfunction tickX(data, {x = _options_js__WEBPACK_IMPORTED_MODULE_4__.identity, ...options} = {}) {\n  return new TickX(data, {...options, x});\n}\n\nfunction tickY(data, {y = _options_js__WEBPACK_IMPORTED_MODULE_4__.identity, ...options} = {}) {\n  return new TickY(data, {...options, y});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy90aWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxQztBQUNVO0FBQ2Y7QUFDbUI7QUFDNEQ7O0FBRS9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUFJO0FBQy9CO0FBQ0E7QUFDQSxJQUFJLG1EQUFPO0FBQ1g7QUFDQTtBQUNBLFdBQVcsbURBQU07QUFDakIsWUFBWSwwREFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFrQjtBQUNsQyxnQkFBZ0Isb0RBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxnQ0FBZ0M7QUFDaEMsV0FBVyx3REFBd0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsWUFBWTtBQUNaLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFNO0FBQzFCLHVCQUF1QixtREFBTTtBQUM3QjtBQUNBLCtCQUErQixFQUFFO0FBQ2pDLG1CQUFtQixxREFBYyxTQUFTLEVBQUUsRUFBRSw2Q0FBTTtBQUNwRDtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxPQUFPLEVBQUUsR0FBRyxLQUFLLEdBQUcsVUFBVTtBQUM5QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLE9BQU8sRUFBRSxHQUFHLEtBQUssR0FBRyxxQkFBcUI7QUFDekMsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGdDQUFnQztBQUNoQyxXQUFXLHdEQUF3RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZO0FBQ1osT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07QUFDNUIscUJBQXFCLG1EQUFNO0FBQzNCO0FBQ0EsK0JBQStCLEVBQUU7QUFDakMsbUJBQW1CLHFEQUFjLFNBQVMsRUFBRSxLQUFLLDZDQUFNO0FBQ3ZEO0FBQ0EsT0FBTyxFQUFFLEdBQUcsS0FBSyxHQUFHLFdBQVc7QUFDL0IsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLEVBQUUsR0FBRyxLQUFLLEdBQUcsbUJBQW1CO0FBQ3ZDLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVPLHNCQUFzQixJQUFJLGlEQUFRLGNBQWMsSUFBSTtBQUMzRCwwQkFBMEIsY0FBYztBQUN4Qzs7QUFFTyxzQkFBc0IsSUFBSSxpREFBUSxjQUFjLElBQUk7QUFDM0QsMEJBQTBCLGNBQWM7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL3RpY2suanM/OWJmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7aWRlbnRpdHksIG51bWJlcn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7YXBwbHlNYXJrZXJzLCBtYXJrZXJzfSBmcm9tIFwiLi4vbWFya2VyLmpzXCI7XG5pbXBvcnQge2FwcGx5RGlyZWN0U3R5bGVzLCBhcHBseUluZGlyZWN0U3R5bGVzLCBhcHBseVRyYW5zZm9ybSwgYXBwbHlDaGFubmVsU3R5bGVzLCBvZmZzZXR9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJpYUxhYmVsOiBcInRpY2tcIixcbiAgZmlsbDogbnVsbCxcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiXG59O1xuXG5jbGFzcyBBYnN0cmFjdFRpY2sgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgY2hhbm5lbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihkYXRhLCBjaGFubmVscywgb3B0aW9ucywgZGVmYXVsdHMpO1xuICAgIG1hcmtlcnModGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwodGhpcy5fdHJhbnNmb3JtLCB0aGlzLCBzY2FsZXMpXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcIngxXCIsIHRoaXMuX3gxKHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMpKVxuICAgICAgICAgIC5hdHRyKFwieDJcIiwgdGhpcy5feDIoc2NhbGVzLCBjaGFubmVscywgZGltZW5zaW9ucykpXG4gICAgICAgICAgLmF0dHIoXCJ5MVwiLCB0aGlzLl95MShzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zKSlcbiAgICAgICAgICAuYXR0cihcInkyXCIsIHRoaXMuX3kyKHNjYWxlcywgY2hhbm5lbHMsIGRpbWVuc2lvbnMpKVxuICAgICAgICAgIC5jYWxsKGFwcGx5Q2hhbm5lbFN0eWxlcywgdGhpcywgY2hhbm5lbHMpXG4gICAgICAgICAgLmNhbGwoYXBwbHlNYXJrZXJzLCB0aGlzLCBjaGFubmVscywgY29udGV4dClcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRpY2tYIGV4dGVuZHMgQWJzdHJhY3RUaWNrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gsIHksIGluc2V0ID0gMCwgaW5zZXRUb3AgPSBpbnNldCwgaW5zZXRCb3R0b20gPSBpbnNldH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeDoge3ZhbHVlOiB4LCBzY2FsZTogXCJ4XCJ9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIiwgdHlwZTogXCJiYW5kXCIsIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuaW5zZXRUb3AgPSBudW1iZXIoaW5zZXRUb3ApO1xuICAgIHRoaXMuaW5zZXRCb3R0b20gPSBudW1iZXIoaW5zZXRCb3R0b20pO1xuICB9XG4gIF90cmFuc2Zvcm0oc2VsZWN0aW9uLCBtYXJrLCB7eH0pIHtcbiAgICBzZWxlY3Rpb24uY2FsbChhcHBseVRyYW5zZm9ybSwgbWFyaywge3h9LCBvZmZzZXQsIDApO1xuICB9XG4gIF94MShzY2FsZXMsIHt4OiBYfSkge1xuICAgIHJldHVybiAoaSkgPT4gWFtpXTtcbiAgfVxuICBfeDIoc2NhbGVzLCB7eDogWH0pIHtcbiAgICByZXR1cm4gKGkpID0+IFhbaV07XG4gIH1cbiAgX3kxKHt5fSwge3k6IFl9LCB7bWFyZ2luVG9wfSkge1xuICAgIGNvbnN0IHtpbnNldFRvcH0gPSB0aGlzO1xuICAgIHJldHVybiBZICYmIHkgPyAoaSkgPT4gWVtpXSArIGluc2V0VG9wIDogbWFyZ2luVG9wICsgaW5zZXRUb3A7XG4gIH1cbiAgX3kyKHt5fSwge3k6IFl9LCB7aGVpZ2h0LCBtYXJnaW5Cb3R0b219KSB7XG4gICAgY29uc3Qge2luc2V0Qm90dG9tfSA9IHRoaXM7XG4gICAgcmV0dXJuIFkgJiYgeSA/IChpKSA9PiBZW2ldICsgeS5iYW5kd2lkdGgoKSAtIGluc2V0Qm90dG9tIDogaGVpZ2h0IC0gbWFyZ2luQm90dG9tIC0gaW5zZXRCb3R0b207XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRpY2tZIGV4dGVuZHMgQWJzdHJhY3RUaWNrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gsIHksIGluc2V0ID0gMCwgaW5zZXRSaWdodCA9IGluc2V0LCBpbnNldExlZnQgPSBpbnNldH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKFxuICAgICAgZGF0YSxcbiAgICAgIHtcbiAgICAgICAgeToge3ZhbHVlOiB5LCBzY2FsZTogXCJ5XCJ9LFxuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgdHlwZTogXCJiYW5kXCIsIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuaW5zZXRSaWdodCA9IG51bWJlcihpbnNldFJpZ2h0KTtcbiAgICB0aGlzLmluc2V0TGVmdCA9IG51bWJlcihpbnNldExlZnQpO1xuICB9XG4gIF90cmFuc2Zvcm0oc2VsZWN0aW9uLCBtYXJrLCB7eX0pIHtcbiAgICBzZWxlY3Rpb24uY2FsbChhcHBseVRyYW5zZm9ybSwgbWFyaywge3l9LCAwLCBvZmZzZXQpO1xuICB9XG4gIF94MSh7eH0sIHt4OiBYfSwge21hcmdpbkxlZnR9KSB7XG4gICAgY29uc3Qge2luc2V0TGVmdH0gPSB0aGlzO1xuICAgIHJldHVybiBYICYmIHggPyAoaSkgPT4gWFtpXSArIGluc2V0TGVmdCA6IG1hcmdpbkxlZnQgKyBpbnNldExlZnQ7XG4gIH1cbiAgX3gyKHt4fSwge3g6IFh9LCB7d2lkdGgsIG1hcmdpblJpZ2h0fSkge1xuICAgIGNvbnN0IHtpbnNldFJpZ2h0fSA9IHRoaXM7XG4gICAgcmV0dXJuIFggJiYgeCA/IChpKSA9PiBYW2ldICsgeC5iYW5kd2lkdGgoKSAtIGluc2V0UmlnaHQgOiB3aWR0aCAtIG1hcmdpblJpZ2h0IC0gaW5zZXRSaWdodDtcbiAgfVxuICBfeTEoc2NhbGVzLCB7eTogWX0pIHtcbiAgICByZXR1cm4gKGkpID0+IFlbaV07XG4gIH1cbiAgX3kyKHNjYWxlcywge3k6IFl9KSB7XG4gICAgcmV0dXJuIChpKSA9PiBZW2ldO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrWChkYXRhLCB7eCA9IGlkZW50aXR5LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIHJldHVybiBuZXcgVGlja1goZGF0YSwgey4uLm9wdGlvbnMsIHh9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tZKGRhdGEsIHt5ID0gaWRlbnRpdHksIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBUaWNrWShkYXRhLCB7Li4ub3B0aW9ucywgeX0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/tick.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/tip.js":
/*!**********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/tip.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tip: () => (/* binding */ Tip),\n/* harmony export */   tip: () => (/* binding */ tip)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../format.js */ \"(ssr)/./node_modules/@observablehq/plot/src/format.js\");\n/* harmony import */ var _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interactions/pointer.js */ \"(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _axis_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./axis.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./text.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"tip\",\n  fill: \"var(--plot-background)\",\n  stroke: \"currentColor\"\n};\n\n// These channels are not displayed in the default tip; see formatChannels.\nconst ignoreChannels = new Set([\"geometry\", \"href\", \"src\", \"ariaLabel\", \"scales\"]);\n\nclass Tip extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    if (options.tip) options = {...options, tip: false};\n    if (options.title === undefined && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isIterable)(data) && (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTextual)(data)) options = {...options, title: _options_js__WEBPACK_IMPORTED_MODULE_2__.identity};\n    const {\n      x,\n      y,\n      x1,\n      x2,\n      y1,\n      y2,\n      anchor,\n      preferredAnchor = \"bottom\",\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      lineHeight = 1,\n      lineWidth = 20,\n      frameAnchor,\n      format,\n      textAnchor = \"start\",\n      textOverflow,\n      textPadding = 8,\n      title,\n      pointerSize = 12,\n      pathFilter = \"drop-shadow(0 3px 4px rgba(0,0,0,0.2))\"\n    } = options;\n    super(\n      data,\n      {\n        x: {value: x1 != null && x2 != null ? null : x, scale: \"x\", optional: true}, // ignore midpoint\n        y: {value: y1 != null && y2 != null ? null : y, scale: \"y\", optional: true}, // ignore midpoint\n        x1: {value: x1, scale: \"x\", optional: x2 == null},\n        y1: {value: y1, scale: \"y\", optional: y2 == null},\n        x2: {value: x2, scale: \"x\", optional: x1 == null},\n        y2: {value: y2, scale: \"y\", optional: y1 == null},\n        title: {value: title, optional: true} // filter: defined\n      },\n      options,\n      defaults\n    );\n    this.anchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeAnchor)(anchor, \"anchor\");\n    this.preferredAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeAnchor)(preferredAnchor, \"preferredAnchor\");\n    this.frameAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeFrameAnchor)(frameAnchor);\n    this.textAnchor = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.impliedString)(textAnchor, \"middle\");\n    this.textPadding = +textPadding;\n    this.pointerSize = +pointerSize;\n    this.pathFilter = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(pathFilter);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = (0,_text_js__WEBPACK_IMPORTED_MODULE_4__.maybeTextOverflow)(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontFamily);\n    this.fontSize = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.number)(fontSize);\n    this.fontStyle = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontStyle);\n    this.fontVariant = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontVariant);\n    this.fontWeight = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.string)(fontWeight);\n    for (const key in defaults) if (key in this.channels) this[key] = defaults[key]; // apply default even if channel\n    this.splitLines = (0,_text_js__WEBPACK_IMPORTED_MODULE_4__.splitter)(this);\n    this.clipLine = (0,_text_js__WEBPACK_IMPORTED_MODULE_4__.clipper)(this);\n    this.format = typeof format === \"string\" || typeof format === \"function\" ? {title: format} : {...format}; // defensive copy before mutate; also promote nullish to empty\n  }\n  render(index, scales, values, dimensions, context) {\n    const mark = this;\n    const {x, y, fx, fy} = scales;\n    const {ownerSVGElement: svg, document} = context;\n    const {anchor, monospace, lineHeight, lineWidth} = this;\n    const {textPadding: r, pointerSize: m, pathFilter} = this;\n    const {marginTop, marginLeft} = dimensions;\n\n    // The anchor position is the middle of x1 & y1 and x2 & y2, if available,\n    // or x & y; the former is considered more specific because it’s how we\n    // disable the implicit stack and interval transforms. If any dimension is\n    // unspecified, we fallback to the frame anchor. We also need to know the\n    // facet offsets to detect when the tip would draw outside the plot, and\n    // thus we need to change the orientation.\n    const {x1: X1, y1: Y1, x2: X2, y2: Y2, x: X = X1 ?? X2, y: Y = Y1 ?? Y2} = values;\n    const ox = fx ? fx(index.fx) - marginLeft : 0;\n    const oy = fy ? fy(index.fy) - marginTop : 0;\n\n    // The order of precedence for the anchor position is: the middle of x1 & y1\n    // and x2 & y2; or x1 & y1 (e.g., area); or lastly x & y. If a dimension is\n    // unspecified, the frame anchor is used.\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.applyFrameAnchor)(this, dimensions);\n    const px = (0,_interactions_pointer_js__WEBPACK_IMPORTED_MODULE_5__.anchorX)(values, cx);\n    const py = (0,_interactions_pointer_js__WEBPACK_IMPORTED_MODULE_5__.anchorY)(values, cy);\n\n    // Resolve the text metric implementation. We may need an ellipsis for text\n    // truncation, so we optimistically compute the ellipsis width.\n    const widthof = monospace ? _text_js__WEBPACK_IMPORTED_MODULE_4__.monospaceWidth : _text_js__WEBPACK_IMPORTED_MODULE_4__.defaultWidth;\n    const ee = widthof(_text_js__WEBPACK_IMPORTED_MODULE_4__.ellipsis);\n\n    // If there’s a title channel, display that as-is; otherwise, show multiple\n    // channels as name-value pairs.\n    let sources, format;\n    if (\"title\" in values) {\n      sources = getSourceChannels.call(this, {title: values.channels.title}, scales);\n      format = formatTitle;\n    } else {\n      sources = getSourceChannels.call(this, values.channels, scales);\n      format = formatChannels;\n    }\n\n    // We don’t call applyChannelStyles because we only use the channels to\n    // derive the content of the tip, not its aesthetics.\n    const g = (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(_text_js__WEBPACK_IMPORTED_MODULE_4__.applyIndirectTextStyles, this)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"g\")\n          .attr(\"transform\", (i) => `translate(${Math.round(px(i))},${Math.round(py(i))})`) // crisp edges\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n          .call((g) => g.append(\"path\").attr(\"filter\", pathFilter))\n          .call((g) =>\n            g.append(\"text\").each(function (i) {\n              const that = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(this);\n              // prevent style inheritance (from path)\n              this.setAttribute(\"fill\", \"currentColor\");\n              this.setAttribute(\"fill-opacity\", 1);\n              this.setAttribute(\"stroke\", \"none\");\n              // iteratively render each channel value\n              const lines = format.call(mark, i, index, sources, scales, values);\n              if (typeof lines === \"string\") {\n                for (const line of mark.splitLines(lines)) {\n                  renderLine(that, {value: mark.clipLine(line)});\n                }\n              } else {\n                const labels = new Set();\n                for (const line of lines) {\n                  const {label = \"\"} = line;\n                  if (label && labels.has(label)) continue;\n                  else labels.add(label);\n                  renderLine(that, line);\n                }\n              }\n            })\n          )\n      );\n\n    // Renders a single line (a name-value pair) to the tip, truncating the text\n    // as needed, and adding a title if the text is truncated. Note that this is\n    // just the initial layout of the text; in postrender we will compute the\n    // exact text metrics and translate the text as needed once we know the\n    // tip’s orientation (anchor).\n    function renderLine(selection, {label, value, color, opacity}) {\n      (label ??= \"\"), (value ??= \"\");\n      const swatch = color != null || opacity != null;\n      let title;\n      let w = lineWidth * 100;\n      const [j] = (0,_text_js__WEBPACK_IMPORTED_MODULE_4__.cut)(label, w, widthof, ee);\n      if (j >= 0) {\n        // label is truncated\n        label = label.slice(0, j).trimEnd() + _text_js__WEBPACK_IMPORTED_MODULE_4__.ellipsis;\n        title = value.trim();\n        value = \"\";\n      } else {\n        if (label || (!value && !swatch)) value = \" \" + value;\n        const [k] = (0,_text_js__WEBPACK_IMPORTED_MODULE_4__.cut)(value, w - widthof(label), widthof, ee);\n        if (k >= 0) {\n          // value is truncated\n          title = value.trim();\n          value = value.slice(0, k).trimEnd() + _text_js__WEBPACK_IMPORTED_MODULE_4__.ellipsis;\n        }\n      }\n      const line = selection.append(\"tspan\").attr(\"x\", 0).attr(\"dy\", `${lineHeight}em`).text(\"\\u200b\"); // zwsp for double-click\n      if (label) line.append(\"tspan\").attr(\"font-weight\", \"bold\").text(label);\n      if (value) line.append(() => document.createTextNode(value));\n      if (swatch) line.append(\"tspan\").text(\" ■\").attr(\"fill\", color).attr(\"fill-opacity\", opacity).style(\"user-select\", \"none\"); // prettier-ignore\n      if (title) line.append(\"title\").text(title);\n    }\n\n    // Only after the plot is attached to the page can we compute the exact text\n    // metrics needed to determine the tip size and orientation (anchor).\n    function postrender() {\n      const {width, height} = dimensions.facet ?? dimensions;\n      g.selectChildren().each(function (i) {\n        let {x: tx, width: w, height: h} = this.getBBox();\n        (w = Math.round(w)), (h = Math.round(h)); // crisp edges\n        let a = anchor; // use the specified anchor, if any\n        if (a === undefined) {\n          const x = px(i) + ox;\n          const y = py(i) + oy;\n          const fitLeft = x + w + m + r * 2 < width;\n          const fitRight = x - w - m - r * 2 > 0;\n          const fitTop = y + h + m + r * 2 < height;\n          const fitBottom = y - h - m - r * 2 > 0;\n          a =\n            fitLeft && fitRight\n              ? fitTop && fitBottom\n                ? mark.preferredAnchor\n                : fitBottom\n                ? \"bottom\"\n                : \"top\"\n              : fitTop && fitBottom\n              ? fitLeft\n                ? \"left\"\n                : \"right\"\n              : (fitLeft || fitRight) && (fitTop || fitBottom)\n              ? `${fitBottom ? \"bottom\" : \"top\"}-${fitLeft ? \"left\" : \"right\"}`\n              : mark.preferredAnchor;\n        }\n        const path = this.firstChild; // note: assumes exactly two children!\n        const text = this.lastChild; // note: assumes exactly two children!\n        path.setAttribute(\"d\", getPath(a, m, r, w, h));\n        if (tx) for (const t of text.childNodes) t.setAttribute(\"x\", -tx);\n        text.setAttribute(\"y\", `${+getLineOffset(a, text.childNodes.length, lineHeight).toFixed(6)}em`);\n        text.setAttribute(\"transform\", `translate(${getTextTranslate(a, m, r, w, h)})`);\n      });\n      g.attr(\"visibility\", null);\n    }\n\n    // Wait until the plot is inserted into the page so that we can use getBBox\n    // to compute the exact text dimensions. If the SVG is already connected, as\n    // when the pointer interaction triggers the re-render, use a faster\n    // microtask instead of an animation frame; if this SSR (e.g., JSDOM), skip\n    // this step. Perhaps this could be done synchronously; getting the\n    // dimensions of the SVG is easy, and although accurate text metrics are\n    // hard, we could use approximate heuristics.\n    if (index.length) {\n      g.attr(\"visibility\", \"hidden\"); // hide until postrender\n      if (svg.isConnected) Promise.resolve().then(postrender);\n      else if (typeof requestAnimationFrame !== \"undefined\") requestAnimationFrame(postrender);\n    }\n\n    return g.node();\n  }\n}\n\nfunction tip(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Tip(data, {...options, x, y});\n}\n\nfunction getLineOffset(anchor, length, lineHeight) {\n  return /^top(?:-|$)/.test(anchor)\n    ? 0.94 - lineHeight\n    :  true\n    ? -0.29 - length * lineHeight\n    : 0;\n}\n\nfunction getTextTranslate(anchor, m, r, width, height) {\n  switch (anchor) {\n    case \"middle\":\n      return [-width / 2, height / 2];\n    case \"top-left\":\n      return [r, m + r];\n    case \"top\":\n      return [-width / 2, m / 2 + r];\n    case \"top-right\":\n      return [-width - r, m + r];\n    case \"right\":\n      return [-m / 2 - width - r, height / 2];\n    case \"bottom-left\":\n      return [r, -m - r];\n    case \"bottom\":\n      return [-width / 2, -m / 2 - r];\n    case \"bottom-right\":\n      return [-width - r, -m - r];\n    case \"left\":\n      return [r + m / 2, height / 2];\n  }\n}\n\nfunction getPath(anchor, m, r, width, height) {\n  const w = width + r * 2;\n  const h = height + r * 2;\n  switch (anchor) {\n    case \"middle\":\n      return `M${-w / 2},${-h / 2}h${w}v${h}h${-w}z`;\n    case \"top-left\":\n      return `M0,0l${m},${m}h${w - m}v${h}h${-w}z`;\n    case \"top\":\n      return `M0,0l${m / 2},${m / 2}h${(w - m) / 2}v${h}h${-w}v${-h}h${(w - m) / 2}z`;\n    case \"top-right\":\n      return `M0,0l${-m},${m}h${m - w}v${h}h${w}z`;\n    case \"right\":\n      return `M0,0l${-m / 2},${-m / 2}v${m / 2 - h / 2}h${-w}v${h}h${w}v${m / 2 - h / 2}z`;\n    case \"bottom-left\":\n      return `M0,0l${m},${-m}h${w - m}v${-h}h${-w}z`;\n    case \"bottom\":\n      return `M0,0l${m / 2},${-m / 2}h${(w - m) / 2}v${-h}h${-w}v${h}h${(w - m) / 2}z`;\n    case \"bottom-right\":\n      return `M0,0l${-m},${-m}h${m - w}v${-h}h${w}z`;\n    case \"left\":\n      return `M0,0l${m / 2},${-m / 2}v${m / 2 - h / 2}h${w}v${h}h${-w}v${m / 2 - h / 2}z`;\n  }\n}\n\n// Note: mutates this.format!\nfunction getSourceChannels(channels, scales) {\n  const sources = {};\n\n  // Promote x and y shorthand for paired channels (in order).\n  let format = this.format;\n  format = maybeExpandPairedFormat(format, channels, \"x\");\n  format = maybeExpandPairedFormat(format, channels, \"y\");\n  this.format = format;\n\n  // Prioritize channels with explicit formats, in the given order.\n  for (const key in format) {\n    const value = format[key];\n    if (value === null || value === false) {\n      continue;\n    } else if (key === \"fx\" || key === \"fy\") {\n      sources[key] = true;\n    } else {\n      const source = (0,_channel_js__WEBPACK_IMPORTED_MODULE_7__.getSource)(channels, key);\n      if (source) sources[key] = source;\n    }\n  }\n\n  // Then fallback to all other (non-ignored) channels.\n  for (const key in channels) {\n    if (key in sources || key in format || ignoreChannels.has(key)) continue;\n    if ((key === \"x\" || key === \"y\") && channels.geometry) continue; // ignore x & y on geo\n    const source = (0,_channel_js__WEBPACK_IMPORTED_MODULE_7__.getSource)(channels, key);\n    if (source) {\n      // Ignore color channels if the values are all literal colors.\n      if (source.scale == null && source.defaultScale === \"color\") continue;\n      sources[key] = source;\n    }\n  }\n\n  // And lastly facet channels, but only if this mark is faceted.\n  if (this.facet) {\n    if (scales.fx && !(\"fx\" in format)) sources.fx = true;\n    if (scales.fy && !(\"fy\" in format)) sources.fy = true;\n  }\n\n  // Promote shorthand string formats, and materialize default formats.\n  for (const key in sources) {\n    const format = this.format[key];\n    if (typeof format === \"string\") {\n      const value = sources[key]?.value ?? scales[key]?.domain() ?? [];\n      this.format[key] = ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal)(value) ? d3__WEBPACK_IMPORTED_MODULE_0__.utcFormat : d3__WEBPACK_IMPORTED_MODULE_0__.format)(format);\n    } else if (format === undefined || format === true) {\n      // For ordinal scales, the inferred tick format can be more concise, such\n      // as only showing the year for yearly data.\n      const scale = scales[key];\n      this.format[key] = scale?.bandwidth ? (0,_axis_js__WEBPACK_IMPORTED_MODULE_8__.inferTickFormat)(scale, scale.domain()) : _format_js__WEBPACK_IMPORTED_MODULE_9__.formatDefault;\n    }\n  }\n\n  return sources;\n}\n\n// Promote x and y shorthand for paired channels, while preserving order.\nfunction maybeExpandPairedFormat(format, channels, key) {\n  if (!(key in format)) return format;\n  const key1 = `${key}1`;\n  const key2 = `${key}2`;\n  if ((key1 in format || !(key1 in channels)) && (key2 in format || !(key2 in channels))) return format;\n  const entries = Object.entries(format);\n  const value = format[key];\n  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);\n  return Object.fromEntries(entries);\n}\n\nfunction formatTitle(i, index, {title}) {\n  return this.format.title(title.value[i], i);\n}\n\nfunction* formatChannels(i, index, channels, scales, values) {\n  for (const key in channels) {\n    if (key === \"fx\" || key === \"fy\") {\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](index[key], i)\n      };\n      continue;\n    }\n    if (key === \"x1\" && \"x2\" in channels) continue;\n    if (key === \"y1\" && \"y2\" in channels) continue;\n    const channel = channels[key];\n    if (key === \"x2\" && \"x1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"x\"),\n        value: formatPair(this.format.x2, channels.x1, channel, i)\n      };\n    } else if (key === \"y2\" && \"y1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"y\"),\n        value: formatPair(this.format.y2, channels.y1, channel, i)\n      };\n    } else {\n      const value = channel.value[i];\n      const scale = channel.scale;\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__.defined)(value) && scale == null) continue;\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](value, i),\n        color: scale === \"color\" ? values[key][i] : null,\n        opacity: scale === \"opacity\" ? values[key][i] : null\n      };\n    }\n  }\n}\n\nfunction formatPair(formatValue, c1, c2, i) {\n  return c2.hint?.length // e.g., stackY’s y1 and y2\n    ? `${formatValue(c2.value[i] - c1.value[i], i)}`\n    : `${formatValue(c1.value[i], i)}–${formatValue(c2.value[i], i)}`;\n}\n\nfunction formatPairLabel(scales, channels, key) {\n  const l1 = formatLabel(scales, channels, `${key}1`, key);\n  const l2 = formatLabel(scales, channels, `${key}2`, key);\n  return l1 === l2 ? l1 : `${l1}–${l2}`;\n}\n\nfunction formatLabel(scales, channels, key, defaultLabel = key) {\n  const channel = channels[key];\n  const scale = scales[channel?.scale ?? key];\n  return String(scale?.label ?? channel?.label ?? defaultLabel);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy90aXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNyQjtBQUNIO0FBQ0M7QUFDSztBQUNpQjtBQUM1QjtBQUN3RDtBQUM0QjtBQUMxQztBQUNoQztBQUNnRDtBQUN0Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7O0FBRU8sa0JBQWtCLDBDQUFJO0FBQzdCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsdUNBQXVDLHVEQUFVLFVBQVUsc0RBQVMsbUJBQW1CLG1CQUFtQixpREFBUTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRixZQUFZLHVFQUF1RTtBQUNuRixhQUFhLDRDQUE0QztBQUN6RCxhQUFhLDRDQUE0QztBQUN6RCxhQUFhLDRDQUE0QztBQUN6RCxhQUFhLDRDQUE0QztBQUN6RCxnQkFBZ0IsOEJBQThCO0FBQzlDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQVc7QUFDN0IsMkJBQTJCLHdEQUFXO0FBQ3RDLHVCQUF1Qiw2REFBZ0I7QUFDdkMsc0JBQXNCLHdEQUFhO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07QUFDNUI7QUFDQTtBQUNBLHdCQUF3QiwyREFBaUI7QUFDekM7QUFDQSxzQkFBc0IsbURBQU07QUFDNUIsb0JBQW9CLG1EQUFNO0FBQzFCLHFCQUFxQixtREFBTTtBQUMzQix1QkFBdUIsbURBQU07QUFDN0Isc0JBQXNCLG1EQUFNO0FBQzVCLHFGQUFxRjtBQUNyRixzQkFBc0Isa0RBQVE7QUFDOUIsb0JBQW9CLGlEQUFPO0FBQzNCLGdGQUFnRixlQUFlLEdBQUcsWUFBWSxpQ0FBaUM7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsMENBQTBDO0FBQ3JELFdBQVcsNENBQTRDO0FBQ3ZELFdBQVcsdUJBQXVCOztBQUVsQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0EscUJBQXFCLDJEQUFnQjtBQUNyQyxlQUFlLGlFQUFPO0FBQ3RCLGVBQWUsaUVBQU87O0FBRXRCO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQWMsR0FBRyxrREFBWTtBQUM3RCx1QkFBdUIsOENBQVE7O0FBRS9CLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNkJBQTZCO0FBQzNFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxtREFBTTtBQUNwQixZQUFZLDBEQUFtQjtBQUMvQixZQUFZLDZEQUF1QjtBQUNuQyxZQUFZLHFEQUFjLFNBQVMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDeEYsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMENBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFHO0FBQ3JCO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQVE7QUFDdEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9CQUFvQiw2Q0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOENBQVE7QUFDeEQ7QUFDQTtBQUNBLHdFQUF3RSxXQUFXLHFCQUFxQjtBQUN4RztBQUNBO0FBQ0Esa0lBQWtJO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsa0RBQWtEO0FBQ2xELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkIsR0FBRywyQkFBMkI7QUFDOUU7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGtDQUFrQyxpRUFBaUU7QUFDbkcsb0RBQW9ELGdDQUFnQztBQUNwRixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPLG9CQUFvQixrQkFBa0IsSUFBSTtBQUNqRCxrREFBa0QsdURBQVU7QUFDNUQsd0JBQXdCLGlCQUFpQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQWdCO0FBQ3RCO0FBQ0EsTUFBTSxDQUF5QjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sR0FBRyxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHO0FBQ2xEO0FBQ0EscUJBQXFCLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxHQUFHLEVBQUUsR0FBRyxHQUFHO0FBQ2hEO0FBQ0EscUJBQXFCLE1BQU0sR0FBRyxNQUFNLEdBQUcsWUFBWSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQVk7QUFDbkY7QUFDQSxxQkFBcUIsR0FBRyxHQUFHLEVBQUUsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDaEQ7QUFDQSxxQkFBcUIsT0FBTyxHQUFHLE9BQU8sR0FBRyxjQUFjLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsY0FBYztBQUN4RjtBQUNBLHFCQUFxQixFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNsRDtBQUNBLHFCQUFxQixNQUFNLEdBQUcsT0FBTyxHQUFHLFlBQVksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxZQUFZO0FBQ3BGO0FBQ0EscUJBQXFCLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ2xEO0FBQ0EscUJBQXFCLE1BQU0sR0FBRyxPQUFPLEdBQUcsY0FBYyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLGNBQWM7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixzREFBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLG1CQUFtQixzREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFVLFVBQVUseUNBQVMsR0FBRyxzQ0FBWTtBQUN0RSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlEQUFlLDBCQUEwQixxREFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEIsa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsV0FBVyxxREFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsMENBQTBDO0FBQ25ELFNBQVMsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ3BFOztBQUVBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsOENBQThDLElBQUk7QUFDbEQsNkJBQTZCLEdBQUcsR0FBRyxHQUFHO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL3RpcC5qcz83OWRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c2VsZWN0LCBmb3JtYXQgYXMgbnVtYmVyRm9ybWF0LCB1dGNGb3JtYXR9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtnZXRTb3VyY2V9IGZyb20gXCIuLi9jaGFubmVsLmpzXCI7XG5pbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7ZGVmaW5lZH0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7Zm9ybWF0RGVmYXVsdH0gZnJvbSBcIi4uL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHthbmNob3JYLCBhbmNob3JZfSBmcm9tIFwiLi4vaW50ZXJhY3Rpb25zL3BvaW50ZXIuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7bWF5YmVBbmNob3IsIG1heWJlRnJhbWVBbmNob3IsIG1heWJlVHVwbGUsIG51bWJlciwgc3RyaW5nfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseURpcmVjdFN0eWxlcywgYXBwbHlGcmFtZUFuY2hvciwgYXBwbHlJbmRpcmVjdFN0eWxlcywgYXBwbHlUcmFuc2Zvcm0sIGltcGxpZWRTdHJpbmd9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHtpZGVudGl0eSwgaXNJdGVyYWJsZSwgaXNUZW1wb3JhbCwgaXNUZXh0dWFsfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtpbmZlclRpY2tGb3JtYXR9IGZyb20gXCIuL2F4aXMuanNcIjtcbmltcG9ydCB7YXBwbHlJbmRpcmVjdFRleHRTdHlsZXMsIGRlZmF1bHRXaWR0aCwgZWxsaXBzaXMsIG1vbm9zcGFjZVdpZHRofSBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQge2N1dCwgY2xpcHBlciwgc3BsaXR0ZXIsIG1heWJlVGV4dE92ZXJmbG93fSBmcm9tIFwiLi90ZXh0LmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwidGlwXCIsXG4gIGZpbGw6IFwidmFyKC0tcGxvdC1iYWNrZ3JvdW5kKVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCJcbn07XG5cbi8vIFRoZXNlIGNoYW5uZWxzIGFyZSBub3QgZGlzcGxheWVkIGluIHRoZSBkZWZhdWx0IHRpcDsgc2VlIGZvcm1hdENoYW5uZWxzLlxuY29uc3QgaWdub3JlQ2hhbm5lbHMgPSBuZXcgU2V0KFtcImdlb21ldHJ5XCIsIFwiaHJlZlwiLCBcInNyY1wiLCBcImFyaWFMYWJlbFwiLCBcInNjYWxlc1wiXSk7XG5cbmV4cG9ydCBjbGFzcyBUaXAgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMudGlwKSBvcHRpb25zID0gey4uLm9wdGlvbnMsIHRpcDogZmFsc2V9O1xuICAgIGlmIChvcHRpb25zLnRpdGxlID09PSB1bmRlZmluZWQgJiYgaXNJdGVyYWJsZShkYXRhKSAmJiBpc1RleHR1YWwoZGF0YSkpIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgdGl0bGU6IGlkZW50aXR5fTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHgxLFxuICAgICAgeDIsXG4gICAgICB5MSxcbiAgICAgIHkyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcHJlZmVycmVkQW5jaG9yID0gXCJib3R0b21cIixcbiAgICAgIG1vbm9zcGFjZSxcbiAgICAgIGZvbnRGYW1pbHkgPSBtb25vc3BhY2UgPyBcInVpLW1vbm9zcGFjZSwgbW9ub3NwYWNlXCIgOiB1bmRlZmluZWQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50LFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIGxpbmVIZWlnaHQgPSAxLFxuICAgICAgbGluZVdpZHRoID0gMjAsXG4gICAgICBmcmFtZUFuY2hvcixcbiAgICAgIGZvcm1hdCxcbiAgICAgIHRleHRBbmNob3IgPSBcInN0YXJ0XCIsXG4gICAgICB0ZXh0T3ZlcmZsb3csXG4gICAgICB0ZXh0UGFkZGluZyA9IDgsXG4gICAgICB0aXRsZSxcbiAgICAgIHBvaW50ZXJTaXplID0gMTIsXG4gICAgICBwYXRoRmlsdGVyID0gXCJkcm9wLXNoYWRvdygwIDNweCA0cHggcmdiYSgwLDAsMCwwLjIpKVwiXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgxICE9IG51bGwgJiYgeDIgIT0gbnVsbCA/IG51bGwgOiB4LCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB0cnVlfSwgLy8gaWdub3JlIG1pZHBvaW50XG4gICAgICAgIHk6IHt2YWx1ZTogeTEgIT0gbnVsbCAmJiB5MiAhPSBudWxsID8gbnVsbCA6IHksIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LCAvLyBpZ25vcmUgbWlkcG9pbnRcbiAgICAgICAgeDE6IHt2YWx1ZTogeDEsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHgyID09IG51bGx9LFxuICAgICAgICB5MToge3ZhbHVlOiB5MSwgc2NhbGU6IFwieVwiLCBvcHRpb25hbDogeTIgPT0gbnVsbH0sXG4gICAgICAgIHgyOiB7dmFsdWU6IHgyLCBzY2FsZTogXCJ4XCIsIG9wdGlvbmFsOiB4MSA9PSBudWxsfSxcbiAgICAgICAgeTI6IHt2YWx1ZTogeTIsIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHkxID09IG51bGx9LFxuICAgICAgICB0aXRsZToge3ZhbHVlOiB0aXRsZSwgb3B0aW9uYWw6IHRydWV9IC8vIGZpbHRlcjogZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZWZhdWx0c1xuICAgICk7XG4gICAgdGhpcy5hbmNob3IgPSBtYXliZUFuY2hvcihhbmNob3IsIFwiYW5jaG9yXCIpO1xuICAgIHRoaXMucHJlZmVycmVkQW5jaG9yID0gbWF5YmVBbmNob3IocHJlZmVycmVkQW5jaG9yLCBcInByZWZlcnJlZEFuY2hvclwiKTtcbiAgICB0aGlzLmZyYW1lQW5jaG9yID0gbWF5YmVGcmFtZUFuY2hvcihmcmFtZUFuY2hvcik7XG4gICAgdGhpcy50ZXh0QW5jaG9yID0gaW1wbGllZFN0cmluZyh0ZXh0QW5jaG9yLCBcIm1pZGRsZVwiKTtcbiAgICB0aGlzLnRleHRQYWRkaW5nID0gK3RleHRQYWRkaW5nO1xuICAgIHRoaXMucG9pbnRlclNpemUgPSArcG9pbnRlclNpemU7XG4gICAgdGhpcy5wYXRoRmlsdGVyID0gc3RyaW5nKHBhdGhGaWx0ZXIpO1xuICAgIHRoaXMubGluZUhlaWdodCA9ICtsaW5lSGVpZ2h0O1xuICAgIHRoaXMubGluZVdpZHRoID0gK2xpbmVXaWR0aDtcbiAgICB0aGlzLnRleHRPdmVyZmxvdyA9IG1heWJlVGV4dE92ZXJmbG93KHRleHRPdmVyZmxvdyk7XG4gICAgdGhpcy5tb25vc3BhY2UgPSAhIW1vbm9zcGFjZTtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBzdHJpbmcoZm9udEZhbWlseSk7XG4gICAgdGhpcy5mb250U2l6ZSA9IG51bWJlcihmb250U2l6ZSk7XG4gICAgdGhpcy5mb250U3R5bGUgPSBzdHJpbmcoZm9udFN0eWxlKTtcbiAgICB0aGlzLmZvbnRWYXJpYW50ID0gc3RyaW5nKGZvbnRWYXJpYW50KTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBzdHJpbmcoZm9udFdlaWdodCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIGlmIChrZXkgaW4gdGhpcy5jaGFubmVscykgdGhpc1trZXldID0gZGVmYXVsdHNba2V5XTsgLy8gYXBwbHkgZGVmYXVsdCBldmVuIGlmIGNoYW5uZWxcbiAgICB0aGlzLnNwbGl0TGluZXMgPSBzcGxpdHRlcih0aGlzKTtcbiAgICB0aGlzLmNsaXBMaW5lID0gY2xpcHBlcih0aGlzKTtcbiAgICB0aGlzLmZvcm1hdCA9IHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGZvcm1hdCA9PT0gXCJmdW5jdGlvblwiID8ge3RpdGxlOiBmb3JtYXR9IDogey4uLmZvcm1hdH07IC8vIGRlZmVuc2l2ZSBjb3B5IGJlZm9yZSBtdXRhdGU7IGFsc28gcHJvbW90ZSBudWxsaXNoIHRvIGVtcHR5XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIHZhbHVlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5LCBmeCwgZnl9ID0gc2NhbGVzO1xuICAgIGNvbnN0IHtvd25lclNWR0VsZW1lbnQ6IHN2ZywgZG9jdW1lbnR9ID0gY29udGV4dDtcbiAgICBjb25zdCB7YW5jaG9yLCBtb25vc3BhY2UsIGxpbmVIZWlnaHQsIGxpbmVXaWR0aH0gPSB0aGlzO1xuICAgIGNvbnN0IHt0ZXh0UGFkZGluZzogciwgcG9pbnRlclNpemU6IG0sIHBhdGhGaWx0ZXJ9ID0gdGhpcztcbiAgICBjb25zdCB7bWFyZ2luVG9wLCBtYXJnaW5MZWZ0fSA9IGRpbWVuc2lvbnM7XG5cbiAgICAvLyBUaGUgYW5jaG9yIHBvc2l0aW9uIGlzIHRoZSBtaWRkbGUgb2YgeDEgJiB5MSBhbmQgeDIgJiB5MiwgaWYgYXZhaWxhYmxlLFxuICAgIC8vIG9yIHggJiB5OyB0aGUgZm9ybWVyIGlzIGNvbnNpZGVyZWQgbW9yZSBzcGVjaWZpYyBiZWNhdXNlIGl04oCZcyBob3cgd2VcbiAgICAvLyBkaXNhYmxlIHRoZSBpbXBsaWNpdCBzdGFjayBhbmQgaW50ZXJ2YWwgdHJhbnNmb3Jtcy4gSWYgYW55IGRpbWVuc2lvbiBpc1xuICAgIC8vIHVuc3BlY2lmaWVkLCB3ZSBmYWxsYmFjayB0byB0aGUgZnJhbWUgYW5jaG9yLiBXZSBhbHNvIG5lZWQgdG8ga25vdyB0aGVcbiAgICAvLyBmYWNldCBvZmZzZXRzIHRvIGRldGVjdCB3aGVuIHRoZSB0aXAgd291bGQgZHJhdyBvdXRzaWRlIHRoZSBwbG90LCBhbmRcbiAgICAvLyB0aHVzIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBvcmllbnRhdGlvbi5cbiAgICBjb25zdCB7eDE6IFgxLCB5MTogWTEsIHgyOiBYMiwgeTI6IFkyLCB4OiBYID0gWDEgPz8gWDIsIHk6IFkgPSBZMSA/PyBZMn0gPSB2YWx1ZXM7XG4gICAgY29uc3Qgb3ggPSBmeCA/IGZ4KGluZGV4LmZ4KSAtIG1hcmdpbkxlZnQgOiAwO1xuICAgIGNvbnN0IG95ID0gZnkgPyBmeShpbmRleC5meSkgLSBtYXJnaW5Ub3AgOiAwO1xuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByZWNlZGVuY2UgZm9yIHRoZSBhbmNob3IgcG9zaXRpb24gaXM6IHRoZSBtaWRkbGUgb2YgeDEgJiB5MVxuICAgIC8vIGFuZCB4MiAmIHkyOyBvciB4MSAmIHkxIChlLmcuLCBhcmVhKTsgb3IgbGFzdGx5IHggJiB5LiBJZiBhIGRpbWVuc2lvbiBpc1xuICAgIC8vIHVuc3BlY2lmaWVkLCB0aGUgZnJhbWUgYW5jaG9yIGlzIHVzZWQuXG4gICAgY29uc3QgW2N4LCBjeV0gPSBhcHBseUZyYW1lQW5jaG9yKHRoaXMsIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IHB4ID0gYW5jaG9yWCh2YWx1ZXMsIGN4KTtcbiAgICBjb25zdCBweSA9IGFuY2hvclkodmFsdWVzLCBjeSk7XG5cbiAgICAvLyBSZXNvbHZlIHRoZSB0ZXh0IG1ldHJpYyBpbXBsZW1lbnRhdGlvbi4gV2UgbWF5IG5lZWQgYW4gZWxsaXBzaXMgZm9yIHRleHRcbiAgICAvLyB0cnVuY2F0aW9uLCBzbyB3ZSBvcHRpbWlzdGljYWxseSBjb21wdXRlIHRoZSBlbGxpcHNpcyB3aWR0aC5cbiAgICBjb25zdCB3aWR0aG9mID0gbW9ub3NwYWNlID8gbW9ub3NwYWNlV2lkdGggOiBkZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZWUgPSB3aWR0aG9mKGVsbGlwc2lzKTtcblxuICAgIC8vIElmIHRoZXJl4oCZcyBhIHRpdGxlIGNoYW5uZWwsIGRpc3BsYXkgdGhhdCBhcy1pczsgb3RoZXJ3aXNlLCBzaG93IG11bHRpcGxlXG4gICAgLy8gY2hhbm5lbHMgYXMgbmFtZS12YWx1ZSBwYWlycy5cbiAgICBsZXQgc291cmNlcywgZm9ybWF0O1xuICAgIGlmIChcInRpdGxlXCIgaW4gdmFsdWVzKSB7XG4gICAgICBzb3VyY2VzID0gZ2V0U291cmNlQ2hhbm5lbHMuY2FsbCh0aGlzLCB7dGl0bGU6IHZhbHVlcy5jaGFubmVscy50aXRsZX0sIHNjYWxlcyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXRUaXRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlcyA9IGdldFNvdXJjZUNoYW5uZWxzLmNhbGwodGhpcywgdmFsdWVzLmNoYW5uZWxzLCBzY2FsZXMpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0Q2hhbm5lbHM7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9u4oCZdCBjYWxsIGFwcGx5Q2hhbm5lbFN0eWxlcyBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoZSBjaGFubmVscyB0b1xuICAgIC8vIGRlcml2ZSB0aGUgY29udGVudCBvZiB0aGUgdGlwLCBub3QgaXRzIGFlc3RoZXRpY3MuXG4gICAgY29uc3QgZyA9IGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlJbmRpcmVjdFRleHRTdHlsZXMsIHRoaXMpXG4gICAgICAuY2FsbChhcHBseVRyYW5zZm9ybSwgdGhpcywge3g6IFggJiYgeCwgeTogWSAmJiB5fSlcbiAgICAgIC5jYWxsKChnKSA9PlxuICAgICAgICBnXG4gICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgLmRhdGEoaW5kZXgpXG4gICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChpKSA9PiBgdHJhbnNsYXRlKCR7TWF0aC5yb3VuZChweChpKSl9LCR7TWF0aC5yb3VuZChweShpKSl9KWApIC8vIGNyaXNwIGVkZ2VzXG4gICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgLmNhbGwoKGcpID0+IGcuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZmlsdGVyXCIsIHBhdGhGaWx0ZXIpKVxuICAgICAgICAgIC5jYWxsKChnKSA9PlxuICAgICAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGhhdCA9IHNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgLy8gcHJldmVudCBzdHlsZSBpbmhlcml0YW5jZSAoZnJvbSBwYXRoKVxuICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIik7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAgIC8vIGl0ZXJhdGl2ZWx5IHJlbmRlciBlYWNoIGNoYW5uZWwgdmFsdWVcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBmb3JtYXQuY2FsbChtYXJrLCBpLCBpbmRleCwgc291cmNlcywgc2NhbGVzLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpbmVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIG1hcmsuc3BsaXRMaW5lcyhsaW5lcykpIHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxpbmUodGhhdCwge3ZhbHVlOiBtYXJrLmNsaXBMaW5lKGxpbmUpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHtsYWJlbCA9IFwiXCJ9ID0gbGluZTtcbiAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbHMuaGFzKGxhYmVsKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBlbHNlIGxhYmVscy5hZGQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgcmVuZGVyTGluZSh0aGF0LCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgKTtcblxuICAgIC8vIFJlbmRlcnMgYSBzaW5nbGUgbGluZSAoYSBuYW1lLXZhbHVlIHBhaXIpIHRvIHRoZSB0aXAsIHRydW5jYXRpbmcgdGhlIHRleHRcbiAgICAvLyBhcyBuZWVkZWQsIGFuZCBhZGRpbmcgYSB0aXRsZSBpZiB0aGUgdGV4dCBpcyB0cnVuY2F0ZWQuIE5vdGUgdGhhdCB0aGlzIGlzXG4gICAgLy8ganVzdCB0aGUgaW5pdGlhbCBsYXlvdXQgb2YgdGhlIHRleHQ7IGluIHBvc3RyZW5kZXIgd2Ugd2lsbCBjb21wdXRlIHRoZVxuICAgIC8vIGV4YWN0IHRleHQgbWV0cmljcyBhbmQgdHJhbnNsYXRlIHRoZSB0ZXh0IGFzIG5lZWRlZCBvbmNlIHdlIGtub3cgdGhlXG4gICAgLy8gdGlw4oCZcyBvcmllbnRhdGlvbiAoYW5jaG9yKS5cbiAgICBmdW5jdGlvbiByZW5kZXJMaW5lKHNlbGVjdGlvbiwge2xhYmVsLCB2YWx1ZSwgY29sb3IsIG9wYWNpdHl9KSB7XG4gICAgICAobGFiZWwgPz89IFwiXCIpLCAodmFsdWUgPz89IFwiXCIpO1xuICAgICAgY29uc3Qgc3dhdGNoID0gY29sb3IgIT0gbnVsbCB8fCBvcGFjaXR5ICE9IG51bGw7XG4gICAgICBsZXQgdGl0bGU7XG4gICAgICBsZXQgdyA9IGxpbmVXaWR0aCAqIDEwMDtcbiAgICAgIGNvbnN0IFtqXSA9IGN1dChsYWJlbCwgdywgd2lkdGhvZiwgZWUpO1xuICAgICAgaWYgKGogPj0gMCkge1xuICAgICAgICAvLyBsYWJlbCBpcyB0cnVuY2F0ZWRcbiAgICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCBqKS50cmltRW5kKCkgKyBlbGxpcHNpcztcbiAgICAgICAgdGl0bGUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYWJlbCB8fCAoIXZhbHVlICYmICFzd2F0Y2gpKSB2YWx1ZSA9IFwiIFwiICsgdmFsdWU7XG4gICAgICAgIGNvbnN0IFtrXSA9IGN1dCh2YWx1ZSwgdyAtIHdpZHRob2YobGFiZWwpLCB3aWR0aG9mLCBlZSk7XG4gICAgICAgIGlmIChrID49IDApIHtcbiAgICAgICAgICAvLyB2YWx1ZSBpcyB0cnVuY2F0ZWRcbiAgICAgICAgICB0aXRsZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGspLnRyaW1FbmQoKSArIGVsbGlwc2lzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lID0gc2VsZWN0aW9uLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBgJHtsaW5lSGVpZ2h0fWVtYCkudGV4dChcIlxcdTIwMGJcIik7IC8vIHp3c3AgZm9yIGRvdWJsZS1jbGlja1xuICAgICAgaWYgKGxhYmVsKSBsaW5lLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIikudGV4dChsYWJlbCk7XG4gICAgICBpZiAodmFsdWUpIGxpbmUuYXBwZW5kKCgpID0+IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XG4gICAgICBpZiAoc3dhdGNoKSBsaW5lLmFwcGVuZChcInRzcGFuXCIpLnRleHQoXCIg4pagXCIpLmF0dHIoXCJmaWxsXCIsIGNvbG9yKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHkpLnN0eWxlKFwidXNlci1zZWxlY3RcIiwgXCJub25lXCIpOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGlmICh0aXRsZSkgbGluZS5hcHBlbmQoXCJ0aXRsZVwiKS50ZXh0KHRpdGxlKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGFmdGVyIHRoZSBwbG90IGlzIGF0dGFjaGVkIHRvIHRoZSBwYWdlIGNhbiB3ZSBjb21wdXRlIHRoZSBleGFjdCB0ZXh0XG4gICAgLy8gbWV0cmljcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aXAgc2l6ZSBhbmQgb3JpZW50YXRpb24gKGFuY2hvcikuXG4gICAgZnVuY3Rpb24gcG9zdHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGRpbWVuc2lvbnMuZmFjZXQgPz8gZGltZW5zaW9ucztcbiAgICAgIGcuc2VsZWN0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGxldCB7eDogdHgsIHdpZHRoOiB3LCBoZWlnaHQ6IGh9ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICAgICh3ID0gTWF0aC5yb3VuZCh3KSksIChoID0gTWF0aC5yb3VuZChoKSk7IC8vIGNyaXNwIGVkZ2VzXG4gICAgICAgIGxldCBhID0gYW5jaG9yOyAvLyB1c2UgdGhlIHNwZWNpZmllZCBhbmNob3IsIGlmIGFueVxuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHB4KGkpICsgb3g7XG4gICAgICAgICAgY29uc3QgeSA9IHB5KGkpICsgb3k7XG4gICAgICAgICAgY29uc3QgZml0TGVmdCA9IHggKyB3ICsgbSArIHIgKiAyIDwgd2lkdGg7XG4gICAgICAgICAgY29uc3QgZml0UmlnaHQgPSB4IC0gdyAtIG0gLSByICogMiA+IDA7XG4gICAgICAgICAgY29uc3QgZml0VG9wID0geSArIGggKyBtICsgciAqIDIgPCBoZWlnaHQ7XG4gICAgICAgICAgY29uc3QgZml0Qm90dG9tID0geSAtIGggLSBtIC0gciAqIDIgPiAwO1xuICAgICAgICAgIGEgPVxuICAgICAgICAgICAgZml0TGVmdCAmJiBmaXRSaWdodFxuICAgICAgICAgICAgICA/IGZpdFRvcCAmJiBmaXRCb3R0b21cbiAgICAgICAgICAgICAgICA/IG1hcmsucHJlZmVycmVkQW5jaG9yXG4gICAgICAgICAgICAgICAgOiBmaXRCb3R0b21cbiAgICAgICAgICAgICAgICA/IFwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICA6IFwidG9wXCJcbiAgICAgICAgICAgICAgOiBmaXRUb3AgJiYgZml0Qm90dG9tXG4gICAgICAgICAgICAgID8gZml0TGVmdFxuICAgICAgICAgICAgICAgID8gXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICA6IFwicmlnaHRcIlxuICAgICAgICAgICAgICA6IChmaXRMZWZ0IHx8IGZpdFJpZ2h0KSAmJiAoZml0VG9wIHx8IGZpdEJvdHRvbSlcbiAgICAgICAgICAgICAgPyBgJHtmaXRCb3R0b20gPyBcImJvdHRvbVwiIDogXCJ0b3BcIn0tJHtmaXRMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJ9YFxuICAgICAgICAgICAgICA6IG1hcmsucHJlZmVycmVkQW5jaG9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZpcnN0Q2hpbGQ7IC8vIG5vdGU6IGFzc3VtZXMgZXhhY3RseSB0d28gY2hpbGRyZW4hXG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmxhc3RDaGlsZDsgLy8gbm90ZTogYXNzdW1lcyBleGFjdGx5IHR3byBjaGlsZHJlbiFcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGdldFBhdGgoYSwgbSwgciwgdywgaCkpO1xuICAgICAgICBpZiAodHgpIGZvciAoY29uc3QgdCBvZiB0ZXh0LmNoaWxkTm9kZXMpIHQuc2V0QXR0cmlidXRlKFwieFwiLCAtdHgpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcInlcIiwgYCR7K2dldExpbmVPZmZzZXQoYSwgdGV4dC5jaGlsZE5vZGVzLmxlbmd0aCwgbGluZUhlaWdodCkudG9GaXhlZCg2KX1lbWApO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Z2V0VGV4dFRyYW5zbGF0ZShhLCBtLCByLCB3LCBoKX0pYCk7XG4gICAgICB9KTtcbiAgICAgIGcuYXR0cihcInZpc2liaWxpdHlcIiwgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gV2FpdCB1bnRpbCB0aGUgcGxvdCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBwYWdlIHNvIHRoYXQgd2UgY2FuIHVzZSBnZXRCQm94XG4gICAgLy8gdG8gY29tcHV0ZSB0aGUgZXhhY3QgdGV4dCBkaW1lbnNpb25zLiBJZiB0aGUgU1ZHIGlzIGFscmVhZHkgY29ubmVjdGVkLCBhc1xuICAgIC8vIHdoZW4gdGhlIHBvaW50ZXIgaW50ZXJhY3Rpb24gdHJpZ2dlcnMgdGhlIHJlLXJlbmRlciwgdXNlIGEgZmFzdGVyXG4gICAgLy8gbWljcm90YXNrIGluc3RlYWQgb2YgYW4gYW5pbWF0aW9uIGZyYW1lOyBpZiB0aGlzIFNTUiAoZS5nLiwgSlNET00pLCBza2lwXG4gICAgLy8gdGhpcyBzdGVwLiBQZXJoYXBzIHRoaXMgY291bGQgYmUgZG9uZSBzeW5jaHJvbm91c2x5OyBnZXR0aW5nIHRoZVxuICAgIC8vIGRpbWVuc2lvbnMgb2YgdGhlIFNWRyBpcyBlYXN5LCBhbmQgYWx0aG91Z2ggYWNjdXJhdGUgdGV4dCBtZXRyaWNzIGFyZVxuICAgIC8vIGhhcmQsIHdlIGNvdWxkIHVzZSBhcHByb3hpbWF0ZSBoZXVyaXN0aWNzLlxuICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgIGcuYXR0cihcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7IC8vIGhpZGUgdW50aWwgcG9zdHJlbmRlclxuICAgICAgaWYgKHN2Zy5pc0Nvbm5lY3RlZCkgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihwb3N0cmVuZGVyKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIpIHJlcXVlc3RBbmltYXRpb25GcmFtZShwb3N0cmVuZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZy5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpcChkYXRhLCB7eCwgeSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBpZiAob3B0aW9ucy5mcmFtZUFuY2hvciA9PT0gdW5kZWZpbmVkKSBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICByZXR1cm4gbmV3IFRpcChkYXRhLCB7Li4ub3B0aW9ucywgeCwgeX0pO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lT2Zmc2V0KGFuY2hvciwgbGVuZ3RoLCBsaW5lSGVpZ2h0KSB7XG4gIHJldHVybiAvXnRvcCg/Oi18JCkvLnRlc3QoYW5jaG9yKVxuICAgID8gMC45NCAtIGxpbmVIZWlnaHRcbiAgICA6IC9eYm90dG9tKD86LXwkKS9cbiAgICA/IC0wLjI5IC0gbGVuZ3RoICogbGluZUhlaWdodFxuICAgIDogKGxlbmd0aCAvIDIpICogbGluZUhlaWdodDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFRyYW5zbGF0ZShhbmNob3IsIG0sIHIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgc3dpdGNoIChhbmNob3IpIHtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICByZXR1cm4gWy13aWR0aCAvIDIsIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgcmV0dXJuIFtyLCBtICsgcl07XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFstd2lkdGggLyAyLCBtIC8gMiArIHJdO1xuICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgIHJldHVybiBbLXdpZHRoIC0gciwgbSArIHJdO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFstbSAvIDIgLSB3aWR0aCAtIHIsIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgcmV0dXJuIFtyLCAtbSAtIHJdO1xuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHJldHVybiBbLXdpZHRoIC8gMiwgLW0gLyAyIC0gcl07XG4gICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgcmV0dXJuIFstd2lkdGggLSByLCAtbSAtIHJdO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gW3IgKyBtIC8gMiwgaGVpZ2h0IC8gMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChhbmNob3IsIG0sIHIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgdyA9IHdpZHRoICsgciAqIDI7XG4gIGNvbnN0IGggPSBoZWlnaHQgKyByICogMjtcbiAgc3dpdGNoIChhbmNob3IpIHtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICByZXR1cm4gYE0key13IC8gMn0sJHstaCAvIDJ9aCR7d312JHtofWgkey13fXpgO1xuICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgcmV0dXJuIGBNMCwwbCR7bX0sJHttfWgke3cgLSBtfXYke2h9aCR7LXd9emA7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIGBNMCwwbCR7bSAvIDJ9LCR7bSAvIDJ9aCR7KHcgLSBtKSAvIDJ9diR7aH1oJHstd312JHstaH1oJHsodyAtIG0pIC8gMn16YDtcbiAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICByZXR1cm4gYE0wLDBsJHstbX0sJHttfWgke20gLSB3fXYke2h9aCR7d316YDtcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBgTTAsMGwkey1tIC8gMn0sJHstbSAvIDJ9diR7bSAvIDIgLSBoIC8gMn1oJHstd312JHtofWgke3d9diR7bSAvIDIgLSBoIC8gMn16YDtcbiAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgIHJldHVybiBgTTAsMGwke219LCR7LW19aCR7dyAtIG19diR7LWh9aCR7LXd9emA7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIGBNMCwwbCR7bSAvIDJ9LCR7LW0gLyAyfWgkeyh3IC0gbSkgLyAyfXYkey1ofWgkey13fXYke2h9aCR7KHcgLSBtKSAvIDJ9emA7XG4gICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgcmV0dXJuIGBNMCwwbCR7LW19LCR7LW19aCR7bSAtIHd9diR7LWh9aCR7d316YDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIGBNMCwwbCR7bSAvIDJ9LCR7LW0gLyAyfXYke20gLyAyIC0gaCAvIDJ9aCR7d312JHtofWgkey13fXYke20gLyAyIC0gaCAvIDJ9emA7XG4gIH1cbn1cblxuLy8gTm90ZTogbXV0YXRlcyB0aGlzLmZvcm1hdCFcbmZ1bmN0aW9uIGdldFNvdXJjZUNoYW5uZWxzKGNoYW5uZWxzLCBzY2FsZXMpIHtcbiAgY29uc3Qgc291cmNlcyA9IHt9O1xuXG4gIC8vIFByb21vdGUgeCBhbmQgeSBzaG9ydGhhbmQgZm9yIHBhaXJlZCBjaGFubmVscyAoaW4gb3JkZXIpLlxuICBsZXQgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gIGZvcm1hdCA9IG1heWJlRXhwYW5kUGFpcmVkRm9ybWF0KGZvcm1hdCwgY2hhbm5lbHMsIFwieFwiKTtcbiAgZm9ybWF0ID0gbWF5YmVFeHBhbmRQYWlyZWRGb3JtYXQoZm9ybWF0LCBjaGFubmVscywgXCJ5XCIpO1xuICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblxuICAvLyBQcmlvcml0aXplIGNoYW5uZWxzIHdpdGggZXhwbGljaXQgZm9ybWF0cywgaW4gdGhlIGdpdmVuIG9yZGVyLlxuICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdFtrZXldO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImZ4XCIgfHwga2V5ID09PSBcImZ5XCIpIHtcbiAgICAgIHNvdXJjZXNba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGdldFNvdXJjZShjaGFubmVscywga2V5KTtcbiAgICAgIGlmIChzb3VyY2UpIHNvdXJjZXNba2V5XSA9IHNvdXJjZTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGVuIGZhbGxiYWNrIHRvIGFsbCBvdGhlciAobm9uLWlnbm9yZWQpIGNoYW5uZWxzLlxuICBmb3IgKGNvbnN0IGtleSBpbiBjaGFubmVscykge1xuICAgIGlmIChrZXkgaW4gc291cmNlcyB8fCBrZXkgaW4gZm9ybWF0IHx8IGlnbm9yZUNoYW5uZWxzLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICBpZiAoKGtleSA9PT0gXCJ4XCIgfHwga2V5ID09PSBcInlcIikgJiYgY2hhbm5lbHMuZ2VvbWV0cnkpIGNvbnRpbnVlOyAvLyBpZ25vcmUgeCAmIHkgb24gZ2VvXG4gICAgY29uc3Qgc291cmNlID0gZ2V0U291cmNlKGNoYW5uZWxzLCBrZXkpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIC8vIElnbm9yZSBjb2xvciBjaGFubmVscyBpZiB0aGUgdmFsdWVzIGFyZSBhbGwgbGl0ZXJhbCBjb2xvcnMuXG4gICAgICBpZiAoc291cmNlLnNjYWxlID09IG51bGwgJiYgc291cmNlLmRlZmF1bHRTY2FsZSA9PT0gXCJjb2xvclwiKSBjb250aW51ZTtcbiAgICAgIHNvdXJjZXNba2V5XSA9IHNvdXJjZTtcbiAgICB9XG4gIH1cblxuICAvLyBBbmQgbGFzdGx5IGZhY2V0IGNoYW5uZWxzLCBidXQgb25seSBpZiB0aGlzIG1hcmsgaXMgZmFjZXRlZC5cbiAgaWYgKHRoaXMuZmFjZXQpIHtcbiAgICBpZiAoc2NhbGVzLmZ4ICYmICEoXCJmeFwiIGluIGZvcm1hdCkpIHNvdXJjZXMuZnggPSB0cnVlO1xuICAgIGlmIChzY2FsZXMuZnkgJiYgIShcImZ5XCIgaW4gZm9ybWF0KSkgc291cmNlcy5meSA9IHRydWU7XG4gIH1cblxuICAvLyBQcm9tb3RlIHNob3J0aGFuZCBzdHJpbmcgZm9ybWF0cywgYW5kIG1hdGVyaWFsaXplIGRlZmF1bHQgZm9ybWF0cy5cbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlcykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZm9ybWF0W2tleV07XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlc1trZXldPy52YWx1ZSA/PyBzY2FsZXNba2V5XT8uZG9tYWluKCkgPz8gW107XG4gICAgICB0aGlzLmZvcm1hdFtrZXldID0gKGlzVGVtcG9yYWwodmFsdWUpID8gdXRjRm9ybWF0IDogbnVtYmVyRm9ybWF0KShmb3JtYXQpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQgfHwgZm9ybWF0ID09PSB0cnVlKSB7XG4gICAgICAvLyBGb3Igb3JkaW5hbCBzY2FsZXMsIHRoZSBpbmZlcnJlZCB0aWNrIGZvcm1hdCBjYW4gYmUgbW9yZSBjb25jaXNlLCBzdWNoXG4gICAgICAvLyBhcyBvbmx5IHNob3dpbmcgdGhlIHllYXIgZm9yIHllYXJseSBkYXRhLlxuICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICAgIHRoaXMuZm9ybWF0W2tleV0gPSBzY2FsZT8uYmFuZHdpZHRoID8gaW5mZXJUaWNrRm9ybWF0KHNjYWxlLCBzY2FsZS5kb21haW4oKSkgOiBmb3JtYXREZWZhdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VzO1xufVxuXG4vLyBQcm9tb3RlIHggYW5kIHkgc2hvcnRoYW5kIGZvciBwYWlyZWQgY2hhbm5lbHMsIHdoaWxlIHByZXNlcnZpbmcgb3JkZXIuXG5mdW5jdGlvbiBtYXliZUV4cGFuZFBhaXJlZEZvcm1hdChmb3JtYXQsIGNoYW5uZWxzLCBrZXkpIHtcbiAgaWYgKCEoa2V5IGluIGZvcm1hdCkpIHJldHVybiBmb3JtYXQ7XG4gIGNvbnN0IGtleTEgPSBgJHtrZXl9MWA7XG4gIGNvbnN0IGtleTIgPSBgJHtrZXl9MmA7XG4gIGlmICgoa2V5MSBpbiBmb3JtYXQgfHwgIShrZXkxIGluIGNoYW5uZWxzKSkgJiYgKGtleTIgaW4gZm9ybWF0IHx8ICEoa2V5MiBpbiBjaGFubmVscykpKSByZXR1cm4gZm9ybWF0O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZm9ybWF0KTtcbiAgY29uc3QgdmFsdWUgPSBmb3JtYXRba2V5XTtcbiAgZW50cmllcy5zcGxpY2UoZW50cmllcy5maW5kSW5kZXgoKFtuYW1lXSkgPT4gbmFtZSA9PT0ga2V5KSArIDEsIDAsIFtrZXkxLCB2YWx1ZV0sIFtrZXkyLCB2YWx1ZV0pO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaXRsZShpLCBpbmRleCwge3RpdGxlfSkge1xuICByZXR1cm4gdGhpcy5mb3JtYXQudGl0bGUodGl0bGUudmFsdWVbaV0sIGkpO1xufVxuXG5mdW5jdGlvbiogZm9ybWF0Q2hhbm5lbHMoaSwgaW5kZXgsIGNoYW5uZWxzLCBzY2FsZXMsIHZhbHVlcykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGFubmVscykge1xuICAgIGlmIChrZXkgPT09IFwiZnhcIiB8fCBrZXkgPT09IFwiZnlcIikge1xuICAgICAgeWllbGQge1xuICAgICAgICBsYWJlbDogZm9ybWF0TGFiZWwoc2NhbGVzLCBjaGFubmVscywga2V5KSxcbiAgICAgICAgdmFsdWU6IHRoaXMuZm9ybWF0W2tleV0oaW5kZXhba2V5XSwgaSlcbiAgICAgIH07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCJ4MVwiICYmIFwieDJcIiBpbiBjaGFubmVscykgY29udGludWU7XG4gICAgaWYgKGtleSA9PT0gXCJ5MVwiICYmIFwieTJcIiBpbiBjaGFubmVscykgY29udGludWU7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNoYW5uZWxzW2tleV07XG4gICAgaWYgKGtleSA9PT0gXCJ4MlwiICYmIFwieDFcIiBpbiBjaGFubmVscykge1xuICAgICAgeWllbGQge1xuICAgICAgICBsYWJlbDogZm9ybWF0UGFpckxhYmVsKHNjYWxlcywgY2hhbm5lbHMsIFwieFwiKSxcbiAgICAgICAgdmFsdWU6IGZvcm1hdFBhaXIodGhpcy5mb3JtYXQueDIsIGNoYW5uZWxzLngxLCBjaGFubmVsLCBpKVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ5MlwiICYmIFwieTFcIiBpbiBjaGFubmVscykge1xuICAgICAgeWllbGQge1xuICAgICAgICBsYWJlbDogZm9ybWF0UGFpckxhYmVsKHNjYWxlcywgY2hhbm5lbHMsIFwieVwiKSxcbiAgICAgICAgdmFsdWU6IGZvcm1hdFBhaXIodGhpcy5mb3JtYXQueTIsIGNoYW5uZWxzLnkxLCBjaGFubmVsLCBpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSBjaGFubmVsLnZhbHVlW2ldO1xuICAgICAgY29uc3Qgc2NhbGUgPSBjaGFubmVsLnNjYWxlO1xuICAgICAgaWYgKCFkZWZpbmVkKHZhbHVlKSAmJiBzY2FsZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgbGFiZWw6IGZvcm1hdExhYmVsKHNjYWxlcywgY2hhbm5lbHMsIGtleSksXG4gICAgICAgIHZhbHVlOiB0aGlzLmZvcm1hdFtrZXldKHZhbHVlLCBpKSxcbiAgICAgICAgY29sb3I6IHNjYWxlID09PSBcImNvbG9yXCIgPyB2YWx1ZXNba2V5XVtpXSA6IG51bGwsXG4gICAgICAgIG9wYWNpdHk6IHNjYWxlID09PSBcIm9wYWNpdHlcIiA/IHZhbHVlc1trZXldW2ldIDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0UGFpcihmb3JtYXRWYWx1ZSwgYzEsIGMyLCBpKSB7XG4gIHJldHVybiBjMi5oaW50Py5sZW5ndGggLy8gZS5nLiwgc3RhY2tZ4oCZcyB5MSBhbmQgeTJcbiAgICA/IGAke2Zvcm1hdFZhbHVlKGMyLnZhbHVlW2ldIC0gYzEudmFsdWVbaV0sIGkpfWBcbiAgICA6IGAke2Zvcm1hdFZhbHVlKGMxLnZhbHVlW2ldLCBpKX3igJMke2Zvcm1hdFZhbHVlKGMyLnZhbHVlW2ldLCBpKX1gO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQYWlyTGFiZWwoc2NhbGVzLCBjaGFubmVscywga2V5KSB7XG4gIGNvbnN0IGwxID0gZm9ybWF0TGFiZWwoc2NhbGVzLCBjaGFubmVscywgYCR7a2V5fTFgLCBrZXkpO1xuICBjb25zdCBsMiA9IGZvcm1hdExhYmVsKHNjYWxlcywgY2hhbm5lbHMsIGAke2tleX0yYCwga2V5KTtcbiAgcmV0dXJuIGwxID09PSBsMiA/IGwxIDogYCR7bDF94oCTJHtsMn1gO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMYWJlbChzY2FsZXMsIGNoYW5uZWxzLCBrZXksIGRlZmF1bHRMYWJlbCA9IGtleSkge1xuICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNba2V5XTtcbiAgY29uc3Qgc2NhbGUgPSBzY2FsZXNbY2hhbm5lbD8uc2NhbGUgPz8ga2V5XTtcbiAgcmV0dXJuIFN0cmluZyhzY2FsZT8ubGFiZWwgPz8gY2hhbm5lbD8ubGFiZWwgPz8gZGVmYXVsdExhYmVsKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/tip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/tree.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/tree.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cluster: () => (/* binding */ cluster),\n/* harmony export */   tree: () => (/* binding */ tree)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _transforms_tree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transforms/tree.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/tree.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dot.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/dot.js\");\n/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/link.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/text.js\");\n\n\n\n\n\n\n\n\n\nfunction tree(\n  data,\n  {\n    fill,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    marker,\n    markerStart = marker,\n    markerEnd = marker,\n    dot: dotDot = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(markerStart) && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(markerEnd),\n    text: textText = \"node:name\",\n    textStroke = \"var(--plot-background)\",\n    title = \"node:path\",\n    dx,\n    dy,\n    textAnchor,\n    treeLayout = d3__WEBPACK_IMPORTED_MODULE_0__.tree,\n    textLayout = treeLayout === d3__WEBPACK_IMPORTED_MODULE_0__.tree || treeLayout === d3__WEBPACK_IMPORTED_MODULE_0__.cluster ? \"mirrored\" : \"normal\",\n    tip,\n    ...options\n  } = {}\n) {\n  if (dx === undefined) dx = (0,_transforms_tree_js__WEBPACK_IMPORTED_MODULE_2__.maybeTreeAnchor)(options.treeAnchor).dx;\n  if (textAnchor !== undefined) throw new Error(\"textAnchor is not a configurable tree option\");\n  textLayout = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyword)(textLayout, \"textLayout\", [\"mirrored\", \"normal\"]);\n\n  function treeText(textOptions) {\n    return (0,_text_js__WEBPACK_IMPORTED_MODULE_3__.text)(\n      data,\n      (0,_transforms_tree_js__WEBPACK_IMPORTED_MODULE_2__.treeNode)({\n        treeLayout,\n        text: textText,\n        fill: fill === undefined ? \"currentColor\" : fill,\n        stroke: textStroke,\n        dx,\n        dy,\n        title,\n        ...textOptions,\n        ...options\n      })\n    );\n  }\n\n  return (0,_mark_js__WEBPACK_IMPORTED_MODULE_4__.marks)(\n    (0,_link_js__WEBPACK_IMPORTED_MODULE_5__.link)(\n      data,\n      (0,_transforms_tree_js__WEBPACK_IMPORTED_MODULE_2__.treeLink)({\n        treeLayout,\n        markerStart,\n        markerEnd,\n        stroke: stroke !== undefined ? stroke : fill === undefined ? \"node:internal\" : fill,\n        strokeWidth,\n        strokeOpacity,\n        strokeLinejoin,\n        strokeLinecap,\n        strokeMiterlimit,\n        strokeDasharray,\n        strokeDashoffset,\n        ...options\n      })\n    ),\n    dotDot\n      ? (0,_dot_js__WEBPACK_IMPORTED_MODULE_6__.dot)(data, (0,_transforms_tree_js__WEBPACK_IMPORTED_MODULE_2__.treeNode)({treeLayout, fill: fill === undefined ? \"node:internal\" : fill, title, tip, ...options}))\n      : null,\n    textText != null\n      ? textLayout === \"mirrored\"\n        ? [\n            treeText({textAnchor: \"start\", treeFilter: \"node:external\"}),\n            treeText({textAnchor: \"end\", treeFilter: \"node:internal\", dx: -dx})\n          ]\n        : treeText()\n      : null\n  );\n}\n\nfunction cluster(data, options) {\n  return tree(data, {...options, treeLayout: d3__WEBPACK_IMPORTED_MODULE_0__.cluster});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy90cmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNuQjtBQUNPO0FBQ2tDO0FBQzdDO0FBQ0U7QUFDQTtBQUNPOztBQUUvQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVMsaUJBQWlCLHNEQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBSTtBQUNyQixnQ0FBZ0Msb0NBQUksbUJBQW1CLHVDQUFPO0FBQzlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw2QkFBNkIsb0VBQWU7QUFDNUM7QUFDQSxlQUFlLG9EQUFPOztBQUV0QjtBQUNBLFdBQVcsOENBQUk7QUFDZjtBQUNBLE1BQU0sNkRBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxTQUFTLCtDQUFLO0FBQ2QsSUFBSSw4Q0FBSTtBQUNSO0FBQ0EsTUFBTSw2REFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUSw0Q0FBRyxPQUFPLDZEQUFRLEVBQUUsc0ZBQXNGO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFpRDtBQUN2RSxzQkFBc0Isd0RBQXdEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxxQkFBcUIsd0JBQXdCLHVDQUFPLENBQUM7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL3RyZWUuanM/NWU5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NsdXN0ZXIgYXMgQ2x1c3RlciwgdHJlZSBhcyBUcmVlfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7bWFya3N9IGZyb20gXCIuLi9tYXJrLmpzXCI7XG5pbXBvcnQge2lzTm9uZWlzaH0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7bWF5YmVUcmVlQW5jaG9yLCB0cmVlTGluaywgdHJlZU5vZGV9IGZyb20gXCIuLi90cmFuc2Zvcm1zL3RyZWUuanNcIjtcbmltcG9ydCB7ZG90fSBmcm9tIFwiLi9kb3QuanNcIjtcbmltcG9ydCB7bGlua30gZnJvbSBcIi4vbGluay5qc1wiO1xuaW1wb3J0IHt0ZXh0fSBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQge2tleXdvcmR9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmVlKFxuICBkYXRhLFxuICB7XG4gICAgZmlsbCxcbiAgICBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBzdHJva2VMaW5lam9pbixcbiAgICBzdHJva2VMaW5lY2FwLFxuICAgIHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZURhc2hvZmZzZXQsXG4gICAgbWFya2VyLFxuICAgIG1hcmtlclN0YXJ0ID0gbWFya2VyLFxuICAgIG1hcmtlckVuZCA9IG1hcmtlcixcbiAgICBkb3Q6IGRvdERvdCA9IGlzTm9uZWlzaChtYXJrZXJTdGFydCkgJiYgaXNOb25laXNoKG1hcmtlckVuZCksXG4gICAgdGV4dDogdGV4dFRleHQgPSBcIm5vZGU6bmFtZVwiLFxuICAgIHRleHRTdHJva2UgPSBcInZhcigtLXBsb3QtYmFja2dyb3VuZClcIixcbiAgICB0aXRsZSA9IFwibm9kZTpwYXRoXCIsXG4gICAgZHgsXG4gICAgZHksXG4gICAgdGV4dEFuY2hvcixcbiAgICB0cmVlTGF5b3V0ID0gVHJlZSxcbiAgICB0ZXh0TGF5b3V0ID0gdHJlZUxheW91dCA9PT0gVHJlZSB8fCB0cmVlTGF5b3V0ID09PSBDbHVzdGVyID8gXCJtaXJyb3JlZFwiIDogXCJub3JtYWxcIixcbiAgICB0aXAsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge31cbikge1xuICBpZiAoZHggPT09IHVuZGVmaW5lZCkgZHggPSBtYXliZVRyZWVBbmNob3Iob3B0aW9ucy50cmVlQW5jaG9yKS5keDtcbiAgaWYgKHRleHRBbmNob3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwidGV4dEFuY2hvciBpcyBub3QgYSBjb25maWd1cmFibGUgdHJlZSBvcHRpb25cIik7XG4gIHRleHRMYXlvdXQgPSBrZXl3b3JkKHRleHRMYXlvdXQsIFwidGV4dExheW91dFwiLCBbXCJtaXJyb3JlZFwiLCBcIm5vcm1hbFwiXSk7XG5cbiAgZnVuY3Rpb24gdHJlZVRleHQodGV4dE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGV4dChcbiAgICAgIGRhdGEsXG4gICAgICB0cmVlTm9kZSh7XG4gICAgICAgIHRyZWVMYXlvdXQsXG4gICAgICAgIHRleHQ6IHRleHRUZXh0LFxuICAgICAgICBmaWxsOiBmaWxsID09PSB1bmRlZmluZWQgPyBcImN1cnJlbnRDb2xvclwiIDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiB0ZXh0U3Ryb2tlLFxuICAgICAgICBkeCxcbiAgICAgICAgZHksXG4gICAgICAgIHRpdGxlLFxuICAgICAgICAuLi50ZXh0T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hcmtzKFxuICAgIGxpbmsoXG4gICAgICBkYXRhLFxuICAgICAgdHJlZUxpbmsoe1xuICAgICAgICB0cmVlTGF5b3V0LFxuICAgICAgICBtYXJrZXJTdGFydCxcbiAgICAgICAgbWFya2VyRW5kLFxuICAgICAgICBzdHJva2U6IHN0cm9rZSAhPT0gdW5kZWZpbmVkID8gc3Ryb2tlIDogZmlsbCA9PT0gdW5kZWZpbmVkID8gXCJub2RlOmludGVybmFsXCIgOiBmaWxsLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW4sXG4gICAgICAgIHN0cm9rZUxpbmVjYXAsXG4gICAgICAgIHN0cm9rZU1pdGVybGltaXQsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSlcbiAgICApLFxuICAgIGRvdERvdFxuICAgICAgPyBkb3QoZGF0YSwgdHJlZU5vZGUoe3RyZWVMYXlvdXQsIGZpbGw6IGZpbGwgPT09IHVuZGVmaW5lZCA/IFwibm9kZTppbnRlcm5hbFwiIDogZmlsbCwgdGl0bGUsIHRpcCwgLi4ub3B0aW9uc30pKVxuICAgICAgOiBudWxsLFxuICAgIHRleHRUZXh0ICE9IG51bGxcbiAgICAgID8gdGV4dExheW91dCA9PT0gXCJtaXJyb3JlZFwiXG4gICAgICAgID8gW1xuICAgICAgICAgICAgdHJlZVRleHQoe3RleHRBbmNob3I6IFwic3RhcnRcIiwgdHJlZUZpbHRlcjogXCJub2RlOmV4dGVybmFsXCJ9KSxcbiAgICAgICAgICAgIHRyZWVUZXh0KHt0ZXh0QW5jaG9yOiBcImVuZFwiLCB0cmVlRmlsdGVyOiBcIm5vZGU6aW50ZXJuYWxcIiwgZHg6IC1keH0pXG4gICAgICAgICAgXVxuICAgICAgICA6IHRyZWVUZXh0KClcbiAgICAgIDogbnVsbFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2x1c3RlcihkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0cmVlKGRhdGEsIHsuLi5vcHRpb25zLCB0cmVlTGF5b3V0OiBDbHVzdGVyfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/vector.js":
/*!*************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/vector.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: () => (/* binding */ Vector),\n/* harmony export */   spike: () => (/* binding */ spike),\n/* harmony export */   vector: () => (/* binding */ vector),\n/* harmony export */   vectorX: () => (/* binding */ vectorX),\n/* harmony export */   vectorY: () => (/* binding */ vectorY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../template.js */ \"(ssr)/./node_modules/@observablehq/plot/src/template.js\");\n\n\n\n\n\n\n\nconst defaults = {\n  ariaLabel: \"vector\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\"\n};\n\nconst defaultRadius = 3.5;\n\n// The size of the arrowhead is proportional to its length, but we still allow\n// the relative size of the head to be controlled via the mark’s width option;\n// doubling the default radius will produce an arrowhead that is twice as big.\n// That said, we’ll probably want a arrow with a fixed head size, too.\nconst wingRatio = defaultRadius * 5;\n\nconst shapeArrow = {\n  draw(context, l, r) {\n    const wing = (l * r) / wingRatio;\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n    context.moveTo(-wing, wing - l);\n    context.lineTo(0, -l);\n    context.lineTo(wing, wing - l);\n  }\n};\n\nconst shapeSpike = {\n  draw(context, l, r) {\n    context.moveTo(-r, 0);\n    context.lineTo(0, -l);\n    context.lineTo(r, 0);\n  }\n};\n\nconst shapes = new Map([\n  [\"arrow\", shapeArrow],\n  [\"spike\", shapeSpike]\n]);\n\nfunction isShapeObject(value) {\n  return value && typeof value.draw === \"function\";\n}\n\nfunction maybeShape(shape) {\n  if (isShapeObject(shape)) return shape;\n  const value = shapes.get(`${shape}`.toLowerCase());\n  if (value) return value;\n  throw new Error(`invalid shape: ${shape}`);\n}\n\nclass Vector extends _mark_js__WEBPACK_IMPORTED_MODULE_1__.Mark {\n  constructor(data, options = {}) {\n    const {x, y, r = defaultRadius, length, rotate, shape = shapeArrow, anchor = \"middle\", frameAnchor} = options;\n    const [vl, cl] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(length, 12);\n    const [vr, cr] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeNumberChannel)(rotate, 0);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        length: {value: vl, scale: \"length\", optional: true},\n        rotate: {value: vr, optional: true}\n      },\n      options,\n      defaults\n    );\n    this.r = +r;\n    this.length = cl;\n    this.rotate = cr;\n    this.shape = maybeShape(shape);\n    this.anchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.keyword)(anchor, \"anchor\", [\"start\", \"middle\", \"end\"]);\n    this.frameAnchor = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeFrameAnchor)(frameAnchor);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, length: L, rotate: A} = channels;\n    const {length, rotate, anchor, shape, r} = this;\n    const [cx, cy] = (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.applyFrameAnchor)(this, dimensions);\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_4__.create)(\"svg:g\", context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyIndirectStyles, this, dimensions, context)\n      .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyDirectStyles, this)\n          .attr(\n            \"transform\",\n            (0,_template_js__WEBPACK_IMPORTED_MODULE_5__.template)`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${\n              A ? (i) => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``\n            }${\n              anchor === \"start\"\n                ? ``\n                : anchor === \"end\"\n                ? L\n                  ? (i) => ` translate(0,${L[i]})`\n                  : ` translate(0,${length})`\n                : L\n                ? (i) => ` translate(0,${L[i] / 2})`\n                : ` translate(0,${length / 2})`\n            }`\n          )\n          .attr(\n            \"d\",\n            L\n              ? (i) => {\n                  const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                  shape.draw(p, L[i], r);\n                  return p;\n                }\n              : (() => {\n                  const p = (0,d3__WEBPACK_IMPORTED_MODULE_0__.pathRound)();\n                  shape.draw(p, length, r);\n                  return p;\n                })()\n          )\n          .call(_style_js__WEBPACK_IMPORTED_MODULE_3__.applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nfunction vector(data, options = {}) {\n  let {x, y, ...rest} = options;\n  if (options.frameAnchor === undefined) [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeTuple)(x, y);\n  return new Vector(data, {...rest, x, y});\n}\n\nfunction vectorX(data, options = {}) {\n  const {x = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, ...rest} = options;\n  return new Vector(data, {...rest, x});\n}\n\nfunction vectorY(data, options = {}) {\n  const {y = _options_js__WEBPACK_IMPORTED_MODULE_2__.identity, ...rest} = options;\n  return new Vector(data, {...rest, y});\n}\n\nfunction spike(data, options = {}) {\n  const {\n    shape = shapeSpike,\n    stroke = defaults.stroke,\n    strokeWidth = 1,\n    fill = stroke,\n    fillOpacity = 0.3,\n    anchor = \"start\",\n    ...rest\n  } = options;\n  return vector(data, {...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy92ZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNMO0FBQ2tFO0FBTzdFO0FBQ21COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBLG9DQUFvQyxNQUFNO0FBQzFDOztBQUVPLHFCQUFxQiwwQ0FBSTtBQUNoQyxnQ0FBZ0M7QUFDaEMsV0FBVyw2RkFBNkY7QUFDeEcscUJBQXFCLCtEQUFrQjtBQUN2QyxxQkFBcUIsK0RBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pELFlBQVkscUNBQXFDO0FBQ2pELGlCQUFpQiwyQ0FBMkM7QUFDNUQsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBTztBQUN6Qix1QkFBdUIsNkRBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxrQ0FBa0M7QUFDN0MscUJBQXFCLDJEQUFnQjtBQUNyQyxXQUFXLG1EQUFNO0FBQ2pCLFlBQVksMERBQW1CO0FBQy9CLFlBQVkscURBQWMsU0FBUyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0EsWUFBWSxzREFBUSxhQUFhLHFCQUFxQixHQUFHLHFCQUFxQjtBQUM5RSxvQ0FBb0MsS0FBSyx5QkFBeUIsT0FBTztBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRCxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLHlDQUF5QyxTQUFTO0FBQ2xELGtDQUFrQyxXQUFXO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFJO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0IseURBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVPLGtDQUFrQztBQUN6QyxPQUFPLGVBQWU7QUFDdEIsa0RBQWtELHVEQUFVO0FBQzVELDJCQUEyQixjQUFjO0FBQ3pDOztBQUVPLG1DQUFtQztBQUMxQyxTQUFTLElBQUksaURBQVEsV0FBVztBQUNoQywyQkFBMkIsV0FBVztBQUN0Qzs7QUFFTyxtQ0FBbUM7QUFDMUMsU0FBUyxJQUFJLGlEQUFRLFdBQVc7QUFDaEMsMkJBQTJCLFdBQVc7QUFDdEM7O0FBRU8saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLCtEQUErRDtBQUN0RiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWFya3MvdmVjdG9yLmpzP2M3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwYXRoUm91bmQgYXMgcGF0aH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7bWF5YmVGcmFtZUFuY2hvciwgbWF5YmVOdW1iZXJDaGFubmVsLCBtYXliZVR1cGxlLCBrZXl3b3JkLCBpZGVudGl0eX0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7XG4gIGFwcGx5Q2hhbm5lbFN0eWxlcyxcbiAgYXBwbHlEaXJlY3RTdHlsZXMsXG4gIGFwcGx5RnJhbWVBbmNob3IsXG4gIGFwcGx5SW5kaXJlY3RTdHlsZXMsXG4gIGFwcGx5VHJhbnNmb3JtXG59IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHt0ZW1wbGF0ZX0gZnJvbSBcIi4uL3RlbXBsYXRlLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwidmVjdG9yXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZVdpZHRoOiAxLjUsXG4gIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIlxufTtcblxuY29uc3QgZGVmYXVsdFJhZGl1cyA9IDMuNTtcblxuLy8gVGhlIHNpemUgb2YgdGhlIGFycm93aGVhZCBpcyBwcm9wb3J0aW9uYWwgdG8gaXRzIGxlbmd0aCwgYnV0IHdlIHN0aWxsIGFsbG93XG4vLyB0aGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgaGVhZCB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgbWFya+KAmXMgd2lkdGggb3B0aW9uO1xuLy8gZG91YmxpbmcgdGhlIGRlZmF1bHQgcmFkaXVzIHdpbGwgcHJvZHVjZSBhbiBhcnJvd2hlYWQgdGhhdCBpcyB0d2ljZSBhcyBiaWcuXG4vLyBUaGF0IHNhaWQsIHdl4oCZbGwgcHJvYmFibHkgd2FudCBhIGFycm93IHdpdGggYSBmaXhlZCBoZWFkIHNpemUsIHRvby5cbmNvbnN0IHdpbmdSYXRpbyA9IGRlZmF1bHRSYWRpdXMgKiA1O1xuXG5jb25zdCBzaGFwZUFycm93ID0ge1xuICBkcmF3KGNvbnRleHQsIGwsIHIpIHtcbiAgICBjb25zdCB3aW5nID0gKGwgKiByKSAvIHdpbmdSYXRpbztcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCAtbCk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXdpbmcsIHdpbmcgLSBsKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCAtbCk7XG4gICAgY29udGV4dC5saW5lVG8od2luZywgd2luZyAtIGwpO1xuICB9XG59O1xuXG5jb25zdCBzaGFwZVNwaWtlID0ge1xuICBkcmF3KGNvbnRleHQsIGwsIHIpIHtcbiAgICBjb250ZXh0Lm1vdmVUbygtciwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgLWwpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICB9XG59O1xuXG5jb25zdCBzaGFwZXMgPSBuZXcgTWFwKFtcbiAgW1wiYXJyb3dcIiwgc2hhcGVBcnJvd10sXG4gIFtcInNwaWtlXCIsIHNoYXBlU3Bpa2VdXG5dKTtcblxuZnVuY3Rpb24gaXNTaGFwZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmRyYXcgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gbWF5YmVTaGFwZShzaGFwZSkge1xuICBpZiAoaXNTaGFwZU9iamVjdChzaGFwZSkpIHJldHVybiBzaGFwZTtcbiAgY29uc3QgdmFsdWUgPSBzaGFwZXMuZ2V0KGAke3NoYXBlfWAudG9Mb3dlckNhc2UoKSk7XG4gIGlmICh2YWx1ZSkgcmV0dXJuIHZhbHVlO1xuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2hhcGU6ICR7c2hhcGV9YCk7XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3IgZXh0ZW5kcyBNYXJrIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3gsIHksIHIgPSBkZWZhdWx0UmFkaXVzLCBsZW5ndGgsIHJvdGF0ZSwgc2hhcGUgPSBzaGFwZUFycm93LCBhbmNob3IgPSBcIm1pZGRsZVwiLCBmcmFtZUFuY2hvcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IFt2bCwgY2xdID0gbWF5YmVOdW1iZXJDaGFubmVsKGxlbmd0aCwgMTIpO1xuICAgIGNvbnN0IFt2ciwgY3JdID0gbWF5YmVOdW1iZXJDaGFubmVsKHJvdGF0ZSwgMCk7XG4gICAgc3VwZXIoXG4gICAgICBkYXRhLFxuICAgICAge1xuICAgICAgICB4OiB7dmFsdWU6IHgsIHNjYWxlOiBcInhcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICB5OiB7dmFsdWU6IHksIHNjYWxlOiBcInlcIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICBsZW5ndGg6IHt2YWx1ZTogdmwsIHNjYWxlOiBcImxlbmd0aFwiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgIHJvdGF0ZToge3ZhbHVlOiB2ciwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzXG4gICAgKTtcbiAgICB0aGlzLnIgPSArcjtcbiAgICB0aGlzLmxlbmd0aCA9IGNsO1xuICAgIHRoaXMucm90YXRlID0gY3I7XG4gICAgdGhpcy5zaGFwZSA9IG1heWJlU2hhcGUoc2hhcGUpO1xuICAgIHRoaXMuYW5jaG9yID0ga2V5d29yZChhbmNob3IsIFwiYW5jaG9yXCIsIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbiAgICB0aGlzLmZyYW1lQW5jaG9yID0gbWF5YmVGcmFtZUFuY2hvcihmcmFtZUFuY2hvcik7XG4gIH1cbiAgcmVuZGVyKGluZGV4LCBzY2FsZXMsIGNoYW5uZWxzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3Qge3gsIHl9ID0gc2NhbGVzO1xuICAgIGNvbnN0IHt4OiBYLCB5OiBZLCBsZW5ndGg6IEwsIHJvdGF0ZTogQX0gPSBjaGFubmVscztcbiAgICBjb25zdCB7bGVuZ3RoLCByb3RhdGUsIGFuY2hvciwgc2hhcGUsIHJ9ID0gdGhpcztcbiAgICBjb25zdCBbY3gsIGN5XSA9IGFwcGx5RnJhbWVBbmNob3IodGhpcywgZGltZW5zaW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZShcInN2ZzpnXCIsIGNvbnRleHQpXG4gICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgLmNhbGwoYXBwbHlUcmFuc2Zvcm0sIHRoaXMsIHt4OiBYICYmIHgsIHk6IFkgJiYgeX0pXG4gICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgZ1xuICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAuY2FsbChhcHBseURpcmVjdFN0eWxlcywgdGhpcylcbiAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICB0ZW1wbGF0ZWB0cmFuc2xhdGUoJHtYID8gKGkpID0+IFhbaV0gOiBjeH0sJHtZID8gKGkpID0+IFlbaV0gOiBjeX0pJHtcbiAgICAgICAgICAgICAgQSA/IChpKSA9PiBgIHJvdGF0ZSgke0FbaV19KWAgOiByb3RhdGUgPyBgIHJvdGF0ZSgke3JvdGF0ZX0pYCA6IGBgXG4gICAgICAgICAgICB9JHtcbiAgICAgICAgICAgICAgYW5jaG9yID09PSBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICA/IGBgXG4gICAgICAgICAgICAgICAgOiBhbmNob3IgPT09IFwiZW5kXCJcbiAgICAgICAgICAgICAgICA/IExcbiAgICAgICAgICAgICAgICAgID8gKGkpID0+IGAgdHJhbnNsYXRlKDAsJHtMW2ldfSlgXG4gICAgICAgICAgICAgICAgICA6IGAgdHJhbnNsYXRlKDAsJHtsZW5ndGh9KWBcbiAgICAgICAgICAgICAgICA6IExcbiAgICAgICAgICAgICAgICA/IChpKSA9PiBgIHRyYW5zbGF0ZSgwLCR7TFtpXSAvIDJ9KWBcbiAgICAgICAgICAgICAgICA6IGAgdHJhbnNsYXRlKDAsJHtsZW5ndGggLyAyfSlgXG4gICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgIFwiZFwiLFxuICAgICAgICAgICAgTFxuICAgICAgICAgICAgICA/IChpKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0aCgpO1xuICAgICAgICAgICAgICAgICAgc2hhcGUuZHJhdyhwLCBMW2ldLCByKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIHNoYXBlLmRyYXcocCwgbGVuZ3RoLCByKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICApXG4gICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCBjaGFubmVscylcbiAgICAgIClcbiAgICAgIC5ub2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlY3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHt4LCB5LCAuLi5yZXN0fSA9IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zLmZyYW1lQW5jaG9yID09PSB1bmRlZmluZWQpIFt4LCB5XSA9IG1heWJlVHVwbGUoeCwgeSk7XG4gIHJldHVybiBuZXcgVmVjdG9yKGRhdGEsIHsuLi5yZXN0LCB4LCB5fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZWN0b3JYKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7eCA9IGlkZW50aXR5LCAuLi5yZXN0fSA9IG9wdGlvbnM7XG4gIHJldHVybiBuZXcgVmVjdG9yKGRhdGEsIHsuLi5yZXN0LCB4fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZWN0b3JZKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7eSA9IGlkZW50aXR5LCAuLi5yZXN0fSA9IG9wdGlvbnM7XG4gIHJldHVybiBuZXcgVmVjdG9yKGRhdGEsIHsuLi5yZXN0LCB5fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGlrZShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNoYXBlID0gc2hhcGVTcGlrZSxcbiAgICBzdHJva2UgPSBkZWZhdWx0cy5zdHJva2UsXG4gICAgc3Ryb2tlV2lkdGggPSAxLFxuICAgIGZpbGwgPSBzdHJva2UsXG4gICAgZmlsbE9wYWNpdHkgPSAwLjMsXG4gICAgYW5jaG9yID0gXCJzdGFydFwiLFxuICAgIC4uLnJlc3RcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB2ZWN0b3IoZGF0YSwgey4uLnJlc3QsIHNoYXBlLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsLCBmaWxsT3BhY2l0eSwgYW5jaG9yfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/vector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/marks/waffle.js":
/*!*************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/marks/waffle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaffleX: () => (/* binding */ WaffleX),\n/* harmony export */   WaffleY: () => (/* binding */ WaffleY),\n/* harmony export */   waffleX: () => (/* binding */ waffleX),\n/* harmony export */   waffleY: () => (/* binding */ waffleY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../template.js */ \"(ssr)/./node_modules/@observablehq/plot/src/template.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _transforms_identity_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../transforms/identity.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js\");\n/* harmony import */ var _transforms_interval_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transforms/interval.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\");\n/* harmony import */ var _transforms_stack_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transforms/stack.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\");\n/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bar.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/bar.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst waffleDefaults = {\n  ariaLabel: \"waffle\"\n};\n\nclass WaffleX extends _bar_js__WEBPACK_IMPORTED_MODULE_1__.BarX {\n  constructor(data, {unit = 1, gap = 1, round, multiple, ...options} = {}) {\n    super(data, wafflePolygon(\"x\", options), waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\n\nclass WaffleY extends _bar_js__WEBPACK_IMPORTED_MODULE_1__.BarY {\n  constructor(data, {unit = 1, gap = 1, round, multiple, ...options} = {}) {\n    super(data, wafflePolygon(\"y\", options), waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\n\nfunction wafflePolygon(y, options) {\n  const x = y === \"y\" ? \"x\" : \"y\";\n  const y1 = `${y}1`;\n  const y2 = `${y}2`;\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_2__.initializer)(waffleRender(options), function (data, facets, channels, scales, dimensions) {\n    const {round, unit} = this;\n    const Y1 = channels[y1].value;\n    const Y2 = channels[y2].value;\n\n    // We might not use all the available bandwidth if the cells don’t fit evenly.\n    const xy = (0,_channel_js__WEBPACK_IMPORTED_MODULE_3__.valueObject)({...(x in channels && {[x]: channels[x]}), [y1]: channels[y1], [y2]: channels[y2]}, scales);\n    const barwidth = this[y === \"y\" ? \"_width\" : \"_height\"](scales, xy, dimensions);\n    const barx = this[y === \"y\" ? \"_x\" : \"_y\"](scales, xy, dimensions);\n\n    // The length of a unit along y in pixels.\n    const scale = unit * scaleof(scales.scales[y]);\n\n    // The number of cells on each row (or column) of the waffle.\n    const {multiple = Math.max(1, Math.floor(Math.sqrt(barwidth / scale)))} = this;\n\n    // The outer size of each square cell, in pixels, including the gap.\n    const cx = Math.min(barwidth / multiple, scale * multiple);\n    const cy = scale * multiple;\n\n    // The reference position.\n    const tx = (barwidth - multiple * cx) / 2;\n    const x0 = typeof barx === \"function\" ? (i) => barx(i) + tx : barx + tx;\n    const y0 = scales[y](0);\n\n    // TODO insets?\n    const transform = y === \"y\" ? ([x, y]) => [x * cx, -y * cy] : ([x, y]) => [y * cy, x * cx];\n    const mx = typeof x0 === \"function\" ? (i) => x0(i) - barwidth / 2 : () => x0;\n    const [ix, iy] = y === \"y\" ? [0, 1] : [1, 0];\n\n    const n = Y2.length;\n    const P = new Array(n);\n    const X = new Float64Array(n);\n    const Y = new Float64Array(n);\n\n    for (let i = 0; i < n; ++i) {\n      P[i] = wafflePoints(round(Y1[i] / unit), round(Y2[i] / unit), multiple).map(transform);\n      const c = P[i].pop(); // extract the transformed centroid\n      X[i] = c[ix] + mx(i);\n      Y[i] = c[iy] + y0;\n    }\n\n    return {\n      channels: {\n        polygon: {value: P, source: null, filter: null},\n        [`c${x}`]: {value: [cx, x0], source: null, filter: null},\n        [`c${y}`]: {value: [cy, y0], source: null, filter: null},\n        [x]: {value: X, scale: null, source: null},\n        [y1]: {value: Y, scale: null, source: channels[y1]},\n        [y2]: {value: Y, scale: null, source: channels[y2]}\n      }\n    };\n  });\n}\n\nfunction waffleRender({render, ...options}) {\n  return {\n    ...options,\n    render: (0,_mark_js__WEBPACK_IMPORTED_MODULE_4__.composeRender)(render, function (index, scales, values, dimensions, context) {\n      const {gap, rx, ry} = this;\n      const {channels, ariaLabel, href, title, ...visualValues} = values;\n      const {document} = context;\n      const polygon = channels.polygon.value;\n      const [cx, x0] = channels.cx.value;\n      const [cy, y0] = channels.cy.value;\n\n      // Create a base pattern with shared attributes for cloning.\n      const patternId = (0,_style_js__WEBPACK_IMPORTED_MODULE_5__.getPatternId)();\n      const basePattern = document.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"pattern\");\n      basePattern.setAttribute(\"width\", cx);\n      basePattern.setAttribute(\"height\", cy);\n      basePattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n      const basePatternRect = basePattern.appendChild(document.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"rect\"));\n      basePatternRect.setAttribute(\"x\", gap / 2);\n      basePatternRect.setAttribute(\"y\", gap / 2);\n      basePatternRect.setAttribute(\"width\", cx - gap);\n      basePatternRect.setAttribute(\"height\", cy - gap);\n      if (rx != null) basePatternRect.setAttribute(\"rx\", rx);\n      if (ry != null) basePatternRect.setAttribute(\"ry\", ry);\n\n      return (0,_context_js__WEBPACK_IMPORTED_MODULE_6__.create)(\"svg:g\", context)\n        .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyIndirectStyles, this, dimensions, context)\n        .call(this._transform, this, scales)\n        .call((g) =>\n          g\n            .selectAll()\n            .data(index)\n            .enter()\n            .append(() => basePattern.cloneNode(true))\n            .attr(\"id\", (i) => `${patternId}-${i}`)\n            .select(\"rect\")\n            .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyDirectStyles, this)\n            .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyChannelStyles, this, visualValues)\n        )\n        .call((g) =>\n          g\n            .selectAll()\n            .data(index)\n            .enter()\n            .append(\"path\")\n            .attr(\"transform\", (0,_template_js__WEBPACK_IMPORTED_MODULE_7__.template)`translate(${x0},${y0})`)\n            .attr(\"d\", (i) => `M${polygon[i].join(\"L\")}Z`)\n            .attr(\"fill\", (i) => `url(#${patternId}-${i})`)\n            .attr(\"stroke\", this.stroke == null ? null : \"none\")\n            .call(_style_js__WEBPACK_IMPORTED_MODULE_5__.applyChannelStyles, this, {ariaLabel, href, title})\n        )\n        .node();\n    })\n  };\n}\n\n// A waffle is approximately a rectangular shape, but may have one or two corner\n// cuts if the starting or ending value is not an even multiple of the number of\n// columns (the width of the waffle in cells). We can represent any waffle by\n// 8 points; below is a waffle of five columns representing the interval 2–11:\n//\n// 1-0\n// |•7-------6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Note that points 0 and 1 always have the same y-value, points 1 and 2 have\n// the same x-value, and so on, so we don’t need to materialize the x- and y-\n// values of all points. Also note that we can’t use the already-projected y-\n// values because these assume that y-values are distributed linearly along y\n// rather than wrapping around in columns.\n//\n// The corner points may be coincident. If the ending value is an even multiple\n// of the number of columns, say representing the interval 2–10, then points 6,\n// 7, and 0 are the same.\n//\n// 1-----0/7/6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Likewise if the starting value is an even multiple, say representing the\n// interval 0–10, points 2–4 are coincident.\n//\n// 1-----0/7/6\n// |• • • • •|\n// |• • • • •|\n// 4/3/2-----5\n//\n// Waffles can also represent fractional intervals (e.g., 2.4–10.1). These\n// require additional corner cuts, so the implementation below generates a few\n// more points.\n//\n// The last point describes the centroid (used for pointing)\nfunction wafflePoints(i1, i2, columns) {\n  if (i2 < i1) return wafflePoints(i2, i1, columns); // ensure i1 <= i2\n  if (i1 < 0) return wafflePointsOffset(i1, i2, columns, Math.ceil(-Math.min(i1, i2) / columns)); // ensure i1 >= 0\n  const x1f = Math.floor(i1 % columns);\n  const x1c = Math.ceil(i1 % columns);\n  const x2f = Math.floor(i2 % columns);\n  const x2c = Math.ceil(i2 % columns);\n  const y1f = Math.floor(i1 / columns);\n  const y1c = Math.ceil(i1 / columns);\n  const y2f = Math.floor(i2 / columns);\n  const y2c = Math.ceil(i2 / columns);\n  const points = [];\n  if (y2c > y1c) points.push([0, y1c]);\n  points.push([x1f, y1c], [x1f, y1f + (i1 % 1)], [x1c, y1f + (i1 % 1)]);\n  if (!(i1 % columns > columns - 1)) {\n    points.push([x1c, y1f]);\n    if (y2f > y1f) points.push([columns, y1f]);\n  }\n  if (y2f > y1f) points.push([columns, y2f]);\n  points.push([x2c, y2f], [x2c, y2f + (i2 % 1)], [x2f, y2f + (i2 % 1)]);\n  if (!(i2 % columns < 1)) {\n    points.push([x2f, y2c]);\n    if (y2c > y1c) points.push([0, y2c]);\n  }\n  points.push(waffleCentroid(i1, i2, columns));\n  return points;\n}\n\nfunction wafflePointsOffset(i1, i2, columns, k) {\n  return wafflePoints(i1 + k * columns, i2 + k * columns, columns).map(([x, y]) => [x, y - k]);\n}\n\nfunction waffleCentroid(i1, i2, columns) {\n  const r = Math.floor(i2 / columns) - Math.floor(i1 / columns);\n  return r === 0\n    ? // Single row\n      waffleRowCentroid(i1, i2, columns)\n    : r === 1\n    ? // Two incomplete rows; use the midpoint of their overlap if any, otherwise the larger row\n      Math.floor(i2 % columns) > Math.ceil(i1 % columns)\n      ? [(Math.floor(i2 % columns) + Math.ceil(i1 % columns)) / 2, Math.floor(i2 / columns)]\n      : i2 % columns > columns - (i1 % columns)\n      ? waffleRowCentroid(i2 - (i2 % columns), i2, columns)\n      : waffleRowCentroid(i1, columns * Math.ceil(i1 / columns), columns)\n    : // At least one full row; take the midpoint of all the rows that include the middle\n      [columns / 2, (Math.round(i1 / columns) + Math.round(i2 / columns)) / 2];\n}\n\nfunction waffleRowCentroid(i1, i2, columns) {\n  const c = Math.floor(i2) - Math.floor(i1);\n  return c === 0\n    ? // Single cell\n      [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (((i1 + i2) / 2) % 1)]\n    : c === 1\n    ? // Two incomplete cells; use the overlap if large enough, otherwise use the largest\n      (i2 % 1) - (i1 % 1) > 0.5\n      ? [Math.ceil(i1 % columns), Math.floor(i2 / columns) + ((i1 % 1) + (i2 % 1)) / 2]\n      : i2 % 1 > 1 - (i1 % 1)\n      ? [Math.floor(i2 % columns) + 0.5, Math.floor(i2 / columns) + (i2 % 1) / 2]\n      : [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (1 + (i1 % 1)) / 2]\n    : // At least one full cell; take the midpoint\n      [\n        Math.ceil(i1 % columns) + Math.ceil(Math.floor(i2) - Math.ceil(i1)) / 2,\n        Math.floor(i1 / columns) + (i2 >= 1 + i1 ? 0.5 : ((i1 + i2) / 2) % 1)\n      ];\n}\n\nfunction maybeRound(round) {\n  if (round === undefined || round === false) return Number;\n  if (round === true) return Math.round;\n  if (typeof round !== \"function\") throw new Error(`invalid round: ${round}`);\n  return round;\n}\n\nfunction maybeMultiple(multiple) {\n  return multiple === undefined ? undefined : Math.max(1, Math.floor(multiple));\n}\n\nfunction scaleof({domain, range}) {\n  return spread(range) / spread(domain);\n}\n\nfunction spread(domain) {\n  const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain);\n  return max - min;\n}\n\nfunction waffleX(data, {tip, ...options} = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_8__.hasXY)(options)) options = {...options, y: _options_js__WEBPACK_IMPORTED_MODULE_8__.indexOf, x2: _options_js__WEBPACK_IMPORTED_MODULE_8__.identity};\n  return new WaffleX(data, {tip: waffleTip(tip), ...(0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_9__.maybeStackX)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_10__.maybeIntervalX)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_11__.maybeIdentityX)(options)))});\n}\n\nfunction waffleY(data, {tip, ...options} = {}) {\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_8__.hasXY)(options)) options = {...options, x: _options_js__WEBPACK_IMPORTED_MODULE_8__.indexOf, y2: _options_js__WEBPACK_IMPORTED_MODULE_8__.identity};\n  return new WaffleY(data, {tip: waffleTip(tip), ...(0,_transforms_stack_js__WEBPACK_IMPORTED_MODULE_9__.maybeStackY)((0,_transforms_interval_js__WEBPACK_IMPORTED_MODULE_10__.maybeIntervalY)((0,_transforms_identity_js__WEBPACK_IMPORTED_MODULE_11__.maybeIdentityY)(options)))});\n}\n\n/**\n * Waffle tips behave a bit unpredictably because we they are driven by the\n * waffle centroid; you could be hovering over a waffle segment, but more than\n * 40px away from its centroid, or closer to the centroid of another segment.\n * We’d rather show a tip, even if it’s the “wrong” one, so we increase the\n * default maxRadius to Infinity. The “right” way to fix this would be to use\n * signed distance to the waffle geometry rather than the centroid.\n */\nfunction waffleTip(tip) {\n  return tip === true\n    ? {maxRadius: Infinity}\n    : (0,_options_js__WEBPACK_IMPORTED_MODULE_8__.isObject)(tip) && tip.maxRadius === undefined\n    ? {...tip, maxRadius: Infinity}\n    : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXJrcy93YWZmbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNJO0FBQ0w7QUFDSTtBQUN3QjtBQUNvQztBQUM3RDtBQUNXO0FBQ3NCO0FBQ0E7QUFDVDtBQUM1Qjs7QUFFcEM7QUFDQTtBQUNBOztBQUVPLHNCQUFzQix5Q0FBSTtBQUNqQyxxQkFBcUIsZ0RBQWdELElBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sc0JBQXNCLHlDQUFJO0FBQ2pDLHFCQUFxQixnREFBZ0QsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEIsZ0JBQWdCLEVBQUU7QUFDbEIsU0FBUyxpRUFBVztBQUNwQixXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsd0RBQVcsRUFBRSxzQkFBc0IsaUJBQWlCLDBDQUEwQztBQUM3RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlFQUFpRTs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RCxhQUFhLEVBQUUsS0FBSyw0Q0FBNEM7QUFDaEUsYUFBYSxFQUFFLEtBQUssNENBQTRDO0FBQ2hFLGNBQWMsb0NBQW9DO0FBQ2xELGVBQWUsNENBQTRDO0FBQzNELGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLFlBQVksdURBQWE7QUFDekIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbURBQW1EO0FBQ2hFLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdURBQVk7QUFDcEMsbURBQW1ELDBDQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwwQ0FBVTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtREFBTTtBQUNuQixjQUFjLDBEQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEdBQUcsRUFBRTtBQUNqRDtBQUNBLGtCQUFrQix3REFBaUI7QUFDbkMsa0JBQWtCLHlEQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBUSxhQUFhLEdBQUcsR0FBRyxHQUFHO0FBQzdELGtDQUFrQyxxQkFBcUI7QUFDdkQseUNBQXlDLFVBQVUsR0FBRyxFQUFFO0FBQ3hEO0FBQ0Esa0JBQWtCLHlEQUFrQixTQUFTLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBOztBQUVPLHdCQUF3QixpQkFBaUIsSUFBSTtBQUNwRCxPQUFPLGtEQUFLLHNCQUFzQixlQUFlLGdEQUFPLE1BQU0saURBQVE7QUFDdEUsNEJBQTRCLHdCQUF3QixpRUFBVyxDQUFDLHdFQUFjLENBQUMsd0VBQWMsWUFBWTtBQUN6Rzs7QUFFTyx3QkFBd0IsaUJBQWlCLElBQUk7QUFDcEQsT0FBTyxrREFBSyxzQkFBc0IsZUFBZSxnREFBTyxNQUFNLGlEQUFRO0FBQ3RFLDRCQUE0Qix3QkFBd0IsaUVBQVcsQ0FBQyx3RUFBYyxDQUFDLHdFQUFjLFlBQVk7QUFDekc7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLHFEQUFRO0FBQ2QsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21hcmtzL3dhZmZsZS5qcz8xNmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXh0ZW50LCBuYW1lc3BhY2VzfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7dmFsdWVPYmplY3R9IGZyb20gXCIuLi9jaGFubmVsLmpzXCI7XG5pbXBvcnQge2NyZWF0ZX0gZnJvbSBcIi4uL2NvbnRleHQuanNcIjtcbmltcG9ydCB7Y29tcG9zZVJlbmRlcn0gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7aGFzWFksIGlkZW50aXR5LCBpbmRleE9mLCBpc09iamVjdH0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7YXBwbHlDaGFubmVsU3R5bGVzLCBhcHBseURpcmVjdFN0eWxlcywgYXBwbHlJbmRpcmVjdFN0eWxlcywgZ2V0UGF0dGVybklkfSBmcm9tIFwiLi4vc3R5bGUuanNcIjtcbmltcG9ydCB7dGVtcGxhdGV9IGZyb20gXCIuLi90ZW1wbGF0ZS5qc1wiO1xuaW1wb3J0IHtpbml0aWFsaXplcn0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvYmFzaWMuanNcIjtcbmltcG9ydCB7bWF5YmVJZGVudGl0eVgsIG1heWJlSWRlbnRpdHlZfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHttYXliZUludGVydmFsWCwgbWF5YmVJbnRlcnZhbFl9IGZyb20gXCIuLi90cmFuc2Zvcm1zL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge21heWJlU3RhY2tYLCBtYXliZVN0YWNrWX0gZnJvbSBcIi4uL3RyYW5zZm9ybXMvc3RhY2suanNcIjtcbmltcG9ydCB7QmFyWCwgQmFyWX0gZnJvbSBcIi4vYmFyLmpzXCI7XG5cbmNvbnN0IHdhZmZsZURlZmF1bHRzID0ge1xuICBhcmlhTGFiZWw6IFwid2FmZmxlXCJcbn07XG5cbmV4cG9ydCBjbGFzcyBXYWZmbGVYIGV4dGVuZHMgQmFyWCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHt1bml0ID0gMSwgZ2FwID0gMSwgcm91bmQsIG11bHRpcGxlLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gICAgc3VwZXIoZGF0YSwgd2FmZmxlUG9seWdvbihcInhcIiwgb3B0aW9ucyksIHdhZmZsZURlZmF1bHRzKTtcbiAgICB0aGlzLnVuaXQgPSBNYXRoLm1heCgwLCB1bml0KTtcbiAgICB0aGlzLmdhcCA9ICtnYXA7XG4gICAgdGhpcy5yb3VuZCA9IG1heWJlUm91bmQocm91bmQpO1xuICAgIHRoaXMubXVsdGlwbGUgPSBtYXliZU11bHRpcGxlKG11bHRpcGxlKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2FmZmxlWSBleHRlbmRzIEJhclkge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB7dW5pdCA9IDEsIGdhcCA9IDEsIHJvdW5kLCBtdWx0aXBsZSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICAgIHN1cGVyKGRhdGEsIHdhZmZsZVBvbHlnb24oXCJ5XCIsIG9wdGlvbnMpLCB3YWZmbGVEZWZhdWx0cyk7XG4gICAgdGhpcy51bml0ID0gTWF0aC5tYXgoMCwgdW5pdCk7XG4gICAgdGhpcy5nYXAgPSArZ2FwO1xuICAgIHRoaXMucm91bmQgPSBtYXliZVJvdW5kKHJvdW5kKTtcbiAgICB0aGlzLm11bHRpcGxlID0gbWF5YmVNdWx0aXBsZShtdWx0aXBsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FmZmxlUG9seWdvbih5LCBvcHRpb25zKSB7XG4gIGNvbnN0IHggPSB5ID09PSBcInlcIiA/IFwieFwiIDogXCJ5XCI7XG4gIGNvbnN0IHkxID0gYCR7eX0xYDtcbiAgY29uc3QgeTIgPSBgJHt5fTJgO1xuICByZXR1cm4gaW5pdGlhbGl6ZXIod2FmZmxlUmVuZGVyKG9wdGlvbnMpLCBmdW5jdGlvbiAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zKSB7XG4gICAgY29uc3Qge3JvdW5kLCB1bml0fSA9IHRoaXM7XG4gICAgY29uc3QgWTEgPSBjaGFubmVsc1t5MV0udmFsdWU7XG4gICAgY29uc3QgWTIgPSBjaGFubmVsc1t5Ml0udmFsdWU7XG5cbiAgICAvLyBXZSBtaWdodCBub3QgdXNlIGFsbCB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCBpZiB0aGUgY2VsbHMgZG9u4oCZdCBmaXQgZXZlbmx5LlxuICAgIGNvbnN0IHh5ID0gdmFsdWVPYmplY3Qoey4uLih4IGluIGNoYW5uZWxzICYmIHtbeF06IGNoYW5uZWxzW3hdfSksIFt5MV06IGNoYW5uZWxzW3kxXSwgW3kyXTogY2hhbm5lbHNbeTJdfSwgc2NhbGVzKTtcbiAgICBjb25zdCBiYXJ3aWR0aCA9IHRoaXNbeSA9PT0gXCJ5XCIgPyBcIl93aWR0aFwiIDogXCJfaGVpZ2h0XCJdKHNjYWxlcywgeHksIGRpbWVuc2lvbnMpO1xuICAgIGNvbnN0IGJhcnggPSB0aGlzW3kgPT09IFwieVwiID8gXCJfeFwiIDogXCJfeVwiXShzY2FsZXMsIHh5LCBkaW1lbnNpb25zKTtcblxuICAgIC8vIFRoZSBsZW5ndGggb2YgYSB1bml0IGFsb25nIHkgaW4gcGl4ZWxzLlxuICAgIGNvbnN0IHNjYWxlID0gdW5pdCAqIHNjYWxlb2Yoc2NhbGVzLnNjYWxlc1t5XSk7XG5cbiAgICAvLyBUaGUgbnVtYmVyIG9mIGNlbGxzIG9uIGVhY2ggcm93IChvciBjb2x1bW4pIG9mIHRoZSB3YWZmbGUuXG4gICAgY29uc3Qge211bHRpcGxlID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihNYXRoLnNxcnQoYmFyd2lkdGggLyBzY2FsZSkpKX0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIG91dGVyIHNpemUgb2YgZWFjaCBzcXVhcmUgY2VsbCwgaW4gcGl4ZWxzLCBpbmNsdWRpbmcgdGhlIGdhcC5cbiAgICBjb25zdCBjeCA9IE1hdGgubWluKGJhcndpZHRoIC8gbXVsdGlwbGUsIHNjYWxlICogbXVsdGlwbGUpO1xuICAgIGNvbnN0IGN5ID0gc2NhbGUgKiBtdWx0aXBsZTtcblxuICAgIC8vIFRoZSByZWZlcmVuY2UgcG9zaXRpb24uXG4gICAgY29uc3QgdHggPSAoYmFyd2lkdGggLSBtdWx0aXBsZSAqIGN4KSAvIDI7XG4gICAgY29uc3QgeDAgPSB0eXBlb2YgYmFyeCA9PT0gXCJmdW5jdGlvblwiID8gKGkpID0+IGJhcngoaSkgKyB0eCA6IGJhcnggKyB0eDtcbiAgICBjb25zdCB5MCA9IHNjYWxlc1t5XSgwKTtcblxuICAgIC8vIFRPRE8gaW5zZXRzP1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHkgPT09IFwieVwiID8gKFt4LCB5XSkgPT4gW3ggKiBjeCwgLXkgKiBjeV0gOiAoW3gsIHldKSA9PiBbeSAqIGN5LCB4ICogY3hdO1xuICAgIGNvbnN0IG14ID0gdHlwZW9mIHgwID09PSBcImZ1bmN0aW9uXCIgPyAoaSkgPT4geDAoaSkgLSBiYXJ3aWR0aCAvIDIgOiAoKSA9PiB4MDtcbiAgICBjb25zdCBbaXgsIGl5XSA9IHkgPT09IFwieVwiID8gWzAsIDFdIDogWzEsIDBdO1xuXG4gICAgY29uc3QgbiA9IFkyLmxlbmd0aDtcbiAgICBjb25zdCBQID0gbmV3IEFycmF5KG4pO1xuICAgIGNvbnN0IFggPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGNvbnN0IFkgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIFBbaV0gPSB3YWZmbGVQb2ludHMocm91bmQoWTFbaV0gLyB1bml0KSwgcm91bmQoWTJbaV0gLyB1bml0KSwgbXVsdGlwbGUpLm1hcCh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgYyA9IFBbaV0ucG9wKCk7IC8vIGV4dHJhY3QgdGhlIHRyYW5zZm9ybWVkIGNlbnRyb2lkXG4gICAgICBYW2ldID0gY1tpeF0gKyBteChpKTtcbiAgICAgIFlbaV0gPSBjW2l5XSArIHkwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsczoge1xuICAgICAgICBwb2x5Z29uOiB7dmFsdWU6IFAsIHNvdXJjZTogbnVsbCwgZmlsdGVyOiBudWxsfSxcbiAgICAgICAgW2BjJHt4fWBdOiB7dmFsdWU6IFtjeCwgeDBdLCBzb3VyY2U6IG51bGwsIGZpbHRlcjogbnVsbH0sXG4gICAgICAgIFtgYyR7eX1gXToge3ZhbHVlOiBbY3ksIHkwXSwgc291cmNlOiBudWxsLCBmaWx0ZXI6IG51bGx9LFxuICAgICAgICBbeF06IHt2YWx1ZTogWCwgc2NhbGU6IG51bGwsIHNvdXJjZTogbnVsbH0sXG4gICAgICAgIFt5MV06IHt2YWx1ZTogWSwgc2NhbGU6IG51bGwsIHNvdXJjZTogY2hhbm5lbHNbeTFdfSxcbiAgICAgICAgW3kyXToge3ZhbHVlOiBZLCBzY2FsZTogbnVsbCwgc291cmNlOiBjaGFubmVsc1t5Ml19XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhZmZsZVJlbmRlcih7cmVuZGVyLCAuLi5vcHRpb25zfSkge1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcmVuZGVyOiBjb21wb3NlUmVuZGVyKHJlbmRlciwgZnVuY3Rpb24gKGluZGV4LCBzY2FsZXMsIHZhbHVlcywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICAgICAgY29uc3Qge2dhcCwgcngsIHJ5fSA9IHRoaXM7XG4gICAgICBjb25zdCB7Y2hhbm5lbHMsIGFyaWFMYWJlbCwgaHJlZiwgdGl0bGUsIC4uLnZpc3VhbFZhbHVlc30gPSB2YWx1ZXM7XG4gICAgICBjb25zdCB7ZG9jdW1lbnR9ID0gY29udGV4dDtcbiAgICAgIGNvbnN0IHBvbHlnb24gPSBjaGFubmVscy5wb2x5Z29uLnZhbHVlO1xuICAgICAgY29uc3QgW2N4LCB4MF0gPSBjaGFubmVscy5jeC52YWx1ZTtcbiAgICAgIGNvbnN0IFtjeSwgeTBdID0gY2hhbm5lbHMuY3kudmFsdWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGJhc2UgcGF0dGVybiB3aXRoIHNoYXJlZCBhdHRyaWJ1dGVzIGZvciBjbG9uaW5nLlxuICAgICAgY29uc3QgcGF0dGVybklkID0gZ2V0UGF0dGVybklkKCk7XG4gICAgICBjb25zdCBiYXNlUGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VzLnN2ZywgXCJwYXR0ZXJuXCIpO1xuICAgICAgYmFzZVBhdHRlcm4uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY3gpO1xuICAgICAgYmFzZVBhdHRlcm4uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGN5KTtcbiAgICAgIGJhc2VQYXR0ZXJuLnNldEF0dHJpYnV0ZShcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgY29uc3QgYmFzZVBhdHRlcm5SZWN0ID0gYmFzZVBhdHRlcm4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZXMuc3ZnLCBcInJlY3RcIikpO1xuICAgICAgYmFzZVBhdHRlcm5SZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgZ2FwIC8gMik7XG4gICAgICBiYXNlUGF0dGVyblJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCBnYXAgLyAyKTtcbiAgICAgIGJhc2VQYXR0ZXJuUmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBjeCAtIGdhcCk7XG4gICAgICBiYXNlUGF0dGVyblJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGN5IC0gZ2FwKTtcbiAgICAgIGlmIChyeCAhPSBudWxsKSBiYXNlUGF0dGVyblJlY3Quc2V0QXR0cmlidXRlKFwicnhcIiwgcngpO1xuICAgICAgaWYgKHJ5ICE9IG51bGwpIGJhc2VQYXR0ZXJuUmVjdC5zZXRBdHRyaWJ1dGUoXCJyeVwiLCByeSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KVxuICAgICAgICAuY2FsbChhcHBseUluZGlyZWN0U3R5bGVzLCB0aGlzLCBkaW1lbnNpb25zLCBjb250ZXh0KVxuICAgICAgICAuY2FsbCh0aGlzLl90cmFuc2Zvcm0sIHRoaXMsIHNjYWxlcylcbiAgICAgICAgLmNhbGwoKGcpID0+XG4gICAgICAgICAgZ1xuICAgICAgICAgICAgLnNlbGVjdEFsbCgpXG4gICAgICAgICAgICAuZGF0YShpbmRleClcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCgpID0+IGJhc2VQYXR0ZXJuLmNsb25lTm9kZSh0cnVlKSlcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKGkpID0+IGAke3BhdHRlcm5JZH0tJHtpfWApXG4gICAgICAgICAgICAuc2VsZWN0KFwicmVjdFwiKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlEaXJlY3RTdHlsZXMsIHRoaXMpXG4gICAgICAgICAgICAuY2FsbChhcHBseUNoYW5uZWxTdHlsZXMsIHRoaXMsIHZpc3VhbFZhbHVlcylcbiAgICAgICAgKVxuICAgICAgICAuY2FsbCgoZykgPT5cbiAgICAgICAgICBnXG4gICAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAgIC5kYXRhKGluZGV4KVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCB0ZW1wbGF0ZWB0cmFuc2xhdGUoJHt4MH0sJHt5MH0pYClcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCAoaSkgPT4gYE0ke3BvbHlnb25baV0uam9pbihcIkxcIil9WmApXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgKGkpID0+IGB1cmwoIyR7cGF0dGVybklkfS0ke2l9KWApXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCB0aGlzLnN0cm9rZSA9PSBudWxsID8gbnVsbCA6IFwibm9uZVwiKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlDaGFubmVsU3R5bGVzLCB0aGlzLCB7YXJpYUxhYmVsLCBocmVmLCB0aXRsZX0pXG4gICAgICAgIClcbiAgICAgICAgLm5vZGUoKTtcbiAgICB9KVxuICB9O1xufVxuXG4vLyBBIHdhZmZsZSBpcyBhcHByb3hpbWF0ZWx5IGEgcmVjdGFuZ3VsYXIgc2hhcGUsIGJ1dCBtYXkgaGF2ZSBvbmUgb3IgdHdvIGNvcm5lclxuLy8gY3V0cyBpZiB0aGUgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlIGlzIG5vdCBhbiBldmVuIG11bHRpcGxlIG9mIHRoZSBudW1iZXIgb2Zcbi8vIGNvbHVtbnMgKHRoZSB3aWR0aCBvZiB0aGUgd2FmZmxlIGluIGNlbGxzKS4gV2UgY2FuIHJlcHJlc2VudCBhbnkgd2FmZmxlIGJ5XG4vLyA4IHBvaW50czsgYmVsb3cgaXMgYSB3YWZmbGUgb2YgZml2ZSBjb2x1bW5zIHJlcHJlc2VudGluZyB0aGUgaW50ZXJ2YWwgMuKAkzExOlxuLy9cbi8vIDEtMFxuLy8gfOKAojctLS0tLS0tNlxuLy8gfOKAoiDigKIg4oCiIOKAoiDigKJ8XG4vLyAyLS0tM+KAoiDigKIg4oCifFxuLy8gICAgIDQtLS0tLTVcbi8vXG4vLyBOb3RlIHRoYXQgcG9pbnRzIDAgYW5kIDEgYWx3YXlzIGhhdmUgdGhlIHNhbWUgeS12YWx1ZSwgcG9pbnRzIDEgYW5kIDIgaGF2ZVxuLy8gdGhlIHNhbWUgeC12YWx1ZSwgYW5kIHNvIG9uLCBzbyB3ZSBkb27igJl0IG5lZWQgdG8gbWF0ZXJpYWxpemUgdGhlIHgtIGFuZCB5LVxuLy8gdmFsdWVzIG9mIGFsbCBwb2ludHMuIEFsc28gbm90ZSB0aGF0IHdlIGNhbuKAmXQgdXNlIHRoZSBhbHJlYWR5LXByb2plY3RlZCB5LVxuLy8gdmFsdWVzIGJlY2F1c2UgdGhlc2UgYXNzdW1lIHRoYXQgeS12YWx1ZXMgYXJlIGRpc3RyaWJ1dGVkIGxpbmVhcmx5IGFsb25nIHlcbi8vIHJhdGhlciB0aGFuIHdyYXBwaW5nIGFyb3VuZCBpbiBjb2x1bW5zLlxuLy9cbi8vIFRoZSBjb3JuZXIgcG9pbnRzIG1heSBiZSBjb2luY2lkZW50LiBJZiB0aGUgZW5kaW5nIHZhbHVlIGlzIGFuIGV2ZW4gbXVsdGlwbGVcbi8vIG9mIHRoZSBudW1iZXIgb2YgY29sdW1ucywgc2F5IHJlcHJlc2VudGluZyB0aGUgaW50ZXJ2YWwgMuKAkzEwLCB0aGVuIHBvaW50cyA2LFxuLy8gNywgYW5kIDAgYXJlIHRoZSBzYW1lLlxuLy9cbi8vIDEtLS0tLTAvNy82XG4vLyB84oCiIOKAoiDigKIg4oCiIOKAonxcbi8vIDItLS0z4oCiIOKAoiDigKJ8XG4vLyAgICAgNC0tLS0tNVxuLy9cbi8vIExpa2V3aXNlIGlmIHRoZSBzdGFydGluZyB2YWx1ZSBpcyBhbiBldmVuIG11bHRpcGxlLCBzYXkgcmVwcmVzZW50aW5nIHRoZVxuLy8gaW50ZXJ2YWwgMOKAkzEwLCBwb2ludHMgMuKAkzQgYXJlIGNvaW5jaWRlbnQuXG4vL1xuLy8gMS0tLS0tMC83LzZcbi8vIHzigKIg4oCiIOKAoiDigKIg4oCifFxuLy8gfOKAoiDigKIg4oCiIOKAoiDigKJ8XG4vLyA0LzMvMi0tLS0tNVxuLy9cbi8vIFdhZmZsZXMgY2FuIGFsc28gcmVwcmVzZW50IGZyYWN0aW9uYWwgaW50ZXJ2YWxzIChlLmcuLCAyLjTigJMxMC4xKS4gVGhlc2Vcbi8vIHJlcXVpcmUgYWRkaXRpb25hbCBjb3JuZXIgY3V0cywgc28gdGhlIGltcGxlbWVudGF0aW9uIGJlbG93IGdlbmVyYXRlcyBhIGZld1xuLy8gbW9yZSBwb2ludHMuXG4vL1xuLy8gVGhlIGxhc3QgcG9pbnQgZGVzY3JpYmVzIHRoZSBjZW50cm9pZCAodXNlZCBmb3IgcG9pbnRpbmcpXG5mdW5jdGlvbiB3YWZmbGVQb2ludHMoaTEsIGkyLCBjb2x1bW5zKSB7XG4gIGlmIChpMiA8IGkxKSByZXR1cm4gd2FmZmxlUG9pbnRzKGkyLCBpMSwgY29sdW1ucyk7IC8vIGVuc3VyZSBpMSA8PSBpMlxuICBpZiAoaTEgPCAwKSByZXR1cm4gd2FmZmxlUG9pbnRzT2Zmc2V0KGkxLCBpMiwgY29sdW1ucywgTWF0aC5jZWlsKC1NYXRoLm1pbihpMSwgaTIpIC8gY29sdW1ucykpOyAvLyBlbnN1cmUgaTEgPj0gMFxuICBjb25zdCB4MWYgPSBNYXRoLmZsb29yKGkxICUgY29sdW1ucyk7XG4gIGNvbnN0IHgxYyA9IE1hdGguY2VpbChpMSAlIGNvbHVtbnMpO1xuICBjb25zdCB4MmYgPSBNYXRoLmZsb29yKGkyICUgY29sdW1ucyk7XG4gIGNvbnN0IHgyYyA9IE1hdGguY2VpbChpMiAlIGNvbHVtbnMpO1xuICBjb25zdCB5MWYgPSBNYXRoLmZsb29yKGkxIC8gY29sdW1ucyk7XG4gIGNvbnN0IHkxYyA9IE1hdGguY2VpbChpMSAvIGNvbHVtbnMpO1xuICBjb25zdCB5MmYgPSBNYXRoLmZsb29yKGkyIC8gY29sdW1ucyk7XG4gIGNvbnN0IHkyYyA9IE1hdGguY2VpbChpMiAvIGNvbHVtbnMpO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgaWYgKHkyYyA+IHkxYykgcG9pbnRzLnB1c2goWzAsIHkxY10pO1xuICBwb2ludHMucHVzaChbeDFmLCB5MWNdLCBbeDFmLCB5MWYgKyAoaTEgJSAxKV0sIFt4MWMsIHkxZiArIChpMSAlIDEpXSk7XG4gIGlmICghKGkxICUgY29sdW1ucyA+IGNvbHVtbnMgLSAxKSkge1xuICAgIHBvaW50cy5wdXNoKFt4MWMsIHkxZl0pO1xuICAgIGlmICh5MmYgPiB5MWYpIHBvaW50cy5wdXNoKFtjb2x1bW5zLCB5MWZdKTtcbiAgfVxuICBpZiAoeTJmID4geTFmKSBwb2ludHMucHVzaChbY29sdW1ucywgeTJmXSk7XG4gIHBvaW50cy5wdXNoKFt4MmMsIHkyZl0sIFt4MmMsIHkyZiArIChpMiAlIDEpXSwgW3gyZiwgeTJmICsgKGkyICUgMSldKTtcbiAgaWYgKCEoaTIgJSBjb2x1bW5zIDwgMSkpIHtcbiAgICBwb2ludHMucHVzaChbeDJmLCB5MmNdKTtcbiAgICBpZiAoeTJjID4geTFjKSBwb2ludHMucHVzaChbMCwgeTJjXSk7XG4gIH1cbiAgcG9pbnRzLnB1c2god2FmZmxlQ2VudHJvaWQoaTEsIGkyLCBjb2x1bW5zKSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5cbmZ1bmN0aW9uIHdhZmZsZVBvaW50c09mZnNldChpMSwgaTIsIGNvbHVtbnMsIGspIHtcbiAgcmV0dXJuIHdhZmZsZVBvaW50cyhpMSArIGsgKiBjb2x1bW5zLCBpMiArIGsgKiBjb2x1bW5zLCBjb2x1bW5zKS5tYXAoKFt4LCB5XSkgPT4gW3gsIHkgLSBrXSk7XG59XG5cbmZ1bmN0aW9uIHdhZmZsZUNlbnRyb2lkKGkxLCBpMiwgY29sdW1ucykge1xuICBjb25zdCByID0gTWF0aC5mbG9vcihpMiAvIGNvbHVtbnMpIC0gTWF0aC5mbG9vcihpMSAvIGNvbHVtbnMpO1xuICByZXR1cm4gciA9PT0gMFxuICAgID8gLy8gU2luZ2xlIHJvd1xuICAgICAgd2FmZmxlUm93Q2VudHJvaWQoaTEsIGkyLCBjb2x1bW5zKVxuICAgIDogciA9PT0gMVxuICAgID8gLy8gVHdvIGluY29tcGxldGUgcm93czsgdXNlIHRoZSBtaWRwb2ludCBvZiB0aGVpciBvdmVybGFwIGlmIGFueSwgb3RoZXJ3aXNlIHRoZSBsYXJnZXIgcm93XG4gICAgICBNYXRoLmZsb29yKGkyICUgY29sdW1ucykgPiBNYXRoLmNlaWwoaTEgJSBjb2x1bW5zKVxuICAgICAgPyBbKE1hdGguZmxvb3IoaTIgJSBjb2x1bW5zKSArIE1hdGguY2VpbChpMSAlIGNvbHVtbnMpKSAvIDIsIE1hdGguZmxvb3IoaTIgLyBjb2x1bW5zKV1cbiAgICAgIDogaTIgJSBjb2x1bW5zID4gY29sdW1ucyAtIChpMSAlIGNvbHVtbnMpXG4gICAgICA/IHdhZmZsZVJvd0NlbnRyb2lkKGkyIC0gKGkyICUgY29sdW1ucyksIGkyLCBjb2x1bW5zKVxuICAgICAgOiB3YWZmbGVSb3dDZW50cm9pZChpMSwgY29sdW1ucyAqIE1hdGguY2VpbChpMSAvIGNvbHVtbnMpLCBjb2x1bW5zKVxuICAgIDogLy8gQXQgbGVhc3Qgb25lIGZ1bGwgcm93OyB0YWtlIHRoZSBtaWRwb2ludCBvZiBhbGwgdGhlIHJvd3MgdGhhdCBpbmNsdWRlIHRoZSBtaWRkbGVcbiAgICAgIFtjb2x1bW5zIC8gMiwgKE1hdGgucm91bmQoaTEgLyBjb2x1bW5zKSArIE1hdGgucm91bmQoaTIgLyBjb2x1bW5zKSkgLyAyXTtcbn1cblxuZnVuY3Rpb24gd2FmZmxlUm93Q2VudHJvaWQoaTEsIGkyLCBjb2x1bW5zKSB7XG4gIGNvbnN0IGMgPSBNYXRoLmZsb29yKGkyKSAtIE1hdGguZmxvb3IoaTEpO1xuICByZXR1cm4gYyA9PT0gMFxuICAgID8gLy8gU2luZ2xlIGNlbGxcbiAgICAgIFtNYXRoLmZsb29yKGkxICUgY29sdW1ucykgKyAwLjUsIE1hdGguZmxvb3IoaTEgLyBjb2x1bW5zKSArICgoKGkxICsgaTIpIC8gMikgJSAxKV1cbiAgICA6IGMgPT09IDFcbiAgICA/IC8vIFR3byBpbmNvbXBsZXRlIGNlbGxzOyB1c2UgdGhlIG92ZXJsYXAgaWYgbGFyZ2UgZW5vdWdoLCBvdGhlcndpc2UgdXNlIHRoZSBsYXJnZXN0XG4gICAgICAoaTIgJSAxKSAtIChpMSAlIDEpID4gMC41XG4gICAgICA/IFtNYXRoLmNlaWwoaTEgJSBjb2x1bW5zKSwgTWF0aC5mbG9vcihpMiAvIGNvbHVtbnMpICsgKChpMSAlIDEpICsgKGkyICUgMSkpIC8gMl1cbiAgICAgIDogaTIgJSAxID4gMSAtIChpMSAlIDEpXG4gICAgICA/IFtNYXRoLmZsb29yKGkyICUgY29sdW1ucykgKyAwLjUsIE1hdGguZmxvb3IoaTIgLyBjb2x1bW5zKSArIChpMiAlIDEpIC8gMl1cbiAgICAgIDogW01hdGguZmxvb3IoaTEgJSBjb2x1bW5zKSArIDAuNSwgTWF0aC5mbG9vcihpMSAvIGNvbHVtbnMpICsgKDEgKyAoaTEgJSAxKSkgLyAyXVxuICAgIDogLy8gQXQgbGVhc3Qgb25lIGZ1bGwgY2VsbDsgdGFrZSB0aGUgbWlkcG9pbnRcbiAgICAgIFtcbiAgICAgICAgTWF0aC5jZWlsKGkxICUgY29sdW1ucykgKyBNYXRoLmNlaWwoTWF0aC5mbG9vcihpMikgLSBNYXRoLmNlaWwoaTEpKSAvIDIsXG4gICAgICAgIE1hdGguZmxvb3IoaTEgLyBjb2x1bW5zKSArIChpMiA+PSAxICsgaTEgPyAwLjUgOiAoKGkxICsgaTIpIC8gMikgJSAxKVxuICAgICAgXTtcbn1cblxuZnVuY3Rpb24gbWF5YmVSb3VuZChyb3VuZCkge1xuICBpZiAocm91bmQgPT09IHVuZGVmaW5lZCB8fCByb3VuZCA9PT0gZmFsc2UpIHJldHVybiBOdW1iZXI7XG4gIGlmIChyb3VuZCA9PT0gdHJ1ZSkgcmV0dXJuIE1hdGgucm91bmQ7XG4gIGlmICh0eXBlb2Ygcm91bmQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHJvdW5kOiAke3JvdW5kfWApO1xuICByZXR1cm4gcm91bmQ7XG59XG5cbmZ1bmN0aW9uIG1heWJlTXVsdGlwbGUobXVsdGlwbGUpIHtcbiAgcmV0dXJuIG11bHRpcGxlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKG11bHRpcGxlKSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlb2Yoe2RvbWFpbiwgcmFuZ2V9KSB7XG4gIHJldHVybiBzcHJlYWQocmFuZ2UpIC8gc3ByZWFkKGRvbWFpbik7XG59XG5cbmZ1bmN0aW9uIHNwcmVhZChkb21haW4pIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGV4dGVudChkb21haW4pO1xuICByZXR1cm4gbWF4IC0gbWluO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FmZmxlWChkYXRhLCB7dGlwLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIGlmICghaGFzWFkob3B0aW9ucykpIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgeTogaW5kZXhPZiwgeDI6IGlkZW50aXR5fTtcbiAgcmV0dXJuIG5ldyBXYWZmbGVYKGRhdGEsIHt0aXA6IHdhZmZsZVRpcCh0aXApLCAuLi5tYXliZVN0YWNrWChtYXliZUludGVydmFsWChtYXliZUlkZW50aXR5WChvcHRpb25zKSkpfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWZmbGVZKGRhdGEsIHt0aXAsIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgaWYgKCFoYXNYWShvcHRpb25zKSkgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCB4OiBpbmRleE9mLCB5MjogaWRlbnRpdHl9O1xuICByZXR1cm4gbmV3IFdhZmZsZVkoZGF0YSwge3RpcDogd2FmZmxlVGlwKHRpcCksIC4uLm1heWJlU3RhY2tZKG1heWJlSW50ZXJ2YWxZKG1heWJlSWRlbnRpdHlZKG9wdGlvbnMpKSl9KTtcbn1cblxuLyoqXG4gKiBXYWZmbGUgdGlwcyBiZWhhdmUgYSBiaXQgdW5wcmVkaWN0YWJseSBiZWNhdXNlIHdlIHRoZXkgYXJlIGRyaXZlbiBieSB0aGVcbiAqIHdhZmZsZSBjZW50cm9pZDsgeW91IGNvdWxkIGJlIGhvdmVyaW5nIG92ZXIgYSB3YWZmbGUgc2VnbWVudCwgYnV0IG1vcmUgdGhhblxuICogNDBweCBhd2F5IGZyb20gaXRzIGNlbnRyb2lkLCBvciBjbG9zZXIgdG8gdGhlIGNlbnRyb2lkIG9mIGFub3RoZXIgc2VnbWVudC5cbiAqIFdl4oCZZCByYXRoZXIgc2hvdyBhIHRpcCwgZXZlbiBpZiBpdOKAmXMgdGhlIOKAnHdyb25n4oCdIG9uZSwgc28gd2UgaW5jcmVhc2UgdGhlXG4gKiBkZWZhdWx0IG1heFJhZGl1cyB0byBJbmZpbml0eS4gVGhlIOKAnHJpZ2h04oCdIHdheSB0byBmaXggdGhpcyB3b3VsZCBiZSB0byB1c2VcbiAqIHNpZ25lZCBkaXN0YW5jZSB0byB0aGUgd2FmZmxlIGdlb21ldHJ5IHJhdGhlciB0aGFuIHRoZSBjZW50cm9pZC5cbiAqL1xuZnVuY3Rpb24gd2FmZmxlVGlwKHRpcCkge1xuICByZXR1cm4gdGlwID09PSB0cnVlXG4gICAgPyB7bWF4UmFkaXVzOiBJbmZpbml0eX1cbiAgICA6IGlzT2JqZWN0KHRpcCkgJiYgdGlwLm1heFJhZGl1cyA9PT0gdW5kZWZpbmVkXG4gICAgPyB7Li4udGlwLCBtYXhSYWRpdXM6IEluZmluaXR5fVxuICAgIDogdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/marks/waffle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/math.js":
/*!*****************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/math.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   radians: () => (/* binding */ radians)\n/* harmony export */ });\nconst radians = Math.PI / 180;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvbWF0aC5qcz9mNGI1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/memoize.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/memoize.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoize1: () => (/* binding */ memoize1),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\nconst unset = Symbol(\"unset\");\n\nfunction memoize1(compute) {\n  return (compute.length === 1 ? memoize1Arg : memoize1Args)(compute);\n}\n\nfunction memoize1Arg(compute) {\n  let cacheValue;\n  let cacheKey = unset;\n  return (key) => {\n    if (!Object.is(cacheKey, key)) {\n      cacheKey = key;\n      cacheValue = compute(key);\n    }\n    return cacheValue;\n  };\n}\n\nfunction memoize1Args(compute) {\n  let cacheValue, cacheKeys;\n  return (...keys) => {\n    if (cacheKeys?.length !== keys.length || cacheKeys.some((k, i) => !Object.is(k, keys[i]))) {\n      cacheKeys = keys;\n      cacheValue = compute(...keys);\n    }\n    return cacheValue;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9tZW1vaXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87O0FBRUE7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL21lbW9pemUuanM/N2YzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemUxKGNvbXB1dGUpIHtcbiAgcmV0dXJuIChjb21wdXRlLmxlbmd0aCA9PT0gMSA/IG1lbW9pemUxQXJnIDogbWVtb2l6ZTFBcmdzKShjb21wdXRlKTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZTFBcmcoY29tcHV0ZSkge1xuICBsZXQgY2FjaGVWYWx1ZTtcbiAgbGV0IGNhY2hlS2V5ID0gdW5zZXQ7XG4gIHJldHVybiAoa2V5KSA9PiB7XG4gICAgaWYgKCFPYmplY3QuaXMoY2FjaGVLZXksIGtleSkpIHtcbiAgICAgIGNhY2hlS2V5ID0ga2V5O1xuICAgICAgY2FjaGVWYWx1ZSA9IGNvbXB1dGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlVmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUxQXJncyhjb21wdXRlKSB7XG4gIGxldCBjYWNoZVZhbHVlLCBjYWNoZUtleXM7XG4gIHJldHVybiAoLi4ua2V5cykgPT4ge1xuICAgIGlmIChjYWNoZUtleXM/Lmxlbmd0aCAhPT0ga2V5cy5sZW5ndGggfHwgY2FjaGVLZXlzLnNvbWUoKGssIGkpID0+ICFPYmplY3QuaXMoaywga2V5c1tpXSkpKSB7XG4gICAgICBjYWNoZUtleXMgPSBrZXlzO1xuICAgICAgY2FjaGVWYWx1ZSA9IGNvbXB1dGUoLi4ua2V5cyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVZhbHVlO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/memoize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/options.js":
/*!********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/options.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedArray: () => (/* binding */ TypedArray),\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerceDate: () => (/* binding */ coerceDate),\n/* harmony export */   coerceDates: () => (/* binding */ coerceDates),\n/* harmony export */   coerceNumbers: () => (/* binding */ coerceNumbers),\n/* harmony export */   column: () => (/* binding */ column),\n/* harmony export */   constant: () => (/* binding */ constant),\n/* harmony export */   dataify: () => (/* binding */ dataify),\n/* harmony export */   field: () => (/* binding */ field),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   hasX: () => (/* binding */ hasX),\n/* harmony export */   hasXY: () => (/* binding */ hasXY),\n/* harmony export */   hasY: () => (/* binding */ hasY),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   indexOf: () => (/* binding */ indexOf),\n/* harmony export */   inherit: () => (/* binding */ inherit),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isColor: () => (/* binding */ isColor),\n/* harmony export */   isDomainSort: () => (/* binding */ isDomainSort),\n/* harmony export */   isEvery: () => (/* binding */ isEvery),\n/* harmony export */   isInterval: () => (/* binding */ isInterval),\n/* harmony export */   isIterable: () => (/* binding */ isIterable),\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isNoneish: () => (/* binding */ isNoneish),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isNumericString: () => (/* binding */ isNumericString),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isOpacity: () => (/* binding */ isOpacity),\n/* harmony export */   isOptions: () => (/* binding */ isOptions),\n/* harmony export */   isOrdinal: () => (/* binding */ isOrdinal),\n/* harmony export */   isRound: () => (/* binding */ isRound),\n/* harmony export */   isScaleOptions: () => (/* binding */ isScaleOptions),\n/* harmony export */   isTemporal: () => (/* binding */ isTemporal),\n/* harmony export */   isTemporalString: () => (/* binding */ isTemporalString),\n/* harmony export */   isTextual: () => (/* binding */ isTextual),\n/* harmony export */   isTimeInterval: () => (/* binding */ isTimeInterval),\n/* harmony export */   isTuples: () => (/* binding */ isTuples),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   keyword: () => (/* binding */ keyword),\n/* harmony export */   labelof: () => (/* binding */ labelof),\n/* harmony export */   lengthof: () => (/* binding */ lengthof),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   maybeAnchor: () => (/* binding */ maybeAnchor),\n/* harmony export */   maybeApplyInterval: () => (/* binding */ maybeApplyInterval),\n/* harmony export */   maybeClip: () => (/* binding */ maybeClip),\n/* harmony export */   maybeColorChannel: () => (/* binding */ maybeColorChannel),\n/* harmony export */   maybeColumn: () => (/* binding */ maybeColumn),\n/* harmony export */   maybeFrameAnchor: () => (/* binding */ maybeFrameAnchor),\n/* harmony export */   maybeInput: () => (/* binding */ maybeInput),\n/* harmony export */   maybeInterval: () => (/* binding */ maybeInterval),\n/* harmony export */   maybeIntervalTransform: () => (/* binding */ maybeIntervalTransform),\n/* harmony export */   maybeKeyword: () => (/* binding */ maybeKeyword),\n/* harmony export */   maybeNamed: () => (/* binding */ maybeNamed),\n/* harmony export */   maybeNiceInterval: () => (/* binding */ maybeNiceInterval),\n/* harmony export */   maybeNumberChannel: () => (/* binding */ maybeNumberChannel),\n/* harmony export */   maybeRangeInterval: () => (/* binding */ maybeRangeInterval),\n/* harmony export */   maybeTuple: () => (/* binding */ maybeTuple),\n/* harmony export */   maybeValue: () => (/* binding */ maybeValue),\n/* harmony export */   maybeZ: () => (/* binding */ maybeZ),\n/* harmony export */   maybeZero: () => (/* binding */ maybeZero),\n/* harmony export */   mid: () => (/* binding */ mid),\n/* harmony export */   named: () => (/* binding */ named),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   numberChannel: () => (/* binding */ numberChannel),\n/* harmony export */   numberInterval: () => (/* binding */ numberInterval),\n/* harmony export */   one: () => (/* binding */ one),\n/* harmony export */   percentile: () => (/* binding */ percentile),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   reindex: () => (/* binding */ reindex),\n/* harmony export */   second: () => (/* binding */ second),\n/* harmony export */   singleton: () => (/* binding */ singleton),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   subarray: () => (/* binding */ subarray),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   taker: () => (/* binding */ taker),\n/* harmony export */   third: () => (/* binding */ third),\n/* harmony export */   valueof: () => (/* binding */ valueof),\n/* harmony export */   yes: () => (/* binding */ yes),\n/* harmony export */   zero: () => (/* binding */ zero)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var isoformat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! isoformat */ \"(ssr)/./node_modules/isoformat/src/parse.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./time.js */ \"(ssr)/./node_modules/@observablehq/plot/src/time.js\");\n\n\n\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\nconst TypedArray = Object.getPrototypeOf(Uint8Array);\nconst objectToString = Object.prototype.toString;\n\nfunction isArray(value) {\n  return value instanceof Array || value instanceof TypedArray;\n}\n\nfunction isNumberArray(value) {\n  return value instanceof TypedArray && !isBigIntArray(value);\n}\n\nfunction isNumberType(type) {\n  return type?.prototype instanceof TypedArray && !isBigIntType(type);\n}\n\nfunction isBigIntArray(value) {\n  return value instanceof BigInt64Array || value instanceof BigUint64Array;\n}\n\nfunction isBigIntType(type) {\n  return type === BigInt64Array || type === BigUint64Array;\n}\n\n// If a reindex is attached to the data, channel values expressed as arrays will\n// be reindexed when the channels are instantiated. See exclusiveFacets.\nconst reindex = Symbol(\"reindex\");\n\nfunction valueof(data, value, type) {\n  const valueType = typeof value;\n  return valueType === \"string\"\n    ? isArrowTable(data)\n      ? maybeTypedArrowify(data.getChild(value), type)\n      : maybeTypedMap(data, field(value), type)\n    : valueType === \"function\"\n    ? maybeTypedMap(data, value, type)\n    : valueType === \"number\" || value instanceof Date || valueType === \"boolean\"\n    ? map(data, constant(value), type)\n    : typeof value?.transform === \"function\"\n    ? maybeTypedArrayify(value.transform(data), type)\n    : maybeTake(maybeTypedArrayify(value, type), data?.[reindex]);\n}\n\nfunction maybeTake(values, index) {\n  return values != null && index ? take(values, index) : values;\n}\n\nfunction maybeTypedMap(data, f, type) {\n  return map(data, isNumberType(type) ? (d, i) => coerceNumber(f(d, i)) : f, type); // allow conversion from BigInt\n}\n\nfunction maybeTypedArrayify(data, type) {\n  return type === undefined\n    ? arrayify(data) // preserve undefined type\n    : isArrowVector(data)\n    ? maybeTypedArrowify(data, type)\n    : data instanceof type\n    ? data\n    : type.from(data, isNumberType(type) && !isNumberArray(data) ? coerceNumber : undefined);\n}\n\nfunction maybeTypedArrowify(vector, type) {\n  return vector == null\n    ? vector\n    : (type === undefined || type === Array) && isArrowDateType(vector.type)\n    ? coerceDates(vectorToArray(vector))\n    : maybeTypedArrayify(vectorToArray(vector), type);\n}\n\nfunction vectorToArray(vector) {\n  return vector.nullCount ? vector.toJSON() : vector.toArray();\n}\n\nconst singleton = [null]; // for data-less decoration marks, e.g. frame\nconst field = (name) => (d) => { const v = d[name]; return v === undefined && d.type === \"Feature\" ? d.properties?.[name] : v; }; // prettier-ignore\nconst indexOf = {transform: range};\nconst identity = {transform: (d) => d};\nconst zero = () => 0;\nconst one = () => 1;\nconst yes = () => true;\nconst string = (x) => (x == null ? x : `${x}`);\nconst number = (x) => (x == null ? x : +x);\nconst boolean = (x) => (x == null ? x : !!x);\nconst first = (x) => (x ? x[0] : undefined);\nconst second = (x) => (x ? x[1] : undefined);\nconst third = (x) => (x ? x[2] : undefined);\nconst constant = (x) => () => x;\n\n// Converts a string like “p25” into a function that takes an index I and an\n// accessor function f, returning the corresponding percentile value.\nfunction percentile(reduce) {\n  const p = +`${reduce}`.slice(1) / 100;\n  return (I, f) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantile)(I, p, f);\n}\n\n// If the values are specified as a typed array, no coercion is required.\nfunction coerceNumbers(values) {\n  return isNumberArray(values) ? values : map(values, coerceNumber, Float64Array);\n}\n\n// Unlike Mark’s number, here we want to convert null and undefined to NaN since\n// the result will be stored in a Float64Array and we don’t want null to be\n// coerced to zero. We use Number instead of unary + to allow BigInt coercion.\nfunction coerceNumber(x) {\n  return x == null ? NaN : Number(x);\n}\n\nfunction coerceDates(values) {\n  return map(values, coerceDate);\n}\n\n// When coercing strings to dates, we only want to allow the ISO 8601 format\n// since the built-in string parsing of the Date constructor varies across\n// browsers. (In the future, this could be made more liberal if desired, though\n// it is still generally preferable to do date parsing yourself explicitly,\n// rather than rely on Plot.) Any non-string values are coerced to number first\n// and treated as milliseconds since UNIX epoch.\nfunction coerceDate(x) {\n  return x instanceof Date && !isNaN(x)\n    ? x\n    : typeof x === \"string\"\n    ? (0,isoformat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(x)\n    : x == null || isNaN((x = Number(x))) // allow conversion from BigInt\n    ? undefined\n    : new Date(x);\n}\n\n// Some channels may allow a string constant to be specified; to differentiate\n// string constants (e.g., \"red\") from named fields (e.g., \"date\"), this\n// function tests whether the given value is a CSS color string and returns a\n// tuple [channel, constant] where one of the two is undefined, and the other is\n// the given value. If you wish to reference a named field that is also a valid\n// CSS color, use an accessor (d => d.red) instead.\nfunction maybeColorChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null ? [undefined, \"none\"] : isColor(value) ? [undefined, value] : [value, undefined];\n}\n\n// Similar to maybeColorChannel, this tests whether the given value is a number\n// indicating a constant, and otherwise assumes that it’s a channel value.\nfunction maybeNumberChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null || typeof value === \"number\" ? [undefined, value] : [value, undefined];\n}\n\n// Validates the specified optional string against the allowed list of keywords.\nfunction maybeKeyword(input, name, allowed) {\n  if (input != null) return keyword(input, name, allowed);\n}\n\n// Validates the specified required string against the allowed list of keywords.\nfunction keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i)) throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\n\n// Like arrayify, but also allows data to be an Apache Arrow Table.\nfunction dataify(data) {\n  return isArrowTable(data) ? data : arrayify(data);\n}\n\n// Promotes the specified data to an array as needed.\nfunction arrayify(values) {\n  if (values == null || isArray(values)) return values;\n  if (isArrowVector(values)) return maybeTypedArrowify(values);\n  if (isGeoJSON(values)) {\n    switch (values.type) {\n      case \"FeatureCollection\":\n        return values.features;\n      case \"GeometryCollection\":\n        return values.geometries;\n      default:\n        return [values];\n    }\n  }\n  return Array.from(values);\n}\n\n// Duck typing test for GeoJSON\nfunction isGeoJSON(x) {\n  switch (x?.type) {\n    case \"FeatureCollection\":\n    case \"GeometryCollection\":\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// An optimization of type.from(values, f): if the given values are already an\n// instanceof the desired array type, the faster values.map method is used.\nfunction map(values, f, type = Array) {\n  return values == null ? values : values instanceof type ? values.map(f) : type.from(values, f);\n}\n\n// An optimization of type.from(values): if the given values are already an\n// instanceof the desired array type, the faster values.slice method is used.\nfunction slice(values, type = Array) {\n  return values instanceof type ? values.slice() : type.from(values);\n}\n\n// Returns true if any of x, x1, or x2 is not (strictly) undefined.\nfunction hasX({x, x1, x2}) {\n  return x !== undefined || x1 !== undefined || x2 !== undefined;\n}\n\n// Returns true if any of y, y1, or y2 is not (strictly) undefined.\nfunction hasY({y, y1, y2}) {\n  return y !== undefined || y1 !== undefined || y2 !== undefined;\n}\n\n// Returns true if has x or y, or if interval is not (strictly) undefined.\nfunction hasXY(options) {\n  return hasX(options) || hasY(options) || options.interval !== undefined;\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a primitive value.\nfunction isObject(option) {\n  return option?.toString === objectToString;\n}\n\n// Disambiguates a scale options object (e.g., {color: {type: \"linear\"}}) from\n// some other option (e.g., {color: \"red\"}). When creating standalone legends,\n// this is used to test whether a scale is defined; this should be consistent\n// with inferScaleType when there are no channels associated with the scale, and\n// if this returns true, then normalizeScale must return non-null.\nfunction isScaleOptions(option) {\n  return isObject(option) && (option.type !== undefined || option.domain !== undefined);\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a channel value\n// definition expressed as a channel transform (e.g., {transform: …}).\n// TODO Check typeof option[Symbol.iterator] !== \"function\"?\nfunction isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\n\n// Disambiguates a sort transform (e.g., {sort: \"date\"}) from a channel domain\n// sort definition (e.g., {sort: {y: \"x\"}}).\nfunction isDomainSort(sort) {\n  return isOptions(sort) && sort.value === undefined && sort.channel === undefined;\n}\n\n// For marks specified either as [0, x] or [x1, x2], such as areas and bars.\nfunction maybeZero(x, x1, x2, x3 = identity) {\n  if (x1 === undefined && x2 === undefined) {\n    // {x} or {}\n    (x1 = 0), (x2 = x === undefined ? x3 : x);\n  } else if (x1 === undefined) {\n    // {x, x2} or {x2}\n    x1 = x === undefined ? 0 : x;\n  } else if (x2 === undefined) {\n    // {x, x1} or {x1}\n    x2 = x === undefined ? 0 : x;\n  }\n  return [x1, x2];\n}\n\n// For marks that have x and y channels (e.g., cell, dot, line, text).\nfunction maybeTuple(x, y) {\n  return x === undefined && y === undefined ? [first, second] : [x, y];\n}\n\n// A helper for extracting the z channel, if it is variable. Used by transforms\n// that require series, such as moving average and normalize.\nfunction maybeZ({z, fill, stroke} = {}) {\n  if (z === undefined) [z] = maybeColorChannel(fill);\n  if (z === undefined) [z] = maybeColorChannel(stroke);\n  return z;\n}\n\nfunction lengthof(data) {\n  return isArray(data) ? data.length : data?.numRows;\n}\n\n// Returns a Uint32Array with elements [0, 1, 2, … data.length - 1].\nfunction range(data) {\n  const n = lengthof(data);\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) r[i] = i;\n  return r;\n}\n\n// Returns an array [values[index[0]], values[index[1]], …].\nfunction take(values, index) {\n  return isArray(values) ? map(index, (i) => values[i], values.constructor) : map(index, (i) => values.at(i));\n}\n\n// If f does not take exactly one argument, wraps it in a function that uses take.\nfunction taker(f) {\n  return f.length === 1 ? (index, values) => f(take(values, index)) : f;\n}\n\n// Uses subarray if available, and otherwise slice.\nfunction subarray(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\n\n// Based on InternMap (d3.group).\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\nfunction maybeInput(key, options) {\n  if (options[key] !== undefined) return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\n\nfunction column(source) {\n  // Defines a column whose values are lazily populated by calling the returned\n  // setter. If the given source is labeled, the label is propagated to the\n  // returned column definition.\n  let value;\n  return [\n    {\n      transform: () => value,\n      label: labelof(source)\n    },\n    (v) => (value = v)\n  ];\n}\n\n// Like column, but allows the source to be null.\nfunction maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\n\nfunction labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== undefined ? value.label : defaultValue;\n}\n\n// Assuming that both x1 and x2 and lazy columns (per above), this derives a new\n// a column that’s the average of the two, and which inherits the column label\n// (if any). Both input columns are assumed to be quantitative. If either column\n// is temporal, the returned column is also temporal.\nfunction mid(x1, x2) {\n  return {\n    transform(data) {\n      const X1 = x1.transform(data);\n      const X2 = x2.transform(data);\n      return isTemporal(X1) || isTemporal(X2)\n        ? map(X1, (_, i) => new Date((+X1[i] + +X2[i]) / 2))\n        : map(X1, (_, i) => (+X1[i] + +X2[i]) / 2, Float64Array);\n    },\n    label: x1.label\n  };\n}\n\n// If the scale options declare an interval, applies it to the values V.\nfunction maybeApplyInterval(V, scale) {\n  const t = maybeIntervalTransform(scale?.interval, scale?.type);\n  return t ? map(V, t) : V;\n}\n\n// Returns the equivalent scale transform for the specified interval option.\nfunction maybeIntervalTransform(interval, type) {\n  const i = maybeInterval(interval, type);\n  return i && ((v) => ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__.defined)(v) ? i.floor(v) : v));\n}\n\n// If interval is not nullish, converts interval shorthand such as a number (for\n// multiples) or a time interval name (such as “day”) to a {floor, offset,\n// range} object similar to a D3 time interval.\nfunction maybeInterval(interval, type) {\n  if (interval == null) return;\n  if (typeof interval === \"number\") return numberInterval(interval);\n  if (typeof interval === \"string\") return (type === \"time\" ? _time_js__WEBPACK_IMPORTED_MODULE_3__.timeInterval : _time_js__WEBPACK_IMPORTED_MODULE_3__.utcInterval)(interval);\n  if (typeof interval.floor !== \"function\") throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval.offset !== \"function\") throw new Error(\"invalid interval; missing offset method\");\n  return interval;\n}\n\nfunction numberInterval(interval) {\n  interval = +interval;\n  if (0 < interval && interval < 1 && Number.isInteger(1 / interval)) interval = -1 / interval;\n  const n = Math.abs(interval);\n  return interval < 0\n    ? {\n        floor: (d) => Math.floor(d * n) / n,\n        offset: (d, s = 1) => (d * n + Math.floor(s)) / n,\n        range: (lo, hi) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.range)(Math.ceil(lo * n), hi * n).map((x) => x / n)\n      }\n    : {\n        floor: (d) => Math.floor(d / n) * n,\n        offset: (d, s = 1) => d + n * Math.floor(s),\n        range: (lo, hi) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.range)(Math.ceil(lo / n), hi / n).map((x) => x * n)\n      };\n}\n\n// Like maybeInterval, but requires a range method too.\nfunction maybeRangeInterval(interval, type) {\n  interval = maybeInterval(interval, type);\n  if (interval && typeof interval.range !== \"function\") throw new Error(\"invalid interval: missing range method\");\n  return interval;\n}\n\n// Like maybeRangeInterval, but requires a ceil method too.\nfunction maybeNiceInterval(interval, type) {\n  interval = maybeRangeInterval(interval, type);\n  if (interval && typeof interval.ceil !== \"function\") throw new Error(\"invalid interval: missing ceil method\");\n  return interval;\n}\n\nfunction isTimeInterval(t) {\n  return isInterval(t) && typeof t?.floor === \"function\" && t.floor() instanceof Date;\n}\n\nfunction isInterval(t) {\n  return typeof t?.range === \"function\";\n}\n\n// This distinguishes between per-dimension options and a standalone value.\nfunction maybeValue(value) {\n  return value === undefined || isOptions(value) ? value : {value};\n}\n\n// Coerces the given channel values (if any) to numbers. This is useful when\n// values will be interpolated into other code, such as an SVG transform, and\n// where we don’t wish to allow unexpected behavior for weird input.\nfunction numberChannel(source) {\n  return source == null\n    ? null\n    : {\n        transform: (data) => valueof(data, source, Float64Array),\n        label: labelof(source)\n      };\n}\n\nfunction isTuples(data) {\n  if (!isIterable(data)) return false;\n  for (const d of data) {\n    if (d == null) continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\n\nfunction isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\n\nfunction isTextual(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\n\nfunction isOrdinal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    const type = typeof value;\n    return type === \"string\" || type === \"boolean\";\n  }\n}\n\nfunction isTemporal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return value instanceof Date;\n  }\n}\n\n// Are these strings that might represent dates? This is stricter than ISO 8601\n// because we want to ignore false positives on numbers; for example, the string\n// \"1192\" is more likely to represent a number than a date even though it is\n// valid ISO 8601 representing 1192-01-01.\nfunction isTemporalString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"string\" && isNaN(value) && (0,isoformat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(value);\n  }\n}\n\n// Are these strings that might represent numbers? This is stricter than\n// coercion because we want to ignore false positives on e.g. empty strings.\nfunction isNumericString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    if (typeof value !== \"string\") return false;\n    if (!value.trim()) continue;\n    return !isNaN(value);\n  }\n}\n\nfunction isNumeric(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"number\";\n  }\n}\n\n// Returns true if every non-null value in the specified iterable of values\n// passes the specified predicate, and there is at least one non-null value;\n// returns false if at least one non-null value does not pass the specified\n// predicate; otherwise returns undefined (as if all values are null).\nfunction isEvery(values, is) {\n  let every;\n  for (const value of values) {\n    if (value == null) continue;\n    if (!is(value)) return false;\n    every = true;\n  }\n  return every;\n}\n\nconst namedColors = new Set(\"none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow\".split(\",\")); // prettier-ignore\n\n// Returns true if value is a valid CSS color string. This is intentionally lax\n// because the CSS color spec keeps growing, and we don’t need to parse these\n// colors—we just need to disambiguate them from column names.\n// https://www.w3.org/TR/SVG11/painting.html#SpecifyingPaint\n// https://www.w3.org/TR/css-color-5/\nfunction isColor(value) {\n  if (typeof value !== \"string\") return false;\n  value = value.toLowerCase().trim();\n  return (\n    /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa\n    /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\\(.*\\)$/.test(value) || // <funciri>, CSS variable, color, etc.\n    namedColors.has(value) // currentColor, red, etc.\n  );\n}\n\nfunction isOpacity(value) {\n  return typeof value === \"number\" && ((0 <= value && value <= 1) || isNaN(value));\n}\n\nfunction isNoneish(value) {\n  return value == null || isNone(value);\n}\n\nfunction isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\n\nfunction isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\n\nfunction maybeAnchor(value, name) {\n  return maybeKeyword(value, name, [\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\"\n  ]);\n}\n\nfunction maybeFrameAnchor(value = \"middle\") {\n  return maybeAnchor(value, \"frameAnchor\");\n}\n\n// Unlike {...defaults, ...options}, this ensures that any undefined (but\n// present) properties in options inherit the given default value.\nfunction inherit(options = {}, ...rest) {\n  let o = options;\n  for (const defaults of rest) {\n    for (const key in defaults) {\n      if (o[key] === undefined) {\n        const value = defaults[key];\n        if (o === options) o = {...o, [key]: value};\n        else o[key] = value;\n      }\n    }\n  }\n  return o;\n}\n\n// Given an iterable of named things (objects with a name property), returns a\n// corresponding object with properties associated with the given name.\nfunction named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = new Set();\n  return Object.fromEntries(\n    Array.from(things, (thing) => {\n      const {name} = thing;\n      if (name == null) throw new Error(\"missing name\");\n      const key = `${name}`;\n      if (key === \"__proto__\") throw new Error(`illegal name: ${key}`);\n      if (names.has(key)) throw new Error(`duplicate name: ${key}`);\n      names.add(key);\n      return [name, thing];\n    })\n  );\n}\n\nfunction maybeNamed(things) {\n  return isIterable(things) ? named(things) : things;\n}\n\nfunction maybeClip(clip) {\n  if (clip === true) clip = \"frame\";\n  else if (clip === false) clip = null;\n  else if (!isGeoJSON(clip) && clip != null) {\n    clip = keyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n    if (clip === \"sphere\") clip = {type: \"Sphere\"};\n  }\n  return clip;\n}\n\n// https://github.com/observablehq/stdlib/blob/746ca2e69135df6178e4f3a17244def35d8d6b20/src/arrow.js#L4C1-L17C1\nfunction isArrowTable(value) {\n  return (\n    value &&\n    typeof value.getChild === \"function\" &&\n    typeof value.toArray === \"function\" &&\n    value.schema &&\n    Array.isArray(value.schema.fields)\n  );\n}\n\nfunction isArrowVector(value) {\n  return value && typeof value.toArray === \"function\" && value.type;\n}\n\n// Apache Arrow now represents dates as numbers. We currently only support\n// implicit coercion to JavaScript Date objects when the numbers represent\n// milliseconds since Unix epoch.\nfunction isArrowDateType(type) {\n  return (\n    type &&\n    (type.typeId === 8 || // date\n      type.typeId === 10) && // timestamp\n    type.unit === 1 // millisecond\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDRDtBQUNQO0FBQ2U7O0FBRXBEO0FBQ087QUFDUDs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPLDBCQUEwQjtBQUMxQixpQ0FBaUMsbUJBQW1CLDhFQUE4RTtBQUNsSSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUDtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsT0FBTztBQUN2QixtQkFBbUIsNENBQVE7QUFDM0I7O0FBRUE7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsZUFBZSxNQUFNO0FBQ3JCLHVEQUF1RCxLQUFLLElBQUksTUFBTTtBQUN0RTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDTyxlQUFlLFVBQVU7QUFDaEM7QUFDQTs7QUFFQTtBQUNPLGVBQWUsVUFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQzVDO0FBQ1A7QUFDQTs7QUFFQSxnREFBZ0QsUUFBUSxnQkFBZ0I7QUFDeEUsNkJBQTZCLGFBQWE7QUFDMUMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQsdURBQXVELGFBQWE7QUFDcEU7QUFDTztBQUNQO0FBQ0E7O0FBRUEsMENBQTBDLGFBQWE7QUFDdkQsMkJBQTJCLE9BQU8sUUFBUTtBQUNuQztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0EsUUFBUSxHQUFHO0FBQ1g7QUFDQSxJQUFJO0FBQ0osUUFBUSxPQUFPLElBQUk7QUFDbkI7QUFDQSxJQUFJO0FBQ0osUUFBUSxPQUFPLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLGlCQUFpQixpQkFBaUIsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixvREFBTztBQUM5Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxVQUFVO0FBQ0g7QUFDUDtBQUNBO0FBQ0EsOERBQThELGtEQUFZLEdBQUcsaURBQVc7QUFDeEYsK0VBQStFO0FBQy9FLGdGQUFnRjtBQUNoRjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU07QUFDakM7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3REFBd0QscURBQVE7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNQO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyL0NBQTIvQzs7QUFFMy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUEsV0FBVyx3QkFBd0I7QUFDbkM7QUFDTyw2QkFBNkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1AsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLGdFQUFnRSxJQUFJO0FBQ3BFLDZEQUE2RCxJQUFJO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL29wdGlvbnMuanM/MWQxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3F1YW50aWxlLCByYW5nZSBhcyByYW5nZWl9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtwYXJzZSBhcyBpc29QYXJzZX0gZnJvbSBcImlzb2Zvcm1hdFwiO1xuaW1wb3J0IHtkZWZpbmVkfSBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge3RpbWVJbnRlcnZhbCwgdXRjSW50ZXJ2YWx9IGZyb20gXCIuL3RpbWUuanNcIjtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZWRBcnJheVxuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUeXBlZEFycmF5ICYmICFpc0JpZ0ludEFycmF5KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGU/LnByb3RvdHlwZSBpbnN0YW5jZW9mIFR5cGVkQXJyYXkgJiYgIWlzQmlnSW50VHlwZSh0eXBlKTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSBCaWdJbnQ2NEFycmF5IHx8IHR5cGUgPT09IEJpZ1VpbnQ2NEFycmF5O1xufVxuXG4vLyBJZiBhIHJlaW5kZXggaXMgYXR0YWNoZWQgdG8gdGhlIGRhdGEsIGNoYW5uZWwgdmFsdWVzIGV4cHJlc3NlZCBhcyBhcnJheXMgd2lsbFxuLy8gYmUgcmVpbmRleGVkIHdoZW4gdGhlIGNoYW5uZWxzIGFyZSBpbnN0YW50aWF0ZWQuIFNlZSBleGNsdXNpdmVGYWNldHMuXG5leHBvcnQgY29uc3QgcmVpbmRleCA9IFN5bWJvbChcInJlaW5kZXhcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZW9mKGRhdGEsIHZhbHVlLCB0eXBlKSB7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlVHlwZSA9PT0gXCJzdHJpbmdcIlxuICAgID8gaXNBcnJvd1RhYmxlKGRhdGEpXG4gICAgICA/IG1heWJlVHlwZWRBcnJvd2lmeShkYXRhLmdldENoaWxkKHZhbHVlKSwgdHlwZSlcbiAgICAgIDogbWF5YmVUeXBlZE1hcChkYXRhLCBmaWVsZCh2YWx1ZSksIHR5cGUpXG4gICAgOiB2YWx1ZVR5cGUgPT09IFwiZnVuY3Rpb25cIlxuICAgID8gbWF5YmVUeXBlZE1hcChkYXRhLCB2YWx1ZSwgdHlwZSlcbiAgICA6IHZhbHVlVHlwZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWVUeXBlID09PSBcImJvb2xlYW5cIlxuICAgID8gbWFwKGRhdGEsIGNvbnN0YW50KHZhbHVlKSwgdHlwZSlcbiAgICA6IHR5cGVvZiB2YWx1ZT8udHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IG1heWJlVHlwZWRBcnJheWlmeSh2YWx1ZS50cmFuc2Zvcm0oZGF0YSksIHR5cGUpXG4gICAgOiBtYXliZVRha2UobWF5YmVUeXBlZEFycmF5aWZ5KHZhbHVlLCB0eXBlKSwgZGF0YT8uW3JlaW5kZXhdKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVUYWtlKHZhbHVlcywgaW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlcyAhPSBudWxsICYmIGluZGV4ID8gdGFrZSh2YWx1ZXMsIGluZGV4KSA6IHZhbHVlcztcbn1cblxuZnVuY3Rpb24gbWF5YmVUeXBlZE1hcChkYXRhLCBmLCB0eXBlKSB7XG4gIHJldHVybiBtYXAoZGF0YSwgaXNOdW1iZXJUeXBlKHR5cGUpID8gKGQsIGkpID0+IGNvZXJjZU51bWJlcihmKGQsIGkpKSA6IGYsIHR5cGUpOyAvLyBhbGxvdyBjb252ZXJzaW9uIGZyb20gQmlnSW50XG59XG5cbmZ1bmN0aW9uIG1heWJlVHlwZWRBcnJheWlmeShkYXRhLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSB1bmRlZmluZWRcbiAgICA/IGFycmF5aWZ5KGRhdGEpIC8vIHByZXNlcnZlIHVuZGVmaW5lZCB0eXBlXG4gICAgOiBpc0Fycm93VmVjdG9yKGRhdGEpXG4gICAgPyBtYXliZVR5cGVkQXJyb3dpZnkoZGF0YSwgdHlwZSlcbiAgICA6IGRhdGEgaW5zdGFuY2VvZiB0eXBlXG4gICAgPyBkYXRhXG4gICAgOiB0eXBlLmZyb20oZGF0YSwgaXNOdW1iZXJUeXBlKHR5cGUpICYmICFpc051bWJlckFycmF5KGRhdGEpID8gY29lcmNlTnVtYmVyIDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVUeXBlZEFycm93aWZ5KHZlY3RvciwgdHlwZSkge1xuICByZXR1cm4gdmVjdG9yID09IG51bGxcbiAgICA/IHZlY3RvclxuICAgIDogKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBBcnJheSkgJiYgaXNBcnJvd0RhdGVUeXBlKHZlY3Rvci50eXBlKVxuICAgID8gY29lcmNlRGF0ZXModmVjdG9yVG9BcnJheSh2ZWN0b3IpKVxuICAgIDogbWF5YmVUeXBlZEFycmF5aWZ5KHZlY3RvclRvQXJyYXkodmVjdG9yKSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHZlY3RvclRvQXJyYXkodmVjdG9yKSB7XG4gIHJldHVybiB2ZWN0b3IubnVsbENvdW50ID8gdmVjdG9yLnRvSlNPTigpIDogdmVjdG9yLnRvQXJyYXkoKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNpbmdsZXRvbiA9IFtudWxsXTsgLy8gZm9yIGRhdGEtbGVzcyBkZWNvcmF0aW9uIG1hcmtzLCBlLmcuIGZyYW1lXG5leHBvcnQgY29uc3QgZmllbGQgPSAobmFtZSkgPT4gKGQpID0+IHsgY29uc3QgdiA9IGRbbmFtZV07IHJldHVybiB2ID09PSB1bmRlZmluZWQgJiYgZC50eXBlID09PSBcIkZlYXR1cmVcIiA/IGQucHJvcGVydGllcz8uW25hbWVdIDogdjsgfTsgLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgaW5kZXhPZiA9IHt0cmFuc2Zvcm06IHJhbmdlfTtcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IHt0cmFuc2Zvcm06IChkKSA9PiBkfTtcbmV4cG9ydCBjb25zdCB6ZXJvID0gKCkgPT4gMDtcbmV4cG9ydCBjb25zdCBvbmUgPSAoKSA9PiAxO1xuZXhwb3J0IGNvbnN0IHllcyA9ICgpID0+IHRydWU7XG5leHBvcnQgY29uc3Qgc3RyaW5nID0gKHgpID0+ICh4ID09IG51bGwgPyB4IDogYCR7eH1gKTtcbmV4cG9ydCBjb25zdCBudW1iZXIgPSAoeCkgPT4gKHggPT0gbnVsbCA/IHggOiAreCk7XG5leHBvcnQgY29uc3QgYm9vbGVhbiA9ICh4KSA9PiAoeCA9PSBudWxsID8geCA6ICEheCk7XG5leHBvcnQgY29uc3QgZmlyc3QgPSAoeCkgPT4gKHggPyB4WzBdIDogdW5kZWZpbmVkKTtcbmV4cG9ydCBjb25zdCBzZWNvbmQgPSAoeCkgPT4gKHggPyB4WzFdIDogdW5kZWZpbmVkKTtcbmV4cG9ydCBjb25zdCB0aGlyZCA9ICh4KSA9PiAoeCA/IHhbMl0gOiB1bmRlZmluZWQpO1xuZXhwb3J0IGNvbnN0IGNvbnN0YW50ID0gKHgpID0+ICgpID0+IHg7XG5cbi8vIENvbnZlcnRzIGEgc3RyaW5nIGxpa2Ug4oCccDI14oCdIGludG8gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGluZGV4IEkgYW5kIGFuXG4vLyBhY2Nlc3NvciBmdW5jdGlvbiBmLCByZXR1cm5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgcGVyY2VudGlsZSB2YWx1ZS5cbmV4cG9ydCBmdW5jdGlvbiBwZXJjZW50aWxlKHJlZHVjZSkge1xuICBjb25zdCBwID0gK2Ake3JlZHVjZX1gLnNsaWNlKDEpIC8gMTAwO1xuICByZXR1cm4gKEksIGYpID0+IHF1YW50aWxlKEksIHAsIGYpO1xufVxuXG4vLyBJZiB0aGUgdmFsdWVzIGFyZSBzcGVjaWZpZWQgYXMgYSB0eXBlZCBhcnJheSwgbm8gY29lcmNpb24gaXMgcmVxdWlyZWQuXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlTnVtYmVycyh2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzTnVtYmVyQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IG1hcCh2YWx1ZXMsIGNvZXJjZU51bWJlciwgRmxvYXQ2NEFycmF5KTtcbn1cblxuLy8gVW5saWtlIE1hcmvigJlzIG51bWJlciwgaGVyZSB3ZSB3YW50IHRvIGNvbnZlcnQgbnVsbCBhbmQgdW5kZWZpbmVkIHRvIE5hTiBzaW5jZVxuLy8gdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCBpbiBhIEZsb2F0NjRBcnJheSBhbmQgd2UgZG9u4oCZdCB3YW50IG51bGwgdG8gYmVcbi8vIGNvZXJjZWQgdG8gemVyby4gV2UgdXNlIE51bWJlciBpbnN0ZWFkIG9mIHVuYXJ5ICsgdG8gYWxsb3cgQmlnSW50IGNvZXJjaW9uLlxuZnVuY3Rpb24gY29lcmNlTnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IE5hTiA6IE51bWJlcih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZURhdGVzKHZhbHVlcykge1xuICByZXR1cm4gbWFwKHZhbHVlcywgY29lcmNlRGF0ZSk7XG59XG5cbi8vIFdoZW4gY29lcmNpbmcgc3RyaW5ncyB0byBkYXRlcywgd2Ugb25seSB3YW50IHRvIGFsbG93IHRoZSBJU08gODYwMSBmb3JtYXRcbi8vIHNpbmNlIHRoZSBidWlsdC1pbiBzdHJpbmcgcGFyc2luZyBvZiB0aGUgRGF0ZSBjb25zdHJ1Y3RvciB2YXJpZXMgYWNyb3NzXG4vLyBicm93c2Vycy4gKEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYmUgbWFkZSBtb3JlIGxpYmVyYWwgaWYgZGVzaXJlZCwgdGhvdWdoXG4vLyBpdCBpcyBzdGlsbCBnZW5lcmFsbHkgcHJlZmVyYWJsZSB0byBkbyBkYXRlIHBhcnNpbmcgeW91cnNlbGYgZXhwbGljaXRseSxcbi8vIHJhdGhlciB0aGFuIHJlbHkgb24gUGxvdC4pIEFueSBub24tc3RyaW5nIHZhbHVlcyBhcmUgY29lcmNlZCB0byBudW1iZXIgZmlyc3Rcbi8vIGFuZCB0cmVhdGVkIGFzIG1pbGxpc2Vjb25kcyBzaW5jZSBVTklYIGVwb2NoLlxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZURhdGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHgpXG4gICAgPyB4XG4gICAgOiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIlxuICAgID8gaXNvUGFyc2UoeClcbiAgICA6IHggPT0gbnVsbCB8fCBpc05hTigoeCA9IE51bWJlcih4KSkpIC8vIGFsbG93IGNvbnZlcnNpb24gZnJvbSBCaWdJbnRcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogbmV3IERhdGUoeCk7XG59XG5cbi8vIFNvbWUgY2hhbm5lbHMgbWF5IGFsbG93IGEgc3RyaW5nIGNvbnN0YW50IHRvIGJlIHNwZWNpZmllZDsgdG8gZGlmZmVyZW50aWF0ZVxuLy8gc3RyaW5nIGNvbnN0YW50cyAoZS5nLiwgXCJyZWRcIikgZnJvbSBuYW1lZCBmaWVsZHMgKGUuZy4sIFwiZGF0ZVwiKSwgdGhpc1xuLy8gZnVuY3Rpb24gdGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBDU1MgY29sb3Igc3RyaW5nIGFuZCByZXR1cm5zIGFcbi8vIHR1cGxlIFtjaGFubmVsLCBjb25zdGFudF0gd2hlcmUgb25lIG9mIHRoZSB0d28gaXMgdW5kZWZpbmVkLCBhbmQgdGhlIG90aGVyIGlzXG4vLyB0aGUgZ2l2ZW4gdmFsdWUuIElmIHlvdSB3aXNoIHRvIHJlZmVyZW5jZSBhIG5hbWVkIGZpZWxkIHRoYXQgaXMgYWxzbyBhIHZhbGlkXG4vLyBDU1MgY29sb3IsIHVzZSBhbiBhY2Nlc3NvciAoZCA9PiBkLnJlZCkgaW5zdGVhZC5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUNvbG9yQ2hhbm5lbCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gW3VuZGVmaW5lZCwgXCJub25lXCJdIDogaXNDb2xvcih2YWx1ZSkgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbdmFsdWUsIHVuZGVmaW5lZF07XG59XG5cbi8vIFNpbWlsYXIgdG8gbWF5YmVDb2xvckNoYW5uZWwsIHRoaXMgdGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXJcbi8vIGluZGljYXRpbmcgYSBjb25zdGFudCwgYW5kIG90aGVyd2lzZSBhc3N1bWVzIHRoYXQgaXTigJlzIGEgY2hhbm5lbCB2YWx1ZS5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZU51bWJlckNoYW5uZWwodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbdmFsdWUsIHVuZGVmaW5lZF07XG59XG5cbi8vIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIG9wdGlvbmFsIHN0cmluZyBhZ2FpbnN0IHRoZSBhbGxvd2VkIGxpc3Qgb2Yga2V5d29yZHMuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVLZXl3b3JkKGlucHV0LCBuYW1lLCBhbGxvd2VkKSB7XG4gIGlmIChpbnB1dCAhPSBudWxsKSByZXR1cm4ga2V5d29yZChpbnB1dCwgbmFtZSwgYWxsb3dlZCk7XG59XG5cbi8vIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIHJlcXVpcmVkIHN0cmluZyBhZ2FpbnN0IHRoZSBhbGxvd2VkIGxpc3Qgb2Yga2V5d29yZHMuXG5leHBvcnQgZnVuY3Rpb24ga2V5d29yZChpbnB1dCwgbmFtZSwgYWxsb3dlZCkge1xuICBjb25zdCBpID0gYCR7aW5wdXR9YC50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWFsbG93ZWQuaW5jbHVkZXMoaSkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCAke25hbWV9OiAke2lucHV0fWApO1xuICByZXR1cm4gaTtcbn1cblxuLy8gTGlrZSBhcnJheWlmeSwgYnV0IGFsc28gYWxsb3dzIGRhdGEgdG8gYmUgYW4gQXBhY2hlIEFycm93IFRhYmxlLlxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFpZnkoZGF0YSkge1xuICByZXR1cm4gaXNBcnJvd1RhYmxlKGRhdGEpID8gZGF0YSA6IGFycmF5aWZ5KGRhdGEpO1xufVxuXG4vLyBQcm9tb3RlcyB0aGUgc3BlY2lmaWVkIGRhdGEgdG8gYW4gYXJyYXkgYXMgbmVlZGVkLlxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlcykge1xuICBpZiAodmFsdWVzID09IG51bGwgfHwgaXNBcnJheSh2YWx1ZXMpKSByZXR1cm4gdmFsdWVzO1xuICBpZiAoaXNBcnJvd1ZlY3Rvcih2YWx1ZXMpKSByZXR1cm4gbWF5YmVUeXBlZEFycm93aWZ5KHZhbHVlcyk7XG4gIGlmIChpc0dlb0pTT04odmFsdWVzKSkge1xuICAgIHN3aXRjaCAodmFsdWVzLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgICAgICByZXR1cm4gdmFsdWVzLmZlYXR1cmVzO1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICByZXR1cm4gdmFsdWVzLmdlb21ldHJpZXM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3ZhbHVlc107XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHZhbHVlcyk7XG59XG5cbi8vIER1Y2sgdHlwaW5nIHRlc3QgZm9yIEdlb0pTT05cbmZ1bmN0aW9uIGlzR2VvSlNPTih4KSB7XG4gIHN3aXRjaCAoeD8udHlwZSkge1xuICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOlxuICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpcbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIlNwaGVyZVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBBbiBvcHRpbWl6YXRpb24gb2YgdHlwZS5mcm9tKHZhbHVlcywgZik6IGlmIHRoZSBnaXZlbiB2YWx1ZXMgYXJlIGFscmVhZHkgYW5cbi8vIGluc3RhbmNlb2YgdGhlIGRlc2lyZWQgYXJyYXkgdHlwZSwgdGhlIGZhc3RlciB2YWx1ZXMubWFwIG1ldGhvZCBpcyB1c2VkLlxuZXhwb3J0IGZ1bmN0aW9uIG1hcCh2YWx1ZXMsIGYsIHR5cGUgPSBBcnJheSkge1xuICByZXR1cm4gdmFsdWVzID09IG51bGwgPyB2YWx1ZXMgOiB2YWx1ZXMgaW5zdGFuY2VvZiB0eXBlID8gdmFsdWVzLm1hcChmKSA6IHR5cGUuZnJvbSh2YWx1ZXMsIGYpO1xufVxuXG4vLyBBbiBvcHRpbWl6YXRpb24gb2YgdHlwZS5mcm9tKHZhbHVlcyk6IGlmIHRoZSBnaXZlbiB2YWx1ZXMgYXJlIGFscmVhZHkgYW5cbi8vIGluc3RhbmNlb2YgdGhlIGRlc2lyZWQgYXJyYXkgdHlwZSwgdGhlIGZhc3RlciB2YWx1ZXMuc2xpY2UgbWV0aG9kIGlzIHVzZWQuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWVzLCB0eXBlID0gQXJyYXkpIHtcbiAgcmV0dXJuIHZhbHVlcyBpbnN0YW5jZW9mIHR5cGUgPyB2YWx1ZXMuc2xpY2UoKSA6IHR5cGUuZnJvbSh2YWx1ZXMpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHgsIHgxLCBvciB4MiBpcyBub3QgKHN0cmljdGx5KSB1bmRlZmluZWQuXG5leHBvcnQgZnVuY3Rpb24gaGFzWCh7eCwgeDEsIHgyfSkge1xuICByZXR1cm4geCAhPT0gdW5kZWZpbmVkIHx8IHgxICE9PSB1bmRlZmluZWQgfHwgeDIgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB5LCB5MSwgb3IgeTIgaXMgbm90IChzdHJpY3RseSkgdW5kZWZpbmVkLlxuZXhwb3J0IGZ1bmN0aW9uIGhhc1koe3ksIHkxLCB5Mn0pIHtcbiAgcmV0dXJuIHkgIT09IHVuZGVmaW5lZCB8fCB5MSAhPT0gdW5kZWZpbmVkIHx8IHkyICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBoYXMgeCBvciB5LCBvciBpZiBpbnRlcnZhbCBpcyBub3QgKHN0cmljdGx5KSB1bmRlZmluZWQuXG5leHBvcnQgZnVuY3Rpb24gaGFzWFkob3B0aW9ucykge1xuICByZXR1cm4gaGFzWChvcHRpb25zKSB8fCBoYXNZKG9wdGlvbnMpIHx8IG9wdGlvbnMuaW50ZXJ2YWwgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gRGlzYW1iaWd1YXRlcyBhbiBvcHRpb25zIG9iamVjdCAoZS5nLiwge3k6IFwieDJcIn0pIGZyb20gYSBwcmltaXRpdmUgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob3B0aW9uKSB7XG4gIHJldHVybiBvcHRpb24/LnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZztcbn1cblxuLy8gRGlzYW1iaWd1YXRlcyBhIHNjYWxlIG9wdGlvbnMgb2JqZWN0IChlLmcuLCB7Y29sb3I6IHt0eXBlOiBcImxpbmVhclwifX0pIGZyb21cbi8vIHNvbWUgb3RoZXIgb3B0aW9uIChlLmcuLCB7Y29sb3I6IFwicmVkXCJ9KS4gV2hlbiBjcmVhdGluZyBzdGFuZGFsb25lIGxlZ2VuZHMsXG4vLyB0aGlzIGlzIHVzZWQgdG8gdGVzdCB3aGV0aGVyIGEgc2NhbGUgaXMgZGVmaW5lZDsgdGhpcyBzaG91bGQgYmUgY29uc2lzdGVudFxuLy8gd2l0aCBpbmZlclNjYWxlVHlwZSB3aGVuIHRoZXJlIGFyZSBubyBjaGFubmVscyBhc3NvY2lhdGVkIHdpdGggdGhlIHNjYWxlLCBhbmRcbi8vIGlmIHRoaXMgcmV0dXJucyB0cnVlLCB0aGVuIG5vcm1hbGl6ZVNjYWxlIG11c3QgcmV0dXJuIG5vbi1udWxsLlxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NhbGVPcHRpb25zKG9wdGlvbikge1xuICByZXR1cm4gaXNPYmplY3Qob3B0aW9uKSAmJiAob3B0aW9uLnR5cGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb24uZG9tYWluICE9PSB1bmRlZmluZWQpO1xufVxuXG4vLyBEaXNhbWJpZ3VhdGVzIGFuIG9wdGlvbnMgb2JqZWN0IChlLmcuLCB7eTogXCJ4MlwifSkgZnJvbSBhIGNoYW5uZWwgdmFsdWVcbi8vIGRlZmluaXRpb24gZXhwcmVzc2VkIGFzIGEgY2hhbm5lbCB0cmFuc2Zvcm0gKGUuZy4sIHt0cmFuc2Zvcm06IOKApn0pLlxuLy8gVE9ETyBDaGVjayB0eXBlb2Ygb3B0aW9uW1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIj9cbmV4cG9ydCBmdW5jdGlvbiBpc09wdGlvbnMob3B0aW9uKSB7XG4gIHJldHVybiBpc09iamVjdChvcHRpb24pICYmIHR5cGVvZiBvcHRpb24udHJhbnNmb3JtICE9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIERpc2FtYmlndWF0ZXMgYSBzb3J0IHRyYW5zZm9ybSAoZS5nLiwge3NvcnQ6IFwiZGF0ZVwifSkgZnJvbSBhIGNoYW5uZWwgZG9tYWluXG4vLyBzb3J0IGRlZmluaXRpb24gKGUuZy4sIHtzb3J0OiB7eTogXCJ4XCJ9fSkuXG5leHBvcnQgZnVuY3Rpb24gaXNEb21haW5Tb3J0KHNvcnQpIHtcbiAgcmV0dXJuIGlzT3B0aW9ucyhzb3J0KSAmJiBzb3J0LnZhbHVlID09PSB1bmRlZmluZWQgJiYgc29ydC5jaGFubmVsID09PSB1bmRlZmluZWQ7XG59XG5cbi8vIEZvciBtYXJrcyBzcGVjaWZpZWQgZWl0aGVyIGFzIFswLCB4XSBvciBbeDEsIHgyXSwgc3VjaCBhcyBhcmVhcyBhbmQgYmFycy5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVplcm8oeCwgeDEsIHgyLCB4MyA9IGlkZW50aXR5KSB7XG4gIGlmICh4MSA9PT0gdW5kZWZpbmVkICYmIHgyID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB7eH0gb3Ige31cbiAgICAoeDEgPSAwKSwgKHgyID0geCA9PT0gdW5kZWZpbmVkID8geDMgOiB4KTtcbiAgfSBlbHNlIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8ge3gsIHgyfSBvciB7eDJ9XG4gICAgeDEgPSB4ID09PSB1bmRlZmluZWQgPyAwIDogeDtcbiAgfSBlbHNlIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8ge3gsIHgxfSBvciB7eDF9XG4gICAgeDIgPSB4ID09PSB1bmRlZmluZWQgPyAwIDogeDtcbiAgfVxuICByZXR1cm4gW3gxLCB4Ml07XG59XG5cbi8vIEZvciBtYXJrcyB0aGF0IGhhdmUgeCBhbmQgeSBjaGFubmVscyAoZS5nLiwgY2VsbCwgZG90LCBsaW5lLCB0ZXh0KS5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVR1cGxlKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCAmJiB5ID09PSB1bmRlZmluZWQgPyBbZmlyc3QsIHNlY29uZF0gOiBbeCwgeV07XG59XG5cbi8vIEEgaGVscGVyIGZvciBleHRyYWN0aW5nIHRoZSB6IGNoYW5uZWwsIGlmIGl0IGlzIHZhcmlhYmxlLiBVc2VkIGJ5IHRyYW5zZm9ybXNcbi8vIHRoYXQgcmVxdWlyZSBzZXJpZXMsIHN1Y2ggYXMgbW92aW5nIGF2ZXJhZ2UgYW5kIG5vcm1hbGl6ZS5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVooe3osIGZpbGwsIHN0cm9rZX0gPSB7fSkge1xuICBpZiAoeiA9PT0gdW5kZWZpbmVkKSBbel0gPSBtYXliZUNvbG9yQ2hhbm5lbChmaWxsKTtcbiAgaWYgKHogPT09IHVuZGVmaW5lZCkgW3pdID0gbWF5YmVDb2xvckNoYW5uZWwoc3Ryb2tlKTtcbiAgcmV0dXJuIHo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGhvZihkYXRhKSB7XG4gIHJldHVybiBpc0FycmF5KGRhdGEpID8gZGF0YS5sZW5ndGggOiBkYXRhPy5udW1Sb3dzO1xufVxuXG4vLyBSZXR1cm5zIGEgVWludDMyQXJyYXkgd2l0aCBlbGVtZW50cyBbMCwgMSwgMiwg4oCmIGRhdGEubGVuZ3RoIC0gMV0uXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UoZGF0YSkge1xuICBjb25zdCBuID0gbGVuZ3Rob2YoZGF0YSk7XG4gIGNvbnN0IHIgPSBuZXcgVWludDMyQXJyYXkobik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSByW2ldID0gaTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFJldHVybnMgYW4gYXJyYXkgW3ZhbHVlc1tpbmRleFswXV0sIHZhbHVlc1tpbmRleFsxXV0sIOKApl0uXG5leHBvcnQgZnVuY3Rpb24gdGFrZSh2YWx1ZXMsIGluZGV4KSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlcykgPyBtYXAoaW5kZXgsIChpKSA9PiB2YWx1ZXNbaV0sIHZhbHVlcy5jb25zdHJ1Y3RvcikgOiBtYXAoaW5kZXgsIChpKSA9PiB2YWx1ZXMuYXQoaSkpO1xufVxuXG4vLyBJZiBmIGRvZXMgbm90IHRha2UgZXhhY3RseSBvbmUgYXJndW1lbnQsIHdyYXBzIGl0IGluIGEgZnVuY3Rpb24gdGhhdCB1c2VzIHRha2UuXG5leHBvcnQgZnVuY3Rpb24gdGFrZXIoZikge1xuICByZXR1cm4gZi5sZW5ndGggPT09IDEgPyAoaW5kZXgsIHZhbHVlcykgPT4gZih0YWtlKHZhbHVlcywgaW5kZXgpKSA6IGY7XG59XG5cbi8vIFVzZXMgc3ViYXJyYXkgaWYgYXZhaWxhYmxlLCBhbmQgb3RoZXJ3aXNlIHNsaWNlLlxuZXhwb3J0IGZ1bmN0aW9uIHN1YmFycmF5KEksIGksIGopIHtcbiAgcmV0dXJuIEkuc3ViYXJyYXkgPyBJLnN1YmFycmF5KGksIGopIDogSS5zbGljZShpLCBqKTtcbn1cblxuLy8gQmFzZWQgb24gSW50ZXJuTWFwIChkMy5ncm91cCkuXG5leHBvcnQgZnVuY3Rpb24ga2V5b2YodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVJbnB1dChrZXksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gb3B0aW9uc1trZXldO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgXCJ4MVwiOlxuICAgIGNhc2UgXCJ4MlwiOlxuICAgICAga2V5ID0gXCJ4XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieTFcIjpcbiAgICBjYXNlIFwieTJcIjpcbiAgICAgIGtleSA9IFwieVwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNba2V5XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbihzb3VyY2UpIHtcbiAgLy8gRGVmaW5lcyBhIGNvbHVtbiB3aG9zZSB2YWx1ZXMgYXJlIGxhemlseSBwb3B1bGF0ZWQgYnkgY2FsbGluZyB0aGUgcmV0dXJuZWRcbiAgLy8gc2V0dGVyLiBJZiB0aGUgZ2l2ZW4gc291cmNlIGlzIGxhYmVsZWQsIHRoZSBsYWJlbCBpcyBwcm9wYWdhdGVkIHRvIHRoZVxuICAvLyByZXR1cm5lZCBjb2x1bW4gZGVmaW5pdGlvbi5cbiAgbGV0IHZhbHVlO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHRyYW5zZm9ybTogKCkgPT4gdmFsdWUsXG4gICAgICBsYWJlbDogbGFiZWxvZihzb3VyY2UpXG4gICAgfSxcbiAgICAodikgPT4gKHZhbHVlID0gdilcbiAgXTtcbn1cblxuLy8gTGlrZSBjb2x1bW4sIGJ1dCBhbGxvd3MgdGhlIHNvdXJjZSB0byBiZSBudWxsLlxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQ29sdW1uKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlID09IG51bGwgPyBbc291cmNlXSA6IGNvbHVtbihzb3VyY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxvZih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZhbHVlICYmIHZhbHVlLmxhYmVsICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5sYWJlbCA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuLy8gQXNzdW1pbmcgdGhhdCBib3RoIHgxIGFuZCB4MiBhbmQgbGF6eSBjb2x1bW5zIChwZXIgYWJvdmUpLCB0aGlzIGRlcml2ZXMgYSBuZXdcbi8vIGEgY29sdW1uIHRoYXTigJlzIHRoZSBhdmVyYWdlIG9mIHRoZSB0d28sIGFuZCB3aGljaCBpbmhlcml0cyB0aGUgY29sdW1uIGxhYmVsXG4vLyAoaWYgYW55KS4gQm90aCBpbnB1dCBjb2x1bW5zIGFyZSBhc3N1bWVkIHRvIGJlIHF1YW50aXRhdGl2ZS4gSWYgZWl0aGVyIGNvbHVtblxuLy8gaXMgdGVtcG9yYWwsIHRoZSByZXR1cm5lZCBjb2x1bW4gaXMgYWxzbyB0ZW1wb3JhbC5cbmV4cG9ydCBmdW5jdGlvbiBtaWQoeDEsIHgyKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtKGRhdGEpIHtcbiAgICAgIGNvbnN0IFgxID0geDEudHJhbnNmb3JtKGRhdGEpO1xuICAgICAgY29uc3QgWDIgPSB4Mi50cmFuc2Zvcm0oZGF0YSk7XG4gICAgICByZXR1cm4gaXNUZW1wb3JhbChYMSkgfHwgaXNUZW1wb3JhbChYMilcbiAgICAgICAgPyBtYXAoWDEsIChfLCBpKSA9PiBuZXcgRGF0ZSgoK1gxW2ldICsgK1gyW2ldKSAvIDIpKVxuICAgICAgICA6IG1hcChYMSwgKF8sIGkpID0+ICgrWDFbaV0gKyArWDJbaV0pIC8gMiwgRmxvYXQ2NEFycmF5KTtcbiAgICB9LFxuICAgIGxhYmVsOiB4MS5sYWJlbFxuICB9O1xufVxuXG4vLyBJZiB0aGUgc2NhbGUgb3B0aW9ucyBkZWNsYXJlIGFuIGludGVydmFsLCBhcHBsaWVzIGl0IHRvIHRoZSB2YWx1ZXMgVi5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFwcGx5SW50ZXJ2YWwoViwgc2NhbGUpIHtcbiAgY29uc3QgdCA9IG1heWJlSW50ZXJ2YWxUcmFuc2Zvcm0oc2NhbGU/LmludGVydmFsLCBzY2FsZT8udHlwZSk7XG4gIHJldHVybiB0ID8gbWFwKFYsIHQpIDogVjtcbn1cblxuLy8gUmV0dXJucyB0aGUgZXF1aXZhbGVudCBzY2FsZSB0cmFuc2Zvcm0gZm9yIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwgb3B0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlSW50ZXJ2YWxUcmFuc2Zvcm0oaW50ZXJ2YWwsIHR5cGUpIHtcbiAgY29uc3QgaSA9IG1heWJlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpO1xuICByZXR1cm4gaSAmJiAoKHYpID0+IChkZWZpbmVkKHYpID8gaS5mbG9vcih2KSA6IHYpKTtcbn1cblxuLy8gSWYgaW50ZXJ2YWwgaXMgbm90IG51bGxpc2gsIGNvbnZlcnRzIGludGVydmFsIHNob3J0aGFuZCBzdWNoIGFzIGEgbnVtYmVyIChmb3Jcbi8vIG11bHRpcGxlcykgb3IgYSB0aW1lIGludGVydmFsIG5hbWUgKHN1Y2ggYXMg4oCcZGF54oCdKSB0byBhIHtmbG9vciwgb2Zmc2V0LFxuLy8gcmFuZ2V9IG9iamVjdCBzaW1pbGFyIHRvIGEgRDMgdGltZSBpbnRlcnZhbC5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVydmFsKGludGVydmFsLCB0eXBlKSB7XG4gIGlmIChpbnRlcnZhbCA9PSBudWxsKSByZXR1cm47XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHJldHVybiBudW1iZXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwic3RyaW5nXCIpIHJldHVybiAodHlwZSA9PT0gXCJ0aW1lXCIgPyB0aW1lSW50ZXJ2YWwgOiB1dGNJbnRlcnZhbCkoaW50ZXJ2YWwpO1xuICBpZiAodHlwZW9mIGludGVydmFsLmZsb29yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWw7IG1pc3NpbmcgZmxvb3IgbWV0aG9kXCIpO1xuICBpZiAodHlwZW9mIGludGVydmFsLm9mZnNldCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsOyBtaXNzaW5nIG9mZnNldCBtZXRob2RcIik7XG4gIHJldHVybiBpbnRlcnZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckludGVydmFsKGludGVydmFsKSB7XG4gIGludGVydmFsID0gK2ludGVydmFsO1xuICBpZiAoMCA8IGludGVydmFsICYmIGludGVydmFsIDwgMSAmJiBOdW1iZXIuaXNJbnRlZ2VyKDEgLyBpbnRlcnZhbCkpIGludGVydmFsID0gLTEgLyBpbnRlcnZhbDtcbiAgY29uc3QgbiA9IE1hdGguYWJzKGludGVydmFsKTtcbiAgcmV0dXJuIGludGVydmFsIDwgMFxuICAgID8ge1xuICAgICAgICBmbG9vcjogKGQpID0+IE1hdGguZmxvb3IoZCAqIG4pIC8gbixcbiAgICAgICAgb2Zmc2V0OiAoZCwgcyA9IDEpID0+IChkICogbiArIE1hdGguZmxvb3IocykpIC8gbixcbiAgICAgICAgcmFuZ2U6IChsbywgaGkpID0+IHJhbmdlaShNYXRoLmNlaWwobG8gKiBuKSwgaGkgKiBuKS5tYXAoKHgpID0+IHggLyBuKVxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBmbG9vcjogKGQpID0+IE1hdGguZmxvb3IoZCAvIG4pICogbixcbiAgICAgICAgb2Zmc2V0OiAoZCwgcyA9IDEpID0+IGQgKyBuICogTWF0aC5mbG9vcihzKSxcbiAgICAgICAgcmFuZ2U6IChsbywgaGkpID0+IHJhbmdlaShNYXRoLmNlaWwobG8gLyBuKSwgaGkgLyBuKS5tYXAoKHgpID0+IHggKiBuKVxuICAgICAgfTtcbn1cblxuLy8gTGlrZSBtYXliZUludGVydmFsLCBidXQgcmVxdWlyZXMgYSByYW5nZSBtZXRob2QgdG9vLlxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUmFuZ2VJbnRlcnZhbChpbnRlcnZhbCwgdHlwZSkge1xuICBpbnRlcnZhbCA9IG1heWJlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpO1xuICBpZiAoaW50ZXJ2YWwgJiYgdHlwZW9mIGludGVydmFsLnJhbmdlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZXJ2YWw6IG1pc3NpbmcgcmFuZ2UgbWV0aG9kXCIpO1xuICByZXR1cm4gaW50ZXJ2YWw7XG59XG5cbi8vIExpa2UgbWF5YmVSYW5nZUludGVydmFsLCBidXQgcmVxdWlyZXMgYSBjZWlsIG1ldGhvZCB0b28uXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVOaWNlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpIHtcbiAgaW50ZXJ2YWwgPSBtYXliZVJhbmdlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpO1xuICBpZiAoaW50ZXJ2YWwgJiYgdHlwZW9mIGludGVydmFsLmNlaWwgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnRlcnZhbDogbWlzc2luZyBjZWlsIG1ldGhvZFwiKTtcbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUaW1lSW50ZXJ2YWwodCkge1xuICByZXR1cm4gaXNJbnRlcnZhbCh0KSAmJiB0eXBlb2YgdD8uZmxvb3IgPT09IFwiZnVuY3Rpb25cIiAmJiB0LmZsb29yKCkgaW5zdGFuY2VvZiBEYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcnZhbCh0KSB7XG4gIHJldHVybiB0eXBlb2YgdD8ucmFuZ2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gVGhpcyBkaXN0aW5ndWlzaGVzIGJldHdlZW4gcGVyLWRpbWVuc2lvbiBvcHRpb25zIGFuZCBhIHN0YW5kYWxvbmUgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc09wdGlvbnModmFsdWUpID8gdmFsdWUgOiB7dmFsdWV9O1xufVxuXG4vLyBDb2VyY2VzIHRoZSBnaXZlbiBjaGFubmVsIHZhbHVlcyAoaWYgYW55KSB0byBudW1iZXJzLiBUaGlzIGlzIHVzZWZ1bCB3aGVuXG4vLyB2YWx1ZXMgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgaW50byBvdGhlciBjb2RlLCBzdWNoIGFzIGFuIFNWRyB0cmFuc2Zvcm0sIGFuZFxuLy8gd2hlcmUgd2UgZG9u4oCZdCB3aXNoIHRvIGFsbG93IHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yIHdlaXJkIGlucHV0LlxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckNoYW5uZWwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT0gbnVsbFxuICAgID8gbnVsbFxuICAgIDoge1xuICAgICAgICB0cmFuc2Zvcm06IChkYXRhKSA9PiB2YWx1ZW9mKGRhdGEsIHNvdXJjZSwgRmxvYXQ2NEFycmF5KSxcbiAgICAgICAgbGFiZWw6IGxhYmVsb2Yoc291cmNlKVxuICAgICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHVwbGVzKGRhdGEpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlKGRhdGEpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgZCBvZiBkYXRhKSB7XG4gICAgaWYgKGQgPT0gbnVsbCkgY29udGludWU7XG4gICAgcmV0dXJuIHR5cGVvZiBkID09PSBcIm9iamVjdFwiICYmIFwiMFwiIGluIGQgJiYgXCIxXCIgaW4gZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGV4dHVhbCh2YWx1ZXMpIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JkaW5hbCh2YWx1ZXMpIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUZW1wb3JhbCh2YWx1ZXMpIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbiAgfVxufVxuXG4vLyBBcmUgdGhlc2Ugc3RyaW5ncyB0aGF0IG1pZ2h0IHJlcHJlc2VudCBkYXRlcz8gVGhpcyBpcyBzdHJpY3RlciB0aGFuIElTTyA4NjAxXG4vLyBiZWNhdXNlIHdlIHdhbnQgdG8gaWdub3JlIGZhbHNlIHBvc2l0aXZlcyBvbiBudW1iZXJzOyBmb3IgZXhhbXBsZSwgdGhlIHN0cmluZ1xuLy8gXCIxMTkyXCIgaXMgbW9yZSBsaWtlbHkgdG8gcmVwcmVzZW50IGEgbnVtYmVyIHRoYW4gYSBkYXRlIGV2ZW4gdGhvdWdoIGl0IGlzXG4vLyB2YWxpZCBJU08gODYwMSByZXByZXNlbnRpbmcgMTE5Mi0wMS0wMS5cbmV4cG9ydCBmdW5jdGlvbiBpc1RlbXBvcmFsU3RyaW5nKHZhbHVlcykge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIGlzTmFOKHZhbHVlKSAmJiBpc29QYXJzZSh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gQXJlIHRoZXNlIHN0cmluZ3MgdGhhdCBtaWdodCByZXByZXNlbnQgbnVtYmVycz8gVGhpcyBpcyBzdHJpY3RlciB0aGFuXG4vLyBjb2VyY2lvbiBiZWNhdXNlIHdlIHdhbnQgdG8gaWdub3JlIGZhbHNlIHBvc2l0aXZlcyBvbiBlLmcuIGVtcHR5IHN0cmluZ3MuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1lcmljU3RyaW5nKHZhbHVlcykge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWx1ZS50cmltKCkpIGNvbnRpbnVlO1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWVyaWModmFsdWVzKSB7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIGNvbnRpbnVlO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIGV2ZXJ5IG5vbi1udWxsIHZhbHVlIGluIHRoZSBzcGVjaWZpZWQgaXRlcmFibGUgb2YgdmFsdWVzXG4vLyBwYXNzZXMgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLW51bGwgdmFsdWU7XG4vLyByZXR1cm5zIGZhbHNlIGlmIGF0IGxlYXN0IG9uZSBub24tbnVsbCB2YWx1ZSBkb2VzIG5vdCBwYXNzIHRoZSBzcGVjaWZpZWRcbi8vIHByZWRpY2F0ZTsgb3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkIChhcyBpZiBhbGwgdmFsdWVzIGFyZSBudWxsKS5cbmV4cG9ydCBmdW5jdGlvbiBpc0V2ZXJ5KHZhbHVlcywgaXMpIHtcbiAgbGV0IGV2ZXJ5O1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAoIWlzKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGV2ZXJ5ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXZlcnk7XG59XG5cbmNvbnN0IG5hbWVkQ29sb3JzID0gbmV3IFNldChcIm5vbmUsY3VycmVudGNvbG9yLHRyYW5zcGFyZW50LGFsaWNlYmx1ZSxhbnRpcXVld2hpdGUsYXF1YSxhcXVhbWFyaW5lLGF6dXJlLGJlaWdlLGJpc3F1ZSxibGFjayxibGFuY2hlZGFsbW9uZCxibHVlLGJsdWV2aW9sZXQsYnJvd24sYnVybHl3b29kLGNhZGV0Ymx1ZSxjaGFydHJldXNlLGNob2NvbGF0ZSxjb3JhbCxjb3JuZmxvd2VyYmx1ZSxjb3Juc2lsayxjcmltc29uLGN5YW4sZGFya2JsdWUsZGFya2N5YW4sZGFya2dvbGRlbnJvZCxkYXJrZ3JheSxkYXJrZ3JlZW4sZGFya2dyZXksZGFya2toYWtpLGRhcmttYWdlbnRhLGRhcmtvbGl2ZWdyZWVuLGRhcmtvcmFuZ2UsZGFya29yY2hpZCxkYXJrcmVkLGRhcmtzYWxtb24sZGFya3NlYWdyZWVuLGRhcmtzbGF0ZWJsdWUsZGFya3NsYXRlZ3JheSxkYXJrc2xhdGVncmV5LGRhcmt0dXJxdW9pc2UsZGFya3Zpb2xldCxkZWVwcGluayxkZWVwc2t5Ymx1ZSxkaW1ncmF5LGRpbWdyZXksZG9kZ2VyYmx1ZSxmaXJlYnJpY2ssZmxvcmFsd2hpdGUsZm9yZXN0Z3JlZW4sZnVjaHNpYSxnYWluc2Jvcm8sZ2hvc3R3aGl0ZSxnb2xkLGdvbGRlbnJvZCxncmF5LGdyZWVuLGdyZWVueWVsbG93LGdyZXksaG9uZXlkZXcsaG90cGluayxpbmRpYW5yZWQsaW5kaWdvLGl2b3J5LGtoYWtpLGxhdmVuZGVyLGxhdmVuZGVyYmx1c2gsbGF3bmdyZWVuLGxlbW9uY2hpZmZvbixsaWdodGJsdWUsbGlnaHRjb3JhbCxsaWdodGN5YW4sbGlnaHRnb2xkZW5yb2R5ZWxsb3csbGlnaHRncmF5LGxpZ2h0Z3JlZW4sbGlnaHRncmV5LGxpZ2h0cGluayxsaWdodHNhbG1vbixsaWdodHNlYWdyZWVuLGxpZ2h0c2t5Ymx1ZSxsaWdodHNsYXRlZ3JheSxsaWdodHNsYXRlZ3JleSxsaWdodHN0ZWVsYmx1ZSxsaWdodHllbGxvdyxsaW1lLGxpbWVncmVlbixsaW5lbixtYWdlbnRhLG1hcm9vbixtZWRpdW1hcXVhbWFyaW5lLG1lZGl1bWJsdWUsbWVkaXVtb3JjaGlkLG1lZGl1bXB1cnBsZSxtZWRpdW1zZWFncmVlbixtZWRpdW1zbGF0ZWJsdWUsbWVkaXVtc3ByaW5nZ3JlZW4sbWVkaXVtdHVycXVvaXNlLG1lZGl1bXZpb2xldHJlZCxtaWRuaWdodGJsdWUsbWludGNyZWFtLG1pc3R5cm9zZSxtb2NjYXNpbixuYXZham93aGl0ZSxuYXZ5LG9sZGxhY2Usb2xpdmUsb2xpdmVkcmFiLG9yYW5nZSxvcmFuZ2VyZWQsb3JjaGlkLHBhbGVnb2xkZW5yb2QscGFsZWdyZWVuLHBhbGV0dXJxdW9pc2UscGFsZXZpb2xldHJlZCxwYXBheWF3aGlwLHBlYWNocHVmZixwZXJ1LHBpbmsscGx1bSxwb3dkZXJibHVlLHB1cnBsZSxyZWJlY2NhcHVycGxlLHJlZCxyb3N5YnJvd24scm95YWxibHVlLHNhZGRsZWJyb3duLHNhbG1vbixzYW5keWJyb3duLHNlYWdyZWVuLHNlYXNoZWxsLHNpZW5uYSxzaWx2ZXIsc2t5Ymx1ZSxzbGF0ZWJsdWUsc2xhdGVncmF5LHNsYXRlZ3JleSxzbm93LHNwcmluZ2dyZWVuLHN0ZWVsYmx1ZSx0YW4sdGVhbCx0aGlzdGxlLHRvbWF0byx0dXJxdW9pc2UsdmlvbGV0LHdoZWF0LHdoaXRlLHdoaXRlc21va2UseWVsbG93XCIuc3BsaXQoXCIsXCIpKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHZhbGlkIENTUyBjb2xvciBzdHJpbmcuIFRoaXMgaXMgaW50ZW50aW9uYWxseSBsYXhcbi8vIGJlY2F1c2UgdGhlIENTUyBjb2xvciBzcGVjIGtlZXBzIGdyb3dpbmcsIGFuZCB3ZSBkb27igJl0IG5lZWQgdG8gcGFyc2UgdGhlc2Vcbi8vIGNvbG9yc+KAlHdlIGp1c3QgbmVlZCB0byBkaXNhbWJpZ3VhdGUgdGhlbSBmcm9tIGNvbHVtbiBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1NwZWNpZnlpbmdQYWludFxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci01L1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sb3IodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICByZXR1cm4gKFxuICAgIC9eI1swLTlhLWZdezMsOH0kLy50ZXN0KHZhbHVlKSB8fCAvLyBoZXggcmdiLCByZ2JhLCBycmdnYmIsIHJyZ2diYmFhXG4gICAgL14oPzp1cmx8dmFyfHJnYnxyZ2JhfGhzbHxoc2xhfGh3YnxsYWJ8bGNofG9rbGFifG9rbGNofGNvbG9yfGNvbG9yLW1peClcXCguKlxcKSQvLnRlc3QodmFsdWUpIHx8IC8vIDxmdW5jaXJpPiwgQ1NTIHZhcmlhYmxlLCBjb2xvciwgZXRjLlxuICAgIG5hbWVkQ29sb3JzLmhhcyh2YWx1ZSkgLy8gY3VycmVudENvbG9yLCByZWQsIGV0Yy5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BhY2l0eSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICgoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAxKSB8fCBpc05hTih2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb25laXNoKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTm9uZSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vbmUodmFsdWUpIHtcbiAgcmV0dXJuIC9eXFxzKm5vbmVcXHMqJC9pLnRlc3QodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gL15cXHMqcm91bmRcXHMqJC9pLnRlc3QodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBbmNob3IodmFsdWUsIG5hbWUpIHtcbiAgcmV0dXJuIG1heWJlS2V5d29yZCh2YWx1ZSwgbmFtZSwgW1xuICAgIFwibWlkZGxlXCIsXG4gICAgXCJ0b3AtbGVmdFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJ0b3AtcmlnaHRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b20tcmlnaHRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwiYm90dG9tLWxlZnRcIixcbiAgICBcImxlZnRcIlxuICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlRnJhbWVBbmNob3IodmFsdWUgPSBcIm1pZGRsZVwiKSB7XG4gIHJldHVybiBtYXliZUFuY2hvcih2YWx1ZSwgXCJmcmFtZUFuY2hvclwiKTtcbn1cblxuLy8gVW5saWtlIHsuLi5kZWZhdWx0cywgLi4ub3B0aW9uc30sIHRoaXMgZW5zdXJlcyB0aGF0IGFueSB1bmRlZmluZWQgKGJ1dFxuLy8gcHJlc2VudCkgcHJvcGVydGllcyBpbiBvcHRpb25zIGluaGVyaXQgdGhlIGdpdmVuIGRlZmF1bHQgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gaW5oZXJpdChvcHRpb25zID0ge30sIC4uLnJlc3QpIHtcbiAgbGV0IG8gPSBvcHRpb25zO1xuICBmb3IgKGNvbnN0IGRlZmF1bHRzIG9mIHJlc3QpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgaWYgKG8gPT09IG9wdGlvbnMpIG8gPSB7Li4ubywgW2tleV06IHZhbHVlfTtcbiAgICAgICAgZWxzZSBvW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIEdpdmVuIGFuIGl0ZXJhYmxlIG9mIG5hbWVkIHRoaW5ncyAob2JqZWN0cyB3aXRoIGEgbmFtZSBwcm9wZXJ0eSksIHJldHVybnMgYVxuLy8gY29ycmVzcG9uZGluZyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZCh0aGluZ3MpIHtcbiAgY29uc29sZS53YXJuKFwibmFtZWQgaXRlcmFibGVzIGFyZSBkZXByZWNhdGVkOyBwbGVhc2UgdXNlIGFuIG9iamVjdCBpbnN0ZWFkXCIpO1xuICBjb25zdCBuYW1lcyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBBcnJheS5mcm9tKHRoaW5ncywgKHRoaW5nKSA9PiB7XG4gICAgICBjb25zdCB7bmFtZX0gPSB0aGluZztcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgbmFtZVwiKTtcbiAgICAgIGNvbnN0IGtleSA9IGAke25hbWV9YDtcbiAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHRocm93IG5ldyBFcnJvcihgaWxsZWdhbCBuYW1lOiAke2tleX1gKTtcbiAgICAgIGlmIChuYW1lcy5oYXMoa2V5KSkgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUgbmFtZTogJHtrZXl9YCk7XG4gICAgICBuYW1lcy5hZGQoa2V5KTtcbiAgICAgIHJldHVybiBbbmFtZSwgdGhpbmddO1xuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZU5hbWVkKHRoaW5ncykge1xuICByZXR1cm4gaXNJdGVyYWJsZSh0aGluZ3MpID8gbmFtZWQodGhpbmdzKSA6IHRoaW5ncztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQ2xpcChjbGlwKSB7XG4gIGlmIChjbGlwID09PSB0cnVlKSBjbGlwID0gXCJmcmFtZVwiO1xuICBlbHNlIGlmIChjbGlwID09PSBmYWxzZSkgY2xpcCA9IG51bGw7XG4gIGVsc2UgaWYgKCFpc0dlb0pTT04oY2xpcCkgJiYgY2xpcCAhPSBudWxsKSB7XG4gICAgY2xpcCA9IGtleXdvcmQoY2xpcCwgXCJjbGlwXCIsIFtcImZyYW1lXCIsIFwic3BoZXJlXCJdKTtcbiAgICBpZiAoY2xpcCA9PT0gXCJzcGhlcmVcIikgY2xpcCA9IHt0eXBlOiBcIlNwaGVyZVwifTtcbiAgfVxuICByZXR1cm4gY2xpcDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29ic2VydmFibGVocS9zdGRsaWIvYmxvYi83NDZjYTJlNjkxMzVkZjYxNzhlNGYzYTE3MjQ0ZGVmMzVkOGQ2YjIwL3NyYy9hcnJvdy5qcyNMNEMxLUwxN0MxXG5mdW5jdGlvbiBpc0Fycm93VGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAmJlxuICAgIHR5cGVvZiB2YWx1ZS5nZXRDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHZhbHVlLnRvQXJyYXkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHZhbHVlLnNjaGVtYSAmJlxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUuc2NoZW1hLmZpZWxkcylcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJvd1ZlY3Rvcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvQXJyYXkgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS50eXBlO1xufVxuXG4vLyBBcGFjaGUgQXJyb3cgbm93IHJlcHJlc2VudHMgZGF0ZXMgYXMgbnVtYmVycy4gV2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydFxuLy8gaW1wbGljaXQgY29lcmNpb24gdG8gSmF2YVNjcmlwdCBEYXRlIG9iamVjdHMgd2hlbiB0aGUgbnVtYmVycyByZXByZXNlbnRcbi8vIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoLlxuZnVuY3Rpb24gaXNBcnJvd0RhdGVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlICYmXG4gICAgKHR5cGUudHlwZUlkID09PSA4IHx8IC8vIGRhdGVcbiAgICAgIHR5cGUudHlwZUlkID09PSAxMCkgJiYgLy8gdGltZXN0YW1wXG4gICAgdHlwZS51bml0ID09PSAxIC8vIG1pbGxpc2Vjb25kXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/order.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/order.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orderof: () => (/* binding */ orderof)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n\n\n// Like a sort comparator, returns a positive value if the given array of values\n// is in ascending order, a negative value if the values are in descending\n// order. Assumes monotonicity; only tests the first and last values.\nfunction orderof(values) {\n  if (values == null) return;\n  const first = values[0];\n  const last = values[values.length - 1];\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(first, last);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9vcmRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLGdDQUFnQztBQUN6QjtBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQVU7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL29yZGVyLmpzPzhmYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtkZXNjZW5kaW5nfSBmcm9tIFwiZDNcIjtcblxuLy8gTGlrZSBhIHNvcnQgY29tcGFyYXRvciwgcmV0dXJucyBhIHBvc2l0aXZlIHZhbHVlIGlmIHRoZSBnaXZlbiBhcnJheSBvZiB2YWx1ZXNcbi8vIGlzIGluIGFzY2VuZGluZyBvcmRlciwgYSBuZWdhdGl2ZSB2YWx1ZSBpZiB0aGUgdmFsdWVzIGFyZSBpbiBkZXNjZW5kaW5nXG4vLyBvcmRlci4gQXNzdW1lcyBtb25vdG9uaWNpdHk7IG9ubHkgdGVzdHMgdGhlIGZpcnN0IGFuZCBsYXN0IHZhbHVlcy5cbmV4cG9ydCBmdW5jdGlvbiBvcmRlcm9mKHZhbHVlcykge1xuICBpZiAodmFsdWVzID09IG51bGwpIHJldHVybjtcbiAgY29uc3QgZmlyc3QgPSB2YWx1ZXNbMF07XG4gIGNvbnN0IGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gZGVzY2VuZGluZyhmaXJzdCwgbGFzdCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/order.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/plot.js":
/*!*****************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/plot.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   plot: () => (/* binding */ plot)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _dimensions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dimensions.js */ \"(ssr)/./node_modules/@observablehq/plot/src/dimensions.js\");\n/* harmony import */ var _facet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./facet.js */ \"(ssr)/./node_modules/@observablehq/plot/src/facet.js\");\n/* harmony import */ var _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interactions/pointer.js */ \"(ssr)/./node_modules/@observablehq/plot/src/interactions/pointer.js\");\n/* harmony import */ var _legends_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./legends.js */ \"(ssr)/./node_modules/@observablehq/plot/src/legends.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./marks/axis.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/axis.js\");\n/* harmony import */ var _marks_frame_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./marks/frame.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/frame.js\");\n/* harmony import */ var _marks_tip_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./marks/tip.js */ \"(ssr)/./node_modules/@observablehq/plot/src/marks/tip.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _scales_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scales.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales.js\");\n/* harmony import */ var _scales_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scales/index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n/* harmony import */ var _transforms_basic_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./transforms/basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction plot(options = {}) {\n  const {facet, style, title, subtitle, caption, ariaLabel, ariaDescription} = options;\n\n  // className for inline styles\n  const className = (0,_style_js__WEBPACK_IMPORTED_MODULE_1__.maybeClassName)(options.className);\n\n  // Flatten any nested marks.\n  const marks = options.marks === undefined ? [] : flatMarks(options.marks);\n\n  // Add implicit tips.\n  marks.push(...inferTips(marks));\n\n  // Compute the top-level facet state. This has roughly the same structure as\n  // mark-specific facet state, except there isn’t a facetsIndex, and there’s a\n  // data and dataLength so we can warn the user if a different data of the same\n  // length is used in a mark.\n  const topFacetState = maybeTopFacet(facet, options);\n\n  // Construct a map from (faceted) Mark instance to facet state, including:\n  // channels - an {fx?, fy?} object to add to the fx and fy scale\n  // groups - a possibly-nested map from facet values to indexes in the data array\n  // facetsIndex - a sparse nested array of indices corresponding to the valid facets\n  const facetStateByMark = new Map();\n  for (const mark of marks) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState) facetStateByMark.set(mark, facetState);\n  }\n\n  // Compute a Map from scale name to an array of associated channels.\n  const channelsByScale = new Map();\n  if (topFacetState) addScaleChannels(channelsByScale, [topFacetState], options);\n  addScaleChannels(channelsByScale, facetStateByMark, options);\n\n  // Add implicit axis marks. Because this happens after faceting (because it\n  // depends on whether faceting is present), we must initialize the facet state\n  // of any implicit axes, too.\n  const axes = flatMarks(inferAxes(marks, channelsByScale, options));\n  for (const mark of axes) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState) facetStateByMark.set(mark, facetState);\n  }\n  marks.unshift(...axes);\n\n  // All the possible facets are given by the domains of the fx or fy scales, or\n  // the cross-product of these domains if we facet by both x and y. We sort\n  // them in order to apply the facet filters afterwards.\n  let facets = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.createFacets)(channelsByScale, options);\n\n  if (facets !== undefined) {\n    const topFacetsIndex = topFacetState ? (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetFilter)(facets, topFacetState) : undefined;\n\n    // Compute a facet index for each mark, parallel to the facets array. For\n    // mark-level facets, compute an index for that mark’s data and options.\n    // Otherwise, use the top-level facet index.\n    for (const mark of marks) {\n      if (mark.facet === null || mark.facet === \"super\") continue;\n      const facetState = facetStateByMark.get(mark);\n      if (facetState === undefined) continue;\n      facetState.facetsIndex = mark.fx != null || mark.fy != null ? (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetFilter)(facets, facetState) : topFacetsIndex;\n    }\n\n    // The cross product of the domains of fx and fy can include fx-fy\n    // combinations for which no mark has an instance associated with that\n    // combination, and therefore we don’t want to render this facet (not even\n    // the frame). The same can occur if you specify the domain of fx and fy\n    // explicitly, but there is no mark instance associated with some values in\n    // the domain. Expunge empty facets, and clear the corresponding elements\n    // from the nested index in each mark.\n    const nonEmpty = new Set();\n    for (const {facetsIndex} of facetStateByMark.values()) {\n      facetsIndex?.forEach((index, i) => {\n        if (index?.length > 0) {\n          nonEmpty.add(i);\n        }\n      });\n    }\n\n    // If all the facets are empty (as when none of the marks are actually\n    // faceted), none of them are empty.\n    facets.forEach(\n      0 < nonEmpty.size && nonEmpty.size < facets.length\n        ? (f, i) => (f.empty = !nonEmpty.has(i))\n        : (f) => (f.empty = false)\n    );\n\n    // For any mark using the “exclude” facet mode, invert the index.\n    for (const mark of marks) {\n      if (mark.facet === \"exclude\") {\n        const facetState = facetStateByMark.get(mark);\n        if (facetState !== undefined) facetState.facetsIndex = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetExclude)(facetState.facetsIndex);\n      }\n    }\n  }\n\n  // If a scale is explicitly declared in options, initialize its associated\n  // channels to the empty array; this will guarantee that a corresponding scale\n  // will be created later (even if there are no other channels). Ignore facet\n  // scale declarations, which are handled above.\n  for (const key of _scales_index_js__WEBPACK_IMPORTED_MODULE_3__.registry.keys()) {\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isScaleOptions)(options[key]) && key !== \"fx\" && key !== \"fy\") {\n      channelsByScale.set(key, []);\n    }\n  }\n\n  // A Map from Mark instance to its render state, including:\n  // index - the data index e.g. [0, 1, 2, 3, …]\n  // channels - an array of materialized channels e.g. [[\"x\", {value}], …]\n  // faceted - a boolean indicating whether this mark is faceted\n  // values - an object of scaled values e.g. {x: [40, 32, …], …}\n  const stateByMark = new Map();\n\n  // Initialize the marks’ state.\n  for (const mark of marks) {\n    if (stateByMark.has(mark)) throw new Error(\"duplicate mark; each mark must be unique\");\n    const {facetsIndex, channels: facetChannels} = facetStateByMark.get(mark) ?? {};\n    const {data, facets, channels} = mark.initialize(facetsIndex, facetChannels, options);\n    applyScaleTransforms(channels, options);\n    stateByMark.set(mark, {data, facets, channels});\n  }\n\n  // Initalize the scales and dimensions.\n  const scaleDescriptors = (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.createScales)(addScaleChannels(channelsByScale, stateByMark, options), options);\n  const dimensions = (0,_dimensions_js__WEBPACK_IMPORTED_MODULE_6__.createDimensions)(scaleDescriptors, marks, options);\n\n  (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.autoScaleRange)(scaleDescriptors, dimensions);\n\n  const scales = (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.createScaleFunctions)(scaleDescriptors);\n  const {fx, fy} = scales;\n  const subdimensions = fx || fy ? (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.innerDimensions)(scaleDescriptors, dimensions) : dimensions;\n  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;\n\n  // Initialize the context.\n  const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_7__.createContext)(options);\n  const document = context.document;\n  const svg = (0,d3__WEBPACK_IMPORTED_MODULE_0__.creator)(\"svg\").call(document.documentElement);\n  let figure = svg; // replaced with the figure element, if any\n  context.ownerSVGElement = svg;\n  context.className = className;\n  context.projection = (0,_projection_js__WEBPACK_IMPORTED_MODULE_8__.createProjection)(options, subdimensions);\n\n  // A path generator for marks that want to draw GeoJSON.\n  context.path = function () {\n    return (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoPath)(this.projection ?? (0,_projection_js__WEBPACK_IMPORTED_MODULE_8__.xyProjection)(scales));\n  };\n\n  // Allows e.g. the axis mark to determine faceting lazily.\n  context.filterFacets = (data, channels) => {\n    return (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetFilter)(facets, {channels, groups: (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetGroups)(data, channels)});\n  };\n\n  // Allows e.g. the tip mark to reference channels and data on other marks.\n  context.getMarkState = (mark) => {\n    const state = stateByMark.get(mark);\n    const facetState = facetStateByMark.get(mark);\n    return {...state, channels: {...state.channels, ...facetState?.channels}};\n  };\n\n  // Allows e.g. the pointer transform to support viewof.\n  context.dispatchValue = (value) => {\n    if (figure.value === value) return;\n    figure.value = value;\n    figure.dispatchEvent(new context.document.defaultView.Event(\"input\", {bubbles: true}));\n  };\n\n  // Reinitialize; for deriving channels dependent on other channels.\n  const newByScale = new Set();\n  for (const [mark, state] of stateByMark) {\n    if (mark.initializer != null) {\n      const dimensions = mark.facet === \"super\" ? superdimensions : subdimensions;\n      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions, context);\n      if (update.data !== undefined) {\n        state.data = update.data;\n      }\n      if (update.facets !== undefined) {\n        state.facets = update.facets;\n      }\n      if (update.channels !== undefined) {\n        const {fx, fy, ...channels} = update.channels; // separate facet channels\n        inferChannelScales(channels);\n        Object.assign(state.channels, channels);\n        for (const channel of Object.values(channels)) {\n          const {scale} = channel;\n          // Initializers aren’t allowed to redefine position scales as this\n          // would introduce a circular dependency; so simply scale these\n          // channels as-is rather than creating new scales, and assume that\n          // they already have the scale’s transform applied, if any (e.g., when\n          // generating ticks for the axis mark).\n          if (scale != null && !(0,_scales_index_js__WEBPACK_IMPORTED_MODULE_3__.isPosition)(_scales_index_js__WEBPACK_IMPORTED_MODULE_3__.registry.get(scale))) {\n            applyScaleTransform(channel, options);\n            newByScale.add(scale);\n          }\n        }\n        // If the initializer returns new mark-level facet channels, we must\n        // record that the mark is now faceted. Note: we aren’t actually\n        // populating the facet state, but subsequently we won’t need it.\n        if (fx != null || fy != null) facetStateByMark.set(mark, true);\n      }\n    }\n  }\n\n  // Reconstruct scales if new scaled channels were created during\n  // reinitialization. Preserve existing scale labels, if any.\n  if (newByScale.size) {\n    const newChannelsByScale = new Map();\n    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));\n    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));\n    const newScaleDescriptors = inheritScaleLabels((0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.createScales)(newChannelsByScale, options), scaleDescriptors);\n    const {scales: newExposedScales, ...newScales} = (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.createScaleFunctions)(newScaleDescriptors);\n    Object.assign(scaleDescriptors, newScaleDescriptors);\n    Object.assign(scales, newScales);\n    Object.assign(scales.scales, newExposedScales);\n  }\n\n  // Sort and filter the facets to match the fx and fy domains; this is needed\n  // because the facets were constructed prior to the fx and fy scales.\n  let facetDomains, facetTranslate;\n  if (facets !== undefined) {\n    facetDomains = {x: fx?.domain(), y: fy?.domain()};\n    facets = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.recreateFacets)(facets, facetDomains);\n    facetTranslate = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetTranslator)(fx, fy, dimensions);\n  }\n\n  // Compute value objects, applying scales and projection as needed.\n  for (const [mark, state] of stateByMark) {\n    state.values = mark.scale(state.channels, scales, context);\n  }\n\n  const {width, height} = dimensions;\n\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(svg)\n    .attr(\"class\", className)\n    .attr(\"fill\", \"currentColor\")\n    .attr(\"font-family\", \"system-ui, sans-serif\")\n    .attr(\"font-size\", 10)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", `0 0 ${width} ${height}`)\n    .attr(\"aria-label\", ariaLabel)\n    .attr(\"aria-description\", ariaDescription)\n    .call((svg) =>\n      // Warning: if you edit this, change defaultClassName.\n      svg.append(\"style\").text(\n        `:where(.${className}) {\n  --plot-background: white;\n  display: block;\n  height: auto;\n  height: intrinsic;\n  max-width: 100%;\n}\n:where(.${className} text),\n:where(.${className} tspan) {\n  white-space: pre;\n}`\n      )\n    )\n    .call(_style_js__WEBPACK_IMPORTED_MODULE_1__.applyInlineStyles, style);\n\n  // Render marks.\n  for (const mark of marks) {\n    const {channels, values, facets: indexes} = stateByMark.get(mark);\n\n    // Render a non-faceted mark.\n    if (facets === undefined || mark.facet === \"super\") {\n      let index = null;\n      if (indexes) {\n        index = indexes[0];\n        index = mark.filter(index, channels, values);\n        if (index.length === 0) continue;\n      }\n      const node = mark.render(index, scales, values, superdimensions, context);\n      if (node == null) continue;\n      svg.appendChild(node);\n    }\n\n    // Render a faceted mark.\n    else {\n      let g;\n      for (const f of facets) {\n        if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty)) continue;\n        let index = null;\n        if (indexes) {\n          const faceted = facetStateByMark.has(mark);\n          index = indexes[faceted ? f.i : 0];\n          index = mark.filter(index, channels, values);\n          if (index.length === 0) continue;\n          if (!faceted && index === indexes[0]) index = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.subarray)(index); // copy before assigning fx, fy, fi\n          (index.fx = f.x), (index.fy = f.y), (index.fi = f.i);\n        }\n        const node = mark.render(index, scales, values, subdimensions, context);\n        if (node == null) continue;\n        // Lazily construct the shared group (to drop empty marks).\n        (g ??= (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(svg).append(\"g\")).append(() => node).datum(f);\n        // Promote ARIA attributes and mark transform to avoid repetition on\n        // each facet; this assumes that these attributes are consistent across\n        // facets, but that should be the case!\n        for (const name of [\"aria-label\", \"aria-description\", \"aria-hidden\", \"transform\"]) {\n          if (node.hasAttribute(name)) {\n            g.attr(name, node.getAttribute(name));\n            node.removeAttribute(name);\n          }\n        }\n      }\n      g?.selectChildren().each(facetTranslate);\n    }\n  }\n\n  // Wrap the plot in a figure, if needed.\n  const legends = (0,_legends_js__WEBPACK_IMPORTED_MODULE_9__.createLegends)(scaleDescriptors, context, options);\n  const {figure: figured = title != null || subtitle != null || caption != null || legends.length > 0} = options;\n  if (figured) {\n    figure = document.createElement(\"figure\");\n    figure.className = `${className}-figure`;\n    figure.style.maxWidth = \"initial\"; // avoid Observable default style\n    if (title != null) figure.append(createTitleElement(document, title, \"h2\"));\n    if (subtitle != null) figure.append(createTitleElement(document, subtitle, \"h3\"));\n    figure.append(...legends, svg);\n    if (caption != null) figure.append(createFigcaption(document, caption));\n    if (\"value\" in svg) (figure.value = svg.value), delete svg.value;\n  }\n\n  figure.scale = (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.exposeScales)(scales.scales);\n  figure.legend = (0,_legends_js__WEBPACK_IMPORTED_MODULE_9__.exposeLegends)(scaleDescriptors, context, options);\n\n  const w = (0,_warnings_js__WEBPACK_IMPORTED_MODULE_10__.consumeWarnings)();\n  if (w > 0) {\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(svg)\n      .append(\"text\")\n      .attr(\"x\", width)\n      .attr(\"y\", 20)\n      .attr(\"dy\", \"-1em\")\n      .attr(\"text-anchor\", \"end\")\n      .attr(\"font-family\", \"initial\") // fix emoji rendering in Chrome\n      .text(\"\\u26a0\\ufe0f\") // emoji variation selector\n      .append(\"title\")\n      .text(`${w.toLocaleString(\"en-US\")} warning${w === 1 ? \"\" : \"s\"}. Please check the console.`);\n  }\n\n  return figure;\n}\n\nfunction createTitleElement(document, contents, tag) {\n  if (contents.ownerDocument) return contents;\n  const e = document.createElement(tag);\n  e.append(contents);\n  return e;\n}\n\nfunction createFigcaption(document, caption) {\n  const e = document.createElement(\"figcaption\");\n  e.append(caption);\n  return e;\n}\n\nfunction flatMarks(marks) {\n  return marks\n    .flat(Infinity)\n    .filter((mark) => mark != null)\n    .map(markify);\n}\n\nfunction markify(mark) {\n  return typeof mark.render === \"function\" ? mark : new Render(mark);\n}\n\nclass Render extends _mark_js__WEBPACK_IMPORTED_MODULE_11__.Mark {\n  constructor(render) {\n    if (typeof render !== \"function\") throw new TypeError(\"invalid mark; missing render function\");\n    super();\n    this.render = render;\n  }\n  render() {}\n}\n\n// Note: mutates channel.value to apply the scale transform, if any.\nfunction applyScaleTransforms(channels, options) {\n  for (const name in channels) applyScaleTransform(channels[name], options);\n  return channels;\n}\n\n// Note: mutates channel.value to apply the scale transform, if any. Also sets\n// channel.transform to false to prevent duplicate transform application.\nfunction applyScaleTransform(channel, options) {\n  const {scale, transform: t = true} = channel;\n  if (scale == null || !t) return;\n  const {\n    type,\n    percent,\n    interval,\n    transform = percent ? (x) => (x == null ? NaN : x * 100) : (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.maybeIntervalTransform)(interval, type)\n  } = options[scale] ?? {};\n  if (transform == null) return;\n  channel.value = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.map)(channel.value, transform);\n  channel.transform = false;\n}\n\n// An initializer may generate channels without knowing how the downstream mark\n// will use them. Marks are typically responsible associated scales with\n// channels, but here we assume common behavior across marks.\nfunction inferChannelScales(channels) {\n  for (const name in channels) {\n    (0,_channel_js__WEBPACK_IMPORTED_MODULE_12__.inferChannelScale)(name, channels[name]);\n  }\n}\n\nfunction addScaleChannels(channelsByScale, stateByMark, options, filter = _options_js__WEBPACK_IMPORTED_MODULE_4__.yes) {\n  for (const {channels} of stateByMark.values()) {\n    for (const name in channels) {\n      const channel = channels[name];\n      const {scale} = channel;\n      if (scale != null && filter(scale)) {\n        // Geo marks affect the default x and y domains if there is no\n        // projection. Skip this (as an optimization) when a projection is\n        // specified, or when the domains for x and y are specified.\n        if (scale === \"projection\") {\n          if (!(0,_projection_js__WEBPACK_IMPORTED_MODULE_8__.hasProjection)(options)) {\n            const gx = options.x?.domain === undefined;\n            const gy = options.y?.domain === undefined;\n            if (gx || gy) {\n              const [x, y] = (0,_projection_js__WEBPACK_IMPORTED_MODULE_8__.getGeometryChannels)(channel);\n              if (gx) addScaleChannel(channelsByScale, \"x\", x);\n              if (gy) addScaleChannel(channelsByScale, \"y\", y);\n            }\n          }\n        } else {\n          addScaleChannel(channelsByScale, scale, channel);\n        }\n      }\n    }\n  }\n  return channelsByScale;\n}\n\nfunction addScaleChannel(channelsByScale, scale, channel) {\n  const scaleChannels = channelsByScale.get(scale);\n  if (scaleChannels !== undefined) scaleChannels.push(channel);\n  else channelsByScale.set(scale, [channel]);\n}\n\n// Returns the facet groups, and possibly fx and fy channels, associated with\n// the top-level facet option {data, x, y}.\nfunction maybeTopFacet(facet, options) {\n  if (facet == null) return;\n  const {x, y} = facet;\n  if (x == null && y == null) return;\n  const data = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.dataify)(facet.data);\n  if (data == null) throw new Error(\"missing facet data\");\n  const channels = {};\n  if (x != null) channels.fx = (0,_channel_js__WEBPACK_IMPORTED_MODULE_12__.createChannel)(data, {value: x, scale: \"fx\"});\n  if (y != null) channels.fy = (0,_channel_js__WEBPACK_IMPORTED_MODULE_12__.createChannel)(data, {value: y, scale: \"fy\"});\n  applyScaleTransforms(channels, options);\n  const groups = (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetGroups)(data, channels);\n  return {channels, groups, data: facet.data};\n}\n\n// Returns the facet groups, and possibly fx and fy channels, associated with a\n// mark, either through top-level faceting or mark-level facet options {fx, fy}.\nfunction maybeMarkFacet(mark, topFacetState, options) {\n  if (mark.facet === null || mark.facet === \"super\") return;\n\n  // This mark defines a mark-level facet. TODO There’s some code duplication\n  // here with maybeTopFacet that we could reduce.\n  const {fx, fy} = mark;\n  if (fx != null || fy != null) {\n    const data = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.dataify)(mark.data ?? fx ?? fy);\n    if (data === undefined) throw new Error(`missing facet data in ${mark.ariaLabel}`);\n    if (data === null) return; // ignore channel definitions if no data is provided TODO this right?\n    const channels = {};\n    if (fx != null) channels.fx = (0,_channel_js__WEBPACK_IMPORTED_MODULE_12__.createChannel)(data, {value: fx, scale: \"fx\"});\n    if (fy != null) channels.fy = (0,_channel_js__WEBPACK_IMPORTED_MODULE_12__.createChannel)(data, {value: fy, scale: \"fy\"});\n    applyScaleTransforms(channels, options);\n    return {channels, groups: (0,_facet_js__WEBPACK_IMPORTED_MODULE_2__.facetGroups)(data, channels)};\n  }\n\n  // This mark links to a top-level facet, if present.\n  if (topFacetState === undefined) return;\n\n  // TODO Can we link the top-level facet channels here?\n  const {channels, groups, data} = topFacetState;\n  if (mark.facet !== \"auto\" || mark.data === data) return {channels, groups};\n\n  // Warn for the common pitfall of wanting to facet mapped data with the\n  // top-level facet option.\n  if (\n    data.length > 0 &&\n    (groups.size > 1 || (groups.size === 1 && channels.fx && channels.fy && [...groups][0][1].size > 1)) &&\n    (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.lengthof)((0,_options_js__WEBPACK_IMPORTED_MODULE_4__.dataify)(mark.data)) === (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.lengthof)(data)\n  ) {\n    (0,_warnings_js__WEBPACK_IMPORTED_MODULE_10__.warn)(\n      `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn’t faceted. The mark data has the same length as the facet data and the mark facet option is \"auto\", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`\n    );\n  }\n}\n\nfunction derive(mark, options = {}) {\n  return (0,_transforms_basic_js__WEBPACK_IMPORTED_MODULE_13__.initializer)({...options, x: null, y: null}, (data, facets, channels, scales, dimensions, context) => {\n    return context.getMarkState(mark);\n  });\n}\n\nfunction inferTips(marks) {\n  const tips = [];\n  for (const mark of marks) {\n    let tipOptions = mark.tip;\n    if (tipOptions) {\n      if (tipOptions === true) tipOptions = {};\n      else if (typeof tipOptions === \"string\") tipOptions = {pointer: tipOptions};\n      let {pointer: p, preferredAnchor: a} = tipOptions;\n      p = /^x$/i.test(p) ? _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_14__.pointerX : /^y$/i.test(p) ? _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_14__.pointerY : _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_14__.pointer; // TODO validate?\n      tipOptions = p(derive(mark, tipOptions));\n      tipOptions.title = null; // prevent implicit title for primitive data\n      if (a === undefined) tipOptions.preferredAnchor = p === _interactions_pointer_js__WEBPACK_IMPORTED_MODULE_14__.pointerY ? \"left\" : \"bottom\";\n      const t = (0,_marks_tip_js__WEBPACK_IMPORTED_MODULE_15__.tip)(mark.data, tipOptions);\n      t.facet = mark.facet; // inherit facet settings\n      t.facetAnchor = mark.facetAnchor; // inherit facet settings\n      tips.push(t);\n    }\n  }\n  return tips;\n}\n\nfunction inferAxes(marks, channelsByScale, options) {\n  let {\n    projection,\n    x = {},\n    y = {},\n    fx = {},\n    fy = {},\n    axis,\n    grid,\n    facet = {},\n    facet: {axis: facetAxis = axis, grid: facetGrid} = facet,\n    x: {axis: xAxis = axis, grid: xGrid = xAxis === null ? null : grid} = x,\n    y: {axis: yAxis = axis, grid: yGrid = yAxis === null ? null : grid} = y,\n    fx: {axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid} = fx,\n    fy: {axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid} = fy\n  } = options;\n\n  // Disable axes if the corresponding scale is not present.\n  if (projection || (!(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isScaleOptions)(x) && !hasPositionChannel(\"x\", marks))) xAxis = xGrid = null;\n  if (projection || (!(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isScaleOptions)(y) && !hasPositionChannel(\"y\", marks))) yAxis = yGrid = null;\n  if (!channelsByScale.has(\"fx\")) fxAxis = fxGrid = null;\n  if (!channelsByScale.has(\"fy\")) fyAxis = fyGrid = null;\n\n  // Resolve the default implicit axes by checking for explicit ones.\n  if (xAxis === undefined) xAxis = !hasAxis(marks, \"x\");\n  if (yAxis === undefined) yAxis = !hasAxis(marks, \"y\");\n  if (fxAxis === undefined) fxAxis = !hasAxis(marks, \"fx\");\n  if (fyAxis === undefined) fyAxis = !hasAxis(marks, \"fy\");\n\n  // Resolve the default orientation of axes.\n  if (xAxis === true) xAxis = \"bottom\";\n  if (yAxis === true) yAxis = \"left\";\n  if (fxAxis === true) fxAxis = xAxis === \"top\" || xAxis === null ? \"bottom\" : \"top\";\n  if (fyAxis === true) fyAxis = yAxis === \"right\" || yAxis === null ? \"left\" : \"right\";\n\n  const axes = [];\n  maybeGrid(axes, fyGrid, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.gridFy, fy);\n  maybeAxis(axes, fyAxis, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisFy, \"right\", \"left\", facet, fy);\n  maybeGrid(axes, fxGrid, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.gridFx, fx);\n  maybeAxis(axes, fxAxis, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisFx, \"top\", \"bottom\", facet, fx);\n  maybeGrid(axes, yGrid, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.gridY, y);\n  maybeAxis(axes, yAxis, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisY, \"left\", \"right\", options, y);\n  maybeGrid(axes, xGrid, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.gridX, x);\n  maybeAxis(axes, xAxis, _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisX, \"bottom\", \"top\", options, x);\n  return axes;\n}\n\nfunction maybeAxis(axes, axis, axisType, primary, secondary, defaults, options) {\n  if (!axis) return;\n  const both = isBoth(axis);\n  options = axisOptions(both ? primary : axis, defaults, options);\n  const {line} = options;\n  if ((axisType === _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisY || axisType === _marks_axis_js__WEBPACK_IMPORTED_MODULE_16__.axisX) && line && !(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isNone)(line)) axes.push((0,_marks_frame_js__WEBPACK_IMPORTED_MODULE_17__.frame)(lineOptions(options)));\n  axes.push(axisType(options));\n  if (both) axes.push(axisType({...options, anchor: secondary, label: null}));\n}\n\nfunction maybeGrid(axes, grid, gridType, options) {\n  if (!grid || (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isNone)(grid)) return;\n  axes.push(gridType(gridOptions(grid, options)));\n}\n\nfunction isBoth(value) {\n  return /^\\s*both\\s*$/i.test(value);\n}\n\nfunction axisOptions(\n  anchor,\n  defaults,\n  {\n    line = defaults.line,\n    ticks,\n    tickSize,\n    tickSpacing,\n    tickPadding,\n    tickFormat,\n    tickRotate,\n    fontVariant,\n    ariaLabel,\n    ariaDescription,\n    label = defaults.label,\n    labelAnchor,\n    labelArrow = defaults.labelArrow,\n    labelOffset\n  }\n) {\n  return {\n    anchor,\n    line,\n    ticks,\n    tickSize,\n    tickSpacing,\n    tickPadding,\n    tickFormat,\n    tickRotate,\n    fontVariant,\n    ariaLabel,\n    ariaDescription,\n    label,\n    labelAnchor,\n    labelArrow,\n    labelOffset\n  };\n}\n\nfunction lineOptions(options) {\n  const {anchor, line} = options;\n  return {anchor, facetAnchor: anchor + \"-empty\", stroke: line === true ? undefined : line};\n}\n\nfunction gridOptions(\n  grid,\n  {\n    stroke = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isColor)(grid) ? grid : undefined,\n    ticks = isGridTicks(grid) ? grid : undefined,\n    tickSpacing,\n    ariaLabel,\n    ariaDescription\n  }\n) {\n  return {\n    stroke,\n    ticks,\n    tickSpacing,\n    ariaLabel,\n    ariaDescription\n  };\n}\n\nfunction isGridTicks(grid) {\n  switch (typeof grid) {\n    case \"number\":\n      return true;\n    case \"string\":\n      return !(0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isColor)(grid);\n  }\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.isIterable)(grid) || typeof grid?.range === \"function\";\n}\n\n// Is there an explicit axis already present? TODO We probably want a more\n// explicit test than looking for the ARIA label, but it does afford some\n// flexibility in axis implementation which is nice.\nfunction hasAxis(marks, k) {\n  const prefix = `${k}-axis `;\n  return marks.some((m) => m.ariaLabel?.startsWith(prefix));\n}\n\nfunction hasPositionChannel(k, marks) {\n  for (const mark of marks) {\n    for (const key in mark.channels) {\n      const {scale} = mark.channels[key];\n      if (scale === k || scale === \"projection\") {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction inheritScaleLabels(newScales, scales) {\n  for (const key in newScales) {\n    const newScale = newScales[key];\n    const scale = scales[key];\n    if (newScale.label === undefined && scale) {\n      newScale.label = scale.label;\n    }\n  }\n  return newScales;\n}\n\n// This differs from the other outerDimensions in that it accounts for rounding\n// and outer padding in the facet scales; we want the frame to align exactly\n// with the actual range, not the desired range.\nfunction actualDimensions({fx, fy}, dimensions) {\n  const {marginTop, marginRight, marginBottom, marginLeft, width, height} = (0,_scales_js__WEBPACK_IMPORTED_MODULE_5__.outerDimensions)(dimensions);\n  const fxr = fx && outerRange(fx);\n  const fyr = fy && outerRange(fy);\n  return {\n    marginTop: fy ? fyr[0] : marginTop,\n    marginRight: fx ? width - fxr[1] : marginRight,\n    marginBottom: fy ? height - fyr[1] : marginBottom,\n    marginLeft: fx ? fxr[0] : marginLeft,\n    // Some marks, namely the x- and y-axis labels, want to know what the\n    // desired (rather than actual) margins are for positioning.\n    inset: {\n      marginTop: dimensions.marginTop,\n      marginRight: dimensions.marginRight,\n      marginBottom: dimensions.marginBottom,\n      marginLeft: dimensions.marginLeft\n    },\n    width,\n    height\n  };\n}\n\nfunction outerRange(scale) {\n  const domain = scale.domain();\n  if (domain.length === 0) return [0, scale.bandwidth()];\n  let x1 = scale(domain[0]);\n  let x2 = scale(domain[domain.length - 1]);\n  if (x2 < x1) [x1, x2] = [x2, x1];\n  return [x1, x2 + scale.bandwidth()];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9wbG90LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDa0I7QUFDbkI7QUFDTTtBQUNnRTtBQUMzQztBQUNaO0FBQzNCO0FBQzREO0FBQ3BEO0FBQ0o7QUFDc0M7QUFDa0I7QUFDUTtBQUNOO0FBQ2hDO0FBQ1c7QUFDWDtBQUNYO0FBQ0U7O0FBRTdDLDBCQUEwQjtBQUNqQyxTQUFTLG9FQUFvRTs7QUFFN0U7QUFDQSxvQkFBb0IseURBQWM7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVk7O0FBRTNCO0FBQ0EsMkNBQTJDLHNEQUFXOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxzREFBVztBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdURBQVk7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsUUFBUSwyREFBYztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsV0FBVyxzQ0FBc0M7QUFDakQsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEOztBQUVBO0FBQ0EsMkJBQTJCLHdEQUFZO0FBQ3ZDLHFCQUFxQixnRUFBZ0I7O0FBRXJDLEVBQUUsMERBQWM7O0FBRWhCLGlCQUFpQixnRUFBb0I7QUFDckMsU0FBUyxRQUFRO0FBQ2pCLG1DQUFtQywyREFBZTtBQUNsRDs7QUFFQTtBQUNBLGtCQUFrQiwwREFBYTtBQUMvQjtBQUNBLGNBQWMsMkNBQU87QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWdCOztBQUV2QztBQUNBO0FBQ0EsV0FBVywyQ0FBTyxvQkFBb0IsNERBQVk7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0RBQVcsVUFBVSxrQkFBa0Isc0RBQVcsaUJBQWlCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4Rjs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUIsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0REFBVSxDQUFDLHNEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdEQUFZO0FBQy9ELFdBQVcsd0NBQXdDLEVBQUUsZ0VBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsYUFBYSx5REFBYztBQUMzQixxQkFBcUIsMERBQWU7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxlQUFlOztBQUV4QixFQUFFLDBDQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxFQUFFLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVUsd0RBQWlCOztBQUUzQjtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFEQUFRLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQU07QUFDckI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwwREFBYTtBQUMvQixTQUFTLDhGQUE4RjtBQUN2RztBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0RBQVk7QUFDN0Isa0JBQWtCLDBEQUFhOztBQUUvQixZQUFZLDhEQUFlO0FBQzNCO0FBQ0EsSUFBSSwwQ0FBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQixTQUFTLG1CQUFtQjtBQUN0RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJDQUFJO0FBQ3pCO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG1FQUFzQjtBQUNyRixJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsZ0RBQUc7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBaUI7QUFDckI7QUFDQTs7QUFFQSwwRUFBMEUsNENBQUc7QUFDN0UsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsZUFBZSxvREFBTztBQUN0QjtBQUNBO0FBQ0EsK0JBQStCLDJEQUFhLFFBQVEsc0JBQXNCO0FBQzFFLCtCQUErQiwyREFBYSxRQUFRLHNCQUFzQjtBQUMxRTtBQUNBLGlCQUFpQixzREFBVztBQUM1QixVQUFVO0FBQ1Y7O0FBRUE7QUFDQSx3RUFBd0UsT0FBTztBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQSxpQkFBaUIsb0RBQU87QUFDeEIscUVBQXFFLGVBQWU7QUFDcEYsK0JBQStCO0FBQy9CO0FBQ0Esa0NBQWtDLDJEQUFhLFFBQVEsdUJBQXVCO0FBQzlFLGtDQUFrQywyREFBYSxRQUFRLHVCQUF1QjtBQUM5RTtBQUNBLFlBQVksa0JBQWtCLHNEQUFXO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQywyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFRLENBQUMsb0RBQU8saUJBQWlCLHFEQUFRO0FBQzdDO0FBQ0EsSUFBSSxtREFBSTtBQUNSLHNCQUFzQixnQkFBZ0IsZ1FBQWdRO0FBQ3RTO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsU0FBUyxrRUFBVyxFQUFFLDZCQUE2QjtBQUNuRDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsV0FBVyxnQ0FBZ0M7QUFDM0MsMkJBQTJCLCtEQUFRLG9CQUFvQiwrREFBUSxHQUFHLDhEQUFPLEVBQUU7QUFDM0U7QUFDQSwrQkFBK0I7QUFDL0IsOERBQThELCtEQUFRO0FBQ3RFLGdCQUFnQixtREFBRztBQUNuQiw0QkFBNEI7QUFDNUIsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVixXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWSx5Q0FBeUM7QUFDckQsUUFBUSxnRUFBZ0U7QUFDeEUsUUFBUSxnRUFBZ0U7QUFDeEUsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsSUFBSTs7QUFFSjtBQUNBLHNCQUFzQiwyREFBYztBQUNwQyxzQkFBc0IsMkRBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsbURBQU07QUFDaEMsMEJBQTBCLG1EQUFNO0FBQ2hDLDBCQUEwQixtREFBTTtBQUNoQywwQkFBMEIsbURBQU07QUFDaEMseUJBQXlCLGtEQUFLO0FBQzlCLHlCQUF5QixrREFBSztBQUM5Qix5QkFBeUIsa0RBQUs7QUFDOUIseUJBQXlCLGtEQUFLO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZixvQkFBb0Isa0RBQUssaUJBQWlCLGtEQUFLLGNBQWMsbURBQU0sa0JBQWtCLHVEQUFLO0FBQzFGO0FBQ0EsZ0NBQWdDLDJDQUEyQztBQUMzRTs7QUFFQTtBQUNBLGVBQWUsbURBQU07QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsY0FBYztBQUN2QixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFPO0FBQ3JCO0FBQ0EsU0FBUyx1REFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEMsU0FBUyxpRUFBaUUsRUFBRSwyREFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3Bsb3QuanM/NTJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0b3IsIGdlb1BhdGgsIHNlbGVjdH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZUNoYW5uZWwsIGluZmVyQ2hhbm5lbFNjYWxlfSBmcm9tIFwiLi9jaGFubmVsLmpzXCI7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCB7Y3JlYXRlRGltZW5zaW9uc30gZnJvbSBcIi4vZGltZW5zaW9ucy5qc1wiO1xuaW1wb3J0IHtjcmVhdGVGYWNldHMsIHJlY3JlYXRlRmFjZXRzLCBmYWNldEV4Y2x1ZGUsIGZhY2V0R3JvdXBzLCBmYWNldFRyYW5zbGF0b3IsIGZhY2V0RmlsdGVyfSBmcm9tIFwiLi9mYWNldC5qc1wiO1xuaW1wb3J0IHtwb2ludGVyLCBwb2ludGVyWCwgcG9pbnRlcll9IGZyb20gXCIuL2ludGVyYWN0aW9ucy9wb2ludGVyLmpzXCI7XG5pbXBvcnQge2NyZWF0ZUxlZ2VuZHMsIGV4cG9zZUxlZ2VuZHN9IGZyb20gXCIuL2xlZ2VuZHMuanNcIjtcbmltcG9ydCB7TWFya30gZnJvbSBcIi4vbWFyay5qc1wiO1xuaW1wb3J0IHtheGlzRngsIGF4aXNGeSwgYXhpc1gsIGF4aXNZLCBncmlkRngsIGdyaWRGeSwgZ3JpZFgsIGdyaWRZfSBmcm9tIFwiLi9tYXJrcy9heGlzLmpzXCI7XG5pbXBvcnQge2ZyYW1lfSBmcm9tIFwiLi9tYXJrcy9mcmFtZS5qc1wiO1xuaW1wb3J0IHt0aXB9IGZyb20gXCIuL21hcmtzL3RpcC5qc1wiO1xuaW1wb3J0IHtpc0NvbG9yLCBpc0l0ZXJhYmxlLCBpc05vbmUsIGlzU2NhbGVPcHRpb25zfSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2RhdGFpZnksIGxlbmd0aG9mLCBtYXAsIHllcywgbWF5YmVJbnRlcnZhbFRyYW5zZm9ybSwgc3ViYXJyYXl9IGZyb20gXCIuL29wdGlvbnMuanNcIjtcbmltcG9ydCB7Y3JlYXRlUHJvamVjdGlvbiwgZ2V0R2VvbWV0cnlDaGFubmVscywgaGFzUHJvamVjdGlvbiwgeHlQcm9qZWN0aW9ufSBmcm9tIFwiLi9wcm9qZWN0aW9uLmpzXCI7XG5pbXBvcnQge2NyZWF0ZVNjYWxlcywgY3JlYXRlU2NhbGVGdW5jdGlvbnMsIGF1dG9TY2FsZVJhbmdlLCBleHBvc2VTY2FsZXN9IGZyb20gXCIuL3NjYWxlcy5qc1wiO1xuaW1wb3J0IHtpbm5lckRpbWVuc2lvbnMsIG91dGVyRGltZW5zaW9uc30gZnJvbSBcIi4vc2NhbGVzLmpzXCI7XG5pbXBvcnQge2lzUG9zaXRpb24sIHJlZ2lzdHJ5IGFzIHNjYWxlUmVnaXN0cnl9IGZyb20gXCIuL3NjYWxlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHthcHBseUlubGluZVN0eWxlcywgbWF5YmVDbGFzc05hbWV9IGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQge2luaXRpYWxpemVyfSBmcm9tIFwiLi90cmFuc2Zvcm1zL2Jhc2ljLmpzXCI7XG5pbXBvcnQge2NvbnN1bWVXYXJuaW5ncywgd2Fybn0gZnJvbSBcIi4vd2FybmluZ3MuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBsb3Qob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtmYWNldCwgc3R5bGUsIHRpdGxlLCBzdWJ0aXRsZSwgY2FwdGlvbiwgYXJpYUxhYmVsLCBhcmlhRGVzY3JpcHRpb259ID0gb3B0aW9ucztcblxuICAvLyBjbGFzc05hbWUgZm9yIGlubGluZSBzdHlsZXNcbiAgY29uc3QgY2xhc3NOYW1lID0gbWF5YmVDbGFzc05hbWUob3B0aW9ucy5jbGFzc05hbWUpO1xuXG4gIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBtYXJrcy5cbiAgY29uc3QgbWFya3MgPSBvcHRpb25zLm1hcmtzID09PSB1bmRlZmluZWQgPyBbXSA6IGZsYXRNYXJrcyhvcHRpb25zLm1hcmtzKTtcblxuICAvLyBBZGQgaW1wbGljaXQgdGlwcy5cbiAgbWFya3MucHVzaCguLi5pbmZlclRpcHMobWFya3MpKTtcblxuICAvLyBDb21wdXRlIHRoZSB0b3AtbGV2ZWwgZmFjZXQgc3RhdGUuIFRoaXMgaGFzIHJvdWdobHkgdGhlIHNhbWUgc3RydWN0dXJlIGFzXG4gIC8vIG1hcmstc3BlY2lmaWMgZmFjZXQgc3RhdGUsIGV4Y2VwdCB0aGVyZSBpc27igJl0IGEgZmFjZXRzSW5kZXgsIGFuZCB0aGVyZeKAmXMgYVxuICAvLyBkYXRhIGFuZCBkYXRhTGVuZ3RoIHNvIHdlIGNhbiB3YXJuIHRoZSB1c2VyIGlmIGEgZGlmZmVyZW50IGRhdGEgb2YgdGhlIHNhbWVcbiAgLy8gbGVuZ3RoIGlzIHVzZWQgaW4gYSBtYXJrLlxuICBjb25zdCB0b3BGYWNldFN0YXRlID0gbWF5YmVUb3BGYWNldChmYWNldCwgb3B0aW9ucyk7XG5cbiAgLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gKGZhY2V0ZWQpIE1hcmsgaW5zdGFuY2UgdG8gZmFjZXQgc3RhdGUsIGluY2x1ZGluZzpcbiAgLy8gY2hhbm5lbHMgLSBhbiB7Zng/LCBmeT99IG9iamVjdCB0byBhZGQgdG8gdGhlIGZ4IGFuZCBmeSBzY2FsZVxuICAvLyBncm91cHMgLSBhIHBvc3NpYmx5LW5lc3RlZCBtYXAgZnJvbSBmYWNldCB2YWx1ZXMgdG8gaW5kZXhlcyBpbiB0aGUgZGF0YSBhcnJheVxuICAvLyBmYWNldHNJbmRleCAtIGEgc3BhcnNlIG5lc3RlZCBhcnJheSBvZiBpbmRpY2VzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbGlkIGZhY2V0c1xuICBjb25zdCBmYWNldFN0YXRlQnlNYXJrID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICBjb25zdCBmYWNldFN0YXRlID0gbWF5YmVNYXJrRmFjZXQobWFyaywgdG9wRmFjZXRTdGF0ZSwgb3B0aW9ucyk7XG4gICAgaWYgKGZhY2V0U3RhdGUpIGZhY2V0U3RhdGVCeU1hcmsuc2V0KG1hcmssIGZhY2V0U3RhdGUpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBhIE1hcCBmcm9tIHNjYWxlIG5hbWUgdG8gYW4gYXJyYXkgb2YgYXNzb2NpYXRlZCBjaGFubmVscy5cbiAgY29uc3QgY2hhbm5lbHNCeVNjYWxlID0gbmV3IE1hcCgpO1xuICBpZiAodG9wRmFjZXRTdGF0ZSkgYWRkU2NhbGVDaGFubmVscyhjaGFubmVsc0J5U2NhbGUsIFt0b3BGYWNldFN0YXRlXSwgb3B0aW9ucyk7XG4gIGFkZFNjYWxlQ2hhbm5lbHMoY2hhbm5lbHNCeVNjYWxlLCBmYWNldFN0YXRlQnlNYXJrLCBvcHRpb25zKTtcblxuICAvLyBBZGQgaW1wbGljaXQgYXhpcyBtYXJrcy4gQmVjYXVzZSB0aGlzIGhhcHBlbnMgYWZ0ZXIgZmFjZXRpbmcgKGJlY2F1c2UgaXRcbiAgLy8gZGVwZW5kcyBvbiB3aGV0aGVyIGZhY2V0aW5nIGlzIHByZXNlbnQpLCB3ZSBtdXN0IGluaXRpYWxpemUgdGhlIGZhY2V0IHN0YXRlXG4gIC8vIG9mIGFueSBpbXBsaWNpdCBheGVzLCB0b28uXG4gIGNvbnN0IGF4ZXMgPSBmbGF0TWFya3MoaW5mZXJBeGVzKG1hcmtzLCBjaGFubmVsc0J5U2NhbGUsIG9wdGlvbnMpKTtcbiAgZm9yIChjb25zdCBtYXJrIG9mIGF4ZXMpIHtcbiAgICBjb25zdCBmYWNldFN0YXRlID0gbWF5YmVNYXJrRmFjZXQobWFyaywgdG9wRmFjZXRTdGF0ZSwgb3B0aW9ucyk7XG4gICAgaWYgKGZhY2V0U3RhdGUpIGZhY2V0U3RhdGVCeU1hcmsuc2V0KG1hcmssIGZhY2V0U3RhdGUpO1xuICB9XG4gIG1hcmtzLnVuc2hpZnQoLi4uYXhlcyk7XG5cbiAgLy8gQWxsIHRoZSBwb3NzaWJsZSBmYWNldHMgYXJlIGdpdmVuIGJ5IHRoZSBkb21haW5zIG9mIHRoZSBmeCBvciBmeSBzY2FsZXMsIG9yXG4gIC8vIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHRoZXNlIGRvbWFpbnMgaWYgd2UgZmFjZXQgYnkgYm90aCB4IGFuZCB5LiBXZSBzb3J0XG4gIC8vIHRoZW0gaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGZhY2V0IGZpbHRlcnMgYWZ0ZXJ3YXJkcy5cbiAgbGV0IGZhY2V0cyA9IGNyZWF0ZUZhY2V0cyhjaGFubmVsc0J5U2NhbGUsIG9wdGlvbnMpO1xuXG4gIGlmIChmYWNldHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHRvcEZhY2V0c0luZGV4ID0gdG9wRmFjZXRTdGF0ZSA/IGZhY2V0RmlsdGVyKGZhY2V0cywgdG9wRmFjZXRTdGF0ZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBDb21wdXRlIGEgZmFjZXQgaW5kZXggZm9yIGVhY2ggbWFyaywgcGFyYWxsZWwgdG8gdGhlIGZhY2V0cyBhcnJheS4gRm9yXG4gICAgLy8gbWFyay1sZXZlbCBmYWNldHMsIGNvbXB1dGUgYW4gaW5kZXggZm9yIHRoYXQgbWFya+KAmXMgZGF0YSBhbmQgb3B0aW9ucy5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0aGUgdG9wLWxldmVsIGZhY2V0IGluZGV4LlxuICAgIGZvciAoY29uc3QgbWFyayBvZiBtYXJrcykge1xuICAgICAgaWYgKG1hcmsuZmFjZXQgPT09IG51bGwgfHwgbWFyay5mYWNldCA9PT0gXCJzdXBlclwiKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGZhY2V0U3RhdGUgPSBmYWNldFN0YXRlQnlNYXJrLmdldChtYXJrKTtcbiAgICAgIGlmIChmYWNldFN0YXRlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgZmFjZXRTdGF0ZS5mYWNldHNJbmRleCA9IG1hcmsuZnggIT0gbnVsbCB8fCBtYXJrLmZ5ICE9IG51bGwgPyBmYWNldEZpbHRlcihmYWNldHMsIGZhY2V0U3RhdGUpIDogdG9wRmFjZXRzSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gVGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIGRvbWFpbnMgb2YgZnggYW5kIGZ5IGNhbiBpbmNsdWRlIGZ4LWZ5XG4gICAgLy8gY29tYmluYXRpb25zIGZvciB3aGljaCBubyBtYXJrIGhhcyBhbiBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhhdFxuICAgIC8vIGNvbWJpbmF0aW9uLCBhbmQgdGhlcmVmb3JlIHdlIGRvbuKAmXQgd2FudCB0byByZW5kZXIgdGhpcyBmYWNldCAobm90IGV2ZW5cbiAgICAvLyB0aGUgZnJhbWUpLiBUaGUgc2FtZSBjYW4gb2NjdXIgaWYgeW91IHNwZWNpZnkgdGhlIGRvbWFpbiBvZiBmeCBhbmQgZnlcbiAgICAvLyBleHBsaWNpdGx5LCBidXQgdGhlcmUgaXMgbm8gbWFyayBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggc29tZSB2YWx1ZXMgaW5cbiAgICAvLyB0aGUgZG9tYWluLiBFeHB1bmdlIGVtcHR5IGZhY2V0cywgYW5kIGNsZWFyIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRzXG4gICAgLy8gZnJvbSB0aGUgbmVzdGVkIGluZGV4IGluIGVhY2ggbWFyay5cbiAgICBjb25zdCBub25FbXB0eSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHtmYWNldHNJbmRleH0gb2YgZmFjZXRTdGF0ZUJ5TWFyay52YWx1ZXMoKSkge1xuICAgICAgZmFjZXRzSW5kZXg/LmZvckVhY2goKGluZGV4LCBpKSA9PiB7XG4gICAgICAgIGlmIChpbmRleD8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5vbkVtcHR5LmFkZChpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIHRoZSBmYWNldHMgYXJlIGVtcHR5IChhcyB3aGVuIG5vbmUgb2YgdGhlIG1hcmtzIGFyZSBhY3R1YWxseVxuICAgIC8vIGZhY2V0ZWQpLCBub25lIG9mIHRoZW0gYXJlIGVtcHR5LlxuICAgIGZhY2V0cy5mb3JFYWNoKFxuICAgICAgMCA8IG5vbkVtcHR5LnNpemUgJiYgbm9uRW1wdHkuc2l6ZSA8IGZhY2V0cy5sZW5ndGhcbiAgICAgICAgPyAoZiwgaSkgPT4gKGYuZW1wdHkgPSAhbm9uRW1wdHkuaGFzKGkpKVxuICAgICAgICA6IChmKSA9PiAoZi5lbXB0eSA9IGZhbHNlKVxuICAgICk7XG5cbiAgICAvLyBGb3IgYW55IG1hcmsgdXNpbmcgdGhlIOKAnGV4Y2x1ZGXigJ0gZmFjZXQgbW9kZSwgaW52ZXJ0IHRoZSBpbmRleC5cbiAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICAgIGlmIChtYXJrLmZhY2V0ID09PSBcImV4Y2x1ZGVcIikge1xuICAgICAgICBjb25zdCBmYWNldFN0YXRlID0gZmFjZXRTdGF0ZUJ5TWFyay5nZXQobWFyayk7XG4gICAgICAgIGlmIChmYWNldFN0YXRlICE9PSB1bmRlZmluZWQpIGZhY2V0U3RhdGUuZmFjZXRzSW5kZXggPSBmYWNldEV4Y2x1ZGUoZmFjZXRTdGF0ZS5mYWNldHNJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBzY2FsZSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIGluIG9wdGlvbnMsIGluaXRpYWxpemUgaXRzIGFzc29jaWF0ZWRcbiAgLy8gY2hhbm5lbHMgdG8gdGhlIGVtcHR5IGFycmF5OyB0aGlzIHdpbGwgZ3VhcmFudGVlIHRoYXQgYSBjb3JyZXNwb25kaW5nIHNjYWxlXG4gIC8vIHdpbGwgYmUgY3JlYXRlZCBsYXRlciAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgY2hhbm5lbHMpLiBJZ25vcmUgZmFjZXRcbiAgLy8gc2NhbGUgZGVjbGFyYXRpb25zLCB3aGljaCBhcmUgaGFuZGxlZCBhYm92ZS5cbiAgZm9yIChjb25zdCBrZXkgb2Ygc2NhbGVSZWdpc3RyeS5rZXlzKCkpIHtcbiAgICBpZiAoaXNTY2FsZU9wdGlvbnMob3B0aW9uc1trZXldKSAmJiBrZXkgIT09IFwiZnhcIiAmJiBrZXkgIT09IFwiZnlcIikge1xuICAgICAgY2hhbm5lbHNCeVNjYWxlLnNldChrZXksIFtdKTtcbiAgICB9XG4gIH1cblxuICAvLyBBIE1hcCBmcm9tIE1hcmsgaW5zdGFuY2UgdG8gaXRzIHJlbmRlciBzdGF0ZSwgaW5jbHVkaW5nOlxuICAvLyBpbmRleCAtIHRoZSBkYXRhIGluZGV4IGUuZy4gWzAsIDEsIDIsIDMsIOKApl1cbiAgLy8gY2hhbm5lbHMgLSBhbiBhcnJheSBvZiBtYXRlcmlhbGl6ZWQgY2hhbm5lbHMgZS5nLiBbW1wieFwiLCB7dmFsdWV9XSwg4oCmXVxuICAvLyBmYWNldGVkIC0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIG1hcmsgaXMgZmFjZXRlZFxuICAvLyB2YWx1ZXMgLSBhbiBvYmplY3Qgb2Ygc2NhbGVkIHZhbHVlcyBlLmcuIHt4OiBbNDAsIDMyLCDigKZdLCDigKZ9XG4gIGNvbnN0IHN0YXRlQnlNYXJrID0gbmV3IE1hcCgpO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIG1hcmtz4oCZIHN0YXRlLlxuICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICBpZiAoc3RhdGVCeU1hcmsuaGFzKG1hcmspKSB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgbWFyazsgZWFjaCBtYXJrIG11c3QgYmUgdW5pcXVlXCIpO1xuICAgIGNvbnN0IHtmYWNldHNJbmRleCwgY2hhbm5lbHM6IGZhY2V0Q2hhbm5lbHN9ID0gZmFjZXRTdGF0ZUJ5TWFyay5nZXQobWFyaykgPz8ge307XG4gICAgY29uc3Qge2RhdGEsIGZhY2V0cywgY2hhbm5lbHN9ID0gbWFyay5pbml0aWFsaXplKGZhY2V0c0luZGV4LCBmYWNldENoYW5uZWxzLCBvcHRpb25zKTtcbiAgICBhcHBseVNjYWxlVHJhbnNmb3JtcyhjaGFubmVscywgb3B0aW9ucyk7XG4gICAgc3RhdGVCeU1hcmsuc2V0KG1hcmssIHtkYXRhLCBmYWNldHMsIGNoYW5uZWxzfSk7XG4gIH1cblxuICAvLyBJbml0YWxpemUgdGhlIHNjYWxlcyBhbmQgZGltZW5zaW9ucy5cbiAgY29uc3Qgc2NhbGVEZXNjcmlwdG9ycyA9IGNyZWF0ZVNjYWxlcyhhZGRTY2FsZUNoYW5uZWxzKGNoYW5uZWxzQnlTY2FsZSwgc3RhdGVCeU1hcmssIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGNyZWF0ZURpbWVuc2lvbnMoc2NhbGVEZXNjcmlwdG9ycywgbWFya3MsIG9wdGlvbnMpO1xuXG4gIGF1dG9TY2FsZVJhbmdlKHNjYWxlRGVzY3JpcHRvcnMsIGRpbWVuc2lvbnMpO1xuXG4gIGNvbnN0IHNjYWxlcyA9IGNyZWF0ZVNjYWxlRnVuY3Rpb25zKHNjYWxlRGVzY3JpcHRvcnMpO1xuICBjb25zdCB7ZngsIGZ5fSA9IHNjYWxlcztcbiAgY29uc3Qgc3ViZGltZW5zaW9ucyA9IGZ4IHx8IGZ5ID8gaW5uZXJEaW1lbnNpb25zKHNjYWxlRGVzY3JpcHRvcnMsIGRpbWVuc2lvbnMpIDogZGltZW5zaW9ucztcbiAgY29uc3Qgc3VwZXJkaW1lbnNpb25zID0gZnggfHwgZnkgPyBhY3R1YWxEaW1lbnNpb25zKHNjYWxlcywgZGltZW5zaW9ucykgOiBkaW1lbnNpb25zO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGNvbnRleHQuXG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG9wdGlvbnMpO1xuICBjb25zdCBkb2N1bWVudCA9IGNvbnRleHQuZG9jdW1lbnQ7XG4gIGNvbnN0IHN2ZyA9IGNyZWF0b3IoXCJzdmdcIikuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICBsZXQgZmlndXJlID0gc3ZnOyAvLyByZXBsYWNlZCB3aXRoIHRoZSBmaWd1cmUgZWxlbWVudCwgaWYgYW55XG4gIGNvbnRleHQub3duZXJTVkdFbGVtZW50ID0gc3ZnO1xuICBjb250ZXh0LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgY29udGV4dC5wcm9qZWN0aW9uID0gY3JlYXRlUHJvamVjdGlvbihvcHRpb25zLCBzdWJkaW1lbnNpb25zKTtcblxuICAvLyBBIHBhdGggZ2VuZXJhdG9yIGZvciBtYXJrcyB0aGF0IHdhbnQgdG8gZHJhdyBHZW9KU09OLlxuICBjb250ZXh0LnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdlb1BhdGgodGhpcy5wcm9qZWN0aW9uID8/IHh5UHJvamVjdGlvbihzY2FsZXMpKTtcbiAgfTtcblxuICAvLyBBbGxvd3MgZS5nLiB0aGUgYXhpcyBtYXJrIHRvIGRldGVybWluZSBmYWNldGluZyBsYXppbHkuXG4gIGNvbnRleHQuZmlsdGVyRmFjZXRzID0gKGRhdGEsIGNoYW5uZWxzKSA9PiB7XG4gICAgcmV0dXJuIGZhY2V0RmlsdGVyKGZhY2V0cywge2NoYW5uZWxzLCBncm91cHM6IGZhY2V0R3JvdXBzKGRhdGEsIGNoYW5uZWxzKX0pO1xuICB9O1xuXG4gIC8vIEFsbG93cyBlLmcuIHRoZSB0aXAgbWFyayB0byByZWZlcmVuY2UgY2hhbm5lbHMgYW5kIGRhdGEgb24gb3RoZXIgbWFya3MuXG4gIGNvbnRleHQuZ2V0TWFya1N0YXRlID0gKG1hcmspID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlQnlNYXJrLmdldChtYXJrKTtcbiAgICBjb25zdCBmYWNldFN0YXRlID0gZmFjZXRTdGF0ZUJ5TWFyay5nZXQobWFyayk7XG4gICAgcmV0dXJuIHsuLi5zdGF0ZSwgY2hhbm5lbHM6IHsuLi5zdGF0ZS5jaGFubmVscywgLi4uZmFjZXRTdGF0ZT8uY2hhbm5lbHN9fTtcbiAgfTtcblxuICAvLyBBbGxvd3MgZS5nLiB0aGUgcG9pbnRlciB0cmFuc2Zvcm0gdG8gc3VwcG9ydCB2aWV3b2YuXG4gIGNvbnRleHQuZGlzcGF0Y2hWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChmaWd1cmUudmFsdWUgPT09IHZhbHVlKSByZXR1cm47XG4gICAgZmlndXJlLnZhbHVlID0gdmFsdWU7XG4gICAgZmlndXJlLmRpc3BhdGNoRXZlbnQobmV3IGNvbnRleHQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKTtcbiAgfTtcblxuICAvLyBSZWluaXRpYWxpemU7IGZvciBkZXJpdmluZyBjaGFubmVscyBkZXBlbmRlbnQgb24gb3RoZXIgY2hhbm5lbHMuXG4gIGNvbnN0IG5ld0J5U2NhbGUgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgW21hcmssIHN0YXRlXSBvZiBzdGF0ZUJ5TWFyaykge1xuICAgIGlmIChtYXJrLmluaXRpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBtYXJrLmZhY2V0ID09PSBcInN1cGVyXCIgPyBzdXBlcmRpbWVuc2lvbnMgOiBzdWJkaW1lbnNpb25zO1xuICAgICAgY29uc3QgdXBkYXRlID0gbWFyay5pbml0aWFsaXplcihzdGF0ZS5kYXRhLCBzdGF0ZS5mYWNldHMsIHN0YXRlLmNoYW5uZWxzLCBzY2FsZXMsIGRpbWVuc2lvbnMsIGNvbnRleHQpO1xuICAgICAgaWYgKHVwZGF0ZS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhdGUuZGF0YSA9IHVwZGF0ZS5kYXRhO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZS5mYWNldHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGF0ZS5mYWNldHMgPSB1cGRhdGUuZmFjZXRzO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZS5jaGFubmVscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHtmeCwgZnksIC4uLmNoYW5uZWxzfSA9IHVwZGF0ZS5jaGFubmVsczsgLy8gc2VwYXJhdGUgZmFjZXQgY2hhbm5lbHNcbiAgICAgICAgaW5mZXJDaGFubmVsU2NhbGVzKGNoYW5uZWxzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5jaGFubmVscywgY2hhbm5lbHMpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgT2JqZWN0LnZhbHVlcyhjaGFubmVscykpIHtcbiAgICAgICAgICBjb25zdCB7c2NhbGV9ID0gY2hhbm5lbDtcbiAgICAgICAgICAvLyBJbml0aWFsaXplcnMgYXJlbuKAmXQgYWxsb3dlZCB0byByZWRlZmluZSBwb3NpdGlvbiBzY2FsZXMgYXMgdGhpc1xuICAgICAgICAgIC8vIHdvdWxkIGludHJvZHVjZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3k7IHNvIHNpbXBseSBzY2FsZSB0aGVzZVxuICAgICAgICAgIC8vIGNoYW5uZWxzIGFzLWlzIHJhdGhlciB0aGFuIGNyZWF0aW5nIG5ldyBzY2FsZXMsIGFuZCBhc3N1bWUgdGhhdFxuICAgICAgICAgIC8vIHRoZXkgYWxyZWFkeSBoYXZlIHRoZSBzY2FsZeKAmXMgdHJhbnNmb3JtIGFwcGxpZWQsIGlmIGFueSAoZS5nLiwgd2hlblxuICAgICAgICAgIC8vIGdlbmVyYXRpbmcgdGlja3MgZm9yIHRoZSBheGlzIG1hcmspLlxuICAgICAgICAgIGlmIChzY2FsZSAhPSBudWxsICYmICFpc1Bvc2l0aW9uKHNjYWxlUmVnaXN0cnkuZ2V0KHNjYWxlKSkpIHtcbiAgICAgICAgICAgIGFwcGx5U2NhbGVUcmFuc2Zvcm0oY2hhbm5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBuZXdCeVNjYWxlLmFkZChzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsaXplciByZXR1cm5zIG5ldyBtYXJrLWxldmVsIGZhY2V0IGNoYW5uZWxzLCB3ZSBtdXN0XG4gICAgICAgIC8vIHJlY29yZCB0aGF0IHRoZSBtYXJrIGlzIG5vdyBmYWNldGVkLiBOb3RlOiB3ZSBhcmVu4oCZdCBhY3R1YWxseVxuICAgICAgICAvLyBwb3B1bGF0aW5nIHRoZSBmYWNldCBzdGF0ZSwgYnV0IHN1YnNlcXVlbnRseSB3ZSB3b27igJl0IG5lZWQgaXQuXG4gICAgICAgIGlmIChmeCAhPSBudWxsIHx8IGZ5ICE9IG51bGwpIGZhY2V0U3RhdGVCeU1hcmsuc2V0KG1hcmssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29uc3RydWN0IHNjYWxlcyBpZiBuZXcgc2NhbGVkIGNoYW5uZWxzIHdlcmUgY3JlYXRlZCBkdXJpbmdcbiAgLy8gcmVpbml0aWFsaXphdGlvbi4gUHJlc2VydmUgZXhpc3Rpbmcgc2NhbGUgbGFiZWxzLCBpZiBhbnkuXG4gIGlmIChuZXdCeVNjYWxlLnNpemUpIHtcbiAgICBjb25zdCBuZXdDaGFubmVsc0J5U2NhbGUgPSBuZXcgTWFwKCk7XG4gICAgYWRkU2NhbGVDaGFubmVscyhuZXdDaGFubmVsc0J5U2NhbGUsIHN0YXRlQnlNYXJrLCBvcHRpb25zLCAoa2V5KSA9PiBuZXdCeVNjYWxlLmhhcyhrZXkpKTtcbiAgICBhZGRTY2FsZUNoYW5uZWxzKGNoYW5uZWxzQnlTY2FsZSwgc3RhdGVCeU1hcmssIG9wdGlvbnMsIChrZXkpID0+IG5ld0J5U2NhbGUuaGFzKGtleSkpO1xuICAgIGNvbnN0IG5ld1NjYWxlRGVzY3JpcHRvcnMgPSBpbmhlcml0U2NhbGVMYWJlbHMoY3JlYXRlU2NhbGVzKG5ld0NoYW5uZWxzQnlTY2FsZSwgb3B0aW9ucyksIHNjYWxlRGVzY3JpcHRvcnMpO1xuICAgIGNvbnN0IHtzY2FsZXM6IG5ld0V4cG9zZWRTY2FsZXMsIC4uLm5ld1NjYWxlc30gPSBjcmVhdGVTY2FsZUZ1bmN0aW9ucyhuZXdTY2FsZURlc2NyaXB0b3JzKTtcbiAgICBPYmplY3QuYXNzaWduKHNjYWxlRGVzY3JpcHRvcnMsIG5ld1NjYWxlRGVzY3JpcHRvcnMpO1xuICAgIE9iamVjdC5hc3NpZ24oc2NhbGVzLCBuZXdTY2FsZXMpO1xuICAgIE9iamVjdC5hc3NpZ24oc2NhbGVzLnNjYWxlcywgbmV3RXhwb3NlZFNjYWxlcyk7XG4gIH1cblxuICAvLyBTb3J0IGFuZCBmaWx0ZXIgdGhlIGZhY2V0cyB0byBtYXRjaCB0aGUgZnggYW5kIGZ5IGRvbWFpbnM7IHRoaXMgaXMgbmVlZGVkXG4gIC8vIGJlY2F1c2UgdGhlIGZhY2V0cyB3ZXJlIGNvbnN0cnVjdGVkIHByaW9yIHRvIHRoZSBmeCBhbmQgZnkgc2NhbGVzLlxuICBsZXQgZmFjZXREb21haW5zLCBmYWNldFRyYW5zbGF0ZTtcbiAgaWYgKGZhY2V0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmFjZXREb21haW5zID0ge3g6IGZ4Py5kb21haW4oKSwgeTogZnk/LmRvbWFpbigpfTtcbiAgICBmYWNldHMgPSByZWNyZWF0ZUZhY2V0cyhmYWNldHMsIGZhY2V0RG9tYWlucyk7XG4gICAgZmFjZXRUcmFuc2xhdGUgPSBmYWNldFRyYW5zbGF0b3IoZngsIGZ5LCBkaW1lbnNpb25zKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdmFsdWUgb2JqZWN0cywgYXBwbHlpbmcgc2NhbGVzIGFuZCBwcm9qZWN0aW9uIGFzIG5lZWRlZC5cbiAgZm9yIChjb25zdCBbbWFyaywgc3RhdGVdIG9mIHN0YXRlQnlNYXJrKSB7XG4gICAgc3RhdGUudmFsdWVzID0gbWFyay5zY2FsZShzdGF0ZS5jaGFubmVscywgc2NhbGVzLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGRpbWVuc2lvbnM7XG5cbiAgc2VsZWN0KHN2ZylcbiAgICAuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcbiAgICAuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsIFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIpXG4gICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgIC5hdHRyKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApXG4gICAgLmF0dHIoXCJhcmlhLWxhYmVsXCIsIGFyaWFMYWJlbClcbiAgICAuYXR0cihcImFyaWEtZGVzY3JpcHRpb25cIiwgYXJpYURlc2NyaXB0aW9uKVxuICAgIC5jYWxsKChzdmcpID0+XG4gICAgICAvLyBXYXJuaW5nOiBpZiB5b3UgZWRpdCB0aGlzLCBjaGFuZ2UgZGVmYXVsdENsYXNzTmFtZS5cbiAgICAgIHN2Zy5hcHBlbmQoXCJzdHlsZVwiKS50ZXh0KFxuICAgICAgICBgOndoZXJlKC4ke2NsYXNzTmFtZX0pIHtcbiAgLS1wbG90LWJhY2tncm91bmQ6IHdoaXRlO1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiBhdXRvO1xuICBoZWlnaHQ6IGludHJpbnNpYztcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuOndoZXJlKC4ke2NsYXNzTmFtZX0gdGV4dCksXG46d2hlcmUoLiR7Y2xhc3NOYW1lfSB0c3Bhbikge1xuICB3aGl0ZS1zcGFjZTogcHJlO1xufWBcbiAgICAgIClcbiAgICApXG4gICAgLmNhbGwoYXBwbHlJbmxpbmVTdHlsZXMsIHN0eWxlKTtcblxuICAvLyBSZW5kZXIgbWFya3MuXG4gIGZvciAoY29uc3QgbWFyayBvZiBtYXJrcykge1xuICAgIGNvbnN0IHtjaGFubmVscywgdmFsdWVzLCBmYWNldHM6IGluZGV4ZXN9ID0gc3RhdGVCeU1hcmsuZ2V0KG1hcmspO1xuXG4gICAgLy8gUmVuZGVyIGEgbm9uLWZhY2V0ZWQgbWFyay5cbiAgICBpZiAoZmFjZXRzID09PSB1bmRlZmluZWQgfHwgbWFyay5mYWNldCA9PT0gXCJzdXBlclwiKSB7XG4gICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleGVzWzBdO1xuICAgICAgICBpbmRleCA9IG1hcmsuZmlsdGVyKGluZGV4LCBjaGFubmVscywgdmFsdWVzKTtcbiAgICAgICAgaWYgKGluZGV4Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gbWFyay5yZW5kZXIoaW5kZXgsIHNjYWxlcywgdmFsdWVzLCBzdXBlcmRpbWVuc2lvbnMsIGNvbnRleHQpO1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgY29udGludWU7XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGEgZmFjZXRlZCBtYXJrLlxuICAgIGVsc2Uge1xuICAgICAgbGV0IGc7XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgZmFjZXRzKSB7XG4gICAgICAgIGlmICghKG1hcmsuZmFjZXRBbmNob3I/LihmYWNldHMsIGZhY2V0RG9tYWlucywgZikgPz8gIWYuZW1wdHkpKSBjb250aW51ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgICBjb25zdCBmYWNldGVkID0gZmFjZXRTdGF0ZUJ5TWFyay5oYXMobWFyayk7XG4gICAgICAgICAgaW5kZXggPSBpbmRleGVzW2ZhY2V0ZWQgPyBmLmkgOiAwXTtcbiAgICAgICAgICBpbmRleCA9IG1hcmsuZmlsdGVyKGluZGV4LCBjaGFubmVscywgdmFsdWVzKTtcbiAgICAgICAgICBpZiAoaW5kZXgubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoIWZhY2V0ZWQgJiYgaW5kZXggPT09IGluZGV4ZXNbMF0pIGluZGV4ID0gc3ViYXJyYXkoaW5kZXgpOyAvLyBjb3B5IGJlZm9yZSBhc3NpZ25pbmcgZngsIGZ5LCBmaVxuICAgICAgICAgIChpbmRleC5meCA9IGYueCksIChpbmRleC5meSA9IGYueSksIChpbmRleC5maSA9IGYuaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG1hcmsucmVuZGVyKGluZGV4LCBzY2FsZXMsIHZhbHVlcywgc3ViZGltZW5zaW9ucywgY29udGV4dCk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAvLyBMYXppbHkgY29uc3RydWN0IHRoZSBzaGFyZWQgZ3JvdXAgKHRvIGRyb3AgZW1wdHkgbWFya3MpLlxuICAgICAgICAoZyA/Pz0gc2VsZWN0KHN2ZykuYXBwZW5kKFwiZ1wiKSkuYXBwZW5kKCgpID0+IG5vZGUpLmRhdHVtKGYpO1xuICAgICAgICAvLyBQcm9tb3RlIEFSSUEgYXR0cmlidXRlcyBhbmQgbWFyayB0cmFuc2Zvcm0gdG8gYXZvaWQgcmVwZXRpdGlvbiBvblxuICAgICAgICAvLyBlYWNoIGZhY2V0OyB0aGlzIGFzc3VtZXMgdGhhdCB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBjb25zaXN0ZW50IGFjcm9zc1xuICAgICAgICAvLyBmYWNldHMsIGJ1dCB0aGF0IHNob3VsZCBiZSB0aGUgY2FzZSFcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFtcImFyaWEtbGFiZWxcIiwgXCJhcmlhLWRlc2NyaXB0aW9uXCIsIFwiYXJpYS1oaWRkZW5cIiwgXCJ0cmFuc2Zvcm1cIl0pIHtcbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIGcuYXR0cihuYW1lLCBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGc/LnNlbGVjdENoaWxkcmVuKCkuZWFjaChmYWNldFRyYW5zbGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCB0aGUgcGxvdCBpbiBhIGZpZ3VyZSwgaWYgbmVlZGVkLlxuICBjb25zdCBsZWdlbmRzID0gY3JlYXRlTGVnZW5kcyhzY2FsZURlc2NyaXB0b3JzLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgY29uc3Qge2ZpZ3VyZTogZmlndXJlZCA9IHRpdGxlICE9IG51bGwgfHwgc3VidGl0bGUgIT0gbnVsbCB8fCBjYXB0aW9uICE9IG51bGwgfHwgbGVnZW5kcy5sZW5ndGggPiAwfSA9IG9wdGlvbnM7XG4gIGlmIChmaWd1cmVkKSB7XG4gICAgZmlndXJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZ3VyZVwiKTtcbiAgICBmaWd1cmUuY2xhc3NOYW1lID0gYCR7Y2xhc3NOYW1lfS1maWd1cmVgO1xuICAgIGZpZ3VyZS5zdHlsZS5tYXhXaWR0aCA9IFwiaW5pdGlhbFwiOyAvLyBhdm9pZCBPYnNlcnZhYmxlIGRlZmF1bHQgc3R5bGVcbiAgICBpZiAodGl0bGUgIT0gbnVsbCkgZmlndXJlLmFwcGVuZChjcmVhdGVUaXRsZUVsZW1lbnQoZG9jdW1lbnQsIHRpdGxlLCBcImgyXCIpKTtcbiAgICBpZiAoc3VidGl0bGUgIT0gbnVsbCkgZmlndXJlLmFwcGVuZChjcmVhdGVUaXRsZUVsZW1lbnQoZG9jdW1lbnQsIHN1YnRpdGxlLCBcImgzXCIpKTtcbiAgICBmaWd1cmUuYXBwZW5kKC4uLmxlZ2VuZHMsIHN2Zyk7XG4gICAgaWYgKGNhcHRpb24gIT0gbnVsbCkgZmlndXJlLmFwcGVuZChjcmVhdGVGaWdjYXB0aW9uKGRvY3VtZW50LCBjYXB0aW9uKSk7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBzdmcpIChmaWd1cmUudmFsdWUgPSBzdmcudmFsdWUpLCBkZWxldGUgc3ZnLnZhbHVlO1xuICB9XG5cbiAgZmlndXJlLnNjYWxlID0gZXhwb3NlU2NhbGVzKHNjYWxlcy5zY2FsZXMpO1xuICBmaWd1cmUubGVnZW5kID0gZXhwb3NlTGVnZW5kcyhzY2FsZURlc2NyaXB0b3JzLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICBjb25zdCB3ID0gY29uc3VtZVdhcm5pbmdzKCk7XG4gIGlmICh3ID4gMCkge1xuICAgIHNlbGVjdChzdmcpXG4gICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoKVxuICAgICAgLmF0dHIoXCJ5XCIsIDIwKVxuICAgICAgLmF0dHIoXCJkeVwiLCBcIi0xZW1cIilcbiAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJpbml0aWFsXCIpIC8vIGZpeCBlbW9qaSByZW5kZXJpbmcgaW4gQ2hyb21lXG4gICAgICAudGV4dChcIlxcdTI2YTBcXHVmZTBmXCIpIC8vIGVtb2ppIHZhcmlhdGlvbiBzZWxlY3RvclxuICAgICAgLmFwcGVuZChcInRpdGxlXCIpXG4gICAgICAudGV4dChgJHt3LnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIil9IHdhcm5pbmcke3cgPT09IDEgPyBcIlwiIDogXCJzXCJ9LiBQbGVhc2UgY2hlY2sgdGhlIGNvbnNvbGUuYCk7XG4gIH1cblxuICByZXR1cm4gZmlndXJlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUaXRsZUVsZW1lbnQoZG9jdW1lbnQsIGNvbnRlbnRzLCB0YWcpIHtcbiAgaWYgKGNvbnRlbnRzLm93bmVyRG9jdW1lbnQpIHJldHVybiBjb250ZW50cztcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZS5hcHBlbmQoY29udGVudHMpO1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlnY2FwdGlvbihkb2N1bWVudCwgY2FwdGlvbikge1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZ2NhcHRpb25cIik7XG4gIGUuYXBwZW5kKGNhcHRpb24pO1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZmxhdE1hcmtzKG1hcmtzKSB7XG4gIHJldHVybiBtYXJrc1xuICAgIC5mbGF0KEluZmluaXR5KVxuICAgIC5maWx0ZXIoKG1hcmspID0+IG1hcmsgIT0gbnVsbClcbiAgICAubWFwKG1hcmtpZnkpO1xufVxuXG5mdW5jdGlvbiBtYXJraWZ5KG1hcmspIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXJrLnJlbmRlciA9PT0gXCJmdW5jdGlvblwiID8gbWFyayA6IG5ldyBSZW5kZXIobWFyayk7XG59XG5cbmNsYXNzIFJlbmRlciBleHRlbmRzIE1hcmsge1xuICBjb25zdHJ1Y3RvcihyZW5kZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBtYXJrOyBtaXNzaW5nIHJlbmRlciBmdW5jdGlvblwiKTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIHJlbmRlcigpIHt9XG59XG5cbi8vIE5vdGU6IG11dGF0ZXMgY2hhbm5lbC52YWx1ZSB0byBhcHBseSB0aGUgc2NhbGUgdHJhbnNmb3JtLCBpZiBhbnkuXG5mdW5jdGlvbiBhcHBseVNjYWxlVHJhbnNmb3JtcyhjaGFubmVscywgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIGFwcGx5U2NhbGVUcmFuc2Zvcm0oY2hhbm5lbHNbbmFtZV0sIG9wdGlvbnMpO1xuICByZXR1cm4gY2hhbm5lbHM7XG59XG5cbi8vIE5vdGU6IG11dGF0ZXMgY2hhbm5lbC52YWx1ZSB0byBhcHBseSB0aGUgc2NhbGUgdHJhbnNmb3JtLCBpZiBhbnkuIEFsc28gc2V0c1xuLy8gY2hhbm5lbC50cmFuc2Zvcm0gdG8gZmFsc2UgdG8gcHJldmVudCBkdXBsaWNhdGUgdHJhbnNmb3JtIGFwcGxpY2F0aW9uLlxuZnVuY3Rpb24gYXBwbHlTY2FsZVRyYW5zZm9ybShjaGFubmVsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtzY2FsZSwgdHJhbnNmb3JtOiB0ID0gdHJ1ZX0gPSBjaGFubmVsO1xuICBpZiAoc2NhbGUgPT0gbnVsbCB8fCAhdCkgcmV0dXJuO1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwZXJjZW50LFxuICAgIGludGVydmFsLFxuICAgIHRyYW5zZm9ybSA9IHBlcmNlbnQgPyAoeCkgPT4gKHggPT0gbnVsbCA/IE5hTiA6IHggKiAxMDApIDogbWF5YmVJbnRlcnZhbFRyYW5zZm9ybShpbnRlcnZhbCwgdHlwZSlcbiAgfSA9IG9wdGlvbnNbc2NhbGVdID8/IHt9O1xuICBpZiAodHJhbnNmb3JtID09IG51bGwpIHJldHVybjtcbiAgY2hhbm5lbC52YWx1ZSA9IG1hcChjaGFubmVsLnZhbHVlLCB0cmFuc2Zvcm0pO1xuICBjaGFubmVsLnRyYW5zZm9ybSA9IGZhbHNlO1xufVxuXG4vLyBBbiBpbml0aWFsaXplciBtYXkgZ2VuZXJhdGUgY2hhbm5lbHMgd2l0aG91dCBrbm93aW5nIGhvdyB0aGUgZG93bnN0cmVhbSBtYXJrXG4vLyB3aWxsIHVzZSB0aGVtLiBNYXJrcyBhcmUgdHlwaWNhbGx5IHJlc3BvbnNpYmxlIGFzc29jaWF0ZWQgc2NhbGVzIHdpdGhcbi8vIGNoYW5uZWxzLCBidXQgaGVyZSB3ZSBhc3N1bWUgY29tbW9uIGJlaGF2aW9yIGFjcm9zcyBtYXJrcy5cbmZ1bmN0aW9uIGluZmVyQ2hhbm5lbFNjYWxlcyhjaGFubmVscykge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIHtcbiAgICBpbmZlckNoYW5uZWxTY2FsZShuYW1lLCBjaGFubmVsc1tuYW1lXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU2NhbGVDaGFubmVscyhjaGFubmVsc0J5U2NhbGUsIHN0YXRlQnlNYXJrLCBvcHRpb25zLCBmaWx0ZXIgPSB5ZXMpIHtcbiAgZm9yIChjb25zdCB7Y2hhbm5lbHN9IG9mIHN0YXRlQnlNYXJrLnZhbHVlcygpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGNoYW5uZWxzKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbbmFtZV07XG4gICAgICBjb25zdCB7c2NhbGV9ID0gY2hhbm5lbDtcbiAgICAgIGlmIChzY2FsZSAhPSBudWxsICYmIGZpbHRlcihzY2FsZSkpIHtcbiAgICAgICAgLy8gR2VvIG1hcmtzIGFmZmVjdCB0aGUgZGVmYXVsdCB4IGFuZCB5IGRvbWFpbnMgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gcHJvamVjdGlvbi4gU2tpcCB0aGlzIChhcyBhbiBvcHRpbWl6YXRpb24pIHdoZW4gYSBwcm9qZWN0aW9uIGlzXG4gICAgICAgIC8vIHNwZWNpZmllZCwgb3Igd2hlbiB0aGUgZG9tYWlucyBmb3IgeCBhbmQgeSBhcmUgc3BlY2lmaWVkLlxuICAgICAgICBpZiAoc2NhbGUgPT09IFwicHJvamVjdGlvblwiKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9qZWN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBneCA9IG9wdGlvbnMueD8uZG9tYWluID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBneSA9IG9wdGlvbnMueT8uZG9tYWluID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZ3ggfHwgZ3kpIHtcbiAgICAgICAgICAgICAgY29uc3QgW3gsIHldID0gZ2V0R2VvbWV0cnlDaGFubmVscyhjaGFubmVsKTtcbiAgICAgICAgICAgICAgaWYgKGd4KSBhZGRTY2FsZUNoYW5uZWwoY2hhbm5lbHNCeVNjYWxlLCBcInhcIiwgeCk7XG4gICAgICAgICAgICAgIGlmIChneSkgYWRkU2NhbGVDaGFubmVsKGNoYW5uZWxzQnlTY2FsZSwgXCJ5XCIsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRTY2FsZUNoYW5uZWwoY2hhbm5lbHNCeVNjYWxlLCBzY2FsZSwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5uZWxzQnlTY2FsZTtcbn1cblxuZnVuY3Rpb24gYWRkU2NhbGVDaGFubmVsKGNoYW5uZWxzQnlTY2FsZSwgc2NhbGUsIGNoYW5uZWwpIHtcbiAgY29uc3Qgc2NhbGVDaGFubmVscyA9IGNoYW5uZWxzQnlTY2FsZS5nZXQoc2NhbGUpO1xuICBpZiAoc2NhbGVDaGFubmVscyAhPT0gdW5kZWZpbmVkKSBzY2FsZUNoYW5uZWxzLnB1c2goY2hhbm5lbCk7XG4gIGVsc2UgY2hhbm5lbHNCeVNjYWxlLnNldChzY2FsZSwgW2NoYW5uZWxdKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgZmFjZXQgZ3JvdXBzLCBhbmQgcG9zc2libHkgZnggYW5kIGZ5IGNoYW5uZWxzLCBhc3NvY2lhdGVkIHdpdGhcbi8vIHRoZSB0b3AtbGV2ZWwgZmFjZXQgb3B0aW9uIHtkYXRhLCB4LCB5fS5cbmZ1bmN0aW9uIG1heWJlVG9wRmFjZXQoZmFjZXQsIG9wdGlvbnMpIHtcbiAgaWYgKGZhY2V0ID09IG51bGwpIHJldHVybjtcbiAgY29uc3Qge3gsIHl9ID0gZmFjZXQ7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsKSByZXR1cm47XG4gIGNvbnN0IGRhdGEgPSBkYXRhaWZ5KGZhY2V0LmRhdGEpO1xuICBpZiAoZGF0YSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGZhY2V0IGRhdGFcIik7XG4gIGNvbnN0IGNoYW5uZWxzID0ge307XG4gIGlmICh4ICE9IG51bGwpIGNoYW5uZWxzLmZ4ID0gY3JlYXRlQ2hhbm5lbChkYXRhLCB7dmFsdWU6IHgsIHNjYWxlOiBcImZ4XCJ9KTtcbiAgaWYgKHkgIT0gbnVsbCkgY2hhbm5lbHMuZnkgPSBjcmVhdGVDaGFubmVsKGRhdGEsIHt2YWx1ZTogeSwgc2NhbGU6IFwiZnlcIn0pO1xuICBhcHBseVNjYWxlVHJhbnNmb3JtcyhjaGFubmVscywgb3B0aW9ucyk7XG4gIGNvbnN0IGdyb3VwcyA9IGZhY2V0R3JvdXBzKGRhdGEsIGNoYW5uZWxzKTtcbiAgcmV0dXJuIHtjaGFubmVscywgZ3JvdXBzLCBkYXRhOiBmYWNldC5kYXRhfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgZmFjZXQgZ3JvdXBzLCBhbmQgcG9zc2libHkgZnggYW5kIGZ5IGNoYW5uZWxzLCBhc3NvY2lhdGVkIHdpdGggYVxuLy8gbWFyaywgZWl0aGVyIHRocm91Z2ggdG9wLWxldmVsIGZhY2V0aW5nIG9yIG1hcmstbGV2ZWwgZmFjZXQgb3B0aW9ucyB7ZngsIGZ5fS5cbmZ1bmN0aW9uIG1heWJlTWFya0ZhY2V0KG1hcmssIHRvcEZhY2V0U3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG1hcmsuZmFjZXQgPT09IG51bGwgfHwgbWFyay5mYWNldCA9PT0gXCJzdXBlclwiKSByZXR1cm47XG5cbiAgLy8gVGhpcyBtYXJrIGRlZmluZXMgYSBtYXJrLWxldmVsIGZhY2V0LiBUT0RPIFRoZXJl4oCZcyBzb21lIGNvZGUgZHVwbGljYXRpb25cbiAgLy8gaGVyZSB3aXRoIG1heWJlVG9wRmFjZXQgdGhhdCB3ZSBjb3VsZCByZWR1Y2UuXG4gIGNvbnN0IHtmeCwgZnl9ID0gbWFyaztcbiAgaWYgKGZ4ICE9IG51bGwgfHwgZnkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhaWZ5KG1hcmsuZGF0YSA/PyBmeCA/PyBmeSk7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGZhY2V0IGRhdGEgaW4gJHttYXJrLmFyaWFMYWJlbH1gKTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuOyAvLyBpZ25vcmUgY2hhbm5lbCBkZWZpbml0aW9ucyBpZiBubyBkYXRhIGlzIHByb3ZpZGVkIFRPRE8gdGhpcyByaWdodD9cbiAgICBjb25zdCBjaGFubmVscyA9IHt9O1xuICAgIGlmIChmeCAhPSBudWxsKSBjaGFubmVscy5meCA9IGNyZWF0ZUNoYW5uZWwoZGF0YSwge3ZhbHVlOiBmeCwgc2NhbGU6IFwiZnhcIn0pO1xuICAgIGlmIChmeSAhPSBudWxsKSBjaGFubmVscy5meSA9IGNyZWF0ZUNoYW5uZWwoZGF0YSwge3ZhbHVlOiBmeSwgc2NhbGU6IFwiZnlcIn0pO1xuICAgIGFwcGx5U2NhbGVUcmFuc2Zvcm1zKGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICByZXR1cm4ge2NoYW5uZWxzLCBncm91cHM6IGZhY2V0R3JvdXBzKGRhdGEsIGNoYW5uZWxzKX07XG4gIH1cblxuICAvLyBUaGlzIG1hcmsgbGlua3MgdG8gYSB0b3AtbGV2ZWwgZmFjZXQsIGlmIHByZXNlbnQuXG4gIGlmICh0b3BGYWNldFN0YXRlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAvLyBUT0RPIENhbiB3ZSBsaW5rIHRoZSB0b3AtbGV2ZWwgZmFjZXQgY2hhbm5lbHMgaGVyZT9cbiAgY29uc3Qge2NoYW5uZWxzLCBncm91cHMsIGRhdGF9ID0gdG9wRmFjZXRTdGF0ZTtcbiAgaWYgKG1hcmsuZmFjZXQgIT09IFwiYXV0b1wiIHx8IG1hcmsuZGF0YSA9PT0gZGF0YSkgcmV0dXJuIHtjaGFubmVscywgZ3JvdXBzfTtcblxuICAvLyBXYXJuIGZvciB0aGUgY29tbW9uIHBpdGZhbGwgb2Ygd2FudGluZyB0byBmYWNldCBtYXBwZWQgZGF0YSB3aXRoIHRoZVxuICAvLyB0b3AtbGV2ZWwgZmFjZXQgb3B0aW9uLlxuICBpZiAoXG4gICAgZGF0YS5sZW5ndGggPiAwICYmXG4gICAgKGdyb3Vwcy5zaXplID4gMSB8fCAoZ3JvdXBzLnNpemUgPT09IDEgJiYgY2hhbm5lbHMuZnggJiYgY2hhbm5lbHMuZnkgJiYgWy4uLmdyb3Vwc11bMF1bMV0uc2l6ZSA+IDEpKSAmJlxuICAgIGxlbmd0aG9mKGRhdGFpZnkobWFyay5kYXRhKSkgPT09IGxlbmd0aG9mKGRhdGEpXG4gICkge1xuICAgIHdhcm4oXG4gICAgICBgV2FybmluZzogdGhlICR7bWFyay5hcmlhTGFiZWx9IG1hcmsgYXBwZWFycyB0byB1c2UgZmFjZXRlZCBkYXRhLCBidXQgaXNu4oCZdCBmYWNldGVkLiBUaGUgbWFyayBkYXRhIGhhcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGZhY2V0IGRhdGEgYW5kIHRoZSBtYXJrIGZhY2V0IG9wdGlvbiBpcyBcImF1dG9cIiwgYnV0IHRoZSBtYXJrIGRhdGEgYW5kIGZhY2V0IGRhdGEgYXJlIGRpc3RpbmN0LiBJZiB0aGlzIG1hcmsgc2hvdWxkIGJlIGZhY2V0ZWQsIHNldCB0aGUgbWFyayBmYWNldCBvcHRpb24gdG8gdHJ1ZTsgb3RoZXJ3aXNlLCBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgYnkgc2V0dGluZyB0aGUgbWFyayBmYWNldCBvcHRpb24gdG8gZmFsc2UuYFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVyaXZlKG1hcmssIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gaW5pdGlhbGl6ZXIoey4uLm9wdGlvbnMsIHg6IG51bGwsIHk6IG51bGx9LCAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zLCBjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0TWFya1N0YXRlKG1hcmspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5mZXJUaXBzKG1hcmtzKSB7XG4gIGNvbnN0IHRpcHMgPSBbXTtcbiAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzKSB7XG4gICAgbGV0IHRpcE9wdGlvbnMgPSBtYXJrLnRpcDtcbiAgICBpZiAodGlwT3B0aW9ucykge1xuICAgICAgaWYgKHRpcE9wdGlvbnMgPT09IHRydWUpIHRpcE9wdGlvbnMgPSB7fTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aXBPcHRpb25zID09PSBcInN0cmluZ1wiKSB0aXBPcHRpb25zID0ge3BvaW50ZXI6IHRpcE9wdGlvbnN9O1xuICAgICAgbGV0IHtwb2ludGVyOiBwLCBwcmVmZXJyZWRBbmNob3I6IGF9ID0gdGlwT3B0aW9ucztcbiAgICAgIHAgPSAvXngkL2kudGVzdChwKSA/IHBvaW50ZXJYIDogL155JC9pLnRlc3QocCkgPyBwb2ludGVyWSA6IHBvaW50ZXI7IC8vIFRPRE8gdmFsaWRhdGU/XG4gICAgICB0aXBPcHRpb25zID0gcChkZXJpdmUobWFyaywgdGlwT3B0aW9ucykpO1xuICAgICAgdGlwT3B0aW9ucy50aXRsZSA9IG51bGw7IC8vIHByZXZlbnQgaW1wbGljaXQgdGl0bGUgZm9yIHByaW1pdGl2ZSBkYXRhXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB0aXBPcHRpb25zLnByZWZlcnJlZEFuY2hvciA9IHAgPT09IHBvaW50ZXJZID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiO1xuICAgICAgY29uc3QgdCA9IHRpcChtYXJrLmRhdGEsIHRpcE9wdGlvbnMpO1xuICAgICAgdC5mYWNldCA9IG1hcmsuZmFjZXQ7IC8vIGluaGVyaXQgZmFjZXQgc2V0dGluZ3NcbiAgICAgIHQuZmFjZXRBbmNob3IgPSBtYXJrLmZhY2V0QW5jaG9yOyAvLyBpbmhlcml0IGZhY2V0IHNldHRpbmdzXG4gICAgICB0aXBzLnB1c2godCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aXBzO1xufVxuXG5mdW5jdGlvbiBpbmZlckF4ZXMobWFya3MsIGNoYW5uZWxzQnlTY2FsZSwgb3B0aW9ucykge1xuICBsZXQge1xuICAgIHByb2plY3Rpb24sXG4gICAgeCA9IHt9LFxuICAgIHkgPSB7fSxcbiAgICBmeCA9IHt9LFxuICAgIGZ5ID0ge30sXG4gICAgYXhpcyxcbiAgICBncmlkLFxuICAgIGZhY2V0ID0ge30sXG4gICAgZmFjZXQ6IHtheGlzOiBmYWNldEF4aXMgPSBheGlzLCBncmlkOiBmYWNldEdyaWR9ID0gZmFjZXQsXG4gICAgeDoge2F4aXM6IHhBeGlzID0gYXhpcywgZ3JpZDogeEdyaWQgPSB4QXhpcyA9PT0gbnVsbCA/IG51bGwgOiBncmlkfSA9IHgsXG4gICAgeToge2F4aXM6IHlBeGlzID0gYXhpcywgZ3JpZDogeUdyaWQgPSB5QXhpcyA9PT0gbnVsbCA/IG51bGwgOiBncmlkfSA9IHksXG4gICAgZng6IHtheGlzOiBmeEF4aXMgPSBmYWNldEF4aXMsIGdyaWQ6IGZ4R3JpZCA9IGZ4QXhpcyA9PT0gbnVsbCA/IG51bGwgOiBmYWNldEdyaWR9ID0gZngsXG4gICAgZnk6IHtheGlzOiBmeUF4aXMgPSBmYWNldEF4aXMsIGdyaWQ6IGZ5R3JpZCA9IGZ5QXhpcyA9PT0gbnVsbCA/IG51bGwgOiBmYWNldEdyaWR9ID0gZnlcbiAgfSA9IG9wdGlvbnM7XG5cbiAgLy8gRGlzYWJsZSBheGVzIGlmIHRoZSBjb3JyZXNwb25kaW5nIHNjYWxlIGlzIG5vdCBwcmVzZW50LlxuICBpZiAocHJvamVjdGlvbiB8fCAoIWlzU2NhbGVPcHRpb25zKHgpICYmICFoYXNQb3NpdGlvbkNoYW5uZWwoXCJ4XCIsIG1hcmtzKSkpIHhBeGlzID0geEdyaWQgPSBudWxsO1xuICBpZiAocHJvamVjdGlvbiB8fCAoIWlzU2NhbGVPcHRpb25zKHkpICYmICFoYXNQb3NpdGlvbkNoYW5uZWwoXCJ5XCIsIG1hcmtzKSkpIHlBeGlzID0geUdyaWQgPSBudWxsO1xuICBpZiAoIWNoYW5uZWxzQnlTY2FsZS5oYXMoXCJmeFwiKSkgZnhBeGlzID0gZnhHcmlkID0gbnVsbDtcbiAgaWYgKCFjaGFubmVsc0J5U2NhbGUuaGFzKFwiZnlcIikpIGZ5QXhpcyA9IGZ5R3JpZCA9IG51bGw7XG5cbiAgLy8gUmVzb2x2ZSB0aGUgZGVmYXVsdCBpbXBsaWNpdCBheGVzIGJ5IGNoZWNraW5nIGZvciBleHBsaWNpdCBvbmVzLlxuICBpZiAoeEF4aXMgPT09IHVuZGVmaW5lZCkgeEF4aXMgPSAhaGFzQXhpcyhtYXJrcywgXCJ4XCIpO1xuICBpZiAoeUF4aXMgPT09IHVuZGVmaW5lZCkgeUF4aXMgPSAhaGFzQXhpcyhtYXJrcywgXCJ5XCIpO1xuICBpZiAoZnhBeGlzID09PSB1bmRlZmluZWQpIGZ4QXhpcyA9ICFoYXNBeGlzKG1hcmtzLCBcImZ4XCIpO1xuICBpZiAoZnlBeGlzID09PSB1bmRlZmluZWQpIGZ5QXhpcyA9ICFoYXNBeGlzKG1hcmtzLCBcImZ5XCIpO1xuXG4gIC8vIFJlc29sdmUgdGhlIGRlZmF1bHQgb3JpZW50YXRpb24gb2YgYXhlcy5cbiAgaWYgKHhBeGlzID09PSB0cnVlKSB4QXhpcyA9IFwiYm90dG9tXCI7XG4gIGlmICh5QXhpcyA9PT0gdHJ1ZSkgeUF4aXMgPSBcImxlZnRcIjtcbiAgaWYgKGZ4QXhpcyA9PT0gdHJ1ZSkgZnhBeGlzID0geEF4aXMgPT09IFwidG9wXCIgfHwgeEF4aXMgPT09IG51bGwgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgaWYgKGZ5QXhpcyA9PT0gdHJ1ZSkgZnlBeGlzID0geUF4aXMgPT09IFwicmlnaHRcIiB8fCB5QXhpcyA9PT0gbnVsbCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuXG4gIGNvbnN0IGF4ZXMgPSBbXTtcbiAgbWF5YmVHcmlkKGF4ZXMsIGZ5R3JpZCwgZ3JpZEZ5LCBmeSk7XG4gIG1heWJlQXhpcyhheGVzLCBmeUF4aXMsIGF4aXNGeSwgXCJyaWdodFwiLCBcImxlZnRcIiwgZmFjZXQsIGZ5KTtcbiAgbWF5YmVHcmlkKGF4ZXMsIGZ4R3JpZCwgZ3JpZEZ4LCBmeCk7XG4gIG1heWJlQXhpcyhheGVzLCBmeEF4aXMsIGF4aXNGeCwgXCJ0b3BcIiwgXCJib3R0b21cIiwgZmFjZXQsIGZ4KTtcbiAgbWF5YmVHcmlkKGF4ZXMsIHlHcmlkLCBncmlkWSwgeSk7XG4gIG1heWJlQXhpcyhheGVzLCB5QXhpcywgYXhpc1ksIFwibGVmdFwiLCBcInJpZ2h0XCIsIG9wdGlvbnMsIHkpO1xuICBtYXliZUdyaWQoYXhlcywgeEdyaWQsIGdyaWRYLCB4KTtcbiAgbWF5YmVBeGlzKGF4ZXMsIHhBeGlzLCBheGlzWCwgXCJib3R0b21cIiwgXCJ0b3BcIiwgb3B0aW9ucywgeCk7XG4gIHJldHVybiBheGVzO1xufVxuXG5mdW5jdGlvbiBtYXliZUF4aXMoYXhlcywgYXhpcywgYXhpc1R5cGUsIHByaW1hcnksIHNlY29uZGFyeSwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgaWYgKCFheGlzKSByZXR1cm47XG4gIGNvbnN0IGJvdGggPSBpc0JvdGgoYXhpcyk7XG4gIG9wdGlvbnMgPSBheGlzT3B0aW9ucyhib3RoID8gcHJpbWFyeSA6IGF4aXMsIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgY29uc3Qge2xpbmV9ID0gb3B0aW9ucztcbiAgaWYgKChheGlzVHlwZSA9PT0gYXhpc1kgfHwgYXhpc1R5cGUgPT09IGF4aXNYKSAmJiBsaW5lICYmICFpc05vbmUobGluZSkpIGF4ZXMucHVzaChmcmFtZShsaW5lT3B0aW9ucyhvcHRpb25zKSkpO1xuICBheGVzLnB1c2goYXhpc1R5cGUob3B0aW9ucykpO1xuICBpZiAoYm90aCkgYXhlcy5wdXNoKGF4aXNUeXBlKHsuLi5vcHRpb25zLCBhbmNob3I6IHNlY29uZGFyeSwgbGFiZWw6IG51bGx9KSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlR3JpZChheGVzLCBncmlkLCBncmlkVHlwZSwgb3B0aW9ucykge1xuICBpZiAoIWdyaWQgfHwgaXNOb25lKGdyaWQpKSByZXR1cm47XG4gIGF4ZXMucHVzaChncmlkVHlwZShncmlkT3B0aW9ucyhncmlkLCBvcHRpb25zKSkpO1xufVxuXG5mdW5jdGlvbiBpc0JvdGgodmFsdWUpIHtcbiAgcmV0dXJuIC9eXFxzKmJvdGhcXHMqJC9pLnRlc3QodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBheGlzT3B0aW9ucyhcbiAgYW5jaG9yLFxuICBkZWZhdWx0cyxcbiAge1xuICAgIGxpbmUgPSBkZWZhdWx0cy5saW5lLFxuICAgIHRpY2tzLFxuICAgIHRpY2tTaXplLFxuICAgIHRpY2tTcGFjaW5nLFxuICAgIHRpY2tQYWRkaW5nLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgdGlja1JvdGF0ZSxcbiAgICBmb250VmFyaWFudCxcbiAgICBhcmlhTGFiZWwsXG4gICAgYXJpYURlc2NyaXB0aW9uLFxuICAgIGxhYmVsID0gZGVmYXVsdHMubGFiZWwsXG4gICAgbGFiZWxBbmNob3IsXG4gICAgbGFiZWxBcnJvdyA9IGRlZmF1bHRzLmxhYmVsQXJyb3csXG4gICAgbGFiZWxPZmZzZXRcbiAgfVxuKSB7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGxpbmUsXG4gICAgdGlja3MsXG4gICAgdGlja1NpemUsXG4gICAgdGlja1NwYWNpbmcsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgdGlja0Zvcm1hdCxcbiAgICB0aWNrUm90YXRlLFxuICAgIGZvbnRWYXJpYW50LFxuICAgIGFyaWFMYWJlbCxcbiAgICBhcmlhRGVzY3JpcHRpb24sXG4gICAgbGFiZWwsXG4gICAgbGFiZWxBbmNob3IsXG4gICAgbGFiZWxBcnJvdyxcbiAgICBsYWJlbE9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBsaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IHthbmNob3IsIGxpbmV9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHthbmNob3IsIGZhY2V0QW5jaG9yOiBhbmNob3IgKyBcIi1lbXB0eVwiLCBzdHJva2U6IGxpbmUgPT09IHRydWUgPyB1bmRlZmluZWQgOiBsaW5lfTtcbn1cblxuZnVuY3Rpb24gZ3JpZE9wdGlvbnMoXG4gIGdyaWQsXG4gIHtcbiAgICBzdHJva2UgPSBpc0NvbG9yKGdyaWQpID8gZ3JpZCA6IHVuZGVmaW5lZCxcbiAgICB0aWNrcyA9IGlzR3JpZFRpY2tzKGdyaWQpID8gZ3JpZCA6IHVuZGVmaW5lZCxcbiAgICB0aWNrU3BhY2luZyxcbiAgICBhcmlhTGFiZWwsXG4gICAgYXJpYURlc2NyaXB0aW9uXG4gIH1cbikge1xuICByZXR1cm4ge1xuICAgIHN0cm9rZSxcbiAgICB0aWNrcyxcbiAgICB0aWNrU3BhY2luZyxcbiAgICBhcmlhTGFiZWwsXG4gICAgYXJpYURlc2NyaXB0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzR3JpZFRpY2tzKGdyaWQpIHtcbiAgc3dpdGNoICh0eXBlb2YgZ3JpZCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiAhaXNDb2xvcihncmlkKTtcbiAgfVxuICByZXR1cm4gaXNJdGVyYWJsZShncmlkKSB8fCB0eXBlb2YgZ3JpZD8ucmFuZ2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gSXMgdGhlcmUgYW4gZXhwbGljaXQgYXhpcyBhbHJlYWR5IHByZXNlbnQ/IFRPRE8gV2UgcHJvYmFibHkgd2FudCBhIG1vcmVcbi8vIGV4cGxpY2l0IHRlc3QgdGhhbiBsb29raW5nIGZvciB0aGUgQVJJQSBsYWJlbCwgYnV0IGl0IGRvZXMgYWZmb3JkIHNvbWVcbi8vIGZsZXhpYmlsaXR5IGluIGF4aXMgaW1wbGVtZW50YXRpb24gd2hpY2ggaXMgbmljZS5cbmZ1bmN0aW9uIGhhc0F4aXMobWFya3MsIGspIHtcbiAgY29uc3QgcHJlZml4ID0gYCR7a30tYXhpcyBgO1xuICByZXR1cm4gbWFya3Muc29tZSgobSkgPT4gbS5hcmlhTGFiZWw/LnN0YXJ0c1dpdGgocHJlZml4KSk7XG59XG5cbmZ1bmN0aW9uIGhhc1Bvc2l0aW9uQ2hhbm5lbChrLCBtYXJrcykge1xuICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXJrLmNoYW5uZWxzKSB7XG4gICAgICBjb25zdCB7c2NhbGV9ID0gbWFyay5jaGFubmVsc1trZXldO1xuICAgICAgaWYgKHNjYWxlID09PSBrIHx8IHNjYWxlID09PSBcInByb2plY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpbmhlcml0U2NhbGVMYWJlbHMobmV3U2NhbGVzLCBzY2FsZXMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV3U2NhbGVzKSB7XG4gICAgY29uc3QgbmV3U2NhbGUgPSBuZXdTY2FsZXNba2V5XTtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIGlmIChuZXdTY2FsZS5sYWJlbCA9PT0gdW5kZWZpbmVkICYmIHNjYWxlKSB7XG4gICAgICBuZXdTY2FsZS5sYWJlbCA9IHNjYWxlLmxhYmVsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3U2NhbGVzO1xufVxuXG4vLyBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgb3V0ZXJEaW1lbnNpb25zIGluIHRoYXQgaXQgYWNjb3VudHMgZm9yIHJvdW5kaW5nXG4vLyBhbmQgb3V0ZXIgcGFkZGluZyBpbiB0aGUgZmFjZXQgc2NhbGVzOyB3ZSB3YW50IHRoZSBmcmFtZSB0byBhbGlnbiBleGFjdGx5XG4vLyB3aXRoIHRoZSBhY3R1YWwgcmFuZ2UsIG5vdCB0aGUgZGVzaXJlZCByYW5nZS5cbmZ1bmN0aW9uIGFjdHVhbERpbWVuc2lvbnMoe2Z4LCBmeX0sIGRpbWVuc2lvbnMpIHtcbiAgY29uc3Qge21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgd2lkdGgsIGhlaWdodH0gPSBvdXRlckRpbWVuc2lvbnMoZGltZW5zaW9ucyk7XG4gIGNvbnN0IGZ4ciA9IGZ4ICYmIG91dGVyUmFuZ2UoZngpO1xuICBjb25zdCBmeXIgPSBmeSAmJiBvdXRlclJhbmdlKGZ5KTtcbiAgcmV0dXJuIHtcbiAgICBtYXJnaW5Ub3A6IGZ5ID8gZnlyWzBdIDogbWFyZ2luVG9wLFxuICAgIG1hcmdpblJpZ2h0OiBmeCA/IHdpZHRoIC0gZnhyWzFdIDogbWFyZ2luUmlnaHQsXG4gICAgbWFyZ2luQm90dG9tOiBmeSA/IGhlaWdodCAtIGZ5clsxXSA6IG1hcmdpbkJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0OiBmeCA/IGZ4clswXSA6IG1hcmdpbkxlZnQsXG4gICAgLy8gU29tZSBtYXJrcywgbmFtZWx5IHRoZSB4LSBhbmQgeS1heGlzIGxhYmVscywgd2FudCB0byBrbm93IHdoYXQgdGhlXG4gICAgLy8gZGVzaXJlZCAocmF0aGVyIHRoYW4gYWN0dWFsKSBtYXJnaW5zIGFyZSBmb3IgcG9zaXRpb25pbmcuXG4gICAgaW5zZXQ6IHtcbiAgICAgIG1hcmdpblRvcDogZGltZW5zaW9ucy5tYXJnaW5Ub3AsXG4gICAgICBtYXJnaW5SaWdodDogZGltZW5zaW9ucy5tYXJnaW5SaWdodCxcbiAgICAgIG1hcmdpbkJvdHRvbTogZGltZW5zaW9ucy5tYXJnaW5Cb3R0b20sXG4gICAgICBtYXJnaW5MZWZ0OiBkaW1lbnNpb25zLm1hcmdpbkxlZnRcbiAgICB9LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBvdXRlclJhbmdlKHNjYWxlKSB7XG4gIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFswLCBzY2FsZS5iYW5kd2lkdGgoKV07XG4gIGxldCB4MSA9IHNjYWxlKGRvbWFpblswXSk7XG4gIGxldCB4MiA9IHNjYWxlKGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0pO1xuICBpZiAoeDIgPCB4MSkgW3gxLCB4Ml0gPSBbeDIsIHgxXTtcbiAgcmV0dXJuIFt4MSwgeDIgKyBzY2FsZS5iYW5kd2lkdGgoKV07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/plot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/projection.js":
/*!***********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/projection.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPosition: () => (/* binding */ applyPosition),\n/* harmony export */   createProjection: () => (/* binding */ createProjection),\n/* harmony export */   getGeometryChannels: () => (/* binding */ getGeometryChannels),\n/* harmony export */   hasProjection: () => (/* binding */ hasProjection),\n/* harmony export */   project: () => (/* binding */ project),\n/* harmony export */   projectionAspectRatio: () => (/* binding */ projectionAspectRatio),\n/* harmony export */   xyProjection: () => (/* binding */ xyProjection)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./channel.js */ \"(ssr)/./node_modules/@observablehq/plot/src/channel.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n\n\n\n\n\nconst pi = Math.PI;\nconst tau = 2 * pi;\nconst defaultAspectRatio = 0.618;\n\nfunction createProjection(\n  {\n    projection,\n    inset: globalInset = 0,\n    insetTop = globalInset,\n    insetRight = globalInset,\n    insetBottom = globalInset,\n    insetLeft = globalInset\n  } = {},\n  dimensions\n) {\n  if (projection == null) return;\n  if (typeof projection.stream === \"function\") return projection; // d3 projection\n  let options;\n  let domain;\n  let clip = \"frame\";\n\n  // If the projection was specified as an object with additional options,\n  // extract those. The order of precedence for insetTop (and other insets) is:\n  // projection.insetTop, projection.inset, (global) insetTop, (global) inset.\n  // Any other options on this object will be passed through to the initializer.\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(projection)) {\n    let inset;\n    ({\n      type: projection,\n      domain,\n      inset,\n      insetTop = inset !== undefined ? inset : insetTop,\n      insetRight = inset !== undefined ? inset : insetRight,\n      insetBottom = inset !== undefined ? inset : insetBottom,\n      insetLeft = inset !== undefined ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection);\n    if (projection == null) return;\n  }\n\n  // For named projections, retrieve the corresponding projection initializer.\n  if (typeof projection !== \"function\") ({type: projection} = namedProjection(projection));\n\n  // Compute the frame dimensions and invoke the projection initializer.\n  const {width, height, marginLeft, marginRight, marginTop, marginBottom} = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection = projection?.({width: dx, height: dy, clip, ...options});\n\n  // The projection initializer might decide to not use a projection.\n  if (projection == null) return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n\n  // Translate the origin to the top-left corner, respecting margins and insets.\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform;\n\n  // If a domain is specified, fit the projection to the frame.\n  if (domain != null) {\n    const [[x0, y0], [x1, y1]] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoPath)(projection).bounds(domain);\n    const k = Math.min(dx / (x1 - x0), dy / (y1 - y0));\n    if (k > 0) {\n      tx -= (k * (x0 + x1) - dx) / 2;\n      ty -= (k * (y0 + y1) - dy) / 2;\n      transform = (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoTransform)({\n        point(x, y) {\n          this.stream.point(x * k + tx, y * k + ty);\n        }\n      });\n    } else {\n      (0,_warnings_js__WEBPACK_IMPORTED_MODULE_2__.warn)(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n\n  transform ??=\n    tx === 0 && ty === 0\n      ? identity()\n      : (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoTransform)({\n          point(x, y) {\n            this.stream.point(x + tx, y + ty);\n          }\n        });\n\n  return {stream: (s) => projection.stream(transform.stream(clip(s)))};\n}\n\nfunction namedProjection(projection) {\n  switch (`${projection}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoAlbersUsa, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoAlbers, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoAzimuthalEqualArea, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoAzimuthalEquidistant, tau, tau);\n    case \"conic-conformal\":\n      return conicProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoConicConformal, tau, tau);\n    case \"conic-equal-area\":\n      return conicProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoConicEqualArea, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoConicEquidistant, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoEqualEarth, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoEquirectangular, tau, pi);\n    case \"gnomonic\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoGnomonic, 3.4641, 3.4641);\n    case \"identity\":\n      return {type: identity};\n    case \"reflect-y\":\n      return {type: reflectY};\n    case \"mercator\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoMercator, tau, tau);\n    case \"orthographic\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoOrthographic, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoStereographic, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(d3__WEBPACK_IMPORTED_MODULE_0__.geoTransverseMercator, tau, tau);\n    default:\n      throw new Error(`unknown projection type: ${projection}`);\n  }\n}\n\nfunction maybePostClip(clip, x1, y1, x2, y2) {\n  if (clip === false || clip == null || typeof clip === \"number\") return (s) => s;\n  if (clip === true) clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoClipRectangle)(x1, y1, x2, y2);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\n\nfunction scaleProjection(createProjection, kx, ky) {\n  return {\n    type: ({width, height, rotate, precision = 0.15, clip}) => {\n      const projection = createProjection();\n      if (precision != null) projection.precision?.(precision);\n      if (rotate != null) projection.rotate?.(rotate);\n      if (typeof clip === \"number\") projection.clipAngle?.(clip);\n      if (width != null) {\n        projection.scale(Math.min(width / kx, height / ky));\n        projection.translate([width / 2, height / 2]);\n      }\n      return projection;\n    },\n    aspectRatio: ky / kx\n  };\n}\n\nfunction conicProjection(createProjection, kx, ky) {\n  const {type, aspectRatio} = scaleProjection(createProjection, kx, ky);\n  return {\n    type: (options) => {\n      const {parallels, domain, width, height} = options;\n      const projection = type(options);\n      if (parallels != null) {\n        projection.parallels(parallels);\n        if (domain === undefined && width != null) {\n          projection.fitSize([width, height], {type: \"Sphere\"});\n        }\n      }\n      return projection;\n    },\n    aspectRatio\n  };\n}\n\nconst identity = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.constant)({stream: (stream) => stream});\n\nconst reflectY = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.constant)(\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoTransform)({\n    point(x, y) {\n      this.stream.point(x, -y);\n    }\n  })\n);\n\n// Applies a point-wise projection to the given paired x and y channels.\n// Note: mutates values!\nfunction project(cx, cy, values, projection) {\n  const x = values[cx];\n  const y = values[cy];\n  const n = x.length;\n  const X = (values[cx] = new Float64Array(n).fill(NaN));\n  const Y = (values[cy] = new Float64Array(n).fill(NaN));\n  let i;\n  const stream = projection.stream({\n    point(x, y) {\n      X[i] = x;\n      Y[i] = y;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x[i], y[i]);\n  }\n}\n\n// Returns true if a projection was specified. This should match the logic of\n// createProjection above, and is called before we construct the projection.\n// (Though note that we ignore the edge case where the projection initializer\n// may return null.)\nfunction hasProjection({projection} = {}) {\n  if (projection == null) return false;\n  if (typeof projection.stream === \"function\") return true;\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(projection)) projection = projection.type;\n  return projection != null;\n}\n\n// When a projection is specified, we can use its aspect ratio to determine a\n// good value for the projection’s height based on the desired width. When we\n// don’t have a way to know, the golden ratio is our best guess. Due to a\n// circular dependency (we need to know the height before we can construct the\n// projection), we have to test the raw projection option rather than the\n// materialized projection; therefore we must be extremely careful that the\n// logic of this function exactly matches createProjection above!\nfunction projectionAspectRatio(projection) {\n  if (typeof projection?.stream === \"function\") return defaultAspectRatio;\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(projection)) {\n    let domain, options;\n    ({domain, type: projection, ...options} = projection);\n    if (domain != null && projection != null) {\n      const type = typeof projection === \"string\" ? namedProjection(projection).type : projection;\n      const [[x0, y0], [x1, y1]] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoPath)(type({...options, width: 100, height: 100})).bounds(domain);\n      const r = (y1 - y0) / (x1 - x0);\n      return r && isFinite(r) ? (r < 0.2 ? 0.2 : r > 5 ? 5 : r) : defaultAspectRatio;\n    }\n  }\n  if (projection == null) return;\n  if (typeof projection !== \"function\") {\n    const {aspectRatio} = namedProjection(projection);\n    if (aspectRatio) return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\n\n// Extract the (possibly) scaled values for the x and y channels, and apply the\n// projection if any.\nfunction applyPosition(channels, scales, {projection}) {\n  const {x, y} = channels;\n  let position = {};\n  if (x) position.x = x;\n  if (y) position.y = y;\n  position = (0,_channel_js__WEBPACK_IMPORTED_MODULE_3__.valueObject)(position, scales);\n  if (projection && x?.scale === \"x\" && y?.scale === \"y\") project(\"x\", \"y\", position, projection);\n  if (x) position.x = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.coerceNumbers)(position.x);\n  if (y) position.y = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.coerceNumbers)(position.y);\n  return position;\n}\n\nfunction getGeometryChannels(channel) {\n  const X = [];\n  const Y = [];\n  const x = {scale: \"x\", value: X};\n  const y = {scale: \"y\", value: Y};\n  const sink = {\n    point(x, y) {\n      X.push(x);\n      Y.push(y);\n    },\n    lineStart() {},\n    lineEnd() {},\n    polygonStart() {},\n    polygonEnd() {},\n    sphere() {}\n  };\n  for (const object of channel.value) (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoStream)(object, sink);\n  return [x, y];\n}\n\n// If no projection is specified, default to a projection that passes points\n// through the x and y scales, if any.\nfunction xyProjection({x: X, y: Y}) {\n  if (X || Y) {\n    X ??= (x) => x;\n    Y ??= (y) => y;\n    return (0,d3__WEBPACK_IMPORTED_MODULE_0__.geoTransform)({\n      point(x, y) {\n        this.stream.point(X(x), Y(y));\n      }\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9wcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBbUJZO0FBQzZCO0FBQ3NCO0FBQzVCOztBQUVuQztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGtCQUFrQjs7QUFFNUQ7QUFDQSxTQUFTLGlFQUFpRTtBQUMxRTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUF3Qzs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsMkNBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixNQUFNLGtEQUFJLG9FQUFvRTtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSw2QkFBNkIsNENBQVk7QUFDekM7QUFDQSw2QkFBNkIseUNBQVM7QUFDdEM7QUFDQSw2QkFBNkIscURBQXFCO0FBQ2xEO0FBQ0EsNkJBQTZCLHVEQUF1QjtBQUNwRDtBQUNBLDZCQUE2QixpREFBaUI7QUFDOUM7QUFDQSw2QkFBNkIsaURBQWlCO0FBQzlDO0FBQ0EsNkJBQTZCLG1EQUFtQjtBQUNoRDtBQUNBLDZCQUE2Qiw2Q0FBYTtBQUMxQztBQUNBLDZCQUE2QixrREFBa0I7QUFDL0M7QUFDQSw2QkFBNkIsMkNBQVc7QUFDeEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2QkFBNkIsMkNBQVc7QUFDeEM7QUFDQSw2QkFBNkIsK0NBQWU7QUFDNUM7QUFDQSw2QkFBNkIsZ0RBQWdCO0FBQzdDO0FBQ0EsNkJBQTZCLHFEQUFxQjtBQUNsRDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsYUFBYSxvREFBZ0I7QUFDN0I7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscURBQVEsRUFBRSwyQkFBMkI7O0FBRXRELGlCQUFpQixxREFBUTtBQUN6QixFQUFFLGdEQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QixZQUFZLElBQUk7QUFDL0M7QUFDQTtBQUNBLE1BQU0scURBQVE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDTztBQUNQO0FBQ0EsTUFBTSxxREFBUTtBQUNkO0FBQ0EsTUFBTSxzQ0FBc0M7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQywyQ0FBTyxPQUFPLG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPLDBDQUEwQyxXQUFXO0FBQzVELFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQVc7QUFDeEI7QUFDQSxzQkFBc0IsMERBQWE7QUFDbkMsc0JBQXNCLDBEQUFhO0FBQ25DO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBUztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDTyx1QkFBdUIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9wcm9qZWN0aW9uLmpzPzA5ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZ2VvQWxiZXJzLFxuICBnZW9BbGJlcnNVc2EsXG4gIGdlb0F6aW11dGhhbEVxdWFsQXJlYSxcbiAgZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnQsXG4gIGdlb0NsaXBSZWN0YW5nbGUsXG4gIGdlb0NvbmljQ29uZm9ybWFsLFxuICBnZW9Db25pY0VxdWFsQXJlYSxcbiAgZ2VvQ29uaWNFcXVpZGlzdGFudCxcbiAgZ2VvRXF1YWxFYXJ0aCxcbiAgZ2VvRXF1aXJlY3Rhbmd1bGFyLFxuICBnZW9Hbm9tb25pYyxcbiAgZ2VvTWVyY2F0b3IsXG4gIGdlb09ydGhvZ3JhcGhpYyxcbiAgZ2VvUGF0aCxcbiAgZ2VvU3RlcmVvZ3JhcGhpYyxcbiAgZ2VvU3RyZWFtLFxuICBnZW9UcmFuc2Zvcm0sXG4gIGdlb1RyYW5zdmVyc2VNZXJjYXRvclxufSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7dmFsdWVPYmplY3R9IGZyb20gXCIuL2NoYW5uZWwuanNcIjtcbmltcG9ydCB7Y29lcmNlTnVtYmVycywgY29uc3RhbnQsIGlzT2JqZWN0fSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge3dhcm59IGZyb20gXCIuL3dhcm5pbmdzLmpzXCI7XG5cbmNvbnN0IHBpID0gTWF0aC5QSTtcbmNvbnN0IHRhdSA9IDIgKiBwaTtcbmNvbnN0IGRlZmF1bHRBc3BlY3RSYXRpbyA9IDAuNjE4O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihcbiAge1xuICAgIHByb2plY3Rpb24sXG4gICAgaW5zZXQ6IGdsb2JhbEluc2V0ID0gMCxcbiAgICBpbnNldFRvcCA9IGdsb2JhbEluc2V0LFxuICAgIGluc2V0UmlnaHQgPSBnbG9iYWxJbnNldCxcbiAgICBpbnNldEJvdHRvbSA9IGdsb2JhbEluc2V0LFxuICAgIGluc2V0TGVmdCA9IGdsb2JhbEluc2V0XG4gIH0gPSB7fSxcbiAgZGltZW5zaW9uc1xuKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBwcm9qZWN0aW9uLnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gcHJvamVjdGlvbjsgLy8gZDMgcHJvamVjdGlvblxuICBsZXQgb3B0aW9ucztcbiAgbGV0IGRvbWFpbjtcbiAgbGV0IGNsaXAgPSBcImZyYW1lXCI7XG5cbiAgLy8gSWYgdGhlIHByb2plY3Rpb24gd2FzIHNwZWNpZmllZCBhcyBhbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIG9wdGlvbnMsXG4gIC8vIGV4dHJhY3QgdGhvc2UuIFRoZSBvcmRlciBvZiBwcmVjZWRlbmNlIGZvciBpbnNldFRvcCAoYW5kIG90aGVyIGluc2V0cykgaXM6XG4gIC8vIHByb2plY3Rpb24uaW5zZXRUb3AsIHByb2plY3Rpb24uaW5zZXQsIChnbG9iYWwpIGluc2V0VG9wLCAoZ2xvYmFsKSBpbnNldC5cbiAgLy8gQW55IG90aGVyIG9wdGlvbnMgb24gdGhpcyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0byB0aGUgaW5pdGlhbGl6ZXIuXG4gIGlmIChpc09iamVjdChwcm9qZWN0aW9uKSkge1xuICAgIGxldCBpbnNldDtcbiAgICAoe1xuICAgICAgdHlwZTogcHJvamVjdGlvbixcbiAgICAgIGRvbWFpbixcbiAgICAgIGluc2V0LFxuICAgICAgaW5zZXRUb3AgPSBpbnNldCAhPT0gdW5kZWZpbmVkID8gaW5zZXQgOiBpbnNldFRvcCxcbiAgICAgIGluc2V0UmlnaHQgPSBpbnNldCAhPT0gdW5kZWZpbmVkID8gaW5zZXQgOiBpbnNldFJpZ2h0LFxuICAgICAgaW5zZXRCb3R0b20gPSBpbnNldCAhPT0gdW5kZWZpbmVkID8gaW5zZXQgOiBpbnNldEJvdHRvbSxcbiAgICAgIGluc2V0TGVmdCA9IGluc2V0ICE9PSB1bmRlZmluZWQgPyBpbnNldCA6IGluc2V0TGVmdCxcbiAgICAgIGNsaXAgPSBjbGlwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0gPSBwcm9qZWN0aW9uKTtcbiAgICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gIH1cblxuICAvLyBGb3IgbmFtZWQgcHJvamVjdGlvbnMsIHJldHJpZXZlIHRoZSBjb3JyZXNwb25kaW5nIHByb2plY3Rpb24gaW5pdGlhbGl6ZXIuXG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbiAhPT0gXCJmdW5jdGlvblwiKSAoe3R5cGU6IHByb2plY3Rpb259ID0gbmFtZWRQcm9qZWN0aW9uKHByb2plY3Rpb24pKTtcblxuICAvLyBDb21wdXRlIHRoZSBmcmFtZSBkaW1lbnNpb25zIGFuZCBpbnZva2UgdGhlIHByb2plY3Rpb24gaW5pdGlhbGl6ZXIuXG4gIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBtYXJnaW5MZWZ0LCBtYXJnaW5SaWdodCwgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b219ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHggPSB3aWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodCAtIGluc2V0TGVmdCAtIGluc2V0UmlnaHQ7XG4gIGNvbnN0IGR5ID0gaGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tIC0gaW5zZXRUb3AgLSBpbnNldEJvdHRvbTtcbiAgcHJvamVjdGlvbiA9IHByb2plY3Rpb24/Lih7d2lkdGg6IGR4LCBoZWlnaHQ6IGR5LCBjbGlwLCAuLi5vcHRpb25zfSk7XG5cbiAgLy8gVGhlIHByb2plY3Rpb24gaW5pdGlhbGl6ZXIgbWlnaHQgZGVjaWRlIHRvIG5vdCB1c2UgYSBwcm9qZWN0aW9uLlxuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gIGNsaXAgPSBtYXliZVBvc3RDbGlwKGNsaXAsIG1hcmdpbkxlZnQsIG1hcmdpblRvcCwgd2lkdGggLSBtYXJnaW5SaWdodCwgaGVpZ2h0IC0gbWFyZ2luQm90dG9tKTtcblxuICAvLyBUcmFuc2xhdGUgdGhlIG9yaWdpbiB0byB0aGUgdG9wLWxlZnQgY29ybmVyLCByZXNwZWN0aW5nIG1hcmdpbnMgYW5kIGluc2V0cy5cbiAgbGV0IHR4ID0gbWFyZ2luTGVmdCArIGluc2V0TGVmdDtcbiAgbGV0IHR5ID0gbWFyZ2luVG9wICsgaW5zZXRUb3A7XG4gIGxldCB0cmFuc2Zvcm07XG5cbiAgLy8gSWYgYSBkb21haW4gaXMgc3BlY2lmaWVkLCBmaXQgdGhlIHByb2plY3Rpb24gdG8gdGhlIGZyYW1lLlxuICBpZiAoZG9tYWluICE9IG51bGwpIHtcbiAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IGdlb1BhdGgocHJvamVjdGlvbikuYm91bmRzKGRvbWFpbik7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGR4IC8gKHgxIC0geDApLCBkeSAvICh5MSAtIHkwKSk7XG4gICAgaWYgKGsgPiAwKSB7XG4gICAgICB0eCAtPSAoayAqICh4MCArIHgxKSAtIGR4KSAvIDI7XG4gICAgICB0eSAtPSAoayAqICh5MCArIHkxKSAtIGR5KSAvIDI7XG4gICAgICB0cmFuc2Zvcm0gPSBnZW9UcmFuc2Zvcm0oe1xuICAgICAgICBwb2ludCh4LCB5KSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCAqIGsgKyB0eCwgeSAqIGsgKyB0eSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBXYXJuaW5nOiB0aGUgcHJvamVjdGlvbiBjb3VsZCBub3QgYmUgZml0IHRvIHRoZSBzcGVjaWZpZWQgZG9tYWluOyB1c2luZyB0aGUgZGVmYXVsdCBzY2FsZS5gKTtcbiAgICB9XG4gIH1cblxuICB0cmFuc2Zvcm0gPz89XG4gICAgdHggPT09IDAgJiYgdHkgPT09IDBcbiAgICAgID8gaWRlbnRpdHkoKVxuICAgICAgOiBnZW9UcmFuc2Zvcm0oe1xuICAgICAgICAgIHBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKyB0eCwgeSArIHR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiB7c3RyZWFtOiAocykgPT4gcHJvamVjdGlvbi5zdHJlYW0odHJhbnNmb3JtLnN0cmVhbShjbGlwKHMpKSl9O1xufVxuXG5mdW5jdGlvbiBuYW1lZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBzd2l0Y2ggKGAke3Byb2plY3Rpb259YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImFsYmVycy11c2FcIjpcbiAgICAgIHJldHVybiBzY2FsZVByb2plY3Rpb24oZ2VvQWxiZXJzVXNhLCAwLjc0NjMsIDAuNDY3Myk7XG4gICAgY2FzZSBcImFsYmVyc1wiOlxuICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihnZW9BbGJlcnMsIDAuNzQ2MywgMC40NjczKTtcbiAgICBjYXNlIFwiYXppbXV0aGFsLWVxdWFsLWFyZWFcIjpcbiAgICAgIHJldHVybiBzY2FsZVByb2plY3Rpb24oZ2VvQXppbXV0aGFsRXF1YWxBcmVhLCA0LCA0KTtcbiAgICBjYXNlIFwiYXppbXV0aGFsLWVxdWlkaXN0YW50XCI6XG4gICAgICByZXR1cm4gc2NhbGVQcm9qZWN0aW9uKGdlb0F6aW11dGhhbEVxdWlkaXN0YW50LCB0YXUsIHRhdSk7XG4gICAgY2FzZSBcImNvbmljLWNvbmZvcm1hbFwiOlxuICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihnZW9Db25pY0NvbmZvcm1hbCwgdGF1LCB0YXUpO1xuICAgIGNhc2UgXCJjb25pYy1lcXVhbC1hcmVhXCI6XG4gICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGdlb0NvbmljRXF1YWxBcmVhLCA2LjE3MDIsIDIuOTc4MSk7XG4gICAgY2FzZSBcImNvbmljLWVxdWlkaXN0YW50XCI6XG4gICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGdlb0NvbmljRXF1aWRpc3RhbnQsIDcuMzEyLCAzLjYyODIpO1xuICAgIGNhc2UgXCJlcXVhbC1lYXJ0aFwiOlxuICAgICAgcmV0dXJuIHNjYWxlUHJvamVjdGlvbihnZW9FcXVhbEVhcnRoLCA1LjQxMzMsIDIuNjM0Nyk7XG4gICAgY2FzZSBcImVxdWlyZWN0YW5ndWxhclwiOlxuICAgICAgcmV0dXJuIHNjYWxlUHJvamVjdGlvbihnZW9FcXVpcmVjdGFuZ3VsYXIsIHRhdSwgcGkpO1xuICAgIGNhc2UgXCJnbm9tb25pY1wiOlxuICAgICAgcmV0dXJuIHNjYWxlUHJvamVjdGlvbihnZW9Hbm9tb25pYywgMy40NjQxLCAzLjQ2NDEpO1xuICAgIGNhc2UgXCJpZGVudGl0eVwiOlxuICAgICAgcmV0dXJuIHt0eXBlOiBpZGVudGl0eX07XG4gICAgY2FzZSBcInJlZmxlY3QteVwiOlxuICAgICAgcmV0dXJuIHt0eXBlOiByZWZsZWN0WX07XG4gICAgY2FzZSBcIm1lcmNhdG9yXCI6XG4gICAgICByZXR1cm4gc2NhbGVQcm9qZWN0aW9uKGdlb01lcmNhdG9yLCB0YXUsIHRhdSk7XG4gICAgY2FzZSBcIm9ydGhvZ3JhcGhpY1wiOlxuICAgICAgcmV0dXJuIHNjYWxlUHJvamVjdGlvbihnZW9PcnRob2dyYXBoaWMsIDIsIDIpO1xuICAgIGNhc2UgXCJzdGVyZW9ncmFwaGljXCI6XG4gICAgICByZXR1cm4gc2NhbGVQcm9qZWN0aW9uKGdlb1N0ZXJlb2dyYXBoaWMsIDIsIDIpO1xuICAgIGNhc2UgXCJ0cmFuc3ZlcnNlLW1lcmNhdG9yXCI6XG4gICAgICByZXR1cm4gc2NhbGVQcm9qZWN0aW9uKGdlb1RyYW5zdmVyc2VNZXJjYXRvciwgdGF1LCB0YXUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJvamVjdGlvbiB0eXBlOiAke3Byb2plY3Rpb259YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVQb3N0Q2xpcChjbGlwLCB4MSwgeTEsIHgyLCB5Mikge1xuICBpZiAoY2xpcCA9PT0gZmFsc2UgfHwgY2xpcCA9PSBudWxsIHx8IHR5cGVvZiBjbGlwID09PSBcIm51bWJlclwiKSByZXR1cm4gKHMpID0+IHM7XG4gIGlmIChjbGlwID09PSB0cnVlKSBjbGlwID0gXCJmcmFtZVwiO1xuICBzd2l0Y2ggKGAke2NsaXB9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImZyYW1lXCI6XG4gICAgICByZXR1cm4gZ2VvQ2xpcFJlY3RhbmdsZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcm9qZWN0aW9uIGNsaXAgdHlwZTogJHtjbGlwfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxlUHJvamVjdGlvbihjcmVhdGVQcm9qZWN0aW9uLCBreCwga3kpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAoe3dpZHRoLCBoZWlnaHQsIHJvdGF0ZSwgcHJlY2lzaW9uID0gMC4xNSwgY2xpcH0pID0+IHtcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKCk7XG4gICAgICBpZiAocHJlY2lzaW9uICE9IG51bGwpIHByb2plY3Rpb24ucHJlY2lzaW9uPy4ocHJlY2lzaW9uKTtcbiAgICAgIGlmIChyb3RhdGUgIT0gbnVsbCkgcHJvamVjdGlvbi5yb3RhdGU/Lihyb3RhdGUpO1xuICAgICAgaWYgKHR5cGVvZiBjbGlwID09PSBcIm51bWJlclwiKSBwcm9qZWN0aW9uLmNsaXBBbmdsZT8uKGNsaXApO1xuICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgcHJvamVjdGlvbi5zY2FsZShNYXRoLm1pbih3aWR0aCAvIGt4LCBoZWlnaHQgLyBreSkpO1xuICAgICAgICBwcm9qZWN0aW9uLnRyYW5zbGF0ZShbd2lkdGggLyAyLCBoZWlnaHQgLyAyXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICB9LFxuICAgIGFzcGVjdFJhdGlvOiBreSAvIGt4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihjcmVhdGVQcm9qZWN0aW9uLCBreCwga3kpIHtcbiAgY29uc3Qge3R5cGUsIGFzcGVjdFJhdGlvfSA9IHNjYWxlUHJvamVjdGlvbihjcmVhdGVQcm9qZWN0aW9uLCBreCwga3kpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCB7cGFyYWxsZWxzLCBkb21haW4sIHdpZHRoLCBoZWlnaHR9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0eXBlKG9wdGlvbnMpO1xuICAgICAgaWYgKHBhcmFsbGVscyAhPSBudWxsKSB7XG4gICAgICAgIHByb2plY3Rpb24ucGFyYWxsZWxzKHBhcmFsbGVscyk7XG4gICAgICAgIGlmIChkb21haW4gPT09IHVuZGVmaW5lZCAmJiB3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvamVjdGlvbi5maXRTaXplKFt3aWR0aCwgaGVpZ2h0XSwge3R5cGU6IFwiU3BoZXJlXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgfSxcbiAgICBhc3BlY3RSYXRpb1xuICB9O1xufVxuXG5jb25zdCBpZGVudGl0eSA9IGNvbnN0YW50KHtzdHJlYW06IChzdHJlYW0pID0+IHN0cmVhbX0pO1xuXG5jb25zdCByZWZsZWN0WSA9IGNvbnN0YW50KFxuICBnZW9UcmFuc2Zvcm0oe1xuICAgIHBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHgsIC15KTtcbiAgICB9XG4gIH0pXG4pO1xuXG4vLyBBcHBsaWVzIGEgcG9pbnQtd2lzZSBwcm9qZWN0aW9uIHRvIHRoZSBnaXZlbiBwYWlyZWQgeCBhbmQgeSBjaGFubmVscy5cbi8vIE5vdGU6IG11dGF0ZXMgdmFsdWVzIVxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3QoY3gsIGN5LCB2YWx1ZXMsIHByb2plY3Rpb24pIHtcbiAgY29uc3QgeCA9IHZhbHVlc1tjeF07XG4gIGNvbnN0IHkgPSB2YWx1ZXNbY3ldO1xuICBjb25zdCBuID0geC5sZW5ndGg7XG4gIGNvbnN0IFggPSAodmFsdWVzW2N4XSA9IG5ldyBGbG9hdDY0QXJyYXkobikuZmlsbChOYU4pKTtcbiAgY29uc3QgWSA9ICh2YWx1ZXNbY3ldID0gbmV3IEZsb2F0NjRBcnJheShuKS5maWxsKE5hTikpO1xuICBsZXQgaTtcbiAgY29uc3Qgc3RyZWFtID0gcHJvamVjdGlvbi5zdHJlYW0oe1xuICAgIHBvaW50KHgsIHkpIHtcbiAgICAgIFhbaV0gPSB4O1xuICAgICAgWVtpXSA9IHk7XG4gICAgfVxuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHN0cmVhbS5wb2ludCh4W2ldLCB5W2ldKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgYSBwcm9qZWN0aW9uIHdhcyBzcGVjaWZpZWQuIFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBsb2dpYyBvZlxuLy8gY3JlYXRlUHJvamVjdGlvbiBhYm92ZSwgYW5kIGlzIGNhbGxlZCBiZWZvcmUgd2UgY29uc3RydWN0IHRoZSBwcm9qZWN0aW9uLlxuLy8gKFRob3VnaCBub3RlIHRoYXQgd2UgaWdub3JlIHRoZSBlZGdlIGNhc2Ugd2hlcmUgdGhlIHByb2plY3Rpb24gaW5pdGlhbGl6ZXJcbi8vIG1heSByZXR1cm4gbnVsbC4pXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJvamVjdGlvbih7cHJvamVjdGlvbn0gPSB7fSkge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbi5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIGlmIChpc09iamVjdChwcm9qZWN0aW9uKSkgcHJvamVjdGlvbiA9IHByb2plY3Rpb24udHlwZTtcbiAgcmV0dXJuIHByb2plY3Rpb24gIT0gbnVsbDtcbn1cblxuLy8gV2hlbiBhIHByb2plY3Rpb24gaXMgc3BlY2lmaWVkLCB3ZSBjYW4gdXNlIGl0cyBhc3BlY3QgcmF0aW8gdG8gZGV0ZXJtaW5lIGFcbi8vIGdvb2QgdmFsdWUgZm9yIHRoZSBwcm9qZWN0aW9u4oCZcyBoZWlnaHQgYmFzZWQgb24gdGhlIGRlc2lyZWQgd2lkdGguIFdoZW4gd2Vcbi8vIGRvbuKAmXQgaGF2ZSBhIHdheSB0byBrbm93LCB0aGUgZ29sZGVuIHJhdGlvIGlzIG91ciBiZXN0IGd1ZXNzLiBEdWUgdG8gYVxuLy8gY2lyY3VsYXIgZGVwZW5kZW5jeSAod2UgbmVlZCB0byBrbm93IHRoZSBoZWlnaHQgYmVmb3JlIHdlIGNhbiBjb25zdHJ1Y3QgdGhlXG4vLyBwcm9qZWN0aW9uKSwgd2UgaGF2ZSB0byB0ZXN0IHRoZSByYXcgcHJvamVjdGlvbiBvcHRpb24gcmF0aGVyIHRoYW4gdGhlXG4vLyBtYXRlcmlhbGl6ZWQgcHJvamVjdGlvbjsgdGhlcmVmb3JlIHdlIG11c3QgYmUgZXh0cmVtZWx5IGNhcmVmdWwgdGhhdCB0aGVcbi8vIGxvZ2ljIG9mIHRoaXMgZnVuY3Rpb24gZXhhY3RseSBtYXRjaGVzIGNyZWF0ZVByb2plY3Rpb24gYWJvdmUhXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbkFzcGVjdFJhdGlvKHByb2plY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBwcm9qZWN0aW9uPy5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGRlZmF1bHRBc3BlY3RSYXRpbztcbiAgaWYgKGlzT2JqZWN0KHByb2plY3Rpb24pKSB7XG4gICAgbGV0IGRvbWFpbiwgb3B0aW9ucztcbiAgICAoe2RvbWFpbiwgdHlwZTogcHJvamVjdGlvbiwgLi4ub3B0aW9uc30gPSBwcm9qZWN0aW9uKTtcbiAgICBpZiAoZG9tYWluICE9IG51bGwgJiYgcHJvamVjdGlvbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHByb2plY3Rpb24gPT09IFwic3RyaW5nXCIgPyBuYW1lZFByb2plY3Rpb24ocHJvamVjdGlvbikudHlwZSA6IHByb2plY3Rpb247XG4gICAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IGdlb1BhdGgodHlwZSh7Li4ub3B0aW9ucywgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9KSkuYm91bmRzKGRvbWFpbik7XG4gICAgICBjb25zdCByID0gKHkxIC0geTApIC8gKHgxIC0geDApO1xuICAgICAgcmV0dXJuIHIgJiYgaXNGaW5pdGUocikgPyAociA8IDAuMiA/IDAuMiA6IHIgPiA1ID8gNSA6IHIpIDogZGVmYXVsdEFzcGVjdFJhdGlvO1xuICAgIH1cbiAgfVxuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qge2FzcGVjdFJhdGlvfSA9IG5hbWVkUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAoYXNwZWN0UmF0aW8pIHJldHVybiBhc3BlY3RSYXRpbztcbiAgfVxuICByZXR1cm4gZGVmYXVsdEFzcGVjdFJhdGlvO1xufVxuXG4vLyBFeHRyYWN0IHRoZSAocG9zc2libHkpIHNjYWxlZCB2YWx1ZXMgZm9yIHRoZSB4IGFuZCB5IGNoYW5uZWxzLCBhbmQgYXBwbHkgdGhlXG4vLyBwcm9qZWN0aW9uIGlmIGFueS5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBvc2l0aW9uKGNoYW5uZWxzLCBzY2FsZXMsIHtwcm9qZWN0aW9ufSkge1xuICBjb25zdCB7eCwgeX0gPSBjaGFubmVscztcbiAgbGV0IHBvc2l0aW9uID0ge307XG4gIGlmICh4KSBwb3NpdGlvbi54ID0geDtcbiAgaWYgKHkpIHBvc2l0aW9uLnkgPSB5O1xuICBwb3NpdGlvbiA9IHZhbHVlT2JqZWN0KHBvc2l0aW9uLCBzY2FsZXMpO1xuICBpZiAocHJvamVjdGlvbiAmJiB4Py5zY2FsZSA9PT0gXCJ4XCIgJiYgeT8uc2NhbGUgPT09IFwieVwiKSBwcm9qZWN0KFwieFwiLCBcInlcIiwgcG9zaXRpb24sIHByb2plY3Rpb24pO1xuICBpZiAoeCkgcG9zaXRpb24ueCA9IGNvZXJjZU51bWJlcnMocG9zaXRpb24ueCk7XG4gIGlmICh5KSBwb3NpdGlvbi55ID0gY29lcmNlTnVtYmVycyhwb3NpdGlvbi55KTtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvbWV0cnlDaGFubmVscyhjaGFubmVsKSB7XG4gIGNvbnN0IFggPSBbXTtcbiAgY29uc3QgWSA9IFtdO1xuICBjb25zdCB4ID0ge3NjYWxlOiBcInhcIiwgdmFsdWU6IFh9O1xuICBjb25zdCB5ID0ge3NjYWxlOiBcInlcIiwgdmFsdWU6IFl9O1xuICBjb25zdCBzaW5rID0ge1xuICAgIHBvaW50KHgsIHkpIHtcbiAgICAgIFgucHVzaCh4KTtcbiAgICAgIFkucHVzaCh5KTtcbiAgICB9LFxuICAgIGxpbmVTdGFydCgpIHt9LFxuICAgIGxpbmVFbmQoKSB7fSxcbiAgICBwb2x5Z29uU3RhcnQoKSB7fSxcbiAgICBwb2x5Z29uRW5kKCkge30sXG4gICAgc3BoZXJlKCkge31cbiAgfTtcbiAgZm9yIChjb25zdCBvYmplY3Qgb2YgY2hhbm5lbC52YWx1ZSkgZ2VvU3RyZWFtKG9iamVjdCwgc2luayk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8vIElmIG5vIHByb2plY3Rpb24gaXMgc3BlY2lmaWVkLCBkZWZhdWx0IHRvIGEgcHJvamVjdGlvbiB0aGF0IHBhc3NlcyBwb2ludHNcbi8vIHRocm91Z2ggdGhlIHggYW5kIHkgc2NhbGVzLCBpZiBhbnkuXG5leHBvcnQgZnVuY3Rpb24geHlQcm9qZWN0aW9uKHt4OiBYLCB5OiBZfSkge1xuICBpZiAoWCB8fCBZKSB7XG4gICAgWCA/Pz0gKHgpID0+IHg7XG4gICAgWSA/Pz0gKHkpID0+IHk7XG4gICAgcmV0dXJuIGdlb1RyYW5zZm9ybSh7XG4gICAgICBwb2ludCh4LCB5KSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KFgoeCksIFkoeSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/projection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales.js":
/*!*******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoScaleRange: () => (/* binding */ autoScaleRange),\n/* harmony export */   createScaleFunctions: () => (/* binding */ createScaleFunctions),\n/* harmony export */   createScales: () => (/* binding */ createScales),\n/* harmony export */   exposeScales: () => (/* binding */ exposeScales),\n/* harmony export */   inferScaleOrder: () => (/* binding */ inferScaleOrder),\n/* harmony export */   innerDimensions: () => (/* binding */ innerDimensions),\n/* harmony export */   isCollapsed: () => (/* binding */ isCollapsed),\n/* harmony export */   isDivergingScale: () => (/* binding */ isDivergingScale),\n/* harmony export */   isOrdinalScale: () => (/* binding */ isOrdinalScale),\n/* harmony export */   isTemporalScale: () => (/* binding */ isTemporalScale),\n/* harmony export */   isThresholdScale: () => (/* binding */ isThresholdScale),\n/* harmony export */   normalizeScale: () => (/* binding */ normalizeScale),\n/* harmony export */   outerDimensions: () => (/* binding */ outerDimensions),\n/* harmony export */   scale: () => (/* binding */ scale)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./order.js */ \"(ssr)/./node_modules/@observablehq/plot/src/order.js\");\n/* harmony import */ var _scales_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scales/index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scales/quantitative.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js\");\n/* harmony import */ var _scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scales/diverging.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/diverging.js\");\n/* harmony import */ var _scales_schemes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scales/schemes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js\");\n/* harmony import */ var _scales_temporal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scales/temporal.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/temporal.js\");\n/* harmony import */ var _scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scales/ordinal.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/ordinal.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction createScales(\n  channelsByScale,\n  {\n    label: globalLabel,\n    inset: globalInset = 0,\n    insetTop: globalInsetTop = globalInset,\n    insetRight: globalInsetRight = globalInset,\n    insetBottom: globalInsetBottom = globalInset,\n    insetLeft: globalInsetLeft = globalInset,\n    round,\n    nice,\n    clamp,\n    zero,\n    align,\n    padding,\n    projection,\n    facet: {label: facetLabel = globalLabel} = {},\n    ...options\n  } = {}\n) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale = createScale(key, channels, {\n      round: _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.registry.get(key) === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.position ? round : undefined, // only for position\n      nice,\n      clamp,\n      zero,\n      align,\n      padding,\n      projection,\n      ...scaleOptions\n    });\n    if (scale) {\n      // populate generic scale options (percent, transform, insets)\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform,\n        inset,\n        insetTop = inset !== undefined ? inset : key === \"y\" ? globalInsetTop : 0, // not fy\n        insetRight = inset !== undefined ? inset : key === \"x\" ? globalInsetRight : 0, // not fx\n        insetBottom = inset !== undefined ? inset : key === \"y\" ? globalInsetBottom : 0, // not fy\n        insetLeft = inset !== undefined ? inset : key === \"x\" ? globalInsetLeft : 0 // not fx\n      } = scaleOptions || {};\n      if (transform == null) transform = undefined;\n      else if (typeof transform !== \"function\") throw new Error(\"invalid scale transform; not a function\");\n      scale.percent = !!percent;\n      scale.label = label === undefined ? inferScaleLabel(channels, scale) : label;\n      scale.transform = transform;\n      if (key === \"x\" || key === \"fx\") {\n        scale.insetLeft = +insetLeft;\n        scale.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale.insetTop = +insetTop;\n        scale.insetBottom = +insetBottom;\n      }\n      scales[key] = scale;\n    }\n  }\n  return scales;\n}\n\nfunction createScaleFunctions(descriptors) {\n  const scales = {};\n  const scaleFunctions = {scales};\n  for (const [key, descriptor] of Object.entries(descriptors)) {\n    const {scale, type, interval, label} = descriptor;\n    scales[key] = exposeScale(descriptor);\n    scaleFunctions[key] = scale;\n    // TODO: pass these properties, which are needed for axes, in the descriptor.\n    scale.type = type;\n    if (interval != null) scale.interval = interval;\n    if (label != null) scale.label = label;\n  }\n  return scaleFunctions;\n}\n\n// Mutates scale.range!\nfunction autoScaleRange(scales, dimensions) {\n  const {x, y, fx, fy} = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx) autoScaleRangeX(fx, superdimensions);\n  if (fy) autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x) autoScaleRangeX(x, subdimensions);\n  if (y) autoScaleRangeY(y, subdimensions);\n}\n\n// Channels can have labels; if all the channels for a given scale are\n// consistently labeled (i.e., have the same value if not undefined), and the\n// corresponding scale doesn’t already have an explicit label, then the\n// channels’ label is promoted to the scale. This inferred label should have an\n// orientation-appropriate arrow added when used as an axis, but we don’t want\n// to add the arrow when the label is set explicitly as an option; so, the\n// inferred label is distinguished as an object with an “inferred” property.\nfunction inferScaleLabel(channels = [], scale) {\n  let label;\n  for (const {label: l} of channels) {\n    if (l === undefined) continue;\n    if (label === undefined) label = l;\n    else if (label !== l) return;\n  }\n  if (label === undefined) return;\n  if (!isOrdinalScale(scale) && scale.percent) label = `${label} (%)`;\n  return {inferred: true, toString: () => label};\n}\n\n// Determines whether the scale points in the “positive” (right or down) or\n// “negative” (left or up) direction; if the scale order cannot be determined,\n// returns NaN; used to assign an appropriate label arrow.\nfunction inferScaleOrder(scale) {\n  return Math.sign((0,_order_js__WEBPACK_IMPORTED_MODULE_1__.orderof)(scale.domain())) * Math.sign((0,_order_js__WEBPACK_IMPORTED_MODULE_1__.orderof)(scale.range()));\n}\n\n// Returns the dimensions of the outer frame; this is subdivided into facets\n// with the margins of each facet collapsing into the outer margins.\nfunction outerDimensions(dimensions) {\n  const {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width,\n    height,\n    facet: {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    }\n  } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\n\n// Returns the dimensions of each facet.\nfunction innerDimensions({fx, fy}, dimensions) {\n  const {marginTop, marginRight, marginBottom, marginLeft, width, height} = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,\n    facet: {width, height}\n  };\n}\n\nfunction autoScaleRangeX(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {insetLeft, insetRight} = scale;\n    const {width, marginLeft = 0, marginRight = 0} = dimensions;\n    const left = marginLeft + insetLeft;\n    const right = width - marginRight - insetRight;\n    scale.range = [left, Math.max(left, right)];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\n\nfunction autoScaleRangeY(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {insetTop, insetBottom} = scale;\n    const {height, marginTop = 0, marginBottom = 0} = dimensions;\n    const top = marginTop + insetTop;\n    const bottom = height - marginBottom - insetBottom;\n    scale.range = [Math.max(top, bottom), top];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);\n    else scale.range.reverse();\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\n\nfunction autoScaleRound(scale) {\n  if (scale.round === undefined && isBandScale(scale) && roundError(scale) <= 30) {\n    scale.scale.round(true);\n  }\n}\n\n// If we were to turn on rounding for this band or point scale, how much wasted\n// space would it introduce (on both ends of the range)? This must match\n// d3.scaleBand’s rounding behavior:\n// https://github.com/d3/d3-scale/blob/83555bd759c7314420bd4240642beda5e258db9e/src/band.js#L20-L32\nfunction roundError({scale}) {\n  const n = scale.domain().length;\n  const [start, stop] = scale.range();\n  const paddingInner = scale.paddingInner ? scale.paddingInner() : 1;\n  const paddingOuter = scale.paddingOuter ? scale.paddingOuter() : scale.padding();\n  const m = n - paddingInner;\n  const step = Math.abs(stop - start) / Math.max(1, m + paddingOuter * 2);\n  return (step - Math.floor(step)) * m;\n}\n\nfunction piecewiseRange(scale) {\n  const length = scale.scale.domain().length + isThresholdScale(scale);\n  if (!(length > 2)) return scale.range;\n  const [start, end] = scale.range;\n  return Array.from({length}, (_, i) => start + (i / (length - 1)) * (end - start));\n}\n\nfunction normalizeScale(key, scale, hint) {\n  return createScale(key, hint === undefined ? undefined : [{hint}], {...scale});\n}\n\nfunction createScale(key, channels = [], options = {}) {\n  const type = inferScaleType(key, channels, options);\n\n  // Warn for common misuses of implicit ordinal scales. We disable this test if\n  // you specify a scale interval or if you set the domain or range explicitly,\n  // since setting the domain or range (typically with a cardinality of more than\n  // two) is another indication that you intended for the scale to be ordinal; we\n  // also disable it for facet scales since these are always band scales.\n  if (\n    options.type === undefined &&\n    options.domain === undefined &&\n    options.range === undefined &&\n    options.interval == null &&\n    key !== \"fx\" &&\n    key !== \"fy\" &&\n    isOrdinalScale({type})\n  ) {\n    const values = channels.map(({value}) => value).filter((value) => value !== undefined);\n    if (values.some(_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal))\n      (0,_warnings_js__WEBPACK_IMPORTED_MODULE_3__.warn)(\n        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n    else if (values.some(_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporalString))\n      (0,_warnings_js__WEBPACK_IMPORTED_MODULE_3__.warn)(\n        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n    else if (values.some(_options_js__WEBPACK_IMPORTED_MODULE_2__.isNumericString))\n      (0,_warnings_js__WEBPACK_IMPORTED_MODULE_3__.warn)(\n        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n  }\n\n  options.type = type; // Mutates input!\n\n  // Once the scale type is known, coerce the associated channel values and any\n  // explicitly-specified domain to the expected type.\n  switch (type) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, _options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers);\n      break;\n    case \"identity\":\n      switch (_scales_index_js__WEBPACK_IMPORTED_MODULE_0__.registry.get(key)) {\n        case _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.position:\n          options = coerceType(channels, options, _options_js__WEBPACK_IMPORTED_MODULE_2__.coerceNumbers);\n          break;\n        case _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, _options_js__WEBPACK_IMPORTED_MODULE_2__.coerceDates);\n      break;\n  }\n\n  switch (type) {\n    case \"diverging\":\n      return (0,_scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__.createScaleDiverging)(key, channels, options);\n    case \"diverging-sqrt\":\n      return (0,_scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__.createScaleDivergingSqrt)(key, channels, options);\n    case \"diverging-pow\":\n      return (0,_scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__.createScaleDivergingPow)(key, channels, options);\n    case \"diverging-log\":\n      return (0,_scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__.createScaleDivergingLog)(key, channels, options);\n    case \"diverging-symlog\":\n      return (0,_scales_diverging_js__WEBPACK_IMPORTED_MODULE_4__.createScaleDivergingSymlog)(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case _scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.ordinalImplicit:\n      return (0,_scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.createScaleOrdinal)(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleLinear)(key, channels, options);\n    case \"sqrt\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleSqrt)(key, channels, options);\n    case \"threshold\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleThreshold)(key, channels, options);\n    case \"quantile\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleQuantile)(key, channels, options);\n    case \"quantize\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleQuantize)(key, channels, options);\n    case \"pow\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScalePow)(key, channels, options);\n    case \"log\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleLog)(key, channels, options);\n    case \"symlog\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleSymlog)(key, channels, options);\n    case \"utc\":\n      return (0,_scales_temporal_js__WEBPACK_IMPORTED_MODULE_7__.createScaleUtc)(key, channels, options);\n    case \"time\":\n      return (0,_scales_temporal_js__WEBPACK_IMPORTED_MODULE_7__.createScaleTime)(key, channels, options);\n    case \"point\":\n      return (0,_scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.createScalePoint)(key, channels, options);\n    case \"band\":\n      return (0,_scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.createScaleBand)(key, channels, options);\n    case \"identity\":\n      return (0,_scales_quantitative_js__WEBPACK_IMPORTED_MODULE_6__.createScaleIdentity)(key);\n    case undefined:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type}`);\n  }\n}\n\nfunction formatScaleType(type) {\n  return typeof type === \"symbol\" ? type.description : type;\n}\n\nfunction maybeScaleType(type) {\n  return typeof type === \"string\" ? `${type}`.toLowerCase() : type;\n}\n\n// A special type symbol when the x and y scales are replaced with a projection.\nconst typeProjection = {toString: () => \"projection\"};\n\nfunction inferScaleType(key, channels, {type, domain, range, scheme, pivot, projection}) {\n  type = maybeScaleType(type);\n\n  // The facet scales are always band scales; this cannot be changed.\n  if (key === \"fx\" || key === \"fy\") return \"band\";\n\n  // If a projection is specified, the x- and y-scales are disabled; these\n  // channels will be projected rather than scaled. (But still check that none\n  // of the associated channels are incompatible with a projection.)\n  if ((key === \"x\" || key === \"y\") && projection != null) type = typeProjection;\n\n  // If a channel dictates a scale type, make sure that it is consistent with\n  // the user-specified scale type (if any) and all other channels. For example,\n  // barY requires x to be a band scale and disallows any other scale type.\n  for (const channel of channels) {\n    const t = maybeScaleType(channel.type);\n    if (t === undefined) continue;\n    else if (type === undefined) type = t;\n    else if (type !== t) throw new Error(`scale incompatible with channel: ${type} !== ${t}`);\n  }\n\n  // If the scale, a channel, or user specified a (consistent) type, return it.\n  if (type === typeProjection) return;\n  if (type !== undefined) return type;\n\n  // If there’s no data (and no type) associated with this scale, don’t create a scale.\n  if (domain === undefined && !channels.some(({value}) => value !== undefined)) return;\n\n  // Some scales have default types.\n  const kind = _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.registry.get(key);\n  if (kind === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.radius) return \"sqrt\";\n  if (kind === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.opacity || kind === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.length) return \"linear\";\n  if (kind === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.symbol) return \"ordinal\";\n\n  // If a domain or range is explicitly specified and doesn’t have two values,\n  // assume it’s ordinal. You can still use a “piecewise” (or “polylinear”)\n  // scale, but you must set the type explicitly.\n  const n = (domain ?? range)?.length;\n  if (n < 2 || n > 2) return asOrdinalType(kind);\n\n  // Otherwise, infer the scale type from the data! Prefer the domain, if\n  // present, over channels. (The domain and channels should be consistently\n  // typed, and the domain is more explicit and typically much smaller.) We only\n  // check the first defined value for expedience and simplicity; we expect\n  // that the types are consistent.\n  if (domain !== undefined) {\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isOrdinal)(domain)) return asOrdinalType(kind);\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal)(domain)) return \"utc\";\n  } else {\n    const values = channels.map(({value}) => value).filter((value) => value !== undefined);\n    if (values.some(_options_js__WEBPACK_IMPORTED_MODULE_2__.isOrdinal)) return asOrdinalType(kind);\n    if (values.some(_options_js__WEBPACK_IMPORTED_MODULE_2__.isTemporal)) return \"utc\";\n  }\n\n  // For color scales, take a hint from the color scheme and pivot option.\n  if (kind === _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.color) {\n    if (pivot != null || (0,_scales_schemes_js__WEBPACK_IMPORTED_MODULE_8__.isDivergingScheme)(scheme)) return \"diverging\";\n    if ((0,_scales_schemes_js__WEBPACK_IMPORTED_MODULE_8__.isCategoricalScheme)(scheme)) return \"categorical\";\n  }\n\n  return \"linear\";\n}\n\n// Positional scales default to a point scale instead of an ordinal scale.\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.position:\n      return \"point\";\n    case _scales_index_js__WEBPACK_IMPORTED_MODULE_0__.color:\n      return _scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\n\nfunction isTemporalScale({type}) {\n  return type === \"time\" || type === \"utc\";\n}\n\nfunction isOrdinalScale({type}) {\n  return type === \"ordinal\" || type === \"point\" || type === \"band\" || type === _scales_ordinal_js__WEBPACK_IMPORTED_MODULE_5__.ordinalImplicit;\n}\n\nfunction isThresholdScale({type}) {\n  return type === \"threshold\";\n}\n\nfunction isBandScale({type}) {\n  return type === \"point\" || type === \"band\";\n}\n\nfunction isDivergingScale({type}) {\n  return /^diverging($|-)/.test(type);\n}\n\n// Certain marks have special behavior if a scale is collapsed, i.e. if the\n// domain is degenerate and represents only a single value such as [3, 3]; for\n// example, a rect will span the full extent of the chart along a collapsed\n// dimension (whereas a dot will simply be drawn in the center).\nfunction isCollapsed(scale) {\n  if (scale === undefined) return true; // treat missing scale as collapsed\n  const domain = scale.domain();\n  const value = scale(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Mutates channel.value!\nfunction coerceType(channels, {domain, ...options}, coerceValues) {\n  for (const c of channels) {\n    if (c.value !== undefined) {\n      if (domain === undefined) domain = c.value?.domain; // promote channel domain\n      c.value = coerceValues(c.value);\n    }\n  }\n  return {\n    domain: domain === undefined ? domain : coerceValues(domain),\n    ...options\n  };\n}\n\nfunction coerceSymbols(values) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.map)(values, _symbol_js__WEBPACK_IMPORTED_MODULE_9__.maybeSymbol);\n}\n\nfunction scale(options = {}) {\n  let scale;\n  for (const key in options) {\n    if (!_scales_index_js__WEBPACK_IMPORTED_MODULE_0__.registry.has(key)) continue; // ignore unknown properties\n    if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_2__.isScaleOptions)(options[key])) continue; // e.g., ignore {color: \"red\"}\n    if (scale !== undefined) throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale === undefined) throw new Error(\"invalid scale definition; no scale found\");\n  return scale;\n}\n\nfunction exposeScales(scales) {\n  return (key) => {\n    if (!_scales_index_js__WEBPACK_IMPORTED_MODULE_0__.registry.has((key = `${key}`))) throw new Error(`unknown scale: ${key}`);\n    return scales[key];\n  };\n}\n\n// Note: axis- and legend-related properties (such as label, ticks and\n// tickFormat) are not included here as they do not affect the scale’s behavior.\nfunction exposeScale({scale, type, domain, range, interpolate, interval, transform, percent, pivot}) {\n  if (type === \"identity\") return {type: \"identity\", apply: (d) => d, invert: (d) => d};\n  const unknown = scale.unknown ? scale.unknown() : undefined;\n  return {\n    type,\n    domain: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.slice)(domain), // defensive copy\n    ...(range !== undefined && {range: (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.slice)(range)}), // defensive copy\n    ...(transform !== undefined && {transform}),\n    ...(percent && {percent}), // only exposed if truthy\n    ...(unknown !== undefined && {unknown}),\n    ...(interval !== undefined && {interval}),\n\n    // quantitative\n    ...(interpolate !== undefined && {interpolate}),\n    ...(scale.clamp && {clamp: scale.clamp()}),\n\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...(pivot !== undefined && {pivot, symmetric: false}),\n\n    // log, diverging-log\n    ...(scale.base && {base: scale.base()}),\n\n    // pow, diverging-pow\n    ...(scale.exponent && {exponent: scale.exponent()}),\n\n    // symlog, diverging-symlog\n    ...(scale.constant && {constant: scale.constant()}),\n\n    // band, point\n    ...(scale.align && {align: scale.align(), round: scale.round()}),\n    ...(scale.padding &&\n      (scale.paddingInner\n        ? {paddingInner: scale.paddingInner(), paddingOuter: scale.paddingOuter()}\n        : {padding: scale.padding()})),\n    ...(scale.bandwidth && {bandwidth: scale.bandwidth(), step: scale.step()}),\n\n    // utilities\n    apply: (t) => scale(t),\n    ...(scale.invert && {invert: (t) => scale.invert(t)})\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVXNCO0FBQ2E7QUFDMEQ7QUFXM0Q7QUFPSDtBQUM0QztBQUNOO0FBQ3NDO0FBQ25FO0FBQ0w7O0FBRTVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUMsSUFBSTtBQUNqRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBUSxjQUFjLHNEQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFLFVBQVU7QUFDVjs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QyxnQkFBZ0I7QUFDVDtBQUNQLG1CQUFtQixrREFBTyw4QkFBOEIsa0RBQU87QUFDL0Q7O0FBRUEsOENBQThDO0FBQzlDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTywwQkFBMEIsT0FBTztBQUN4QyxTQUFTLGlFQUFpRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHdDQUF3QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlDQUF5QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qjs7QUFFTztBQUNQLDZEQUE2RCxLQUFLLElBQUksU0FBUztBQUMvRTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDLG9CQUFvQixtREFBVTtBQUM5QixNQUFNLGtEQUFJO0FBQ1Ysa0RBQWtELEtBQUssOEZBQThGO0FBQ3JKO0FBQ0EsVUFBVSxzR0FBc0csZ0tBQWdLLEtBQUssdUZBQXVGLEtBQUssWUFBWTtBQUM3WDtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qix5REFBZ0I7QUFDekMsTUFBTSxrREFBSTtBQUNWLGtEQUFrRCxLQUFLLG9OQUFvTjtBQUMzUTtBQUNBLFVBQVUsc0dBQXNHLHFMQUFxTCxLQUFLLFlBQVk7QUFDdFQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIsd0RBQWU7QUFDeEMsTUFBTSxrREFBSTtBQUNWLGtEQUFrRCxLQUFLLHFNQUFxTTtBQUM1UDtBQUNBLFVBQVUsMEZBQTBGLEtBQUssNEZBQTRGLEtBQUssWUFBWTtBQUN0TjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBYTtBQUMzRDtBQUNBO0FBQ0EsY0FBYyxzREFBUTtBQUN0QixhQUFhLHNEQUFRO0FBQ3JCLGtEQUFrRCxzREFBYTtBQUMvRDtBQUNBLGFBQWEsb0RBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9EQUFXO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMEVBQW9CO0FBQ2pDO0FBQ0EsYUFBYSw4RUFBd0I7QUFDckM7QUFDQSxhQUFhLDZFQUF1QjtBQUNwQztBQUNBLGFBQWEsNkVBQXVCO0FBQ3BDO0FBQ0EsYUFBYSxnRkFBMEI7QUFDdkM7QUFDQTtBQUNBLFNBQVMsK0RBQWU7QUFDeEIsYUFBYSxzRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwRUFBaUI7QUFDOUI7QUFDQSxhQUFhLHdFQUFlO0FBQzVCO0FBQ0EsYUFBYSw2RUFBb0I7QUFDakM7QUFDQSxhQUFhLDRFQUFtQjtBQUNoQztBQUNBLGFBQWEsNEVBQW1CO0FBQ2hDO0FBQ0EsYUFBYSx1RUFBYztBQUMzQjtBQUNBLGFBQWEsdUVBQWM7QUFDM0I7QUFDQSxhQUFhLDBFQUFpQjtBQUM5QjtBQUNBLGFBQWEsbUVBQWM7QUFDM0I7QUFDQSxhQUFhLG9FQUFlO0FBQzVCO0FBQ0EsYUFBYSxvRUFBZ0I7QUFDN0I7QUFDQSxhQUFhLG1FQUFlO0FBQzVCO0FBQ0EsYUFBYSw0RUFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsS0FBSztBQUM1Qzs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEIsd0NBQXdDLCtDQUErQztBQUN2Rjs7QUFFQSw4Q0FBOEM7QUFDOUM7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxNQUFNLE1BQU0sRUFBRTtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsTUFBTTs7QUFFckQ7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCLGVBQWUsb0RBQU07QUFDckIsZUFBZSxxREFBTyxhQUFhLG9EQUFNO0FBQ3pDLGVBQWUsb0RBQU07O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxRQUFRLHNEQUFTO0FBQ2pCLFFBQVEsdURBQVU7QUFDbEIsSUFBSTtBQUNKLGtDQUFrQyxNQUFNO0FBQ3hDLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0IsbURBQVU7QUFDOUI7O0FBRUE7QUFDQSxlQUFlLG1EQUFLO0FBQ3BCLHlCQUF5QixxRUFBaUI7QUFDMUMsUUFBUSx1RUFBbUI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFRO0FBQ2pCO0FBQ0EsU0FBUyxtREFBSztBQUNkLGFBQWEsK0RBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sMEJBQTBCLEtBQUs7QUFDdEM7QUFDQTs7QUFFTyx5QkFBeUIsS0FBSztBQUNyQywrRUFBK0UsK0RBQWU7QUFDOUY7O0FBRU8sMkJBQTJCLEtBQUs7QUFDdkM7QUFDQTs7QUFFQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBOztBQUVPLDJCQUEyQixLQUFLO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNPO0FBQ1Asd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0RBQUcsU0FBUyxtREFBVztBQUNoQzs7QUFFTywyQkFBMkI7QUFDbEM7QUFDQTtBQUNBLFNBQVMsc0RBQVEscUJBQXFCO0FBQ3RDLFNBQVMsMkRBQWMsMEJBQTBCLGlCQUFpQjtBQUNsRSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxTQUFTLHNEQUFRLGVBQWUsSUFBSSx1Q0FBdUMsSUFBSTtBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw2RUFBNkU7QUFDbkcsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQUs7QUFDakIsZ0NBQWdDLE9BQU8sa0RBQUssUUFBUTtBQUNwRCxvQ0FBb0MsVUFBVTtBQUM5QyxvQkFBb0IsUUFBUTtBQUM1QixrQ0FBa0MsUUFBUTtBQUMxQyxtQ0FBbUMsU0FBUzs7QUFFNUM7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRCx3QkFBd0IscUJBQXFCOztBQUU3QyxxQ0FBcUM7QUFDckMsZ0NBQWdDLHdCQUF3Qjs7QUFFeEQ7QUFDQSx1QkFBdUIsbUJBQW1COztBQUUxQztBQUNBLDJCQUEyQiwyQkFBMkI7O0FBRXREO0FBQ0EsMkJBQTJCLDJCQUEyQjs7QUFFdEQ7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVyx5QkFBeUI7QUFDcEMsNEJBQTRCLGlEQUFpRDs7QUFFN0U7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvc2NhbGVzLmpzPzY2YjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNPcmRpbmFsLFxuICBpc1RlbXBvcmFsLFxuICBpc1RlbXBvcmFsU3RyaW5nLFxuICBpc051bWVyaWNTdHJpbmcsXG4gIGlzU2NhbGVPcHRpb25zLFxuICBtYXAsXG4gIHNsaWNlLFxuICBjb2VyY2VOdW1iZXJzLFxuICBjb2VyY2VEYXRlc1xufSBmcm9tIFwiLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge29yZGVyb2Z9IGZyb20gXCIuL29yZGVyLmpzXCI7XG5pbXBvcnQge3JlZ2lzdHJ5LCBjb2xvciwgcG9zaXRpb24sIHJhZGl1cywgb3BhY2l0eSwgc3ltYm9sLCBsZW5ndGh9IGZyb20gXCIuL3NjYWxlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2NhbGVMaW5lYXIsXG4gIGNyZWF0ZVNjYWxlU3FydCxcbiAgY3JlYXRlU2NhbGVQb3csXG4gIGNyZWF0ZVNjYWxlTG9nLFxuICBjcmVhdGVTY2FsZVN5bWxvZyxcbiAgY3JlYXRlU2NhbGVRdWFudGlsZSxcbiAgY3JlYXRlU2NhbGVRdWFudGl6ZSxcbiAgY3JlYXRlU2NhbGVUaHJlc2hvbGQsXG4gIGNyZWF0ZVNjYWxlSWRlbnRpdHlcbn0gZnJvbSBcIi4vc2NhbGVzL3F1YW50aXRhdGl2ZS5qc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2NhbGVEaXZlcmdpbmcsXG4gIGNyZWF0ZVNjYWxlRGl2ZXJnaW5nU3FydCxcbiAgY3JlYXRlU2NhbGVEaXZlcmdpbmdQb3csXG4gIGNyZWF0ZVNjYWxlRGl2ZXJnaW5nTG9nLFxuICBjcmVhdGVTY2FsZURpdmVyZ2luZ1N5bWxvZ1xufSBmcm9tIFwiLi9zY2FsZXMvZGl2ZXJnaW5nLmpzXCI7XG5pbXBvcnQge2lzQ2F0ZWdvcmljYWxTY2hlbWUsIGlzRGl2ZXJnaW5nU2NoZW1lfSBmcm9tIFwiLi9zY2FsZXMvc2NoZW1lcy5qc1wiO1xuaW1wb3J0IHtjcmVhdGVTY2FsZVRpbWUsIGNyZWF0ZVNjYWxlVXRjfSBmcm9tIFwiLi9zY2FsZXMvdGVtcG9yYWwuanNcIjtcbmltcG9ydCB7Y3JlYXRlU2NhbGVPcmRpbmFsLCBjcmVhdGVTY2FsZVBvaW50LCBjcmVhdGVTY2FsZUJhbmQsIG9yZGluYWxJbXBsaWNpdH0gZnJvbSBcIi4vc2NhbGVzL29yZGluYWwuanNcIjtcbmltcG9ydCB7bWF5YmVTeW1ib2x9IGZyb20gXCIuL3N5bWJvbC5qc1wiO1xuaW1wb3J0IHt3YXJufSBmcm9tIFwiLi93YXJuaW5ncy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVzKFxuICBjaGFubmVsc0J5U2NhbGUsXG4gIHtcbiAgICBsYWJlbDogZ2xvYmFsTGFiZWwsXG4gICAgaW5zZXQ6IGdsb2JhbEluc2V0ID0gMCxcbiAgICBpbnNldFRvcDogZ2xvYmFsSW5zZXRUb3AgPSBnbG9iYWxJbnNldCxcbiAgICBpbnNldFJpZ2h0OiBnbG9iYWxJbnNldFJpZ2h0ID0gZ2xvYmFsSW5zZXQsXG4gICAgaW5zZXRCb3R0b206IGdsb2JhbEluc2V0Qm90dG9tID0gZ2xvYmFsSW5zZXQsXG4gICAgaW5zZXRMZWZ0OiBnbG9iYWxJbnNldExlZnQgPSBnbG9iYWxJbnNldCxcbiAgICByb3VuZCxcbiAgICBuaWNlLFxuICAgIGNsYW1wLFxuICAgIHplcm8sXG4gICAgYWxpZ24sXG4gICAgcGFkZGluZyxcbiAgICBwcm9qZWN0aW9uLFxuICAgIGZhY2V0OiB7bGFiZWw6IGZhY2V0TGFiZWwgPSBnbG9iYWxMYWJlbH0gPSB7fSxcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHNjYWxlcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIGNoYW5uZWxzXSBvZiBjaGFubmVsc0J5U2NhbGUpIHtcbiAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBvcHRpb25zW2tleV07XG4gICAgY29uc3Qgc2NhbGUgPSBjcmVhdGVTY2FsZShrZXksIGNoYW5uZWxzLCB7XG4gICAgICByb3VuZDogcmVnaXN0cnkuZ2V0KGtleSkgPT09IHBvc2l0aW9uID8gcm91bmQgOiB1bmRlZmluZWQsIC8vIG9ubHkgZm9yIHBvc2l0aW9uXG4gICAgICBuaWNlLFxuICAgICAgY2xhbXAsXG4gICAgICB6ZXJvLFxuICAgICAgYWxpZ24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcHJvamVjdGlvbixcbiAgICAgIC4uLnNjYWxlT3B0aW9uc1xuICAgIH0pO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgLy8gcG9wdWxhdGUgZ2VuZXJpYyBzY2FsZSBvcHRpb25zIChwZXJjZW50LCB0cmFuc2Zvcm0sIGluc2V0cylcbiAgICAgIGxldCB7XG4gICAgICAgIGxhYmVsID0ga2V5ID09PSBcImZ4XCIgfHwga2V5ID09PSBcImZ5XCIgPyBmYWNldExhYmVsIDogZ2xvYmFsTGFiZWwsXG4gICAgICAgIHBlcmNlbnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgaW5zZXQsXG4gICAgICAgIGluc2V0VG9wID0gaW5zZXQgIT09IHVuZGVmaW5lZCA/IGluc2V0IDoga2V5ID09PSBcInlcIiA/IGdsb2JhbEluc2V0VG9wIDogMCwgLy8gbm90IGZ5XG4gICAgICAgIGluc2V0UmlnaHQgPSBpbnNldCAhPT0gdW5kZWZpbmVkID8gaW5zZXQgOiBrZXkgPT09IFwieFwiID8gZ2xvYmFsSW5zZXRSaWdodCA6IDAsIC8vIG5vdCBmeFxuICAgICAgICBpbnNldEJvdHRvbSA9IGluc2V0ICE9PSB1bmRlZmluZWQgPyBpbnNldCA6IGtleSA9PT0gXCJ5XCIgPyBnbG9iYWxJbnNldEJvdHRvbSA6IDAsIC8vIG5vdCBmeVxuICAgICAgICBpbnNldExlZnQgPSBpbnNldCAhPT0gdW5kZWZpbmVkID8gaW5zZXQgOiBrZXkgPT09IFwieFwiID8gZ2xvYmFsSW5zZXRMZWZ0IDogMCAvLyBub3QgZnhcbiAgICAgIH0gPSBzY2FsZU9wdGlvbnMgfHwge307XG4gICAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHRyYW5zZm9ybSA9IHVuZGVmaW5lZDtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzY2FsZSB0cmFuc2Zvcm07IG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgc2NhbGUucGVyY2VudCA9ICEhcGVyY2VudDtcbiAgICAgIHNjYWxlLmxhYmVsID0gbGFiZWwgPT09IHVuZGVmaW5lZCA/IGluZmVyU2NhbGVMYWJlbChjaGFubmVscywgc2NhbGUpIDogbGFiZWw7XG4gICAgICBzY2FsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICBpZiAoa2V5ID09PSBcInhcIiB8fCBrZXkgPT09IFwiZnhcIikge1xuICAgICAgICBzY2FsZS5pbnNldExlZnQgPSAraW5zZXRMZWZ0O1xuICAgICAgICBzY2FsZS5pbnNldFJpZ2h0ID0gK2luc2V0UmlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ5XCIgfHwga2V5ID09PSBcImZ5XCIpIHtcbiAgICAgICAgc2NhbGUuaW5zZXRUb3AgPSAraW5zZXRUb3A7XG4gICAgICAgIHNjYWxlLmluc2V0Qm90dG9tID0gK2luc2V0Qm90dG9tO1xuICAgICAgfVxuICAgICAgc2NhbGVzW2tleV0gPSBzY2FsZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjYWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlRnVuY3Rpb25zKGRlc2NyaXB0b3JzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IHt9O1xuICBjb25zdCBzY2FsZUZ1bmN0aW9ucyA9IHtzY2FsZXN9O1xuICBmb3IgKGNvbnN0IFtrZXksIGRlc2NyaXB0b3JdIG9mIE9iamVjdC5lbnRyaWVzKGRlc2NyaXB0b3JzKSkge1xuICAgIGNvbnN0IHtzY2FsZSwgdHlwZSwgaW50ZXJ2YWwsIGxhYmVsfSA9IGRlc2NyaXB0b3I7XG4gICAgc2NhbGVzW2tleV0gPSBleHBvc2VTY2FsZShkZXNjcmlwdG9yKTtcbiAgICBzY2FsZUZ1bmN0aW9uc1trZXldID0gc2NhbGU7XG4gICAgLy8gVE9ETzogcGFzcyB0aGVzZSBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgbmVlZGVkIGZvciBheGVzLCBpbiB0aGUgZGVzY3JpcHRvci5cbiAgICBzY2FsZS50eXBlID0gdHlwZTtcbiAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkgc2NhbGUuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICBpZiAobGFiZWwgIT0gbnVsbCkgc2NhbGUubGFiZWwgPSBsYWJlbDtcbiAgfVxuICByZXR1cm4gc2NhbGVGdW5jdGlvbnM7XG59XG5cbi8vIE11dGF0ZXMgc2NhbGUucmFuZ2UhXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NjYWxlUmFuZ2Uoc2NhbGVzLCBkaW1lbnNpb25zKSB7XG4gIGNvbnN0IHt4LCB5LCBmeCwgZnl9ID0gc2NhbGVzO1xuICBjb25zdCBzdXBlcmRpbWVuc2lvbnMgPSBmeCB8fCBmeSA/IG91dGVyRGltZW5zaW9ucyhkaW1lbnNpb25zKSA6IGRpbWVuc2lvbnM7XG4gIGlmIChmeCkgYXV0b1NjYWxlUmFuZ2VYKGZ4LCBzdXBlcmRpbWVuc2lvbnMpO1xuICBpZiAoZnkpIGF1dG9TY2FsZVJhbmdlWShmeSwgc3VwZXJkaW1lbnNpb25zKTtcbiAgY29uc3Qgc3ViZGltZW5zaW9ucyA9IGZ4IHx8IGZ5ID8gaW5uZXJEaW1lbnNpb25zKHNjYWxlcywgZGltZW5zaW9ucykgOiBkaW1lbnNpb25zO1xuICBpZiAoeCkgYXV0b1NjYWxlUmFuZ2VYKHgsIHN1YmRpbWVuc2lvbnMpO1xuICBpZiAoeSkgYXV0b1NjYWxlUmFuZ2VZKHksIHN1YmRpbWVuc2lvbnMpO1xufVxuXG4vLyBDaGFubmVscyBjYW4gaGF2ZSBsYWJlbHM7IGlmIGFsbCB0aGUgY2hhbm5lbHMgZm9yIGEgZ2l2ZW4gc2NhbGUgYXJlXG4vLyBjb25zaXN0ZW50bHkgbGFiZWxlZCAoaS5lLiwgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBpZiBub3QgdW5kZWZpbmVkKSwgYW5kIHRoZVxuLy8gY29ycmVzcG9uZGluZyBzY2FsZSBkb2VzbuKAmXQgYWxyZWFkeSBoYXZlIGFuIGV4cGxpY2l0IGxhYmVsLCB0aGVuIHRoZVxuLy8gY2hhbm5lbHPigJkgbGFiZWwgaXMgcHJvbW90ZWQgdG8gdGhlIHNjYWxlLiBUaGlzIGluZmVycmVkIGxhYmVsIHNob3VsZCBoYXZlIGFuXG4vLyBvcmllbnRhdGlvbi1hcHByb3ByaWF0ZSBhcnJvdyBhZGRlZCB3aGVuIHVzZWQgYXMgYW4gYXhpcywgYnV0IHdlIGRvbuKAmXQgd2FudFxuLy8gdG8gYWRkIHRoZSBhcnJvdyB3aGVuIHRoZSBsYWJlbCBpcyBzZXQgZXhwbGljaXRseSBhcyBhbiBvcHRpb247IHNvLCB0aGVcbi8vIGluZmVycmVkIGxhYmVsIGlzIGRpc3Rpbmd1aXNoZWQgYXMgYW4gb2JqZWN0IHdpdGggYW4g4oCcaW5mZXJyZWTigJ0gcHJvcGVydHkuXG5mdW5jdGlvbiBpbmZlclNjYWxlTGFiZWwoY2hhbm5lbHMgPSBbXSwgc2NhbGUpIHtcbiAgbGV0IGxhYmVsO1xuICBmb3IgKGNvbnN0IHtsYWJlbDogbH0gb2YgY2hhbm5lbHMpIHtcbiAgICBpZiAobCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBpZiAobGFiZWwgPT09IHVuZGVmaW5lZCkgbGFiZWwgPSBsO1xuICAgIGVsc2UgaWYgKGxhYmVsICE9PSBsKSByZXR1cm47XG4gIH1cbiAgaWYgKGxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKCFpc09yZGluYWxTY2FsZShzY2FsZSkgJiYgc2NhbGUucGVyY2VudCkgbGFiZWwgPSBgJHtsYWJlbH0gKCUpYDtcbiAgcmV0dXJuIHtpbmZlcnJlZDogdHJ1ZSwgdG9TdHJpbmc6ICgpID0+IGxhYmVsfTtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzY2FsZSBwb2ludHMgaW4gdGhlIOKAnHBvc2l0aXZl4oCdIChyaWdodCBvciBkb3duKSBvclxuLy8g4oCcbmVnYXRpdmXigJ0gKGxlZnQgb3IgdXApIGRpcmVjdGlvbjsgaWYgdGhlIHNjYWxlIG9yZGVyIGNhbm5vdCBiZSBkZXRlcm1pbmVkLFxuLy8gcmV0dXJucyBOYU47IHVzZWQgdG8gYXNzaWduIGFuIGFwcHJvcHJpYXRlIGxhYmVsIGFycm93LlxuZXhwb3J0IGZ1bmN0aW9uIGluZmVyU2NhbGVPcmRlcihzY2FsZSkge1xuICByZXR1cm4gTWF0aC5zaWduKG9yZGVyb2Yoc2NhbGUuZG9tYWluKCkpKSAqIE1hdGguc2lnbihvcmRlcm9mKHNjYWxlLnJhbmdlKCkpKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb3V0ZXIgZnJhbWU7IHRoaXMgaXMgc3ViZGl2aWRlZCBpbnRvIGZhY2V0c1xuLy8gd2l0aCB0aGUgbWFyZ2lucyBvZiBlYWNoIGZhY2V0IGNvbGxhcHNpbmcgaW50byB0aGUgb3V0ZXIgbWFyZ2lucy5cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckRpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICBjb25zdCB7XG4gICAgbWFyZ2luVG9wLFxuICAgIG1hcmdpblJpZ2h0LFxuICAgIG1hcmdpbkJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmYWNldDoge1xuICAgICAgbWFyZ2luVG9wOiBmYWNldE1hcmdpblRvcCxcbiAgICAgIG1hcmdpblJpZ2h0OiBmYWNldE1hcmdpblJpZ2h0LFxuICAgICAgbWFyZ2luQm90dG9tOiBmYWNldE1hcmdpbkJvdHRvbSxcbiAgICAgIG1hcmdpbkxlZnQ6IGZhY2V0TWFyZ2luTGVmdFxuICAgIH1cbiAgfSA9IGRpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgbWFyZ2luVG9wOiBNYXRoLm1heChtYXJnaW5Ub3AsIGZhY2V0TWFyZ2luVG9wKSxcbiAgICBtYXJnaW5SaWdodDogTWF0aC5tYXgobWFyZ2luUmlnaHQsIGZhY2V0TWFyZ2luUmlnaHQpLFxuICAgIG1hcmdpbkJvdHRvbTogTWF0aC5tYXgobWFyZ2luQm90dG9tLCBmYWNldE1hcmdpbkJvdHRvbSksXG4gICAgbWFyZ2luTGVmdDogTWF0aC5tYXgobWFyZ2luTGVmdCwgZmFjZXRNYXJnaW5MZWZ0KSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiBlYWNoIGZhY2V0LlxuZXhwb3J0IGZ1bmN0aW9uIGlubmVyRGltZW5zaW9ucyh7ZngsIGZ5fSwgZGltZW5zaW9ucykge1xuICBjb25zdCB7bWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0LCB3aWR0aCwgaGVpZ2h0fSA9IG91dGVyRGltZW5zaW9ucyhkaW1lbnNpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBtYXJnaW5Ub3AsXG4gICAgbWFyZ2luUmlnaHQsXG4gICAgbWFyZ2luQm90dG9tLFxuICAgIG1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IGZ4ID8gZnguc2NhbGUuYmFuZHdpZHRoKCkgKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQgOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGZ5ID8gZnkuc2NhbGUuYmFuZHdpZHRoKCkgKyBtYXJnaW5Ub3AgKyBtYXJnaW5Cb3R0b20gOiBoZWlnaHQsXG4gICAgZmFjZXQ6IHt3aWR0aCwgaGVpZ2h0fVxuICB9O1xufVxuXG5mdW5jdGlvbiBhdXRvU2NhbGVSYW5nZVgoc2NhbGUsIGRpbWVuc2lvbnMpIHtcbiAgaWYgKHNjYWxlLnJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7aW5zZXRMZWZ0LCBpbnNldFJpZ2h0fSA9IHNjYWxlO1xuICAgIGNvbnN0IHt3aWR0aCwgbWFyZ2luTGVmdCA9IDAsIG1hcmdpblJpZ2h0ID0gMH0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IGxlZnQgPSBtYXJnaW5MZWZ0ICsgaW5zZXRMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggLSBtYXJnaW5SaWdodCAtIGluc2V0UmlnaHQ7XG4gICAgc2NhbGUucmFuZ2UgPSBbbGVmdCwgTWF0aC5tYXgobGVmdCwgcmlnaHQpXTtcbiAgICBpZiAoIWlzT3JkaW5hbFNjYWxlKHNjYWxlKSkgc2NhbGUucmFuZ2UgPSBwaWVjZXdpc2VSYW5nZShzY2FsZSk7XG4gICAgc2NhbGUuc2NhbGUucmFuZ2Uoc2NhbGUucmFuZ2UpO1xuICB9XG4gIGF1dG9TY2FsZVJvdW5kKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gYXV0b1NjYWxlUmFuZ2VZKHNjYWxlLCBkaW1lbnNpb25zKSB7XG4gIGlmIChzY2FsZS5yYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge2luc2V0VG9wLCBpbnNldEJvdHRvbX0gPSBzY2FsZTtcbiAgICBjb25zdCB7aGVpZ2h0LCBtYXJnaW5Ub3AgPSAwLCBtYXJnaW5Cb3R0b20gPSAwfSA9IGRpbWVuc2lvbnM7XG4gICAgY29uc3QgdG9wID0gbWFyZ2luVG9wICsgaW5zZXRUb3A7XG4gICAgY29uc3QgYm90dG9tID0gaGVpZ2h0IC0gbWFyZ2luQm90dG9tIC0gaW5zZXRCb3R0b207XG4gICAgc2NhbGUucmFuZ2UgPSBbTWF0aC5tYXgodG9wLCBib3R0b20pLCB0b3BdO1xuICAgIGlmICghaXNPcmRpbmFsU2NhbGUoc2NhbGUpKSBzY2FsZS5yYW5nZSA9IHBpZWNld2lzZVJhbmdlKHNjYWxlKTtcbiAgICBlbHNlIHNjYWxlLnJhbmdlLnJldmVyc2UoKTtcbiAgICBzY2FsZS5zY2FsZS5yYW5nZShzY2FsZS5yYW5nZSk7XG4gIH1cbiAgYXV0b1NjYWxlUm91bmQoc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBhdXRvU2NhbGVSb3VuZChzY2FsZSkge1xuICBpZiAoc2NhbGUucm91bmQgPT09IHVuZGVmaW5lZCAmJiBpc0JhbmRTY2FsZShzY2FsZSkgJiYgcm91bmRFcnJvcihzY2FsZSkgPD0gMzApIHtcbiAgICBzY2FsZS5zY2FsZS5yb3VuZCh0cnVlKTtcbiAgfVxufVxuXG4vLyBJZiB3ZSB3ZXJlIHRvIHR1cm4gb24gcm91bmRpbmcgZm9yIHRoaXMgYmFuZCBvciBwb2ludCBzY2FsZSwgaG93IG11Y2ggd2FzdGVkXG4vLyBzcGFjZSB3b3VsZCBpdCBpbnRyb2R1Y2UgKG9uIGJvdGggZW5kcyBvZiB0aGUgcmFuZ2UpPyBUaGlzIG11c3QgbWF0Y2hcbi8vIGQzLnNjYWxlQmFuZOKAmXMgcm91bmRpbmcgYmVoYXZpb3I6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi84MzU1NWJkNzU5YzczMTQ0MjBiZDQyNDA2NDJiZWRhNWUyNThkYjllL3NyYy9iYW5kLmpzI0wyMC1MMzJcbmZ1bmN0aW9uIHJvdW5kRXJyb3Ioe3NjYWxlfSkge1xuICBjb25zdCBuID0gc2NhbGUuZG9tYWluKCkubGVuZ3RoO1xuICBjb25zdCBbc3RhcnQsIHN0b3BdID0gc2NhbGUucmFuZ2UoKTtcbiAgY29uc3QgcGFkZGluZ0lubmVyID0gc2NhbGUucGFkZGluZ0lubmVyID8gc2NhbGUucGFkZGluZ0lubmVyKCkgOiAxO1xuICBjb25zdCBwYWRkaW5nT3V0ZXIgPSBzY2FsZS5wYWRkaW5nT3V0ZXIgPyBzY2FsZS5wYWRkaW5nT3V0ZXIoKSA6IHNjYWxlLnBhZGRpbmcoKTtcbiAgY29uc3QgbSA9IG4gLSBwYWRkaW5nSW5uZXI7XG4gIGNvbnN0IHN0ZXAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMSwgbSArIHBhZGRpbmdPdXRlciAqIDIpO1xuICByZXR1cm4gKHN0ZXAgLSBNYXRoLmZsb29yKHN0ZXApKSAqIG07XG59XG5cbmZ1bmN0aW9uIHBpZWNld2lzZVJhbmdlKHNjYWxlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnNjYWxlLmRvbWFpbigpLmxlbmd0aCArIGlzVGhyZXNob2xkU2NhbGUoc2NhbGUpO1xuICBpZiAoIShsZW5ndGggPiAyKSkgcmV0dXJuIHNjYWxlLnJhbmdlO1xuICBjb25zdCBbc3RhcnQsIGVuZF0gPSBzY2FsZS5yYW5nZTtcbiAgcmV0dXJuIEFycmF5LmZyb20oe2xlbmd0aH0sIChfLCBpKSA9PiBzdGFydCArIChpIC8gKGxlbmd0aCAtIDEpKSAqIChlbmQgLSBzdGFydCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU2NhbGUoa2V5LCBzY2FsZSwgaGludCkge1xuICByZXR1cm4gY3JlYXRlU2NhbGUoa2V5LCBoaW50ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBbe2hpbnR9XSwgey4uLnNjYWxlfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlKGtleSwgY2hhbm5lbHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHR5cGUgPSBpbmZlclNjYWxlVHlwZShrZXksIGNoYW5uZWxzLCBvcHRpb25zKTtcblxuICAvLyBXYXJuIGZvciBjb21tb24gbWlzdXNlcyBvZiBpbXBsaWNpdCBvcmRpbmFsIHNjYWxlcy4gV2UgZGlzYWJsZSB0aGlzIHRlc3QgaWZcbiAgLy8geW91IHNwZWNpZnkgYSBzY2FsZSBpbnRlcnZhbCBvciBpZiB5b3Ugc2V0IHRoZSBkb21haW4gb3IgcmFuZ2UgZXhwbGljaXRseSxcbiAgLy8gc2luY2Ugc2V0dGluZyB0aGUgZG9tYWluIG9yIHJhbmdlICh0eXBpY2FsbHkgd2l0aCBhIGNhcmRpbmFsaXR5IG9mIG1vcmUgdGhhblxuICAvLyB0d28pIGlzIGFub3RoZXIgaW5kaWNhdGlvbiB0aGF0IHlvdSBpbnRlbmRlZCBmb3IgdGhlIHNjYWxlIHRvIGJlIG9yZGluYWw7IHdlXG4gIC8vIGFsc28gZGlzYWJsZSBpdCBmb3IgZmFjZXQgc2NhbGVzIHNpbmNlIHRoZXNlIGFyZSBhbHdheXMgYmFuZCBzY2FsZXMuXG4gIGlmIChcbiAgICBvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCAmJlxuICAgIG9wdGlvbnMuZG9tYWluID09PSB1bmRlZmluZWQgJiZcbiAgICBvcHRpb25zLnJhbmdlID09PSB1bmRlZmluZWQgJiZcbiAgICBvcHRpb25zLmludGVydmFsID09IG51bGwgJiZcbiAgICBrZXkgIT09IFwiZnhcIiAmJlxuICAgIGtleSAhPT0gXCJmeVwiICYmXG4gICAgaXNPcmRpbmFsU2NhbGUoe3R5cGV9KVxuICApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBjaGFubmVscy5tYXAoKHt2YWx1ZX0pID0+IHZhbHVlKS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAodmFsdWVzLnNvbWUoaXNUZW1wb3JhbCkpXG4gICAgICB3YXJuKFxuICAgICAgICBgV2FybmluZzogc29tZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgJHtrZXl9IHNjYWxlIGFyZSBkYXRlcy4gRGF0ZXMgYXJlIHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggYSBcInV0Y1wiIG9yIFwidGltZVwiIHNjYWxlIHJhdGhlciB0aGFuIGEgXCIke2Zvcm1hdFNjYWxlVHlwZShcbiAgICAgICAgICB0eXBlXG4gICAgICAgICl9XCIgc2NhbGUuIElmIHlvdSBhcmUgdXNpbmcgYSBiYXIgbWFyaywgeW91IHByb2JhYmx5IHdhbnQgYSByZWN0IG1hcmsgd2l0aCB0aGUgaW50ZXJ2YWwgb3B0aW9uIGluc3RlYWQ7IGlmIHlvdSBhcmUgdXNpbmcgYSBncm91cCB0cmFuc2Zvcm0sIHlvdSBwcm9iYWJseSB3YW50IGEgYmluIHRyYW5zZm9ybSBpbnN0ZWFkLiBJZiB5b3Ugd2FudCB0byB0cmVhdCB0aGlzIGRhdGEgYXMgb3JkaW5hbCwgeW91IGNhbiBzcGVjaWZ5IHRoZSBpbnRlcnZhbCBvZiB0aGUgJHtrZXl9IHNjYWxlIChlLmcuLCBkMy51dGNEYXkpLCBvciB5b3UgY2FuIHN1cHByZXNzIHRoaXMgd2FybmluZyBieSBzZXR0aW5nIHRoZSB0eXBlIG9mIHRoZSAke2tleX0gc2NhbGUgdG8gXCIke2Zvcm1hdFNjYWxlVHlwZShcbiAgICAgICAgICB0eXBlXG4gICAgICAgICl9XCIuYFxuICAgICAgKTtcbiAgICBlbHNlIGlmICh2YWx1ZXMuc29tZShpc1RlbXBvcmFsU3RyaW5nKSlcbiAgICAgIHdhcm4oXG4gICAgICAgIGBXYXJuaW5nOiBzb21lIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSAke2tleX0gc2NhbGUgYXJlIHN0cmluZ3MgdGhhdCBhcHBlYXIgdG8gYmUgZGF0ZXMgKGUuZy4sIFlZWVktTU0tREQpLiBJZiB0aGVzZSBzdHJpbmdzIHJlcHJlc2VudCBkYXRlcywgeW91IHNob3VsZCBwYXJzZSB0aGVtIHRvIERhdGUgb2JqZWN0cy4gRGF0ZXMgYXJlIHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggYSBcInV0Y1wiIG9yIFwidGltZVwiIHNjYWxlIHJhdGhlciB0aGFuIGEgXCIke2Zvcm1hdFNjYWxlVHlwZShcbiAgICAgICAgICB0eXBlXG4gICAgICAgICl9XCIgc2NhbGUuIElmIHlvdSBhcmUgdXNpbmcgYSBiYXIgbWFyaywgeW91IHByb2JhYmx5IHdhbnQgYSByZWN0IG1hcmsgd2l0aCB0aGUgaW50ZXJ2YWwgb3B0aW9uIGluc3RlYWQ7IGlmIHlvdSBhcmUgdXNpbmcgYSBncm91cCB0cmFuc2Zvcm0sIHlvdSBwcm9iYWJseSB3YW50IGEgYmluIHRyYW5zZm9ybSBpbnN0ZWFkLiBJZiB5b3Ugd2FudCB0byB0cmVhdCB0aGlzIGRhdGEgYXMgb3JkaW5hbCwgeW91IGNhbiBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgYnkgc2V0dGluZyB0aGUgdHlwZSBvZiB0aGUgJHtrZXl9IHNjYWxlIHRvIFwiJHtmb3JtYXRTY2FsZVR5cGUoXG4gICAgICAgICAgdHlwZVxuICAgICAgICApfVwiLmBcbiAgICAgICk7XG4gICAgZWxzZSBpZiAodmFsdWVzLnNvbWUoaXNOdW1lcmljU3RyaW5nKSlcbiAgICAgIHdhcm4oXG4gICAgICAgIGBXYXJuaW5nOiBzb21lIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSAke2tleX0gc2NhbGUgYXJlIHN0cmluZ3MgdGhhdCBhcHBlYXIgdG8gYmUgbnVtYmVycy4gSWYgdGhlc2Ugc3RyaW5ncyByZXByZXNlbnQgbnVtYmVycywgeW91IHNob3VsZCBwYXJzZSBvciBjb2VyY2UgdGhlbSB0byBudW1iZXJzLiBOdW1iZXJzIGFyZSB0eXBpY2FsbHkgYXNzb2NpYXRlZCB3aXRoIGEgXCJsaW5lYXJcIiBzY2FsZSByYXRoZXIgdGhhbiBhIFwiJHtmb3JtYXRTY2FsZVR5cGUoXG4gICAgICAgICAgdHlwZVxuICAgICAgICApfVwiIHNjYWxlLiBJZiB5b3Ugd2FudCB0byB0cmVhdCB0aGlzIGRhdGEgYXMgb3JkaW5hbCwgeW91IGNhbiBzcGVjaWZ5IHRoZSBpbnRlcnZhbCBvZiB0aGUgJHtrZXl9IHNjYWxlIChlLmcuLCAxIGZvciBpbnRlZ2VycyksIG9yIHlvdSBjYW4gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGJ5IHNldHRpbmcgdGhlIHR5cGUgb2YgdGhlICR7a2V5fSBzY2FsZSB0byBcIiR7Zm9ybWF0U2NhbGVUeXBlKFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKX1cIi5gXG4gICAgICApO1xuICB9XG5cbiAgb3B0aW9ucy50eXBlID0gdHlwZTsgLy8gTXV0YXRlcyBpbnB1dCFcblxuICAvLyBPbmNlIHRoZSBzY2FsZSB0eXBlIGlzIGtub3duLCBjb2VyY2UgdGhlIGFzc29jaWF0ZWQgY2hhbm5lbCB2YWx1ZXMgYW5kIGFueVxuICAvLyBleHBsaWNpdGx5LXNwZWNpZmllZCBkb21haW4gdG8gdGhlIGV4cGVjdGVkIHR5cGUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJkaXZlcmdpbmdcIjpcbiAgICBjYXNlIFwiZGl2ZXJnaW5nLXNxcnRcIjpcbiAgICBjYXNlIFwiZGl2ZXJnaW5nLXBvd1wiOlxuICAgIGNhc2UgXCJkaXZlcmdpbmctbG9nXCI6XG4gICAgY2FzZSBcImRpdmVyZ2luZy1zeW1sb2dcIjpcbiAgICBjYXNlIFwiY3ljbGljYWxcIjpcbiAgICBjYXNlIFwic2VxdWVudGlhbFwiOlxuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICBjYXNlIFwic3FydFwiOlxuICAgIGNhc2UgXCJ0aHJlc2hvbGRcIjpcbiAgICBjYXNlIFwicXVhbnRpbGVcIjpcbiAgICBjYXNlIFwicG93XCI6XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgIGNhc2UgXCJzeW1sb2dcIjpcbiAgICAgIG9wdGlvbnMgPSBjb2VyY2VUeXBlKGNoYW5uZWxzLCBvcHRpb25zLCBjb2VyY2VOdW1iZXJzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpZGVudGl0eVwiOlxuICAgICAgc3dpdGNoIChyZWdpc3RyeS5nZXQoa2V5KSkge1xuICAgICAgICBjYXNlIHBvc2l0aW9uOlxuICAgICAgICAgIG9wdGlvbnMgPSBjb2VyY2VUeXBlKGNoYW5uZWxzLCBvcHRpb25zLCBjb2VyY2VOdW1iZXJzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzeW1ib2w6XG4gICAgICAgICAgb3B0aW9ucyA9IGNvZXJjZVR5cGUoY2hhbm5lbHMsIG9wdGlvbnMsIGNvZXJjZVN5bWJvbHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInV0Y1wiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICBvcHRpb25zID0gY29lcmNlVHlwZShjaGFubmVscywgb3B0aW9ucywgY29lcmNlRGF0ZXMpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiZGl2ZXJnaW5nXCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVEaXZlcmdpbmcoa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcImRpdmVyZ2luZy1zcXJ0XCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVEaXZlcmdpbmdTcXJ0KGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJkaXZlcmdpbmctcG93XCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVEaXZlcmdpbmdQb3coa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcImRpdmVyZ2luZy1sb2dcIjpcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsZURpdmVyZ2luZ0xvZyhrZXksIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiZGl2ZXJnaW5nLXN5bWxvZ1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlRGl2ZXJnaW5nU3ltbG9nKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJjYXRlZ29yaWNhbFwiOlxuICAgIGNhc2UgXCJvcmRpbmFsXCI6XG4gICAgY2FzZSBvcmRpbmFsSW1wbGljaXQ6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVPcmRpbmFsKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJjeWNsaWNhbFwiOlxuICAgIGNhc2UgXCJzZXF1ZW50aWFsXCI6XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlTGluZWFyKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJzcXJ0XCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVTcXJ0KGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJ0aHJlc2hvbGRcIjpcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsZVRocmVzaG9sZChrZXksIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwicXVhbnRpbGVcIjpcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsZVF1YW50aWxlKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJxdWFudGl6ZVwiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlUXVhbnRpemUoa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcInBvd1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlUG93KGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsZUxvZyhrZXksIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwic3ltbG9nXCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVTeW1sb2coa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcInV0Y1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlVXRjKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVUaW1lKGtleSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxlUG9pbnQoa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcImJhbmRcIjpcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsZUJhbmQoa2V5LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgY2FzZSBcImlkZW50aXR5XCI6XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGVJZGVudGl0eShrZXkpO1xuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNjYWxlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJzeW1ib2xcIiA/IHR5cGUuZGVzY3JpcHRpb24gOiB0eXBlO1xufVxuXG5mdW5jdGlvbiBtYXliZVNjYWxlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGAke3R5cGV9YC50b0xvd2VyQ2FzZSgpIDogdHlwZTtcbn1cblxuLy8gQSBzcGVjaWFsIHR5cGUgc3ltYm9sIHdoZW4gdGhlIHggYW5kIHkgc2NhbGVzIGFyZSByZXBsYWNlZCB3aXRoIGEgcHJvamVjdGlvbi5cbmNvbnN0IHR5cGVQcm9qZWN0aW9uID0ge3RvU3RyaW5nOiAoKSA9PiBcInByb2plY3Rpb25cIn07XG5cbmZ1bmN0aW9uIGluZmVyU2NhbGVUeXBlKGtleSwgY2hhbm5lbHMsIHt0eXBlLCBkb21haW4sIHJhbmdlLCBzY2hlbWUsIHBpdm90LCBwcm9qZWN0aW9ufSkge1xuICB0eXBlID0gbWF5YmVTY2FsZVR5cGUodHlwZSk7XG5cbiAgLy8gVGhlIGZhY2V0IHNjYWxlcyBhcmUgYWx3YXlzIGJhbmQgc2NhbGVzOyB0aGlzIGNhbm5vdCBiZSBjaGFuZ2VkLlxuICBpZiAoa2V5ID09PSBcImZ4XCIgfHwga2V5ID09PSBcImZ5XCIpIHJldHVybiBcImJhbmRcIjtcblxuICAvLyBJZiBhIHByb2plY3Rpb24gaXMgc3BlY2lmaWVkLCB0aGUgeC0gYW5kIHktc2NhbGVzIGFyZSBkaXNhYmxlZDsgdGhlc2VcbiAgLy8gY2hhbm5lbHMgd2lsbCBiZSBwcm9qZWN0ZWQgcmF0aGVyIHRoYW4gc2NhbGVkLiAoQnV0IHN0aWxsIGNoZWNrIHRoYXQgbm9uZVxuICAvLyBvZiB0aGUgYXNzb2NpYXRlZCBjaGFubmVscyBhcmUgaW5jb21wYXRpYmxlIHdpdGggYSBwcm9qZWN0aW9uLilcbiAgaWYgKChrZXkgPT09IFwieFwiIHx8IGtleSA9PT0gXCJ5XCIpICYmIHByb2plY3Rpb24gIT0gbnVsbCkgdHlwZSA9IHR5cGVQcm9qZWN0aW9uO1xuXG4gIC8vIElmIGEgY2hhbm5lbCBkaWN0YXRlcyBhIHNjYWxlIHR5cGUsIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGNvbnNpc3RlbnQgd2l0aFxuICAvLyB0aGUgdXNlci1zcGVjaWZpZWQgc2NhbGUgdHlwZSAoaWYgYW55KSBhbmQgYWxsIG90aGVyIGNoYW5uZWxzLiBGb3IgZXhhbXBsZSxcbiAgLy8gYmFyWSByZXF1aXJlcyB4IHRvIGJlIGEgYmFuZCBzY2FsZSBhbmQgZGlzYWxsb3dzIGFueSBvdGhlciBzY2FsZSB0eXBlLlxuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICBjb25zdCB0ID0gbWF5YmVTY2FsZVR5cGUoY2hhbm5lbC50eXBlKTtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSB0O1xuICAgIGVsc2UgaWYgKHR5cGUgIT09IHQpIHRocm93IG5ldyBFcnJvcihgc2NhbGUgaW5jb21wYXRpYmxlIHdpdGggY2hhbm5lbDogJHt0eXBlfSAhPT0gJHt0fWApO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNjYWxlLCBhIGNoYW5uZWwsIG9yIHVzZXIgc3BlY2lmaWVkIGEgKGNvbnNpc3RlbnQpIHR5cGUsIHJldHVybiBpdC5cbiAgaWYgKHR5cGUgPT09IHR5cGVQcm9qZWN0aW9uKSByZXR1cm47XG4gIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHJldHVybiB0eXBlO1xuXG4gIC8vIElmIHRoZXJl4oCZcyBubyBkYXRhIChhbmQgbm8gdHlwZSkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NhbGUsIGRvbuKAmXQgY3JlYXRlIGEgc2NhbGUuXG4gIGlmIChkb21haW4gPT09IHVuZGVmaW5lZCAmJiAhY2hhbm5lbHMuc29tZSgoe3ZhbHVlfSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpIHJldHVybjtcblxuICAvLyBTb21lIHNjYWxlcyBoYXZlIGRlZmF1bHQgdHlwZXMuXG4gIGNvbnN0IGtpbmQgPSByZWdpc3RyeS5nZXQoa2V5KTtcbiAgaWYgKGtpbmQgPT09IHJhZGl1cykgcmV0dXJuIFwic3FydFwiO1xuICBpZiAoa2luZCA9PT0gb3BhY2l0eSB8fCBraW5kID09PSBsZW5ndGgpIHJldHVybiBcImxpbmVhclwiO1xuICBpZiAoa2luZCA9PT0gc3ltYm9sKSByZXR1cm4gXCJvcmRpbmFsXCI7XG5cbiAgLy8gSWYgYSBkb21haW4gb3IgcmFuZ2UgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYW5kIGRvZXNu4oCZdCBoYXZlIHR3byB2YWx1ZXMsXG4gIC8vIGFzc3VtZSBpdOKAmXMgb3JkaW5hbC4gWW91IGNhbiBzdGlsbCB1c2UgYSDigJxwaWVjZXdpc2XigJ0gKG9yIOKAnHBvbHlsaW5lYXLigJ0pXG4gIC8vIHNjYWxlLCBidXQgeW91IG11c3Qgc2V0IHRoZSB0eXBlIGV4cGxpY2l0bHkuXG4gIGNvbnN0IG4gPSAoZG9tYWluID8/IHJhbmdlKT8ubGVuZ3RoO1xuICBpZiAobiA8IDIgfHwgbiA+IDIpIHJldHVybiBhc09yZGluYWxUeXBlKGtpbmQpO1xuXG4gIC8vIE90aGVyd2lzZSwgaW5mZXIgdGhlIHNjYWxlIHR5cGUgZnJvbSB0aGUgZGF0YSEgUHJlZmVyIHRoZSBkb21haW4sIGlmXG4gIC8vIHByZXNlbnQsIG92ZXIgY2hhbm5lbHMuIChUaGUgZG9tYWluIGFuZCBjaGFubmVscyBzaG91bGQgYmUgY29uc2lzdGVudGx5XG4gIC8vIHR5cGVkLCBhbmQgdGhlIGRvbWFpbiBpcyBtb3JlIGV4cGxpY2l0IGFuZCB0eXBpY2FsbHkgbXVjaCBzbWFsbGVyLikgV2Ugb25seVxuICAvLyBjaGVjayB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZSBmb3IgZXhwZWRpZW5jZSBhbmQgc2ltcGxpY2l0eTsgd2UgZXhwZWN0XG4gIC8vIHRoYXQgdGhlIHR5cGVzIGFyZSBjb25zaXN0ZW50LlxuICBpZiAoZG9tYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNPcmRpbmFsKGRvbWFpbikpIHJldHVybiBhc09yZGluYWxUeXBlKGtpbmQpO1xuICAgIGlmIChpc1RlbXBvcmFsKGRvbWFpbikpIHJldHVybiBcInV0Y1wiO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZhbHVlcyA9IGNoYW5uZWxzLm1hcCgoe3ZhbHVlfSkgPT4gdmFsdWUpLmZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGlmICh2YWx1ZXMuc29tZShpc09yZGluYWwpKSByZXR1cm4gYXNPcmRpbmFsVHlwZShraW5kKTtcbiAgICBpZiAodmFsdWVzLnNvbWUoaXNUZW1wb3JhbCkpIHJldHVybiBcInV0Y1wiO1xuICB9XG5cbiAgLy8gRm9yIGNvbG9yIHNjYWxlcywgdGFrZSBhIGhpbnQgZnJvbSB0aGUgY29sb3Igc2NoZW1lIGFuZCBwaXZvdCBvcHRpb24uXG4gIGlmIChraW5kID09PSBjb2xvcikge1xuICAgIGlmIChwaXZvdCAhPSBudWxsIHx8IGlzRGl2ZXJnaW5nU2NoZW1lKHNjaGVtZSkpIHJldHVybiBcImRpdmVyZ2luZ1wiO1xuICAgIGlmIChpc0NhdGVnb3JpY2FsU2NoZW1lKHNjaGVtZSkpIHJldHVybiBcImNhdGVnb3JpY2FsXCI7XG4gIH1cblxuICByZXR1cm4gXCJsaW5lYXJcIjtcbn1cblxuLy8gUG9zaXRpb25hbCBzY2FsZXMgZGVmYXVsdCB0byBhIHBvaW50IHNjYWxlIGluc3RlYWQgb2YgYW4gb3JkaW5hbCBzY2FsZS5cbmZ1bmN0aW9uIGFzT3JkaW5hbFR5cGUoa2luZCkge1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIHBvc2l0aW9uOlxuICAgICAgcmV0dXJuIFwicG9pbnRcIjtcbiAgICBjYXNlIGNvbG9yOlxuICAgICAgcmV0dXJuIG9yZGluYWxJbXBsaWNpdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RlbXBvcmFsU2NhbGUoe3R5cGV9KSB7XG4gIHJldHVybiB0eXBlID09PSBcInRpbWVcIiB8fCB0eXBlID09PSBcInV0Y1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPcmRpbmFsU2NhbGUoe3R5cGV9KSB7XG4gIHJldHVybiB0eXBlID09PSBcIm9yZGluYWxcIiB8fCB0eXBlID09PSBcInBvaW50XCIgfHwgdHlwZSA9PT0gXCJiYW5kXCIgfHwgdHlwZSA9PT0gb3JkaW5hbEltcGxpY2l0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUaHJlc2hvbGRTY2FsZSh7dHlwZX0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGhyZXNob2xkXCI7XG59XG5cbmZ1bmN0aW9uIGlzQmFuZFNjYWxlKHt0eXBlfSkge1xuICByZXR1cm4gdHlwZSA9PT0gXCJwb2ludFwiIHx8IHR5cGUgPT09IFwiYmFuZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXZlcmdpbmdTY2FsZSh7dHlwZX0pIHtcbiAgcmV0dXJuIC9eZGl2ZXJnaW5nKCR8LSkvLnRlc3QodHlwZSk7XG59XG5cbi8vIENlcnRhaW4gbWFya3MgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yIGlmIGEgc2NhbGUgaXMgY29sbGFwc2VkLCBpLmUuIGlmIHRoZVxuLy8gZG9tYWluIGlzIGRlZ2VuZXJhdGUgYW5kIHJlcHJlc2VudHMgb25seSBhIHNpbmdsZSB2YWx1ZSBzdWNoIGFzIFszLCAzXTsgZm9yXG4vLyBleGFtcGxlLCBhIHJlY3Qgd2lsbCBzcGFuIHRoZSBmdWxsIGV4dGVudCBvZiB0aGUgY2hhcnQgYWxvbmcgYSBjb2xsYXBzZWRcbi8vIGRpbWVuc2lvbiAod2hlcmVhcyBhIGRvdCB3aWxsIHNpbXBseSBiZSBkcmF3biBpbiB0aGUgY2VudGVyKS5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbGxhcHNlZChzY2FsZSkge1xuICBpZiAoc2NhbGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7IC8vIHRyZWF0IG1pc3Npbmcgc2NhbGUgYXMgY29sbGFwc2VkXG4gIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICBjb25zdCB2YWx1ZSA9IHNjYWxlKGRvbWFpblswXSk7XG4gIGZvciAobGV0IGkgPSAxLCBuID0gZG9tYWluLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmIChzY2FsZShkb21haW5baV0pIC0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIE11dGF0ZXMgY2hhbm5lbC52YWx1ZSFcbmZ1bmN0aW9uIGNvZXJjZVR5cGUoY2hhbm5lbHMsIHtkb21haW4sIC4uLm9wdGlvbnN9LCBjb2VyY2VWYWx1ZXMpIHtcbiAgZm9yIChjb25zdCBjIG9mIGNoYW5uZWxzKSB7XG4gICAgaWYgKGMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGRvbWFpbiA9PT0gdW5kZWZpbmVkKSBkb21haW4gPSBjLnZhbHVlPy5kb21haW47IC8vIHByb21vdGUgY2hhbm5lbCBkb21haW5cbiAgICAgIGMudmFsdWUgPSBjb2VyY2VWYWx1ZXMoYy52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZG9tYWluOiBkb21haW4gPT09IHVuZGVmaW5lZCA/IGRvbWFpbiA6IGNvZXJjZVZhbHVlcyhkb21haW4pLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29lcmNlU3ltYm9scyh2YWx1ZXMpIHtcbiAgcmV0dXJuIG1hcCh2YWx1ZXMsIG1heWJlU3ltYm9sKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG9wdGlvbnMgPSB7fSkge1xuICBsZXQgc2NhbGU7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJlZ2lzdHJ5LmhhcyhrZXkpKSBjb250aW51ZTsgLy8gaWdub3JlIHVua25vd24gcHJvcGVydGllc1xuICAgIGlmICghaXNTY2FsZU9wdGlvbnMob3B0aW9uc1trZXldKSkgY29udGludWU7IC8vIGUuZy4sIGlnbm9yZSB7Y29sb3I6IFwicmVkXCJ9XG4gICAgaWYgKHNjYWxlICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcImFtYmlndW91cyBzY2FsZSBkZWZpbml0aW9uOyBtdWx0aXBsZSBzY2FsZXMgZm91bmRcIik7XG4gICAgc2NhbGUgPSBleHBvc2VTY2FsZShub3JtYWxpemVTY2FsZShrZXksIG9wdGlvbnNba2V5XSkpO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNjYWxlIGRlZmluaXRpb247IG5vIHNjYWxlIGZvdW5kXCIpO1xuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvc2VTY2FsZXMoc2NhbGVzKSB7XG4gIHJldHVybiAoa2V5KSA9PiB7XG4gICAgaWYgKCFyZWdpc3RyeS5oYXMoKGtleSA9IGAke2tleX1gKSkpIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzY2FsZTogJHtrZXl9YCk7XG4gICAgcmV0dXJuIHNjYWxlc1trZXldO1xuICB9O1xufVxuXG4vLyBOb3RlOiBheGlzLSBhbmQgbGVnZW5kLXJlbGF0ZWQgcHJvcGVydGllcyAoc3VjaCBhcyBsYWJlbCwgdGlja3MgYW5kXG4vLyB0aWNrRm9ybWF0KSBhcmUgbm90IGluY2x1ZGVkIGhlcmUgYXMgdGhleSBkbyBub3QgYWZmZWN0IHRoZSBzY2FsZeKAmXMgYmVoYXZpb3IuXG5mdW5jdGlvbiBleHBvc2VTY2FsZSh7c2NhbGUsIHR5cGUsIGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBpbnRlcnZhbCwgdHJhbnNmb3JtLCBwZXJjZW50LCBwaXZvdH0pIHtcbiAgaWYgKHR5cGUgPT09IFwiaWRlbnRpdHlcIikgcmV0dXJuIHt0eXBlOiBcImlkZW50aXR5XCIsIGFwcGx5OiAoZCkgPT4gZCwgaW52ZXJ0OiAoZCkgPT4gZH07XG4gIGNvbnN0IHVua25vd24gPSBzY2FsZS51bmtub3duID8gc2NhbGUudW5rbm93bigpIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgZG9tYWluOiBzbGljZShkb21haW4pLCAvLyBkZWZlbnNpdmUgY29weVxuICAgIC4uLihyYW5nZSAhPT0gdW5kZWZpbmVkICYmIHtyYW5nZTogc2xpY2UocmFuZ2UpfSksIC8vIGRlZmVuc2l2ZSBjb3B5XG4gICAgLi4uKHRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkICYmIHt0cmFuc2Zvcm19KSxcbiAgICAuLi4ocGVyY2VudCAmJiB7cGVyY2VudH0pLCAvLyBvbmx5IGV4cG9zZWQgaWYgdHJ1dGh5XG4gICAgLi4uKHVua25vd24gIT09IHVuZGVmaW5lZCAmJiB7dW5rbm93bn0pLFxuICAgIC4uLihpbnRlcnZhbCAhPT0gdW5kZWZpbmVkICYmIHtpbnRlcnZhbH0pLFxuXG4gICAgLy8gcXVhbnRpdGF0aXZlXG4gICAgLi4uKGludGVycG9sYXRlICE9PSB1bmRlZmluZWQgJiYge2ludGVycG9sYXRlfSksXG4gICAgLi4uKHNjYWxlLmNsYW1wICYmIHtjbGFtcDogc2NhbGUuY2xhbXAoKX0pLFxuXG4gICAgLy8gZGl2ZXJnaW5nIChhbHdheXMgYXN5bW1ldHJpYzsgd2UgbmV2ZXIgd2FudCB0byBhcHBseSB0aGUgc3ltbWV0cmljIHRyYW5zZm9ybSB0d2ljZSlcbiAgICAuLi4ocGl2b3QgIT09IHVuZGVmaW5lZCAmJiB7cGl2b3QsIHN5bW1ldHJpYzogZmFsc2V9KSxcblxuICAgIC8vIGxvZywgZGl2ZXJnaW5nLWxvZ1xuICAgIC4uLihzY2FsZS5iYXNlICYmIHtiYXNlOiBzY2FsZS5iYXNlKCl9KSxcblxuICAgIC8vIHBvdywgZGl2ZXJnaW5nLXBvd1xuICAgIC4uLihzY2FsZS5leHBvbmVudCAmJiB7ZXhwb25lbnQ6IHNjYWxlLmV4cG9uZW50KCl9KSxcblxuICAgIC8vIHN5bWxvZywgZGl2ZXJnaW5nLXN5bWxvZ1xuICAgIC4uLihzY2FsZS5jb25zdGFudCAmJiB7Y29uc3RhbnQ6IHNjYWxlLmNvbnN0YW50KCl9KSxcblxuICAgIC8vIGJhbmQsIHBvaW50XG4gICAgLi4uKHNjYWxlLmFsaWduICYmIHthbGlnbjogc2NhbGUuYWxpZ24oKSwgcm91bmQ6IHNjYWxlLnJvdW5kKCl9KSxcbiAgICAuLi4oc2NhbGUucGFkZGluZyAmJlxuICAgICAgKHNjYWxlLnBhZGRpbmdJbm5lclxuICAgICAgICA/IHtwYWRkaW5nSW5uZXI6IHNjYWxlLnBhZGRpbmdJbm5lcigpLCBwYWRkaW5nT3V0ZXI6IHNjYWxlLnBhZGRpbmdPdXRlcigpfVxuICAgICAgICA6IHtwYWRkaW5nOiBzY2FsZS5wYWRkaW5nKCl9KSksXG4gICAgLi4uKHNjYWxlLmJhbmR3aWR0aCAmJiB7YmFuZHdpZHRoOiBzY2FsZS5iYW5kd2lkdGgoKSwgc3RlcDogc2NhbGUuc3RlcCgpfSksXG5cbiAgICAvLyB1dGlsaXRpZXNcbiAgICBhcHBseTogKHQpID0+IHNjYWxlKHQpLFxuICAgIC4uLihzY2FsZS5pbnZlcnQgJiYge2ludmVydDogKHQpID0+IHNjYWxlLmludmVydCh0KX0pXG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/diverging.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/diverging.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScaleDiverging: () => (/* binding */ createScaleDiverging),\n/* harmony export */   createScaleDivergingLog: () => (/* binding */ createScaleDivergingLog),\n/* harmony export */   createScaleDivergingPow: () => (/* binding */ createScaleDivergingPow),\n/* harmony export */   createScaleDivergingSqrt: () => (/* binding */ createScaleDivergingSqrt),\n/* harmony export */   createScaleDivergingSymlog: () => (/* binding */ createScaleDivergingSymlog)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _quantitative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quantitative.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js\");\n/* harmony import */ var _schemes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schemes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js\");\n\n\n\n\n\n\n\n\nfunction createScaleD(\n  key,\n  scale,\n  transform,\n  channels,\n  {\n    type,\n    nice,\n    clamp,\n    domain = (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.inferDomain)(channels),\n    unknown,\n    pivot = 0,\n    scheme,\n    range,\n    symmetric = true,\n    interpolate = _index_js__WEBPACK_IMPORTED_MODULE_2__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_2__.color\n      ? scheme == null && range !== undefined\n        ? d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRgb\n        : (0,_schemes_js__WEBPACK_IMPORTED_MODULE_3__.quantitativeScheme)(scheme !== undefined ? scheme : \"rdbu\")\n      : d3__WEBPACK_IMPORTED_MODULE_0__.interpolateNumber,\n    reverse\n  }\n) {\n  pivot = +pivot;\n  domain = (0,_options_js__WEBPACK_IMPORTED_MODULE_4__.arrayify)(domain);\n  let [min, max] = domain;\n  if (domain.length > 2) (0,_warnings_js__WEBPACK_IMPORTED_MODULE_5__.warn)(`Warning: the diverging ${key} scale domain contains extra elements.`);\n\n  if ((0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(min, max) < 0) ([min, max] = [max, min]), (reverse = !reverse);\n  min = Math.min(min, pivot);\n  max = Math.max(max, pivot);\n\n  // Sometimes interpolate is a named interpolator, such as \"lab\" for Lab color\n  // space. Other times interpolate is a function that takes two arguments and\n  // is used in conjunction with the range. And other times the interpolate\n  // function is a “fixed” interpolator on the [0, 1] interval, as when a\n  // color scheme such as interpolateRdBu is used.\n  if (typeof interpolate !== \"function\") {\n    interpolate = (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.maybeInterpolator)(interpolate);\n  }\n\n  // If an explicit range is specified, promote it to a piecewise interpolator.\n  if (range !== undefined) {\n    interpolate =\n      interpolate.length === 1 ? (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.interpolatePiecewise)(interpolate)(...range) : (0,d3__WEBPACK_IMPORTED_MODULE_0__.piecewise)(interpolate, range);\n  }\n\n  // Reverse before normalization.\n  if (reverse) interpolate = (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.flip)(interpolate);\n\n  // Normalize the interpolator for symmetric difference around the pivot.\n  if (symmetric) {\n    const mid = transform.apply(pivot);\n    const mindelta = mid - transform.apply(min);\n    const maxdelta = transform.apply(max) - mid;\n    if (mindelta < maxdelta) min = transform.invert(mid - maxdelta);\n    else if (mindelta > maxdelta) max = transform.invert(mid + mindelta);\n  }\n\n  scale.domain([min, pivot, max]).unknown(unknown).interpolator(interpolate);\n  if (clamp) scale.clamp(clamp);\n  if (nice) scale.nice(nice);\n  return {type, domain: [min, max], pivot, interpolate, scale};\n}\n\nfunction createScaleDiverging(key, channels, options) {\n  return createScaleD(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleDiverging)(), transformIdentity, channels, options);\n}\n\nfunction createScaleDivergingSqrt(key, channels, options) {\n  return createScaleDivergingPow(key, channels, {...options, exponent: 0.5});\n}\n\nfunction createScaleDivergingPow(key, channels, {exponent = 1, ...options}) {\n  return createScaleD(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleDivergingPow)().exponent((exponent = +exponent)), transformPow(exponent), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\n\nfunction createScaleDivergingLog(\n  key,\n  channels,\n  {base = 10, pivot = 1, domain = (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.inferDomain)(channels, pivot < 0 ? _defined_js__WEBPACK_IMPORTED_MODULE_6__.negative : _defined_js__WEBPACK_IMPORTED_MODULE_6__.positive), ...options}\n) {\n  return createScaleD(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleDivergingLog)().base((base = +base)), transformLog, channels, {\n    domain,\n    pivot,\n    ...options\n  });\n}\n\nfunction createScaleDivergingSymlog(key, channels, {constant = 1, ...options}) {\n  return createScaleD(\n    key,\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleDivergingSymlog)().constant((constant = +constant)),\n    transformSymlog(constant),\n    channels,\n    options\n  );\n}\n\nconst transformIdentity = {\n  apply(x) {\n    return x;\n  },\n  invert(x) {\n    return x;\n  }\n};\n\nconst transformLog = {\n  apply: Math.log,\n  invert: Math.exp\n};\n\nconst transformSqrt = {\n  apply(x) {\n    return Math.sign(x) * Math.sqrt(Math.abs(x));\n  },\n  invert(x) {\n    return Math.sign(x) * (x * x);\n  }\n};\n\nfunction transformPow(exponent) {\n  return exponent === 0.5\n    ? transformSqrt\n    : {\n        apply(x) {\n          return Math.sign(x) * Math.pow(Math.abs(x), exponent);\n        },\n        invert(x) {\n          return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent);\n        }\n      };\n}\n\nfunction transformSymlog(constant) {\n  return {\n    apply(x) {\n      return Math.sign(x) * Math.log1p(Math.abs(x / constant));\n    },\n    invert(x) {\n      return Math.sign(x) * Math.expm1(Math.abs(x)) * constant;\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvZGl2ZXJnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQVNZO0FBQ3FDO0FBQ1Y7QUFDSDtBQUNPO0FBQ2tEO0FBQzdDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0NBQVEsY0FBYyw0Q0FBSztBQUM3QztBQUNBLFVBQVUsOENBQWM7QUFDeEIsVUFBVSwrREFBa0I7QUFDNUIsUUFBUSxpREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFRO0FBQ25CO0FBQ0EseUJBQXlCLGtEQUFJLDJCQUEyQixLQUFLOztBQUU3RCxNQUFNLDhDQUFVO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0VBQW9CLDBCQUEwQiw2Q0FBUztBQUN4Rjs7QUFFQTtBQUNBLDZCQUE2QixzREFBSTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRU87QUFDUCwyQkFBMkIsa0RBQWM7QUFDekM7O0FBRU87QUFDUCxpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVPLGlEQUFpRCx5QkFBeUI7QUFDakYsMkJBQTJCLHFEQUFpQjtBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBLEdBQUcsK0JBQStCLDZEQUFXLHVCQUF1QixpREFBUSxHQUFHLGlEQUFRO0FBQ3ZGO0FBQ0EsMkJBQTJCLHFEQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU8sb0RBQW9ELHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0EsSUFBSSx3REFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3NjYWxlcy9kaXZlcmdpbmcuanM/ODFmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBkZXNjZW5kaW5nLFxuICBpbnRlcnBvbGF0ZU51bWJlcixcbiAgaW50ZXJwb2xhdGVSZ2IsXG4gIHBpZWNld2lzZSxcbiAgc2NhbGVEaXZlcmdpbmcsXG4gIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBzY2FsZURpdmVyZ2luZ1BvdyxcbiAgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcImQzXCI7XG5pbXBvcnQge25lZ2F0aXZlLCBwb3NpdGl2ZX0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7YXJyYXlpZnl9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge3dhcm59IGZyb20gXCIuLi93YXJuaW5ncy5qc1wiO1xuaW1wb3J0IHtjb2xvciwgcmVnaXN0cnl9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2ZsaXAsIGluZmVyRG9tYWluLCBpbnRlcnBvbGF0ZVBpZWNld2lzZSwgbWF5YmVJbnRlcnBvbGF0b3J9IGZyb20gXCIuL3F1YW50aXRhdGl2ZS5qc1wiO1xuaW1wb3J0IHtxdWFudGl0YXRpdmVTY2hlbWV9IGZyb20gXCIuL3NjaGVtZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRlU2NhbGVEKFxuICBrZXksXG4gIHNjYWxlLFxuICB0cmFuc2Zvcm0sXG4gIGNoYW5uZWxzLFxuICB7XG4gICAgdHlwZSxcbiAgICBuaWNlLFxuICAgIGNsYW1wLFxuICAgIGRvbWFpbiA9IGluZmVyRG9tYWluKGNoYW5uZWxzKSxcbiAgICB1bmtub3duLFxuICAgIHBpdm90ID0gMCxcbiAgICBzY2hlbWUsXG4gICAgcmFuZ2UsXG4gICAgc3ltbWV0cmljID0gdHJ1ZSxcbiAgICBpbnRlcnBvbGF0ZSA9IHJlZ2lzdHJ5LmdldChrZXkpID09PSBjb2xvclxuICAgICAgPyBzY2hlbWUgPT0gbnVsbCAmJiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgICAgOiBxdWFudGl0YXRpdmVTY2hlbWUoc2NoZW1lICE9PSB1bmRlZmluZWQgPyBzY2hlbWUgOiBcInJkYnVcIilcbiAgICAgIDogaW50ZXJwb2xhdGVOdW1iZXIsXG4gICAgcmV2ZXJzZVxuICB9XG4pIHtcbiAgcGl2b3QgPSArcGl2b3Q7XG4gIGRvbWFpbiA9IGFycmF5aWZ5KGRvbWFpbik7XG4gIGxldCBbbWluLCBtYXhdID0gZG9tYWluO1xuICBpZiAoZG9tYWluLmxlbmd0aCA+IDIpIHdhcm4oYFdhcm5pbmc6IHRoZSBkaXZlcmdpbmcgJHtrZXl9IHNjYWxlIGRvbWFpbiBjb250YWlucyBleHRyYSBlbGVtZW50cy5gKTtcblxuICBpZiAoZGVzY2VuZGluZyhtaW4sIG1heCkgPCAwKSAoW21pbiwgbWF4XSA9IFttYXgsIG1pbl0pLCAocmV2ZXJzZSA9ICFyZXZlcnNlKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBwaXZvdCk7XG4gIG1heCA9IE1hdGgubWF4KG1heCwgcGl2b3QpO1xuXG4gIC8vIFNvbWV0aW1lcyBpbnRlcnBvbGF0ZSBpcyBhIG5hbWVkIGludGVycG9sYXRvciwgc3VjaCBhcyBcImxhYlwiIGZvciBMYWIgY29sb3JcbiAgLy8gc3BhY2UuIE90aGVyIHRpbWVzIGludGVycG9sYXRlIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJndW1lbnRzIGFuZFxuICAvLyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHJhbmdlLiBBbmQgb3RoZXIgdGltZXMgdGhlIGludGVycG9sYXRlXG4gIC8vIGZ1bmN0aW9uIGlzIGEg4oCcZml4ZWTigJ0gaW50ZXJwb2xhdG9yIG9uIHRoZSBbMCwgMV0gaW50ZXJ2YWwsIGFzIHdoZW4gYVxuICAvLyBjb2xvciBzY2hlbWUgc3VjaCBhcyBpbnRlcnBvbGF0ZVJkQnUgaXMgdXNlZC5cbiAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaW50ZXJwb2xhdGUgPSBtYXliZUludGVycG9sYXRvcihpbnRlcnBvbGF0ZSk7XG4gIH1cblxuICAvLyBJZiBhbiBleHBsaWNpdCByYW5nZSBpcyBzcGVjaWZpZWQsIHByb21vdGUgaXQgdG8gYSBwaWVjZXdpc2UgaW50ZXJwb2xhdG9yLlxuICBpZiAocmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGludGVycG9sYXRlID1cbiAgICAgIGludGVycG9sYXRlLmxlbmd0aCA9PT0gMSA/IGludGVycG9sYXRlUGllY2V3aXNlKGludGVycG9sYXRlKSguLi5yYW5nZSkgOiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHJhbmdlKTtcbiAgfVxuXG4gIC8vIFJldmVyc2UgYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmIChyZXZlcnNlKSBpbnRlcnBvbGF0ZSA9IGZsaXAoaW50ZXJwb2xhdGUpO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgaW50ZXJwb2xhdG9yIGZvciBzeW1tZXRyaWMgZGlmZmVyZW5jZSBhcm91bmQgdGhlIHBpdm90LlxuICBpZiAoc3ltbWV0cmljKSB7XG4gICAgY29uc3QgbWlkID0gdHJhbnNmb3JtLmFwcGx5KHBpdm90KTtcbiAgICBjb25zdCBtaW5kZWx0YSA9IG1pZCAtIHRyYW5zZm9ybS5hcHBseShtaW4pO1xuICAgIGNvbnN0IG1heGRlbHRhID0gdHJhbnNmb3JtLmFwcGx5KG1heCkgLSBtaWQ7XG4gICAgaWYgKG1pbmRlbHRhIDwgbWF4ZGVsdGEpIG1pbiA9IHRyYW5zZm9ybS5pbnZlcnQobWlkIC0gbWF4ZGVsdGEpO1xuICAgIGVsc2UgaWYgKG1pbmRlbHRhID4gbWF4ZGVsdGEpIG1heCA9IHRyYW5zZm9ybS5pbnZlcnQobWlkICsgbWluZGVsdGEpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluKFttaW4sIHBpdm90LCBtYXhdKS51bmtub3duKHVua25vd24pLmludGVycG9sYXRvcihpbnRlcnBvbGF0ZSk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAoY2xhbXApO1xuICBpZiAobmljZSkgc2NhbGUubmljZShuaWNlKTtcbiAgcmV0dXJuIHt0eXBlLCBkb21haW46IFttaW4sIG1heF0sIHBpdm90LCBpbnRlcnBvbGF0ZSwgc2NhbGV9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVEaXZlcmdpbmcoa2V5LCBjaGFubmVscywgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlU2NhbGVEKGtleSwgc2NhbGVEaXZlcmdpbmcoKSwgdHJhbnNmb3JtSWRlbnRpdHksIGNoYW5uZWxzLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlRGl2ZXJnaW5nU3FydChrZXksIGNoYW5uZWxzLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVTY2FsZURpdmVyZ2luZ1BvdyhrZXksIGNoYW5uZWxzLCB7Li4ub3B0aW9ucywgZXhwb25lbnQ6IDAuNX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVEaXZlcmdpbmdQb3coa2V5LCBjaGFubmVscywge2V4cG9uZW50ID0gMSwgLi4ub3B0aW9uc30pIHtcbiAgcmV0dXJuIGNyZWF0ZVNjYWxlRChrZXksIHNjYWxlRGl2ZXJnaW5nUG93KCkuZXhwb25lbnQoKGV4cG9uZW50ID0gK2V4cG9uZW50KSksIHRyYW5zZm9ybVBvdyhleHBvbmVudCksIGNoYW5uZWxzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0eXBlOiBcImRpdmVyZ2luZy1wb3dcIlxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlRGl2ZXJnaW5nTG9nKFxuICBrZXksXG4gIGNoYW5uZWxzLFxuICB7YmFzZSA9IDEwLCBwaXZvdCA9IDEsIGRvbWFpbiA9IGluZmVyRG9tYWluKGNoYW5uZWxzLCBwaXZvdCA8IDAgPyBuZWdhdGl2ZSA6IHBvc2l0aXZlKSwgLi4ub3B0aW9uc31cbikge1xuICByZXR1cm4gY3JlYXRlU2NhbGVEKGtleSwgc2NhbGVEaXZlcmdpbmdMb2coKS5iYXNlKChiYXNlID0gK2Jhc2UpKSwgdHJhbnNmb3JtTG9nLCBjaGFubmVscywge1xuICAgIGRvbWFpbixcbiAgICBwaXZvdCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVEaXZlcmdpbmdTeW1sb2coa2V5LCBjaGFubmVscywge2NvbnN0YW50ID0gMSwgLi4ub3B0aW9uc30pIHtcbiAgcmV0dXJuIGNyZWF0ZVNjYWxlRChcbiAgICBrZXksXG4gICAgc2NhbGVEaXZlcmdpbmdTeW1sb2coKS5jb25zdGFudCgoY29uc3RhbnQgPSArY29uc3RhbnQpKSxcbiAgICB0cmFuc2Zvcm1TeW1sb2coY29uc3RhbnQpLFxuICAgIGNoYW5uZWxzLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cblxuY29uc3QgdHJhbnNmb3JtSWRlbnRpdHkgPSB7XG4gIGFwcGx5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfSxcbiAgaW52ZXJ0KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxufTtcblxuY29uc3QgdHJhbnNmb3JtTG9nID0ge1xuICBhcHBseTogTWF0aC5sb2csXG4gIGludmVydDogTWF0aC5leHBcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVNxcnQgPSB7XG4gIGFwcGx5KHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5zcXJ0KE1hdGguYWJzKHgpKTtcbiAgfSxcbiAgaW52ZXJ0KHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogKHggKiB4KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBleHBvbmVudCA9PT0gMC41XG4gICAgPyB0cmFuc2Zvcm1TcXJ0XG4gICAgOiB7XG4gICAgICAgIGFwcGx5KHgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIGV4cG9uZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW52ZXJ0KHgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyBleHBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjb25zdGFudCkge1xuICByZXR1cm4ge1xuICAgIGFwcGx5KHgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjb25zdGFudCkpO1xuICAgIH0sXG4gICAgaW52ZXJ0KHgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmV4cG0xKE1hdGguYWJzKHgpKSAqIGNvbnN0YW50O1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/diverging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   hasNumericRange: () => (/* binding */ hasNumericRange),\n/* harmony export */   isPosition: () => (/* binding */ isPosition),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   opacity: () => (/* binding */ opacity),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   projection: () => (/* binding */ projection),\n/* harmony export */   radius: () => (/* binding */ radius),\n/* harmony export */   registry: () => (/* binding */ registry),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n// Positional scales have associated axes, and for ordinal data, a point or band\n// scale is used instead of an ordinal scale.\nconst position = Symbol(\"position\");\n\n// Color scales default to the turbo interpolator for quantitative data, and to\n// the Tableau10 scheme for ordinal data. Color scales may also have an\n// associated legend.\nconst color = Symbol(\"color\");\n\n// Radius scales default to the sqrt type, have a default range of [0, 3], and a\n// default domain from 0 to the median first quartile of associated channels.\nconst radius = Symbol(\"radius\");\n\n// Length scales default to the linear type, have a default range of [0, 12],\n// and a default domain from 0 to the median median of associated channels.\nconst length = Symbol(\"length\");\n\n// Opacity scales have a default range of [0, 1], and a default domain from 0 to\n// the maximum value of associated channels.\nconst opacity = Symbol(\"opacity\");\n\n// Symbol scales have a default range of categorical symbols.\nconst symbol = Symbol(\"symbol\");\n\n// There isn’t really a projection scale; this represents x and y for geometry.\n// This is used to denote channels that should be projected.\nconst projection = Symbol(\"projection\");\n\n// TODO Rather than hard-coding the list of known scale names, collect the names\n// and categories for each plot specification, so that custom marks can register\n// custom scales.\nconst registry = new Map([\n  [\"x\", position],\n  [\"y\", position],\n  [\"fx\", position],\n  [\"fy\", position],\n  [\"r\", radius],\n  [\"color\", color],\n  [\"opacity\", opacity],\n  [\"symbol\", symbol],\n  [\"length\", length],\n  [\"projection\", projection]\n]);\n\nfunction isPosition(kind) {\n  return kind === position || kind === projection;\n}\n\nfunction hasNumericRange(kind) {\n  return kind === position || kind === radius || kind === length || kind === opacity;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDTzs7QUFFUDtBQUNPOztBQUVQLDBDQUEwQztBQUMxQztBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvaW5kZXguanM/MjA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3NpdGlvbmFsIHNjYWxlcyBoYXZlIGFzc29jaWF0ZWQgYXhlcywgYW5kIGZvciBvcmRpbmFsIGRhdGEsIGEgcG9pbnQgb3IgYmFuZFxuLy8gc2NhbGUgaXMgdXNlZCBpbnN0ZWFkIG9mIGFuIG9yZGluYWwgc2NhbGUuXG5leHBvcnQgY29uc3QgcG9zaXRpb24gPSBTeW1ib2woXCJwb3NpdGlvblwiKTtcblxuLy8gQ29sb3Igc2NhbGVzIGRlZmF1bHQgdG8gdGhlIHR1cmJvIGludGVycG9sYXRvciBmb3IgcXVhbnRpdGF0aXZlIGRhdGEsIGFuZCB0b1xuLy8gdGhlIFRhYmxlYXUxMCBzY2hlbWUgZm9yIG9yZGluYWwgZGF0YS4gQ29sb3Igc2NhbGVzIG1heSBhbHNvIGhhdmUgYW5cbi8vIGFzc29jaWF0ZWQgbGVnZW5kLlxuZXhwb3J0IGNvbnN0IGNvbG9yID0gU3ltYm9sKFwiY29sb3JcIik7XG5cbi8vIFJhZGl1cyBzY2FsZXMgZGVmYXVsdCB0byB0aGUgc3FydCB0eXBlLCBoYXZlIGEgZGVmYXVsdCByYW5nZSBvZiBbMCwgM10sIGFuZCBhXG4vLyBkZWZhdWx0IGRvbWFpbiBmcm9tIDAgdG8gdGhlIG1lZGlhbiBmaXJzdCBxdWFydGlsZSBvZiBhc3NvY2lhdGVkIGNoYW5uZWxzLlxuZXhwb3J0IGNvbnN0IHJhZGl1cyA9IFN5bWJvbChcInJhZGl1c1wiKTtcblxuLy8gTGVuZ3RoIHNjYWxlcyBkZWZhdWx0IHRvIHRoZSBsaW5lYXIgdHlwZSwgaGF2ZSBhIGRlZmF1bHQgcmFuZ2Ugb2YgWzAsIDEyXSxcbi8vIGFuZCBhIGRlZmF1bHQgZG9tYWluIGZyb20gMCB0byB0aGUgbWVkaWFuIG1lZGlhbiBvZiBhc3NvY2lhdGVkIGNoYW5uZWxzLlxuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IFN5bWJvbChcImxlbmd0aFwiKTtcblxuLy8gT3BhY2l0eSBzY2FsZXMgaGF2ZSBhIGRlZmF1bHQgcmFuZ2Ugb2YgWzAsIDFdLCBhbmQgYSBkZWZhdWx0IGRvbWFpbiBmcm9tIDAgdG9cbi8vIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGFzc29jaWF0ZWQgY2hhbm5lbHMuXG5leHBvcnQgY29uc3Qgb3BhY2l0eSA9IFN5bWJvbChcIm9wYWNpdHlcIik7XG5cbi8vIFN5bWJvbCBzY2FsZXMgaGF2ZSBhIGRlZmF1bHQgcmFuZ2Ugb2YgY2F0ZWdvcmljYWwgc3ltYm9scy5cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSBTeW1ib2woXCJzeW1ib2xcIik7XG5cbi8vIFRoZXJlIGlzbuKAmXQgcmVhbGx5IGEgcHJvamVjdGlvbiBzY2FsZTsgdGhpcyByZXByZXNlbnRzIHggYW5kIHkgZm9yIGdlb21ldHJ5LlxuLy8gVGhpcyBpcyB1c2VkIHRvIGRlbm90ZSBjaGFubmVscyB0aGF0IHNob3VsZCBiZSBwcm9qZWN0ZWQuXG5leHBvcnQgY29uc3QgcHJvamVjdGlvbiA9IFN5bWJvbChcInByb2plY3Rpb25cIik7XG5cbi8vIFRPRE8gUmF0aGVyIHRoYW4gaGFyZC1jb2RpbmcgdGhlIGxpc3Qgb2Yga25vd24gc2NhbGUgbmFtZXMsIGNvbGxlY3QgdGhlIG5hbWVzXG4vLyBhbmQgY2F0ZWdvcmllcyBmb3IgZWFjaCBwbG90IHNwZWNpZmljYXRpb24sIHNvIHRoYXQgY3VzdG9tIG1hcmtzIGNhbiByZWdpc3RlclxuLy8gY3VzdG9tIHNjYWxlcy5cbmV4cG9ydCBjb25zdCByZWdpc3RyeSA9IG5ldyBNYXAoW1xuICBbXCJ4XCIsIHBvc2l0aW9uXSxcbiAgW1wieVwiLCBwb3NpdGlvbl0sXG4gIFtcImZ4XCIsIHBvc2l0aW9uXSxcbiAgW1wiZnlcIiwgcG9zaXRpb25dLFxuICBbXCJyXCIsIHJhZGl1c10sXG4gIFtcImNvbG9yXCIsIGNvbG9yXSxcbiAgW1wib3BhY2l0eVwiLCBvcGFjaXR5XSxcbiAgW1wic3ltYm9sXCIsIHN5bWJvbF0sXG4gIFtcImxlbmd0aFwiLCBsZW5ndGhdLFxuICBbXCJwcm9qZWN0aW9uXCIsIHByb2plY3Rpb25dXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUG9zaXRpb24oa2luZCkge1xuICByZXR1cm4ga2luZCA9PT0gcG9zaXRpb24gfHwga2luZCA9PT0gcHJvamVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc051bWVyaWNSYW5nZShraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBwb3NpdGlvbiB8fCBraW5kID09PSByYWRpdXMgfHwga2luZCA9PT0gbGVuZ3RoIHx8IGtpbmQgPT09IG9wYWNpdHk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/ordinal.js":
/*!***************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/ordinal.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScaleBand: () => (/* binding */ createScaleBand),\n/* harmony export */   createScaleOrdinal: () => (/* binding */ createScaleOrdinal),\n/* harmony export */   createScalePoint: () => (/* binding */ createScalePoint),\n/* harmony export */   ordinalImplicit: () => (/* binding */ ordinalImplicit)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _schemes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schemes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js\");\n\n\n\n\n\n\n\n\n// This denotes an implicitly ordinal color scale: the scale type was not set,\n// but the associated values are strings or booleans. If the associated defined\n// values are entirely boolean, the range will default to greys. You can opt out\n// of this by setting the type explicitly.\nconst ordinalImplicit = Symbol(\"ordinal\");\n\nfunction createScaleO(key, scale, channels, {type, interval, domain, range, reverse, hint}) {\n  interval = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeRangeInterval)(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  if (type === \"categorical\" || type === ordinalImplicit) type = \"ordinal\"; // shorthand for color schemes\n  if (reverse) domain = (0,d3__WEBPACK_IMPORTED_MODULE_0__.reverse)(domain);\n  domain = scale.domain(domain).domain(); // deduplicate\n  if (range !== undefined) {\n    // If the range is specified as a function, pass it the domain.\n    if (typeof range === \"function\") range = range(domain);\n    scale.range(range);\n  }\n  return {type, domain, range, scale, hint, interval};\n}\n\nfunction createScaleOrdinal(key, channels, {type, interval, domain, range, scheme, unknown, ...options}) {\n  interval = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeRangeInterval)(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  let hint;\n  if (_index_js__WEBPACK_IMPORTED_MODULE_2__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_2__.symbol) {\n    hint = inferSymbolHint(channels);\n    range = range === undefined ? inferSymbolRange(hint) : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.map)(range, _symbol_js__WEBPACK_IMPORTED_MODULE_3__.maybeSymbol);\n  } else if (_index_js__WEBPACK_IMPORTED_MODULE_2__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_2__.color) {\n    if (range === undefined && (type === \"ordinal\" || type === ordinalImplicit)) {\n      range = (0,_schemes_js__WEBPACK_IMPORTED_MODULE_4__.maybeBooleanRange)(domain, scheme);\n      if (range !== undefined) scheme = undefined; // Don’t re-apply scheme.\n    }\n    if (scheme === undefined && range === undefined) {\n      scheme = type === \"ordinal\" ? \"turbo\" : \"observable10\";\n    }\n    if (scheme !== undefined) {\n      if (range !== undefined) {\n        const interpolate = (0,_schemes_js__WEBPACK_IMPORTED_MODULE_4__.quantitativeScheme)(scheme);\n        const t0 = range[0],\n          d = range[1] - range[0];\n        range = ({length: n}) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)((t) => interpolate(t0 + d * t), n);\n      } else {\n        range = (0,_schemes_js__WEBPACK_IMPORTED_MODULE_4__.ordinalScheme)(scheme);\n      }\n    }\n  }\n  if (unknown === d3__WEBPACK_IMPORTED_MODULE_0__.scaleImplicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return createScaleO(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleOrdinal)().unknown(unknown), channels, {...options, type, domain, range, hint});\n}\n\nfunction createScalePoint(key, channels, {align = 0.5, padding = 0.5, ...options}) {\n  return maybeRound((0,d3__WEBPACK_IMPORTED_MODULE_0__.scalePoint)().align(align).padding(padding), channels, options, key);\n}\n\nfunction createScaleBand(\n  key,\n  channels,\n  {\n    align = 0.5,\n    padding = 0.1,\n    paddingInner = padding,\n    paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding,\n    ...options\n  }\n) {\n  return maybeRound(\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleBand)().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),\n    channels,\n    options,\n    key\n  );\n}\n\nfunction maybeRound(scale, channels, options, key) {\n  let {round} = options;\n  if (round !== undefined) scale.round((round = !!round));\n  scale = createScaleO(key, scale, channels, options);\n  scale.round = round; // preserve for autoScaleRound\n  return scale;\n}\n\nfunction inferDomain(channels, interval, key) {\n  const values = new d3__WEBPACK_IMPORTED_MODULE_0__.InternSet();\n  for (const {value, domain} of channels) {\n    if (domain !== undefined) return domain(); // see channelDomain\n    if (value === undefined) continue;\n    for (const v of value) values.add(v);\n  }\n  if (interval !== undefined) {\n    const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(values).map(interval.floor, interval);\n    return interval.range(min, interval.offset(max));\n  }\n  if (values.size > 10e3 && _index_js__WEBPACK_IMPORTED_MODULE_2__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_2__.position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.sort)(values, _defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined);\n}\n\n// If all channels provide a consistent hint, propagate it to the scale.\nfunction inferHint(channels, key) {\n  let value;\n  for (const {hint} of channels) {\n    const candidate = hint?.[key];\n    if (candidate === undefined) continue; // no hint here\n    if (value === undefined) value = candidate; // first hint\n    else if (value !== candidate) return; // inconsistent hint\n  }\n  return value;\n}\n\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\n\nfunction inferSymbolRange(hint) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(hint.fill) ? d3__WEBPACK_IMPORTED_MODULE_0__.symbolsStroke : d3__WEBPACK_IMPORTED_MODULE_0__.symbolsFill;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvb3JkaW5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVHO0FBQ2pDO0FBQ3ZCO0FBQ2tCO0FBQ3hCO0FBQ29CO0FBQ3FCOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQLDZDQUE2Qyw2Q0FBNkM7QUFDMUYsYUFBYSwrREFBa0I7QUFDL0I7QUFDQSw0RUFBNEU7QUFDNUUsd0JBQXdCLDJDQUFTO0FBQ2pDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVPLDRDQUE0QywyREFBMkQ7QUFDOUcsYUFBYSwrREFBa0I7QUFDL0I7QUFDQTtBQUNBLE1BQU0sK0NBQVEsY0FBYyw2Q0FBTTtBQUNsQztBQUNBLDJEQUEyRCxnREFBRyxRQUFRLG1EQUFXO0FBQ2pGLElBQUksU0FBUywrQ0FBUSxjQUFjLDRDQUFLO0FBQ3hDO0FBQ0EsY0FBYyw4REFBaUI7QUFDL0IsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBa0I7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQixVQUFVLEtBQUssNENBQVE7QUFDekMsUUFBUTtBQUNSLGdCQUFnQiwwREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQWE7QUFDL0IsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQSwyQkFBMkIsZ0RBQVksZ0NBQWdDLHNDQUFzQztBQUM3Rzs7QUFFTywwQ0FBMEMsdUNBQXVDO0FBQ3hGLG9CQUFvQiw4Q0FBVTtBQUM5Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5Q0FBUztBQUM5QixjQUFjLGVBQWU7QUFDN0IsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQVEsY0FBYywrQ0FBUTtBQUMxRCxrREFBa0QsS0FBSztBQUN2RDtBQUNBLFNBQVMsd0NBQUksU0FBUyx5REFBZ0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0EsMkNBQTJDO0FBQzNDLGdEQUFnRDtBQUNoRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsc0RBQVMsY0FBYyw2Q0FBYSxHQUFHLDJDQUFXO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvb3JkaW5hbC5qcz85NDU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW50ZXJuU2V0LCBleHRlbnQsIHF1YW50aXplLCByZXZlcnNlIGFzIHJldmVyc2VvZiwgc29ydCwgc3ltYm9sc0ZpbGwsIHN5bWJvbHNTdHJva2V9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHtzY2FsZUJhbmQsIHNjYWxlT3JkaW5hbCwgc2NhbGVQb2ludCwgc2NhbGVJbXBsaWNpdH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2FzY2VuZGluZ0RlZmluZWR9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge2lzTm9uZWlzaCwgbWFwLCBtYXliZVJhbmdlSW50ZXJ2YWx9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge21heWJlU3ltYm9sfSBmcm9tIFwiLi4vc3ltYm9sLmpzXCI7XG5pbXBvcnQge3JlZ2lzdHJ5LCBjb2xvciwgcG9zaXRpb24sIHN5bWJvbH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7bWF5YmVCb29sZWFuUmFuZ2UsIG9yZGluYWxTY2hlbWUsIHF1YW50aXRhdGl2ZVNjaGVtZX0gZnJvbSBcIi4vc2NoZW1lcy5qc1wiO1xuXG4vLyBUaGlzIGRlbm90ZXMgYW4gaW1wbGljaXRseSBvcmRpbmFsIGNvbG9yIHNjYWxlOiB0aGUgc2NhbGUgdHlwZSB3YXMgbm90IHNldCxcbi8vIGJ1dCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgYXJlIHN0cmluZ3Mgb3IgYm9vbGVhbnMuIElmIHRoZSBhc3NvY2lhdGVkIGRlZmluZWRcbi8vIHZhbHVlcyBhcmUgZW50aXJlbHkgYm9vbGVhbiwgdGhlIHJhbmdlIHdpbGwgZGVmYXVsdCB0byBncmV5cy4gWW91IGNhbiBvcHQgb3V0XG4vLyBvZiB0aGlzIGJ5IHNldHRpbmcgdGhlIHR5cGUgZXhwbGljaXRseS5cbmV4cG9ydCBjb25zdCBvcmRpbmFsSW1wbGljaXQgPSBTeW1ib2woXCJvcmRpbmFsXCIpO1xuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZU8oa2V5LCBzY2FsZSwgY2hhbm5lbHMsIHt0eXBlLCBpbnRlcnZhbCwgZG9tYWluLCByYW5nZSwgcmV2ZXJzZSwgaGludH0pIHtcbiAgaW50ZXJ2YWwgPSBtYXliZVJhbmdlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpO1xuICBpZiAoZG9tYWluID09PSB1bmRlZmluZWQpIGRvbWFpbiA9IGluZmVyRG9tYWluKGNoYW5uZWxzLCBpbnRlcnZhbCwga2V5KTtcbiAgaWYgKHR5cGUgPT09IFwiY2F0ZWdvcmljYWxcIiB8fCB0eXBlID09PSBvcmRpbmFsSW1wbGljaXQpIHR5cGUgPSBcIm9yZGluYWxcIjsgLy8gc2hvcnRoYW5kIGZvciBjb2xvciBzY2hlbWVzXG4gIGlmIChyZXZlcnNlKSBkb21haW4gPSByZXZlcnNlb2YoZG9tYWluKTtcbiAgZG9tYWluID0gc2NhbGUuZG9tYWluKGRvbWFpbikuZG9tYWluKCk7IC8vIGRlZHVwbGljYXRlXG4gIGlmIChyYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSWYgdGhlIHJhbmdlIGlzIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uLCBwYXNzIGl0IHRoZSBkb21haW4uXG4gICAgaWYgKHR5cGVvZiByYW5nZSA9PT0gXCJmdW5jdGlvblwiKSByYW5nZSA9IHJhbmdlKGRvbWFpbik7XG4gICAgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICB9XG4gIHJldHVybiB7dHlwZSwgZG9tYWluLCByYW5nZSwgc2NhbGUsIGhpbnQsIGludGVydmFsfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlT3JkaW5hbChrZXksIGNoYW5uZWxzLCB7dHlwZSwgaW50ZXJ2YWwsIGRvbWFpbiwgcmFuZ2UsIHNjaGVtZSwgdW5rbm93biwgLi4ub3B0aW9uc30pIHtcbiAgaW50ZXJ2YWwgPSBtYXliZVJhbmdlSW50ZXJ2YWwoaW50ZXJ2YWwsIHR5cGUpO1xuICBpZiAoZG9tYWluID09PSB1bmRlZmluZWQpIGRvbWFpbiA9IGluZmVyRG9tYWluKGNoYW5uZWxzLCBpbnRlcnZhbCwga2V5KTtcbiAgbGV0IGhpbnQ7XG4gIGlmIChyZWdpc3RyeS5nZXQoa2V5KSA9PT0gc3ltYm9sKSB7XG4gICAgaGludCA9IGluZmVyU3ltYm9sSGludChjaGFubmVscyk7XG4gICAgcmFuZ2UgPSByYW5nZSA9PT0gdW5kZWZpbmVkID8gaW5mZXJTeW1ib2xSYW5nZShoaW50KSA6IG1hcChyYW5nZSwgbWF5YmVTeW1ib2wpO1xuICB9IGVsc2UgaWYgKHJlZ2lzdHJ5LmdldChrZXkpID09PSBjb2xvcikge1xuICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkICYmICh0eXBlID09PSBcIm9yZGluYWxcIiB8fCB0eXBlID09PSBvcmRpbmFsSW1wbGljaXQpKSB7XG4gICAgICByYW5nZSA9IG1heWJlQm9vbGVhblJhbmdlKGRvbWFpbiwgc2NoZW1lKTtcbiAgICAgIGlmIChyYW5nZSAhPT0gdW5kZWZpbmVkKSBzY2hlbWUgPSB1bmRlZmluZWQ7IC8vIERvbuKAmXQgcmUtYXBwbHkgc2NoZW1lLlxuICAgIH1cbiAgICBpZiAoc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gdHlwZSA9PT0gXCJvcmRpbmFsXCIgPyBcInR1cmJvXCIgOiBcIm9ic2VydmFibGUxMFwiO1xuICAgIH1cbiAgICBpZiAoc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gcXVhbnRpdGF0aXZlU2NoZW1lKHNjaGVtZSk7XG4gICAgICAgIGNvbnN0IHQwID0gcmFuZ2VbMF0sXG4gICAgICAgICAgZCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICAgIHJhbmdlID0gKHtsZW5ndGg6IG59KSA9PiBxdWFudGl6ZSgodCkgPT4gaW50ZXJwb2xhdGUodDAgKyBkICogdCksIG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBvcmRpbmFsU2NoZW1lKHNjaGVtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1bmtub3duID09PSBzY2FsZUltcGxpY2l0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbXBsaWNpdCB1bmtub3duIG9uICR7a2V5fSBzY2FsZSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNjYWxlTyhrZXksIHNjYWxlT3JkaW5hbCgpLnVua25vd24odW5rbm93biksIGNoYW5uZWxzLCB7Li4ub3B0aW9ucywgdHlwZSwgZG9tYWluLCByYW5nZSwgaGludH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVQb2ludChrZXksIGNoYW5uZWxzLCB7YWxpZ24gPSAwLjUsIHBhZGRpbmcgPSAwLjUsIC4uLm9wdGlvbnN9KSB7XG4gIHJldHVybiBtYXliZVJvdW5kKHNjYWxlUG9pbnQoKS5hbGlnbihhbGlnbikucGFkZGluZyhwYWRkaW5nKSwgY2hhbm5lbHMsIG9wdGlvbnMsIGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZUJhbmQoXG4gIGtleSxcbiAgY2hhbm5lbHMsXG4gIHtcbiAgICBhbGlnbiA9IDAuNSxcbiAgICBwYWRkaW5nID0gMC4xLFxuICAgIHBhZGRpbmdJbm5lciA9IHBhZGRpbmcsXG4gICAgcGFkZGluZ091dGVyID0ga2V5ID09PSBcImZ4XCIgfHwga2V5ID09PSBcImZ5XCIgPyAwIDogcGFkZGluZyxcbiAgICAuLi5vcHRpb25zXG4gIH1cbikge1xuICByZXR1cm4gbWF5YmVSb3VuZChcbiAgICBzY2FsZUJhbmQoKS5hbGlnbihhbGlnbikucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcikucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlciksXG4gICAgY2hhbm5lbHMsXG4gICAgb3B0aW9ucyxcbiAgICBrZXlcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVSb3VuZChzY2FsZSwgY2hhbm5lbHMsIG9wdGlvbnMsIGtleSkge1xuICBsZXQge3JvdW5kfSA9IG9wdGlvbnM7XG4gIGlmIChyb3VuZCAhPT0gdW5kZWZpbmVkKSBzY2FsZS5yb3VuZCgocm91bmQgPSAhIXJvdW5kKSk7XG4gIHNjYWxlID0gY3JlYXRlU2NhbGVPKGtleSwgc2NhbGUsIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgc2NhbGUucm91bmQgPSByb3VuZDsgLy8gcHJlc2VydmUgZm9yIGF1dG9TY2FsZVJvdW5kXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gaW5mZXJEb21haW4oY2hhbm5lbHMsIGludGVydmFsLCBrZXkpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEludGVyblNldCgpO1xuICBmb3IgKGNvbnN0IHt2YWx1ZSwgZG9tYWlufSBvZiBjaGFubmVscykge1xuICAgIGlmIChkb21haW4gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGRvbWFpbigpOyAvLyBzZWUgY2hhbm5lbERvbWFpblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHZhbHVlcy5hZGQodik7XG4gIH1cbiAgaWYgKGludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZXh0ZW50KHZhbHVlcykubWFwKGludGVydmFsLmZsb29yLCBpbnRlcnZhbCk7XG4gICAgcmV0dXJuIGludGVydmFsLnJhbmdlKG1pbiwgaW50ZXJ2YWwub2Zmc2V0KG1heCkpO1xuICB9XG4gIGlmICh2YWx1ZXMuc2l6ZSA+IDEwZTMgJiYgcmVnaXN0cnkuZ2V0KGtleSkgPT09IHBvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbXBsaWNpdCBvcmRpbmFsIGRvbWFpbiBvZiAke2tleX0gc2NhbGUgaGFzIG1vcmUgdGhhbiAxMCwwMDAgdmFsdWVzYCk7XG4gIH1cbiAgcmV0dXJuIHNvcnQodmFsdWVzLCBhc2NlbmRpbmdEZWZpbmVkKTtcbn1cblxuLy8gSWYgYWxsIGNoYW5uZWxzIHByb3ZpZGUgYSBjb25zaXN0ZW50IGhpbnQsIHByb3BhZ2F0ZSBpdCB0byB0aGUgc2NhbGUuXG5mdW5jdGlvbiBpbmZlckhpbnQoY2hhbm5lbHMsIGtleSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3Qge2hpbnR9IG9mIGNoYW5uZWxzKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlID0gaGludD8uW2tleV07XG4gICAgaWYgKGNhbmRpZGF0ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gbm8gaGludCBoZXJlXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gY2FuZGlkYXRlOyAvLyBmaXJzdCBoaW50XG4gICAgZWxzZSBpZiAodmFsdWUgIT09IGNhbmRpZGF0ZSkgcmV0dXJuOyAvLyBpbmNvbnNpc3RlbnQgaGludFxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5mZXJTeW1ib2xIaW50KGNoYW5uZWxzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsbDogaW5mZXJIaW50KGNoYW5uZWxzLCBcImZpbGxcIiksXG4gICAgc3Ryb2tlOiBpbmZlckhpbnQoY2hhbm5lbHMsIFwic3Ryb2tlXCIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZmVyU3ltYm9sUmFuZ2UoaGludCkge1xuICByZXR1cm4gaXNOb25laXNoKGhpbnQuZmlsbCkgPyBzeW1ib2xzU3Ryb2tlIDogc3ltYm9sc0ZpbGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/ordinal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js":
/*!********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/quantitative.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScaleIdentity: () => (/* binding */ createScaleIdentity),\n/* harmony export */   createScaleLinear: () => (/* binding */ createScaleLinear),\n/* harmony export */   createScaleLog: () => (/* binding */ createScaleLog),\n/* harmony export */   createScalePow: () => (/* binding */ createScalePow),\n/* harmony export */   createScaleQ: () => (/* binding */ createScaleQ),\n/* harmony export */   createScaleQuantile: () => (/* binding */ createScaleQuantile),\n/* harmony export */   createScaleQuantize: () => (/* binding */ createScaleQuantize),\n/* harmony export */   createScaleSqrt: () => (/* binding */ createScaleSqrt),\n/* harmony export */   createScaleSymlog: () => (/* binding */ createScaleSymlog),\n/* harmony export */   createScaleThreshold: () => (/* binding */ createScaleThreshold),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   inferDomain: () => (/* binding */ inferDomain),\n/* harmony export */   interpolatePiecewise: () => (/* binding */ interpolatePiecewise),\n/* harmony export */   maybeInterpolator: () => (/* binding */ maybeInterpolator)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../order.js */ \"(ssr)/./node_modules/@observablehq/plot/src/order.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/index.js\");\n/* harmony import */ var _schemes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schemes.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js\");\n\n\n\n\n\n\n\nconst flip = (i) => (t) => i(1 - t);\nconst unit = [0, 1];\n\nconst interpolators = new Map([\n  // numbers\n  [\"number\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateNumber],\n\n  // color spaces\n  [\"rgb\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRgb],\n  [\"hsl\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateHsl],\n  [\"hcl\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateHcl],\n  [\"lab\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateLab]\n]);\n\nfunction maybeInterpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i)) throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\n\nfunction createScaleQ(\n  key,\n  scale,\n  channels,\n  {\n    type,\n    nice,\n    clamp,\n    zero,\n    domain = inferAutoDomain(key, channels),\n    unknown,\n    round,\n    scheme,\n    interval,\n    range = _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.radius\n      ? inferRadialRange(channels, domain)\n      : _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.length\n      ? inferLengthRange(channels, domain)\n      : _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.opacity\n      ? unit\n      : undefined,\n    interpolate = _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.color\n      ? scheme == null && range !== undefined\n        ? d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRgb\n        : (0,_schemes_js__WEBPACK_IMPORTED_MODULE_2__.quantitativeScheme)(scheme !== undefined ? scheme : type === \"cyclical\" ? \"rainbow\" : \"turbo\")\n      : round\n      ? d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRound\n      : d3__WEBPACK_IMPORTED_MODULE_0__.interpolateNumber,\n    reverse\n  }\n) {\n  domain = maybeRepeat(domain);\n  interval = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeRangeInterval)(interval, type);\n  if (type === \"cyclical\" || type === \"sequential\") type = \"linear\"; // shorthand for color schemes\n  if (typeof interpolate !== \"function\") interpolate = maybeInterpolator(interpolate); // named interpolator\n  reverse = !!reverse;\n\n  // If an explicit range is specified, and it has a different length than the\n  // domain, then redistribute the range using a piecewise interpolator.\n  if (range !== undefined) {\n    const n = domain.length;\n    const m = (range = maybeRepeat(range)).length;\n    if (n !== m) {\n      if (interpolate.length === 1) throw new Error(\"invalid piecewise interpolator\"); // e.g., turbo\n      interpolate = (0,d3__WEBPACK_IMPORTED_MODULE_0__.piecewise)(interpolate, range);\n      range = undefined;\n    }\n  }\n\n  // Disambiguate between a two-argument interpolator that is used in\n  // conjunction with the range, and a one-argument “fixed” interpolator on the\n  // [0, 1] interval as with the RdBu color scheme.\n  if (interpolate.length === 1) {\n    if (reverse) {\n      interpolate = flip(interpolate);\n      reverse = false;\n    }\n    if (range === undefined) {\n      range = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range.length === 2) range = unit; // optimize common case of [0, 1]\n    }\n    scale.interpolate((range === unit ? _options_js__WEBPACK_IMPORTED_MODULE_3__.constant : interpolatePiecewise)(interpolate));\n  } else {\n    scale.interpolate(interpolate);\n  }\n\n  // If a zero option is specified, we assume that the domain is numeric, and we\n  // want to ensure that the domain crosses zero. However, note that the domain\n  // may be reversed (descending) so we shouldn’t assume that the first value is\n  // smaller than the last; and also it’s possible that the domain has more than\n  // two values for a “poly” scale. And lastly be careful not to mutate input!\n  if (zero) {\n    const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain);\n    if (min > 0 || max < 0) {\n      domain = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.slice)(domain);\n      const o = (0,_order_js__WEBPACK_IMPORTED_MODULE_4__.orderof)(domain) || 1; // treat degenerate as ascending\n      if (o === Math.sign(min)) domain[0] = 0; // [1, 2] or [-1, -2]\n      else domain[domain.length - 1] = 0; // [2, 1] or [-2, -1]\n    }\n  }\n\n  if (reverse) domain = (0,d3__WEBPACK_IMPORTED_MODULE_0__.reverse)(domain);\n  scale.domain(domain).unknown(unknown);\n  if (nice) scale.nice(maybeNice(nice, type)), (domain = scale.domain());\n  if (range !== undefined) scale.range(range);\n  if (clamp) scale.clamp(clamp);\n  return {type, domain, range, scale, interpolate, interval};\n}\n\nfunction maybeRepeat(values) {\n  values = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.arrayify)(values);\n  return values.length >= 2 ? values : [values[0], values[0]];\n}\n\nfunction maybeNice(nice, type) {\n  return nice === true ? undefined : typeof nice === \"number\" ? nice : (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.maybeNiceInterval)(nice, type);\n}\n\nfunction createScaleLinear(key, channels, options) {\n  return createScaleQ(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleLinear)(), channels, options);\n}\n\nfunction createScaleSqrt(key, channels, options) {\n  return createScalePow(key, channels, {...options, exponent: 0.5});\n}\n\nfunction createScalePow(key, channels, {exponent = 1, ...options}) {\n  return createScaleQ(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scalePow)().exponent(exponent), channels, {...options, type: \"pow\"});\n}\n\nfunction createScaleLog(key, channels, {base = 10, domain = inferLogDomain(channels), ...options}) {\n  return createScaleQ(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleLog)().base(base), channels, {...options, domain});\n}\n\nfunction createScaleSymlog(key, channels, {constant = 1, ...options}) {\n  return createScaleQ(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleSymlog)().constant(constant), channels, options);\n}\n\nfunction createScaleQuantile(\n  key,\n  channels,\n  {\n    range,\n    quantiles = range === undefined ? 5 : (range = [...range]).length, // deprecated; use n instead\n    n = quantiles,\n    scheme = \"rdylbu\",\n    domain = inferQuantileDomain(channels),\n    unknown,\n    interpolate,\n    reverse\n  }\n) {\n  if (range === undefined) {\n    range =\n      interpolate !== undefined\n        ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, n)\n        : _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.color\n        ? (0,_schemes_js__WEBPACK_IMPORTED_MODULE_2__.ordinalRange)(scheme, n)\n        : undefined;\n  }\n  if (domain.length > 0) {\n    domain = (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleQuantile)(domain, range === undefined ? {length: n} : range).quantiles();\n  }\n  return createScaleThreshold(key, channels, {domain, range, reverse, unknown});\n}\n\nfunction createScaleQuantize(\n  key,\n  channels,\n  {\n    range,\n    n = range === undefined ? 5 : (range = [...range]).length,\n    scheme = \"rdylbu\",\n    domain = inferAutoDomain(key, channels),\n    unknown,\n    interpolate,\n    reverse\n  }\n) {\n  const [min, max] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(domain);\n  let thresholds;\n  if (range === undefined) {\n    thresholds = (0,d3__WEBPACK_IMPORTED_MODULE_0__.ticks)(min, max, n); // approximate number of nice, round thresholds\n    if (thresholds[0] <= min) thresholds.splice(0, 1); // drop exact lower bound\n    if (thresholds[thresholds.length - 1] >= max) thresholds.pop(); // drop exact upper bound\n    n = thresholds.length + 1;\n    range =\n      interpolate !== undefined\n        ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, n)\n        : _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.color\n        ? (0,_schemes_js__WEBPACK_IMPORTED_MODULE_2__.ordinalRange)(scheme, n)\n        : undefined;\n  } else {\n    thresholds = (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)((0,d3__WEBPACK_IMPORTED_MODULE_0__.interpolateNumber)(min, max), n + 1).slice(1, -1); // exactly n - 1 thresholds to match range\n    if (min instanceof Date) thresholds = thresholds.map((x) => new Date(x)); // preserve date types\n  }\n  if ((0,_order_js__WEBPACK_IMPORTED_MODULE_4__.orderof)((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.arrayify)(domain)) < 0) thresholds.reverse(); // preserve descending domain\n  return createScaleThreshold(key, channels, {domain: thresholds, range, reverse, unknown});\n}\n\nfunction createScaleThreshold(\n  key,\n  channels,\n  {\n    domain = [0], // explicit thresholds in ascending order\n    unknown,\n    scheme = \"rdylbu\",\n    interpolate,\n    range = interpolate !== undefined\n      ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, domain.length + 1)\n      : _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key) === _index_js__WEBPACK_IMPORTED_MODULE_1__.color\n      ? (0,_schemes_js__WEBPACK_IMPORTED_MODULE_2__.ordinalRange)(scheme, domain.length + 1)\n      : undefined,\n    reverse\n  }\n) {\n  domain = (0,_options_js__WEBPACK_IMPORTED_MODULE_3__.arrayify)(domain);\n  const sign = (0,_order_js__WEBPACK_IMPORTED_MODULE_4__.orderof)(domain); // preserve descending domain\n  if (!isNaN(sign) && !isOrdered(domain, sign)) throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse) range = (0,d3__WEBPACK_IMPORTED_MODULE_0__.reverse)(range); // domain ascending, so reverse range\n  return {\n    type: \"threshold\",\n    scale: (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleThreshold)(sign < 0 ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.reverse)(domain) : domain, range === undefined ? [] : range).unknown(unknown),\n    domain,\n    range\n  };\n}\n\nfunction isOrdered(domain, sign) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s = (0,d3__WEBPACK_IMPORTED_MODULE_0__.descending)(d, (d = domain[i]));\n    if (s !== 0 && s !== sign) return false;\n  }\n  return true;\n}\n\n// For non-numeric identity scales such as color and symbol, we can’t use D3’s\n// identity scale because it coerces to number; and we can’t compute the domain\n// (and equivalently range) since we can’t know whether the values are\n// continuous or discrete.\nfunction createScaleIdentity(key) {\n  return {type: \"identity\", scale: (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.hasNumericRange)(_index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key)) ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleIdentity)() : (d) => d};\n}\n\nfunction inferDomain(channels, f = _defined_js__WEBPACK_IMPORTED_MODULE_5__.finite) {\n  return channels.length\n    ? [\n        (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(channels, ({value}) => (value === undefined ? value : (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(value, f))),\n        (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(channels, ({value}) => (value === undefined ? value : (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(value, f)))\n      ]\n    : [0, 1];\n}\n\nfunction inferAutoDomain(key, channels) {\n  const type = _index_js__WEBPACK_IMPORTED_MODULE_1__.registry.get(key);\n  return (type === _index_js__WEBPACK_IMPORTED_MODULE_1__.radius || type === _index_js__WEBPACK_IMPORTED_MODULE_1__.opacity || type === _index_js__WEBPACK_IMPORTED_MODULE_1__.length ? inferZeroDomain : inferDomain)(channels);\n}\n\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(channels, ({value}) => (value === undefined ? value : (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(value, _defined_js__WEBPACK_IMPORTED_MODULE_5__.finite))) : 1];\n}\n\n// We don’t want the upper bound of the radial domain to be zero, as this would\n// be degenerate, so we ignore nonpositive values. We also don’t want the\n// maximum default radius to exceed 30px.\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({radius}) => radius !== undefined);\n  if (hint !== undefined) return [0, hint.radius]; // a natural maximum radius, e.g. hexbins\n  const h25 = (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantile)(channels, 0.5, ({value}) => (value === undefined ? NaN : (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantile)(value, 0.25, _defined_js__WEBPACK_IMPORTED_MODULE_5__.positive)));\n  const range = domain.map((d) => 3 * Math.sqrt(d / h25));\n  const k = 30 / (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(range);\n  return k < 1 ? range.map((r) => r * k) : range;\n}\n\n// We want a length scale’s domain to go from zero to a positive value, and to\n// treat negative lengths if any as inverted vectors of equivalent magnitude. We\n// also don’t want the maximum default length to exceed 60px.\nfunction inferLengthRange(channels, domain) {\n  const h50 = (0,d3__WEBPACK_IMPORTED_MODULE_0__.median)(channels, ({value}) => (value === undefined ? NaN : (0,d3__WEBPACK_IMPORTED_MODULE_0__.median)(value, Math.abs)));\n  const range = domain.map((d) => (12 * d) / h50);\n  const k = 60 / (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(range);\n  return k < 1 ? range.map((r) => r * k) : range;\n}\n\nfunction inferLogDomain(channels) {\n  for (const {value} of channels) {\n    if (value !== undefined) {\n      for (let v of value) {\n        if (v > 0) return inferDomain(channels, _defined_js__WEBPACK_IMPORTED_MODULE_5__.positive);\n        if (v < 0) return inferDomain(channels, _defined_js__WEBPACK_IMPORTED_MODULE_5__.negative);\n      }\n    }\n  }\n  return [1, 10];\n}\n\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const {value} of channels) {\n    if (value === undefined) continue;\n    for (const v of value) domain.push(v);\n  }\n  return domain;\n}\n\nfunction interpolatePiecewise(interpolate) {\n  return (i, j) => (t) => interpolate(i + t * (j - i));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvcXVhbnRpdGF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JZO0FBQzZDO0FBQ3NDO0FBQzNEO0FBQ2lEO0FBQ3ZCOztBQUV2RDtBQUNQOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlEQUFpQjs7QUFFOUI7QUFDQSxVQUFVLDhDQUFjO0FBQ3hCLFVBQVUsOENBQWM7QUFDeEIsVUFBVSw4Q0FBYztBQUN4QixVQUFVLDhDQUFjO0FBQ3hCOztBQUVPO0FBQ1AsZUFBZSxZQUFZO0FBQzNCLHNFQUFzRSxFQUFFO0FBQ3hFO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQVEsY0FBYyw2Q0FBTTtBQUN4QztBQUNBLFFBQVEsK0NBQVEsY0FBYyw2Q0FBTTtBQUNwQztBQUNBLFFBQVEsK0NBQVEsY0FBYyw4Q0FBTztBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLCtDQUFRLGNBQWMsNENBQUs7QUFDN0M7QUFDQSxVQUFVLDhDQUFjO0FBQ3hCLFVBQVUsK0RBQWtCO0FBQzVCO0FBQ0EsUUFBUSxnREFBZ0I7QUFDeEIsUUFBUSxpREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUFrQjtBQUMvQixxRUFBcUU7QUFDckUsdUZBQXVGO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RixvQkFBb0IsNkNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esd0NBQXdDLGlEQUFRO0FBQ2hELElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNO0FBQzdCO0FBQ0EsZUFBZSxrREFBSztBQUNwQixnQkFBZ0Isa0RBQU8sZUFBZTtBQUN0QywrQ0FBK0M7QUFDL0MsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUEsd0JBQXdCLDJDQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsV0FBVyxxREFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLDhEQUFpQjtBQUN4Rjs7QUFFTztBQUNQLDJCQUEyQiwrQ0FBVztBQUN0Qzs7QUFFTztBQUNQLHdDQUF3QywwQkFBMEI7QUFDbEU7O0FBRU8sd0NBQXdDLHlCQUF5QjtBQUN4RSwyQkFBMkIsNENBQVEsa0NBQWtDLHdCQUF3QjtBQUM3Rjs7QUFFTyx3Q0FBd0MseURBQXlEO0FBQ3hHLDJCQUEyQiw0Q0FBUSwwQkFBMEIsbUJBQW1CO0FBQ2hGOztBQUVPLDJDQUEyQyx5QkFBeUI7QUFDM0UsMkJBQTJCLCtDQUFXO0FBQ3RDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQVE7QUFDbEIsVUFBVSwrQ0FBUSxjQUFjLDRDQUFLO0FBQ3JDLFVBQVUseURBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBYSxnQ0FBZ0MsV0FBVztBQUNyRTtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUU7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU07QUFDM0I7QUFDQTtBQUNBLGlCQUFpQix5Q0FBSyxlQUFlO0FBQ3JDLHVEQUF1RDtBQUN2RCxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBUTtBQUNsQixVQUFVLCtDQUFRLGNBQWMsNENBQUs7QUFDckMsVUFBVSx5REFBWTtBQUN0QjtBQUNBLElBQUk7QUFDSixpQkFBaUIsNENBQVEsQ0FBQyxxREFBaUIsaUNBQWlDO0FBQzVFLDhFQUE4RTtBQUM5RTtBQUNBLE1BQU0sa0RBQU8sQ0FBQyxxREFBUSxxQ0FBcUM7QUFDM0QsOENBQThDLDRDQUE0QztBQUMxRjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFRO0FBQ2hCLFFBQVEsK0NBQVEsY0FBYyw0Q0FBSztBQUNuQyxRQUFRLHlEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBUTtBQUNuQixlQUFlLGtEQUFPLFVBQVU7QUFDaEMsdUVBQXVFLEtBQUs7QUFDNUUsdUJBQXVCLDJDQUFTLFNBQVM7QUFDekM7QUFDQTtBQUNBLFdBQVcsa0RBQWMsWUFBWSwyQ0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNELGNBQWMsOENBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNPO0FBQ1AsVUFBVSx5QkFBeUIsMERBQWUsQ0FBQywrQ0FBUSxhQUFhLGlEQUFhO0FBQ3JGOztBQUVPLG1DQUFtQywrQ0FBTTtBQUNoRDtBQUNBO0FBQ0EsUUFBUSx1Q0FBRyxhQUFhLE1BQU0sb0NBQW9DLHVDQUFHO0FBQ3JFLFFBQVEsdUNBQUcsYUFBYSxNQUFNLG9DQUFvQyx1Q0FBRztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtDQUFRO0FBQ3ZCLG1CQUFtQiw2Q0FBTSxhQUFhLDhDQUFPLGFBQWEsNkNBQU07QUFDaEU7O0FBRUE7QUFDQSwrQkFBK0IsdUNBQUcsYUFBYSxNQUFNLG9DQUFvQyx1Q0FBRyxRQUFRLCtDQUFNO0FBQzFHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEMsbURBQW1EO0FBQ25ELGNBQWMsNENBQVEsa0JBQWtCLE1BQU0sa0NBQWtDLDRDQUFRLGNBQWMsaURBQVE7QUFDOUc7QUFDQSxpQkFBaUIsdUNBQUc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMENBQU0sYUFBYSxNQUFNLGtDQUFrQywwQ0FBTTtBQUMvRTtBQUNBLGlCQUFpQix1Q0FBRztBQUNwQjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxnREFBZ0QsaURBQVE7QUFDeEQsZ0RBQWdELGlEQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvc2NhbGVzL3F1YW50aXRhdGl2ZS5qcz83ZmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGRlc2NlbmRpbmcsXG4gIGV4dGVudCxcbiAgaW50ZXJwb2xhdGVIY2wsXG4gIGludGVycG9sYXRlSHNsLFxuICBpbnRlcnBvbGF0ZUxhYixcbiAgaW50ZXJwb2xhdGVOdW1iZXIsXG4gIGludGVycG9sYXRlUmdiLFxuICBpbnRlcnBvbGF0ZVJvdW5kLFxuICBtYXgsXG4gIG1lZGlhbixcbiAgbWluLFxuICBwaWVjZXdpc2UsXG4gIHF1YW50aWxlLFxuICBxdWFudGl6ZSxcbiAgcmV2ZXJzZSBhcyByZXZlcnNlb2YsXG4gIHNjYWxlSWRlbnRpdHksXG4gIHNjYWxlTGluZWFyLFxuICBzY2FsZUxvZyxcbiAgc2NhbGVQb3csXG4gIHNjYWxlUXVhbnRpbGUsXG4gIHNjYWxlU3ltbG9nLFxuICBzY2FsZVRocmVzaG9sZCxcbiAgdGlja3Ncbn0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2Zpbml0ZSwgbmVnYXRpdmUsIHBvc2l0aXZlfSBmcm9tIFwiLi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IHthcnJheWlmeSwgY29uc3RhbnQsIG1heWJlTmljZUludGVydmFsLCBtYXliZVJhbmdlSW50ZXJ2YWwsIHNsaWNlfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtvcmRlcm9mfSBmcm9tIFwiLi4vb3JkZXIuanNcIjtcbmltcG9ydCB7Y29sb3IsIGxlbmd0aCwgb3BhY2l0eSwgcmFkaXVzLCByZWdpc3RyeSwgaGFzTnVtZXJpY1JhbmdlfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHtvcmRpbmFsUmFuZ2UsIHF1YW50aXRhdGl2ZVNjaGVtZX0gZnJvbSBcIi4vc2NoZW1lcy5qc1wiO1xuXG5leHBvcnQgY29uc3QgZmxpcCA9IChpKSA9PiAodCkgPT4gaSgxIC0gdCk7XG5jb25zdCB1bml0ID0gWzAsIDFdO1xuXG5jb25zdCBpbnRlcnBvbGF0b3JzID0gbmV3IE1hcChbXG4gIC8vIG51bWJlcnNcbiAgW1wibnVtYmVyXCIsIGludGVycG9sYXRlTnVtYmVyXSxcblxuICAvLyBjb2xvciBzcGFjZXNcbiAgW1wicmdiXCIsIGludGVycG9sYXRlUmdiXSxcbiAgW1wiaHNsXCIsIGludGVycG9sYXRlSHNsXSxcbiAgW1wiaGNsXCIsIGludGVycG9sYXRlSGNsXSxcbiAgW1wibGFiXCIsIGludGVycG9sYXRlTGFiXVxuXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVycG9sYXRvcihpbnRlcnBvbGF0ZSkge1xuICBjb25zdCBpID0gYCR7aW50ZXJwb2xhdGV9YC50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWludGVycG9sYXRvcnMuaGFzKGkpKSB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gaW50ZXJwb2xhdG9yOiAke2l9YCk7XG4gIHJldHVybiBpbnRlcnBvbGF0b3JzLmdldChpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlUShcbiAga2V5LFxuICBzY2FsZSxcbiAgY2hhbm5lbHMsXG4gIHtcbiAgICB0eXBlLFxuICAgIG5pY2UsXG4gICAgY2xhbXAsXG4gICAgemVybyxcbiAgICBkb21haW4gPSBpbmZlckF1dG9Eb21haW4oa2V5LCBjaGFubmVscyksXG4gICAgdW5rbm93bixcbiAgICByb3VuZCxcbiAgICBzY2hlbWUsXG4gICAgaW50ZXJ2YWwsXG4gICAgcmFuZ2UgPSByZWdpc3RyeS5nZXQoa2V5KSA9PT0gcmFkaXVzXG4gICAgICA/IGluZmVyUmFkaWFsUmFuZ2UoY2hhbm5lbHMsIGRvbWFpbilcbiAgICAgIDogcmVnaXN0cnkuZ2V0KGtleSkgPT09IGxlbmd0aFxuICAgICAgPyBpbmZlckxlbmd0aFJhbmdlKGNoYW5uZWxzLCBkb21haW4pXG4gICAgICA6IHJlZ2lzdHJ5LmdldChrZXkpID09PSBvcGFjaXR5XG4gICAgICA/IHVuaXRcbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIGludGVycG9sYXRlID0gcmVnaXN0cnkuZ2V0KGtleSkgPT09IGNvbG9yXG4gICAgICA/IHNjaGVtZSA9PSBudWxsICYmIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgICA6IHF1YW50aXRhdGl2ZVNjaGVtZShzY2hlbWUgIT09IHVuZGVmaW5lZCA/IHNjaGVtZSA6IHR5cGUgPT09IFwiY3ljbGljYWxcIiA/IFwicmFpbmJvd1wiIDogXCJ0dXJib1wiKVxuICAgICAgOiByb3VuZFxuICAgICAgPyBpbnRlcnBvbGF0ZVJvdW5kXG4gICAgICA6IGludGVycG9sYXRlTnVtYmVyLFxuICAgIHJldmVyc2VcbiAgfVxuKSB7XG4gIGRvbWFpbiA9IG1heWJlUmVwZWF0KGRvbWFpbik7XG4gIGludGVydmFsID0gbWF5YmVSYW5nZUludGVydmFsKGludGVydmFsLCB0eXBlKTtcbiAgaWYgKHR5cGUgPT09IFwiY3ljbGljYWxcIiB8fCB0eXBlID09PSBcInNlcXVlbnRpYWxcIikgdHlwZSA9IFwibGluZWFyXCI7IC8vIHNob3J0aGFuZCBmb3IgY29sb3Igc2NoZW1lc1xuICBpZiAodHlwZW9mIGludGVycG9sYXRlICE9PSBcImZ1bmN0aW9uXCIpIGludGVycG9sYXRlID0gbWF5YmVJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGUpOyAvLyBuYW1lZCBpbnRlcnBvbGF0b3JcbiAgcmV2ZXJzZSA9ICEhcmV2ZXJzZTtcblxuICAvLyBJZiBhbiBleHBsaWNpdCByYW5nZSBpcyBzcGVjaWZpZWQsIGFuZCBpdCBoYXMgYSBkaWZmZXJlbnQgbGVuZ3RoIHRoYW4gdGhlXG4gIC8vIGRvbWFpbiwgdGhlbiByZWRpc3RyaWJ1dGUgdGhlIHJhbmdlIHVzaW5nIGEgcGllY2V3aXNlIGludGVycG9sYXRvci5cbiAgaWYgKHJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBuID0gZG9tYWluLmxlbmd0aDtcbiAgICBjb25zdCBtID0gKHJhbmdlID0gbWF5YmVSZXBlYXQocmFuZ2UpKS5sZW5ndGg7XG4gICAgaWYgKG4gIT09IG0pIHtcbiAgICAgIGlmIChpbnRlcnBvbGF0ZS5sZW5ndGggPT09IDEpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGllY2V3aXNlIGludGVycG9sYXRvclwiKTsgLy8gZS5nLiwgdHVyYm9cbiAgICAgIGludGVycG9sYXRlID0gcGllY2V3aXNlKGludGVycG9sYXRlLCByYW5nZSk7XG4gICAgICByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBEaXNhbWJpZ3VhdGUgYmV0d2VlbiBhIHR3by1hcmd1bWVudCBpbnRlcnBvbGF0b3IgdGhhdCBpcyB1c2VkIGluXG4gIC8vIGNvbmp1bmN0aW9uIHdpdGggdGhlIHJhbmdlLCBhbmQgYSBvbmUtYXJndW1lbnQg4oCcZml4ZWTigJ0gaW50ZXJwb2xhdG9yIG9uIHRoZVxuICAvLyBbMCwgMV0gaW50ZXJ2YWwgYXMgd2l0aCB0aGUgUmRCdSBjb2xvciBzY2hlbWUuXG4gIGlmIChpbnRlcnBvbGF0ZS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgaW50ZXJwb2xhdGUgPSBmbGlwKGludGVycG9sYXRlKTtcbiAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhbmdlID0gRmxvYXQ2NEFycmF5LmZyb20oZG9tYWluLCAoXywgaSkgPT4gaSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMikgcmFuZ2UgPSB1bml0OyAvLyBvcHRpbWl6ZSBjb21tb24gY2FzZSBvZiBbMCwgMV1cbiAgICB9XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUoKHJhbmdlID09PSB1bml0ID8gY29uc3RhbnQgOiBpbnRlcnBvbGF0ZVBpZWNld2lzZSkoaW50ZXJwb2xhdGUpKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSk7XG4gIH1cblxuICAvLyBJZiBhIHplcm8gb3B0aW9uIGlzIHNwZWNpZmllZCwgd2UgYXNzdW1lIHRoYXQgdGhlIGRvbWFpbiBpcyBudW1lcmljLCBhbmQgd2VcbiAgLy8gd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgZG9tYWluIGNyb3NzZXMgemVyby4gSG93ZXZlciwgbm90ZSB0aGF0IHRoZSBkb21haW5cbiAgLy8gbWF5IGJlIHJldmVyc2VkIChkZXNjZW5kaW5nKSBzbyB3ZSBzaG91bGRu4oCZdCBhc3N1bWUgdGhhdCB0aGUgZmlyc3QgdmFsdWUgaXNcbiAgLy8gc21hbGxlciB0aGFuIHRoZSBsYXN0OyBhbmQgYWxzbyBpdOKAmXMgcG9zc2libGUgdGhhdCB0aGUgZG9tYWluIGhhcyBtb3JlIHRoYW5cbiAgLy8gdHdvIHZhbHVlcyBmb3IgYSDigJxwb2x54oCdIHNjYWxlLiBBbmQgbGFzdGx5IGJlIGNhcmVmdWwgbm90IHRvIG11dGF0ZSBpbnB1dCFcbiAgaWYgKHplcm8pIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZXh0ZW50KGRvbWFpbik7XG4gICAgaWYgKG1pbiA+IDAgfHwgbWF4IDwgMCkge1xuICAgICAgZG9tYWluID0gc2xpY2UoZG9tYWluKTtcbiAgICAgIGNvbnN0IG8gPSBvcmRlcm9mKGRvbWFpbikgfHwgMTsgLy8gdHJlYXQgZGVnZW5lcmF0ZSBhcyBhc2NlbmRpbmdcbiAgICAgIGlmIChvID09PSBNYXRoLnNpZ24obWluKSkgZG9tYWluWzBdID0gMDsgLy8gWzEsIDJdIG9yIFstMSwgLTJdXG4gICAgICBlbHNlIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gPSAwOyAvLyBbMiwgMV0gb3IgWy0yLCAtMV1cbiAgICB9XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgZG9tYWluID0gcmV2ZXJzZW9mKGRvbWFpbik7XG4gIHNjYWxlLmRvbWFpbihkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKG1heWJlTmljZShuaWNlLCB0eXBlKSksIChkb21haW4gPSBzY2FsZS5kb21haW4oKSk7XG4gIGlmIChyYW5nZSAhPT0gdW5kZWZpbmVkKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAoY2xhbXApO1xuICByZXR1cm4ge3R5cGUsIGRvbWFpbiwgcmFuZ2UsIHNjYWxlLCBpbnRlcnBvbGF0ZSwgaW50ZXJ2YWx9O1xufVxuXG5mdW5jdGlvbiBtYXliZVJlcGVhdCh2YWx1ZXMpIHtcbiAgdmFsdWVzID0gYXJyYXlpZnkodmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPj0gMiA/IHZhbHVlcyA6IFt2YWx1ZXNbMF0sIHZhbHVlc1swXV07XG59XG5cbmZ1bmN0aW9uIG1heWJlTmljZShuaWNlLCB0eXBlKSB7XG4gIHJldHVybiBuaWNlID09PSB0cnVlID8gdW5kZWZpbmVkIDogdHlwZW9mIG5pY2UgPT09IFwibnVtYmVyXCIgPyBuaWNlIDogbWF5YmVOaWNlSW50ZXJ2YWwobmljZSwgdHlwZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZUxpbmVhcihrZXksIGNoYW5uZWxzLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVTY2FsZVEoa2V5LCBzY2FsZUxpbmVhcigpLCBjaGFubmVscywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZVNxcnQoa2V5LCBjaGFubmVscywgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlU2NhbGVQb3coa2V5LCBjaGFubmVscywgey4uLm9wdGlvbnMsIGV4cG9uZW50OiAwLjV9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlUG93KGtleSwgY2hhbm5lbHMsIHtleHBvbmVudCA9IDEsIC4uLm9wdGlvbnN9KSB7XG4gIHJldHVybiBjcmVhdGVTY2FsZVEoa2V5LCBzY2FsZVBvdygpLmV4cG9uZW50KGV4cG9uZW50KSwgY2hhbm5lbHMsIHsuLi5vcHRpb25zLCB0eXBlOiBcInBvd1wifSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZUxvZyhrZXksIGNoYW5uZWxzLCB7YmFzZSA9IDEwLCBkb21haW4gPSBpbmZlckxvZ0RvbWFpbihjaGFubmVscyksIC4uLm9wdGlvbnN9KSB7XG4gIHJldHVybiBjcmVhdGVTY2FsZVEoa2V5LCBzY2FsZUxvZygpLmJhc2UoYmFzZSksIGNoYW5uZWxzLCB7Li4ub3B0aW9ucywgZG9tYWlufSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZVN5bWxvZyhrZXksIGNoYW5uZWxzLCB7Y29uc3RhbnQgPSAxLCAuLi5vcHRpb25zfSkge1xuICByZXR1cm4gY3JlYXRlU2NhbGVRKGtleSwgc2NhbGVTeW1sb2coKS5jb25zdGFudChjb25zdGFudCksIGNoYW5uZWxzLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlUXVhbnRpbGUoXG4gIGtleSxcbiAgY2hhbm5lbHMsXG4gIHtcbiAgICByYW5nZSxcbiAgICBxdWFudGlsZXMgPSByYW5nZSA9PT0gdW5kZWZpbmVkID8gNSA6IChyYW5nZSA9IFsuLi5yYW5nZV0pLmxlbmd0aCwgLy8gZGVwcmVjYXRlZDsgdXNlIG4gaW5zdGVhZFxuICAgIG4gPSBxdWFudGlsZXMsXG4gICAgc2NoZW1lID0gXCJyZHlsYnVcIixcbiAgICBkb21haW4gPSBpbmZlclF1YW50aWxlRG9tYWluKGNoYW5uZWxzKSxcbiAgICB1bmtub3duLFxuICAgIGludGVycG9sYXRlLFxuICAgIHJldmVyc2VcbiAgfVxuKSB7XG4gIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmFuZ2UgPVxuICAgICAgaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHF1YW50aXplKGludGVycG9sYXRlLCBuKVxuICAgICAgICA6IHJlZ2lzdHJ5LmdldChrZXkpID09PSBjb2xvclxuICAgICAgICA/IG9yZGluYWxSYW5nZShzY2hlbWUsIG4pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChkb21haW4ubGVuZ3RoID4gMCkge1xuICAgIGRvbWFpbiA9IHNjYWxlUXVhbnRpbGUoZG9tYWluLCByYW5nZSA9PT0gdW5kZWZpbmVkID8ge2xlbmd0aDogbn0gOiByYW5nZSkucXVhbnRpbGVzKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNjYWxlVGhyZXNob2xkKGtleSwgY2hhbm5lbHMsIHtkb21haW4sIHJhbmdlLCByZXZlcnNlLCB1bmtub3dufSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZVF1YW50aXplKFxuICBrZXksXG4gIGNoYW5uZWxzLFxuICB7XG4gICAgcmFuZ2UsXG4gICAgbiA9IHJhbmdlID09PSB1bmRlZmluZWQgPyA1IDogKHJhbmdlID0gWy4uLnJhbmdlXSkubGVuZ3RoLFxuICAgIHNjaGVtZSA9IFwicmR5bGJ1XCIsXG4gICAgZG9tYWluID0gaW5mZXJBdXRvRG9tYWluKGtleSwgY2hhbm5lbHMpLFxuICAgIHVua25vd24sXG4gICAgaW50ZXJwb2xhdGUsXG4gICAgcmV2ZXJzZVxuICB9XG4pIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGV4dGVudChkb21haW4pO1xuICBsZXQgdGhyZXNob2xkcztcbiAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJlc2hvbGRzID0gdGlja3MobWluLCBtYXgsIG4pOyAvLyBhcHByb3hpbWF0ZSBudW1iZXIgb2YgbmljZSwgcm91bmQgdGhyZXNob2xkc1xuICAgIGlmICh0aHJlc2hvbGRzWzBdIDw9IG1pbikgdGhyZXNob2xkcy5zcGxpY2UoMCwgMSk7IC8vIGRyb3AgZXhhY3QgbG93ZXIgYm91bmRcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdID49IG1heCkgdGhyZXNob2xkcy5wb3AoKTsgLy8gZHJvcCBleGFjdCB1cHBlciBib3VuZFxuICAgIG4gPSB0aHJlc2hvbGRzLmxlbmd0aCArIDE7XG4gICAgcmFuZ2UgPVxuICAgICAgaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHF1YW50aXplKGludGVycG9sYXRlLCBuKVxuICAgICAgICA6IHJlZ2lzdHJ5LmdldChrZXkpID09PSBjb2xvclxuICAgICAgICA/IG9yZGluYWxSYW5nZShzY2hlbWUsIG4pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHRocmVzaG9sZHMgPSBxdWFudGl6ZShpbnRlcnBvbGF0ZU51bWJlcihtaW4sIG1heCksIG4gKyAxKS5zbGljZSgxLCAtMSk7IC8vIGV4YWN0bHkgbiAtIDEgdGhyZXNob2xkcyB0byBtYXRjaCByYW5nZVxuICAgIGlmIChtaW4gaW5zdGFuY2VvZiBEYXRlKSB0aHJlc2hvbGRzID0gdGhyZXNob2xkcy5tYXAoKHgpID0+IG5ldyBEYXRlKHgpKTsgLy8gcHJlc2VydmUgZGF0ZSB0eXBlc1xuICB9XG4gIGlmIChvcmRlcm9mKGFycmF5aWZ5KGRvbWFpbikpIDwgMCkgdGhyZXNob2xkcy5yZXZlcnNlKCk7IC8vIHByZXNlcnZlIGRlc2NlbmRpbmcgZG9tYWluXG4gIHJldHVybiBjcmVhdGVTY2FsZVRocmVzaG9sZChrZXksIGNoYW5uZWxzLCB7ZG9tYWluOiB0aHJlc2hvbGRzLCByYW5nZSwgcmV2ZXJzZSwgdW5rbm93bn0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVUaHJlc2hvbGQoXG4gIGtleSxcbiAgY2hhbm5lbHMsXG4gIHtcbiAgICBkb21haW4gPSBbMF0sIC8vIGV4cGxpY2l0IHRocmVzaG9sZHMgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgdW5rbm93bixcbiAgICBzY2hlbWUgPSBcInJkeWxidVwiLFxuICAgIGludGVycG9sYXRlLFxuICAgIHJhbmdlID0gaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBxdWFudGl6ZShpbnRlcnBvbGF0ZSwgZG9tYWluLmxlbmd0aCArIDEpXG4gICAgICA6IHJlZ2lzdHJ5LmdldChrZXkpID09PSBjb2xvclxuICAgICAgPyBvcmRpbmFsUmFuZ2Uoc2NoZW1lLCBkb21haW4ubGVuZ3RoICsgMSlcbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIHJldmVyc2VcbiAgfVxuKSB7XG4gIGRvbWFpbiA9IGFycmF5aWZ5KGRvbWFpbik7XG4gIGNvbnN0IHNpZ24gPSBvcmRlcm9mKGRvbWFpbik7IC8vIHByZXNlcnZlIGRlc2NlbmRpbmcgZG9tYWluXG4gIGlmICghaXNOYU4oc2lnbikgJiYgIWlzT3JkZXJlZChkb21haW4sIHNpZ24pKSB0aHJvdyBuZXcgRXJyb3IoYHRoZSAke2tleX0gc2NhbGUgaGFzIGEgbm9uLW1vbm90b25pYyBkb21haW5gKTtcbiAgaWYgKHJldmVyc2UpIHJhbmdlID0gcmV2ZXJzZW9mKHJhbmdlKTsgLy8gZG9tYWluIGFzY2VuZGluZywgc28gcmV2ZXJzZSByYW5nZVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGhyZXNob2xkXCIsXG4gICAgc2NhbGU6IHNjYWxlVGhyZXNob2xkKHNpZ24gPCAwID8gcmV2ZXJzZW9mKGRvbWFpbikgOiBkb21haW4sIHJhbmdlID09PSB1bmRlZmluZWQgPyBbXSA6IHJhbmdlKS51bmtub3duKHVua25vd24pLFxuICAgIGRvbWFpbixcbiAgICByYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc09yZGVyZWQoZG9tYWluLCBzaWduKSB7XG4gIGZvciAobGV0IGkgPSAxLCBuID0gZG9tYWluLmxlbmd0aCwgZCA9IGRvbWFpblswXTsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHMgPSBkZXNjZW5kaW5nKGQsIChkID0gZG9tYWluW2ldKSk7XG4gICAgaWYgKHMgIT09IDAgJiYgcyAhPT0gc2lnbikgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBGb3Igbm9uLW51bWVyaWMgaWRlbnRpdHkgc2NhbGVzIHN1Y2ggYXMgY29sb3IgYW5kIHN5bWJvbCwgd2UgY2Fu4oCZdCB1c2UgRDPigJlzXG4vLyBpZGVudGl0eSBzY2FsZSBiZWNhdXNlIGl0IGNvZXJjZXMgdG8gbnVtYmVyOyBhbmQgd2UgY2Fu4oCZdCBjb21wdXRlIHRoZSBkb21haW5cbi8vIChhbmQgZXF1aXZhbGVudGx5IHJhbmdlKSBzaW5jZSB3ZSBjYW7igJl0IGtub3cgd2hldGhlciB0aGUgdmFsdWVzIGFyZVxuLy8gY29udGludW91cyBvciBkaXNjcmV0ZS5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FsZUlkZW50aXR5KGtleSkge1xuICByZXR1cm4ge3R5cGU6IFwiaWRlbnRpdHlcIiwgc2NhbGU6IGhhc051bWVyaWNSYW5nZShyZWdpc3RyeS5nZXQoa2V5KSkgPyBzY2FsZUlkZW50aXR5KCkgOiAoZCkgPT4gZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmZlckRvbWFpbihjaGFubmVscywgZiA9IGZpbml0ZSkge1xuICByZXR1cm4gY2hhbm5lbHMubGVuZ3RoXG4gICAgPyBbXG4gICAgICAgIG1pbihjaGFubmVscywgKHt2YWx1ZX0pID0+ICh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBtaW4odmFsdWUsIGYpKSksXG4gICAgICAgIG1heChjaGFubmVscywgKHt2YWx1ZX0pID0+ICh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBtYXgodmFsdWUsIGYpKSlcbiAgICAgIF1cbiAgICA6IFswLCAxXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJBdXRvRG9tYWluKGtleSwgY2hhbm5lbHMpIHtcbiAgY29uc3QgdHlwZSA9IHJlZ2lzdHJ5LmdldChrZXkpO1xuICByZXR1cm4gKHR5cGUgPT09IHJhZGl1cyB8fCB0eXBlID09PSBvcGFjaXR5IHx8IHR5cGUgPT09IGxlbmd0aCA/IGluZmVyWmVyb0RvbWFpbiA6IGluZmVyRG9tYWluKShjaGFubmVscyk7XG59XG5cbmZ1bmN0aW9uIGluZmVyWmVyb0RvbWFpbihjaGFubmVscykge1xuICByZXR1cm4gWzAsIGNoYW5uZWxzLmxlbmd0aCA/IG1heChjaGFubmVscywgKHt2YWx1ZX0pID0+ICh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBtYXgodmFsdWUsIGZpbml0ZSkpKSA6IDFdO1xufVxuXG4vLyBXZSBkb27igJl0IHdhbnQgdGhlIHVwcGVyIGJvdW5kIG9mIHRoZSByYWRpYWwgZG9tYWluIHRvIGJlIHplcm8sIGFzIHRoaXMgd291bGRcbi8vIGJlIGRlZ2VuZXJhdGUsIHNvIHdlIGlnbm9yZSBub25wb3NpdGl2ZSB2YWx1ZXMuIFdlIGFsc28gZG9u4oCZdCB3YW50IHRoZVxuLy8gbWF4aW11bSBkZWZhdWx0IHJhZGl1cyB0byBleGNlZWQgMzBweC5cbmZ1bmN0aW9uIGluZmVyUmFkaWFsUmFuZ2UoY2hhbm5lbHMsIGRvbWFpbikge1xuICBjb25zdCBoaW50ID0gY2hhbm5lbHMuZmluZCgoe3JhZGl1c30pID0+IHJhZGl1cyAhPT0gdW5kZWZpbmVkKTtcbiAgaWYgKGhpbnQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFswLCBoaW50LnJhZGl1c107IC8vIGEgbmF0dXJhbCBtYXhpbXVtIHJhZGl1cywgZS5nLiBoZXhiaW5zXG4gIGNvbnN0IGgyNSA9IHF1YW50aWxlKGNoYW5uZWxzLCAwLjUsICh7dmFsdWV9KSA9PiAodmFsdWUgPT09IHVuZGVmaW5lZCA/IE5hTiA6IHF1YW50aWxlKHZhbHVlLCAwLjI1LCBwb3NpdGl2ZSkpKTtcbiAgY29uc3QgcmFuZ2UgPSBkb21haW4ubWFwKChkKSA9PiAzICogTWF0aC5zcXJ0KGQgLyBoMjUpKTtcbiAgY29uc3QgayA9IDMwIC8gbWF4KHJhbmdlKTtcbiAgcmV0dXJuIGsgPCAxID8gcmFuZ2UubWFwKChyKSA9PiByICogaykgOiByYW5nZTtcbn1cblxuLy8gV2Ugd2FudCBhIGxlbmd0aCBzY2FsZeKAmXMgZG9tYWluIHRvIGdvIGZyb20gemVybyB0byBhIHBvc2l0aXZlIHZhbHVlLCBhbmQgdG9cbi8vIHRyZWF0IG5lZ2F0aXZlIGxlbmd0aHMgaWYgYW55IGFzIGludmVydGVkIHZlY3RvcnMgb2YgZXF1aXZhbGVudCBtYWduaXR1ZGUuIFdlXG4vLyBhbHNvIGRvbuKAmXQgd2FudCB0aGUgbWF4aW11bSBkZWZhdWx0IGxlbmd0aCB0byBleGNlZWQgNjBweC5cbmZ1bmN0aW9uIGluZmVyTGVuZ3RoUmFuZ2UoY2hhbm5lbHMsIGRvbWFpbikge1xuICBjb25zdCBoNTAgPSBtZWRpYW4oY2hhbm5lbHMsICh7dmFsdWV9KSA9PiAodmFsdWUgPT09IHVuZGVmaW5lZCA/IE5hTiA6IG1lZGlhbih2YWx1ZSwgTWF0aC5hYnMpKSk7XG4gIGNvbnN0IHJhbmdlID0gZG9tYWluLm1hcCgoZCkgPT4gKDEyICogZCkgLyBoNTApO1xuICBjb25zdCBrID0gNjAgLyBtYXgocmFuZ2UpO1xuICByZXR1cm4gayA8IDEgPyByYW5nZS5tYXAoKHIpID0+IHIgKiBrKSA6IHJhbmdlO1xufVxuXG5mdW5jdGlvbiBpbmZlckxvZ0RvbWFpbihjaGFubmVscykge1xuICBmb3IgKGNvbnN0IHt2YWx1ZX0gb2YgY2hhbm5lbHMpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAodiA+IDApIHJldHVybiBpbmZlckRvbWFpbihjaGFubmVscywgcG9zaXRpdmUpO1xuICAgICAgICBpZiAodiA8IDApIHJldHVybiBpbmZlckRvbWFpbihjaGFubmVscywgbmVnYXRpdmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWzEsIDEwXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJRdWFudGlsZURvbWFpbihjaGFubmVscykge1xuICBjb25zdCBkb21haW4gPSBbXTtcbiAgZm9yIChjb25zdCB7dmFsdWV9IG9mIGNoYW5uZWxzKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkgZG9tYWluLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlUGllY2V3aXNlKGludGVycG9sYXRlKSB7XG4gIHJldHVybiAoaSwgaikgPT4gKHQpID0+IGludGVycG9sYXRlKGkgKyB0ICogKGogLSBpKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js":
/*!***************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/schemes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCategoricalScheme: () => (/* binding */ isCategoricalScheme),\n/* harmony export */   isDivergingScheme: () => (/* binding */ isDivergingScheme),\n/* harmony export */   maybeBooleanRange: () => (/* binding */ maybeBooleanRange),\n/* harmony export */   ordinalRange: () => (/* binding */ ordinalRange),\n/* harmony export */   ordinalScheme: () => (/* binding */ ordinalScheme),\n/* harmony export */   quantitativeScheme: () => (/* binding */ quantitativeScheme)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n\n\nconst categoricalSchemes = new Map([\n  [\"accent\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeAccent],\n  [\"category10\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeCategory10],\n  [\"dark2\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeDark2],\n  [\"observable10\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeObservable10],\n  [\"paired\", d3__WEBPACK_IMPORTED_MODULE_0__.schemePaired],\n  [\"pastel1\", d3__WEBPACK_IMPORTED_MODULE_0__.schemePastel1],\n  [\"pastel2\", d3__WEBPACK_IMPORTED_MODULE_0__.schemePastel2],\n  [\"set1\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeSet1],\n  [\"set2\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeSet2],\n  [\"set3\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeSet3],\n  [\"tableau10\", d3__WEBPACK_IMPORTED_MODULE_0__.schemeTableau10]\n]);\n\nfunction isCategoricalScheme(scheme) {\n  return scheme != null && categoricalSchemes.has(`${scheme}`.toLowerCase());\n}\n\nconst ordinalSchemes = new Map([\n  ...categoricalSchemes,\n\n  // diverging\n  [\"brbg\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeBrBG, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBrBG)],\n  [\"prgn\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemePRGn, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePRGn)],\n  [\"piyg\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemePiYG, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePiYG)],\n  [\"puor\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemePuOr, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuOr)],\n  [\"rdbu\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdBu)],\n  [\"rdgy\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdGy, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdGy)],\n  [\"rdylbu\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdYlBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlBu)],\n  [\"rdylgn\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdYlGn, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlGn)],\n  [\"spectral\", scheme11(d3__WEBPACK_IMPORTED_MODULE_0__.schemeSpectral, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateSpectral)],\n\n  // reversed diverging (for temperature data)\n  [\"burd\", scheme11r(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdBu)],\n  [\"buylrd\", scheme11r(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdYlBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlBu)],\n\n  // sequential (single-hue)\n  [\"blues\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeBlues, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBlues)],\n  [\"greens\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeGreens, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGreens)],\n  [\"greys\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeGreys, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGreys)],\n  [\"oranges\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeOranges, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateOranges)],\n  [\"purples\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemePurples, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePurples)],\n  [\"reds\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeReds, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateReds)],\n\n  // sequential (multi-hue)\n  [\"turbo\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateTurbo)],\n  [\"viridis\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateViridis)],\n  [\"magma\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateMagma)],\n  [\"inferno\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateInferno)],\n  [\"plasma\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePlasma)],\n  [\"cividis\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCividis)],\n  [\"cubehelix\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCubehelixDefault)],\n  [\"warm\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateWarm)],\n  [\"cool\", schemei(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCool)],\n  [\"bugn\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeBuGn, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBuGn)],\n  [\"bupu\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeBuPu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBuPu)],\n  [\"gnbu\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeGnBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGnBu)],\n  [\"orrd\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeOrRd, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateOrRd)],\n  [\"pubu\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemePuBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuBu)],\n  [\"pubugn\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemePuBuGn, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuBuGn)],\n  [\"purd\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemePuRd, d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuRd)],\n  [\"rdpu\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeRdPu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdPu)],\n  [\"ylgn\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeYlGn, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlGn)],\n  [\"ylgnbu\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeYlGnBu, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlGnBu)],\n  [\"ylorbr\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeYlOrBr, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlOrBr)],\n  [\"ylorrd\", scheme9(d3__WEBPACK_IMPORTED_MODULE_0__.schemeYlOrRd, d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlOrRd)],\n\n  // cyclical\n  [\"rainbow\", schemeicyclical(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRainbow)],\n  [\"sinebow\", schemeicyclical(d3__WEBPACK_IMPORTED_MODULE_0__.interpolateSinebow)]\n]);\n\nfunction scheme9(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 1) return [scheme[3][1]]; // favor midpoint\n    if (n === 2) return [scheme[3][1], scheme[3][2]]; // favor darker\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, n) : scheme[n];\n  };\n}\n\nfunction scheme11(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 2) return [scheme[3][0], scheme[3][2]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, n) : scheme[n];\n  };\n}\n\nfunction scheme11r(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 2) return [scheme[3][2], scheme[3][0]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)((t) => interpolate(1 - t), n) : scheme[n].slice().reverse();\n  };\n}\n\nfunction schemei(interpolate) {\n  return ({length: n}) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, Math.max(2, Math.floor(n)));\n}\n\nfunction schemeicyclical(interpolate) {\n  return ({length: n}) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.quantize)(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\n\nfunction ordinalScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!ordinalSchemes.has(s)) throw new Error(`unknown ordinal scheme: ${s}`);\n  return ordinalSchemes.get(s);\n}\n\nfunction ordinalRange(scheme, length) {\n  const s = ordinalScheme(scheme);\n  const r = typeof s === \"function\" ? s({length}) : s;\n  return r.length !== length ? r.slice(0, length) : r;\n}\n\n// If the specified domain contains only booleans (ignoring null and undefined),\n// returns a corresponding range where false is mapped to the low color and true\n// is mapped to the high color of the specified scheme.\nfunction maybeBooleanRange(domain, scheme = \"greys\") {\n  const range = new Set();\n  const [f, t] = ordinalRange(scheme, 2);\n  for (const value of domain) {\n    if (value == null) continue;\n    if (value === true) range.add(t);\n    else if (value === false) range.add(f);\n    else return;\n  }\n  return [...range];\n}\n\nconst quantitativeSchemes = new Map([\n  // diverging\n  [\"brbg\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBrBG],\n  [\"prgn\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePRGn],\n  [\"piyg\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePiYG],\n  [\"puor\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuOr],\n  [\"rdbu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdBu],\n  [\"rdgy\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdGy],\n  [\"rdylbu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlBu],\n  [\"rdylgn\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlGn],\n  [\"spectral\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateSpectral],\n\n  // reversed diverging (for temperature data)\n  [\"burd\", (t) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdBu)(1 - t)],\n  [\"buylrd\", (t) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdYlBu)(1 - t)],\n\n  // sequential (single-hue)\n  [\"blues\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBlues],\n  [\"greens\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGreens],\n  [\"greys\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGreys],\n  [\"purples\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePurples],\n  [\"reds\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateReds],\n  [\"oranges\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateOranges],\n\n  // sequential (multi-hue)\n  [\"turbo\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateTurbo],\n  [\"viridis\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateViridis],\n  [\"magma\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateMagma],\n  [\"inferno\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateInferno],\n  [\"plasma\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePlasma],\n  [\"cividis\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCividis],\n  [\"cubehelix\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCubehelixDefault],\n  [\"warm\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateWarm],\n  [\"cool\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateCool],\n  [\"bugn\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBuGn],\n  [\"bupu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateBuPu],\n  [\"gnbu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateGnBu],\n  [\"orrd\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateOrRd],\n  [\"pubugn\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuBuGn],\n  [\"pubu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuBu],\n  [\"purd\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolatePuRd],\n  [\"rdpu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRdPu],\n  [\"ylgnbu\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlGnBu],\n  [\"ylgn\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlGn],\n  [\"ylorbr\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlOrBr],\n  [\"ylorrd\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateYlOrRd],\n\n  // cyclical\n  [\"rainbow\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateRainbow],\n  [\"sinebow\", d3__WEBPACK_IMPORTED_MODULE_0__.interpolateSinebow]\n]);\n\nfunction quantitativeScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!quantitativeSchemes.has(s)) throw new Error(`unknown quantitative scheme: ${s}`);\n  return quantitativeSchemes.get(s);\n}\n\nconst divergingSchemes = new Set([\n  \"brbg\",\n  \"prgn\",\n  \"piyg\",\n  \"puor\",\n  \"rdbu\",\n  \"rdgy\",\n  \"rdylbu\",\n  \"rdylgn\",\n  \"spectral\",\n  \"burd\",\n  \"buylrd\"\n]);\n\nfunction isDivergingScheme(scheme) {\n  return scheme != null && divergingSchemes.has(`${scheme}`.toLowerCase());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvc2NoZW1lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBOEVZOztBQUVaO0FBQ0EsYUFBYSw0Q0FBWTtBQUN6QixpQkFBaUIsZ0RBQWdCO0FBQ2pDLFlBQVksMkNBQVc7QUFDdkIsbUJBQW1CLGtEQUFrQjtBQUNyQyxhQUFhLDRDQUFZO0FBQ3pCLGNBQWMsNkNBQWE7QUFDM0IsY0FBYyw2Q0FBYTtBQUMzQixXQUFXLDBDQUFVO0FBQ3JCLFdBQVcsMENBQVU7QUFDckIsV0FBVywwQ0FBVTtBQUNyQixnQkFBZ0IsK0NBQWU7QUFDL0I7O0FBRU87QUFDUCxxREFBcUQsT0FBTztBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msb0JBQW9CLDBDQUFVLEVBQUUsK0NBQWU7QUFDL0Msc0JBQXNCLDRDQUFZLEVBQUUsaURBQWlCO0FBQ3JELHNCQUFzQiw0Q0FBWSxFQUFFLGlEQUFpQjtBQUNyRCx3QkFBd0IsOENBQWMsRUFBRSxtREFBbUI7O0FBRTNEO0FBQ0EscUJBQXFCLDBDQUFVLEVBQUUsK0NBQWU7QUFDaEQsdUJBQXVCLDRDQUFZLEVBQUUsaURBQWlCOztBQUV0RDtBQUNBLG9CQUFvQiwyQ0FBVyxFQUFFLGdEQUFnQjtBQUNqRCxxQkFBcUIsNENBQVksRUFBRSxpREFBaUI7QUFDcEQsb0JBQW9CLDJDQUFXLEVBQUUsZ0RBQWdCO0FBQ2pELHNCQUFzQiw2Q0FBYSxFQUFFLGtEQUFrQjtBQUN2RCxzQkFBc0IsNkNBQWEsRUFBRSxrREFBa0I7QUFDdkQsbUJBQW1CLDBDQUFVLEVBQUUsK0NBQWU7O0FBRTlDO0FBQ0Esb0JBQW9CLGdEQUFnQjtBQUNwQyxzQkFBc0Isa0RBQWtCO0FBQ3hDLG9CQUFvQixnREFBZ0I7QUFDcEMsc0JBQXNCLGtEQUFrQjtBQUN4QyxxQkFBcUIsaURBQWlCO0FBQ3RDLHNCQUFzQixrREFBa0I7QUFDeEMsd0JBQXdCLDJEQUEyQjtBQUNuRCxtQkFBbUIsK0NBQWU7QUFDbEMsbUJBQW1CLCtDQUFlO0FBQ2xDLG1CQUFtQiwwQ0FBVSxFQUFFLCtDQUFlO0FBQzlDLG1CQUFtQiwwQ0FBVSxFQUFFLCtDQUFlO0FBQzlDLG1CQUFtQiwwQ0FBVSxFQUFFLCtDQUFlO0FBQzlDLG1CQUFtQiwwQ0FBVSxFQUFFLCtDQUFlO0FBQzlDLG1CQUFtQiwwQ0FBVSxFQUFFLCtDQUFlO0FBQzlDLHFCQUFxQiw0Q0FBWSxFQUFFLGlEQUFpQjtBQUNwRCxtQkFBbUIsMENBQVUsRUFBRSwrQ0FBZTtBQUM5QyxtQkFBbUIsMENBQVUsRUFBRSwrQ0FBZTtBQUM5QyxtQkFBbUIsMENBQVUsRUFBRSwrQ0FBZTtBQUM5QyxxQkFBcUIsNENBQVksRUFBRSxpREFBaUI7QUFDcEQscUJBQXFCLDRDQUFZLEVBQUUsaURBQWlCO0FBQ3BELHFCQUFxQiw0Q0FBWSxFQUFFLGlEQUFpQjs7QUFFcEQ7QUFDQSw4QkFBOEIsa0RBQWtCO0FBQ2hELDhCQUE4QixrREFBa0I7QUFDaEQ7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsd0NBQXdDO0FBQ3hDLHNEQUFzRDtBQUN0RDtBQUNBLG1CQUFtQiw0Q0FBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLHNEQUFzRDtBQUN0RDtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLHNEQUFzRDtBQUN0RDtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVLEtBQUssNENBQVE7QUFDbEM7O0FBRUE7QUFDQSxXQUFXLFVBQVUsS0FBSyw0Q0FBUTtBQUNsQzs7QUFFTztBQUNQLGVBQWUsT0FBTztBQUN0Qix5RUFBeUUsRUFBRTtBQUMzRTtBQUNBOztBQUVPO0FBQ1A7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsK0NBQWU7QUFDMUIsV0FBVywrQ0FBZTtBQUMxQixXQUFXLCtDQUFlO0FBQzFCLFdBQVcsK0NBQWU7QUFDMUIsV0FBVywrQ0FBZTtBQUMxQixXQUFXLCtDQUFlO0FBQzFCLGFBQWEsaURBQWlCO0FBQzlCLGFBQWEsaURBQWlCO0FBQzlCLGVBQWUsbURBQW1COztBQUVsQztBQUNBLGtCQUFrQixtREFBZTtBQUNqQyxvQkFBb0IscURBQWlCOztBQUVyQztBQUNBLFlBQVksZ0RBQWdCO0FBQzVCLGFBQWEsaURBQWlCO0FBQzlCLFlBQVksZ0RBQWdCO0FBQzVCLGNBQWMsa0RBQWtCO0FBQ2hDLFdBQVcsK0NBQWU7QUFDMUIsY0FBYyxrREFBa0I7O0FBRWhDO0FBQ0EsWUFBWSxnREFBZ0I7QUFDNUIsY0FBYyxrREFBa0I7QUFDaEMsWUFBWSxnREFBZ0I7QUFDNUIsY0FBYyxrREFBa0I7QUFDaEMsYUFBYSxpREFBaUI7QUFDOUIsY0FBYyxrREFBa0I7QUFDaEMsZ0JBQWdCLDJEQUEyQjtBQUMzQyxXQUFXLCtDQUFlO0FBQzFCLFdBQVcsK0NBQWU7QUFDMUIsV0FBVywrQ0FBZTtBQUMxQixXQUFXLCtDQUFlO0FBQzFCLFdBQVcsK0NBQWU7QUFDMUIsV0FBVywrQ0FBZTtBQUMxQixhQUFhLGlEQUFpQjtBQUM5QixXQUFXLCtDQUFlO0FBQzFCLFdBQVcsK0NBQWU7QUFDMUIsV0FBVywrQ0FBZTtBQUMxQixhQUFhLGlEQUFpQjtBQUM5QixXQUFXLCtDQUFlO0FBQzFCLGFBQWEsaURBQWlCO0FBQzlCLGFBQWEsaURBQWlCOztBQUU5QjtBQUNBLGNBQWMsa0RBQWtCO0FBQ2hDLGNBQWMsa0RBQWtCO0FBQ2hDOztBQUVPO0FBQ1AsZUFBZSxPQUFPO0FBQ3RCLG1GQUFtRixFQUFFO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxtREFBbUQsT0FBTztBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvc2NhbGVzL3NjaGVtZXMuanM/MGQ5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpbnRlcnBvbGF0ZUJsdWVzLFxuICBpbnRlcnBvbGF0ZUJyQkcsXG4gIGludGVycG9sYXRlQnVHbixcbiAgaW50ZXJwb2xhdGVCdVB1LFxuICBpbnRlcnBvbGF0ZUduQnUsXG4gIGludGVycG9sYXRlR3JlZW5zLFxuICBpbnRlcnBvbGF0ZUdyZXlzLFxuICBpbnRlcnBvbGF0ZU9yYW5nZXMsXG4gIGludGVycG9sYXRlT3JSZCxcbiAgaW50ZXJwb2xhdGVQaVlHLFxuICBpbnRlcnBvbGF0ZVBSR24sXG4gIGludGVycG9sYXRlUHVCdSxcbiAgaW50ZXJwb2xhdGVQdUJ1R24sXG4gIGludGVycG9sYXRlUHVPcixcbiAgaW50ZXJwb2xhdGVQdVJkLFxuICBpbnRlcnBvbGF0ZVB1cnBsZXMsXG4gIGludGVycG9sYXRlUmRCdSxcbiAgaW50ZXJwb2xhdGVSZEd5LFxuICBpbnRlcnBvbGF0ZVJkUHUsXG4gIGludGVycG9sYXRlUmRZbEJ1LFxuICBpbnRlcnBvbGF0ZVJkWWxHbixcbiAgaW50ZXJwb2xhdGVSZWRzLFxuICBpbnRlcnBvbGF0ZVNwZWN0cmFsLFxuICBpbnRlcnBvbGF0ZVlsR24sXG4gIGludGVycG9sYXRlWWxHbkJ1LFxuICBpbnRlcnBvbGF0ZVlsT3JCcixcbiAgaW50ZXJwb2xhdGVZbE9yUmQsXG4gIGludGVycG9sYXRlVHVyYm8sXG4gIGludGVycG9sYXRlVmlyaWRpcyxcbiAgaW50ZXJwb2xhdGVNYWdtYSxcbiAgaW50ZXJwb2xhdGVJbmZlcm5vLFxuICBpbnRlcnBvbGF0ZVBsYXNtYSxcbiAgaW50ZXJwb2xhdGVDaXZpZGlzLFxuICBpbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQsXG4gIGludGVycG9sYXRlV2FybSxcbiAgaW50ZXJwb2xhdGVDb29sLFxuICBpbnRlcnBvbGF0ZVJhaW5ib3csXG4gIGludGVycG9sYXRlU2luZWJvdyxcbiAgcXVhbnRpemUsXG4gIHNjaGVtZUFjY2VudCxcbiAgc2NoZW1lQmx1ZXMsXG4gIHNjaGVtZUJyQkcsXG4gIHNjaGVtZUJ1R24sXG4gIHNjaGVtZUJ1UHUsXG4gIHNjaGVtZUNhdGVnb3J5MTAsXG4gIHNjaGVtZURhcmsyLFxuICBzY2hlbWVHbkJ1LFxuICBzY2hlbWVHcmVlbnMsXG4gIHNjaGVtZUdyZXlzLFxuICBzY2hlbWVPYnNlcnZhYmxlMTAsXG4gIHNjaGVtZU9yYW5nZXMsXG4gIHNjaGVtZU9yUmQsXG4gIHNjaGVtZVBhaXJlZCxcbiAgc2NoZW1lUGFzdGVsMSxcbiAgc2NoZW1lUGFzdGVsMixcbiAgc2NoZW1lUGlZRyxcbiAgc2NoZW1lUFJHbixcbiAgc2NoZW1lUHVCdSxcbiAgc2NoZW1lUHVCdUduLFxuICBzY2hlbWVQdU9yLFxuICBzY2hlbWVQdVJkLFxuICBzY2hlbWVQdXJwbGVzLFxuICBzY2hlbWVSZEJ1LFxuICBzY2hlbWVSZEd5LFxuICBzY2hlbWVSZFB1LFxuICBzY2hlbWVSZFlsQnUsXG4gIHNjaGVtZVJkWWxHbixcbiAgc2NoZW1lUmVkcyxcbiAgc2NoZW1lU2V0MSxcbiAgc2NoZW1lU2V0MixcbiAgc2NoZW1lU2V0MyxcbiAgc2NoZW1lU3BlY3RyYWwsXG4gIHNjaGVtZVRhYmxlYXUxMCxcbiAgc2NoZW1lWWxHbixcbiAgc2NoZW1lWWxHbkJ1LFxuICBzY2hlbWVZbE9yQnIsXG4gIHNjaGVtZVlsT3JSZFxufSBmcm9tIFwiZDNcIjtcblxuY29uc3QgY2F0ZWdvcmljYWxTY2hlbWVzID0gbmV3IE1hcChbXG4gIFtcImFjY2VudFwiLCBzY2hlbWVBY2NlbnRdLFxuICBbXCJjYXRlZ29yeTEwXCIsIHNjaGVtZUNhdGVnb3J5MTBdLFxuICBbXCJkYXJrMlwiLCBzY2hlbWVEYXJrMl0sXG4gIFtcIm9ic2VydmFibGUxMFwiLCBzY2hlbWVPYnNlcnZhYmxlMTBdLFxuICBbXCJwYWlyZWRcIiwgc2NoZW1lUGFpcmVkXSxcbiAgW1wicGFzdGVsMVwiLCBzY2hlbWVQYXN0ZWwxXSxcbiAgW1wicGFzdGVsMlwiLCBzY2hlbWVQYXN0ZWwyXSxcbiAgW1wic2V0MVwiLCBzY2hlbWVTZXQxXSxcbiAgW1wic2V0MlwiLCBzY2hlbWVTZXQyXSxcbiAgW1wic2V0M1wiLCBzY2hlbWVTZXQzXSxcbiAgW1widGFibGVhdTEwXCIsIHNjaGVtZVRhYmxlYXUxMF1cbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDYXRlZ29yaWNhbFNjaGVtZShzY2hlbWUpIHtcbiAgcmV0dXJuIHNjaGVtZSAhPSBudWxsICYmIGNhdGVnb3JpY2FsU2NoZW1lcy5oYXMoYCR7c2NoZW1lfWAudG9Mb3dlckNhc2UoKSk7XG59XG5cbmNvbnN0IG9yZGluYWxTY2hlbWVzID0gbmV3IE1hcChbXG4gIC4uLmNhdGVnb3JpY2FsU2NoZW1lcyxcblxuICAvLyBkaXZlcmdpbmdcbiAgW1wiYnJiZ1wiLCBzY2hlbWUxMShzY2hlbWVCckJHLCBpbnRlcnBvbGF0ZUJyQkcpXSxcbiAgW1wicHJnblwiLCBzY2hlbWUxMShzY2hlbWVQUkduLCBpbnRlcnBvbGF0ZVBSR24pXSxcbiAgW1wicGl5Z1wiLCBzY2hlbWUxMShzY2hlbWVQaVlHLCBpbnRlcnBvbGF0ZVBpWUcpXSxcbiAgW1wicHVvclwiLCBzY2hlbWUxMShzY2hlbWVQdU9yLCBpbnRlcnBvbGF0ZVB1T3IpXSxcbiAgW1wicmRidVwiLCBzY2hlbWUxMShzY2hlbWVSZEJ1LCBpbnRlcnBvbGF0ZVJkQnUpXSxcbiAgW1wicmRneVwiLCBzY2hlbWUxMShzY2hlbWVSZEd5LCBpbnRlcnBvbGF0ZVJkR3kpXSxcbiAgW1wicmR5bGJ1XCIsIHNjaGVtZTExKHNjaGVtZVJkWWxCdSwgaW50ZXJwb2xhdGVSZFlsQnUpXSxcbiAgW1wicmR5bGduXCIsIHNjaGVtZTExKHNjaGVtZVJkWWxHbiwgaW50ZXJwb2xhdGVSZFlsR24pXSxcbiAgW1wic3BlY3RyYWxcIiwgc2NoZW1lMTEoc2NoZW1lU3BlY3RyYWwsIGludGVycG9sYXRlU3BlY3RyYWwpXSxcblxuICAvLyByZXZlcnNlZCBkaXZlcmdpbmcgKGZvciB0ZW1wZXJhdHVyZSBkYXRhKVxuICBbXCJidXJkXCIsIHNjaGVtZTExcihzY2hlbWVSZEJ1LCBpbnRlcnBvbGF0ZVJkQnUpXSxcbiAgW1wiYnV5bHJkXCIsIHNjaGVtZTExcihzY2hlbWVSZFlsQnUsIGludGVycG9sYXRlUmRZbEJ1KV0sXG5cbiAgLy8gc2VxdWVudGlhbCAoc2luZ2xlLWh1ZSlcbiAgW1wiYmx1ZXNcIiwgc2NoZW1lOShzY2hlbWVCbHVlcywgaW50ZXJwb2xhdGVCbHVlcyldLFxuICBbXCJncmVlbnNcIiwgc2NoZW1lOShzY2hlbWVHcmVlbnMsIGludGVycG9sYXRlR3JlZW5zKV0sXG4gIFtcImdyZXlzXCIsIHNjaGVtZTkoc2NoZW1lR3JleXMsIGludGVycG9sYXRlR3JleXMpXSxcbiAgW1wib3Jhbmdlc1wiLCBzY2hlbWU5KHNjaGVtZU9yYW5nZXMsIGludGVycG9sYXRlT3JhbmdlcyldLFxuICBbXCJwdXJwbGVzXCIsIHNjaGVtZTkoc2NoZW1lUHVycGxlcywgaW50ZXJwb2xhdGVQdXJwbGVzKV0sXG4gIFtcInJlZHNcIiwgc2NoZW1lOShzY2hlbWVSZWRzLCBpbnRlcnBvbGF0ZVJlZHMpXSxcblxuICAvLyBzZXF1ZW50aWFsIChtdWx0aS1odWUpXG4gIFtcInR1cmJvXCIsIHNjaGVtZWkoaW50ZXJwb2xhdGVUdXJibyldLFxuICBbXCJ2aXJpZGlzXCIsIHNjaGVtZWkoaW50ZXJwb2xhdGVWaXJpZGlzKV0sXG4gIFtcIm1hZ21hXCIsIHNjaGVtZWkoaW50ZXJwb2xhdGVNYWdtYSldLFxuICBbXCJpbmZlcm5vXCIsIHNjaGVtZWkoaW50ZXJwb2xhdGVJbmZlcm5vKV0sXG4gIFtcInBsYXNtYVwiLCBzY2hlbWVpKGludGVycG9sYXRlUGxhc21hKV0sXG4gIFtcImNpdmlkaXNcIiwgc2NoZW1laShpbnRlcnBvbGF0ZUNpdmlkaXMpXSxcbiAgW1wiY3ViZWhlbGl4XCIsIHNjaGVtZWkoaW50ZXJwb2xhdGVDdWJlaGVsaXhEZWZhdWx0KV0sXG4gIFtcIndhcm1cIiwgc2NoZW1laShpbnRlcnBvbGF0ZVdhcm0pXSxcbiAgW1wiY29vbFwiLCBzY2hlbWVpKGludGVycG9sYXRlQ29vbCldLFxuICBbXCJidWduXCIsIHNjaGVtZTkoc2NoZW1lQnVHbiwgaW50ZXJwb2xhdGVCdUduKV0sXG4gIFtcImJ1cHVcIiwgc2NoZW1lOShzY2hlbWVCdVB1LCBpbnRlcnBvbGF0ZUJ1UHUpXSxcbiAgW1wiZ25idVwiLCBzY2hlbWU5KHNjaGVtZUduQnUsIGludGVycG9sYXRlR25CdSldLFxuICBbXCJvcnJkXCIsIHNjaGVtZTkoc2NoZW1lT3JSZCwgaW50ZXJwb2xhdGVPclJkKV0sXG4gIFtcInB1YnVcIiwgc2NoZW1lOShzY2hlbWVQdUJ1LCBpbnRlcnBvbGF0ZVB1QnUpXSxcbiAgW1wicHVidWduXCIsIHNjaGVtZTkoc2NoZW1lUHVCdUduLCBpbnRlcnBvbGF0ZVB1QnVHbildLFxuICBbXCJwdXJkXCIsIHNjaGVtZTkoc2NoZW1lUHVSZCwgaW50ZXJwb2xhdGVQdVJkKV0sXG4gIFtcInJkcHVcIiwgc2NoZW1lOShzY2hlbWVSZFB1LCBpbnRlcnBvbGF0ZVJkUHUpXSxcbiAgW1wieWxnblwiLCBzY2hlbWU5KHNjaGVtZVlsR24sIGludGVycG9sYXRlWWxHbildLFxuICBbXCJ5bGduYnVcIiwgc2NoZW1lOShzY2hlbWVZbEduQnUsIGludGVycG9sYXRlWWxHbkJ1KV0sXG4gIFtcInlsb3JiclwiLCBzY2hlbWU5KHNjaGVtZVlsT3JCciwgaW50ZXJwb2xhdGVZbE9yQnIpXSxcbiAgW1wieWxvcnJkXCIsIHNjaGVtZTkoc2NoZW1lWWxPclJkLCBpbnRlcnBvbGF0ZVlsT3JSZCldLFxuXG4gIC8vIGN5Y2xpY2FsXG4gIFtcInJhaW5ib3dcIiwgc2NoZW1laWN5Y2xpY2FsKGludGVycG9sYXRlUmFpbmJvdyldLFxuICBbXCJzaW5lYm93XCIsIHNjaGVtZWljeWNsaWNhbChpbnRlcnBvbGF0ZVNpbmVib3cpXVxuXSk7XG5cbmZ1bmN0aW9uIHNjaGVtZTkoc2NoZW1lLCBpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gKHtsZW5ndGg6IG59KSA9PiB7XG4gICAgaWYgKG4gPT09IDEpIHJldHVybiBbc2NoZW1lWzNdWzFdXTsgLy8gZmF2b3IgbWlkcG9pbnRcbiAgICBpZiAobiA9PT0gMikgcmV0dXJuIFtzY2hlbWVbM11bMV0sIHNjaGVtZVszXVsyXV07IC8vIGZhdm9yIGRhcmtlclxuICAgIG4gPSBNYXRoLm1heCgzLCBNYXRoLmZsb29yKG4pKTtcbiAgICByZXR1cm4gbiA+IDkgPyBxdWFudGl6ZShpbnRlcnBvbGF0ZSwgbikgOiBzY2hlbWVbbl07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjaGVtZTExKHNjaGVtZSwgaW50ZXJwb2xhdGUpIHtcbiAgcmV0dXJuICh7bGVuZ3RoOiBufSkgPT4ge1xuICAgIGlmIChuID09PSAyKSByZXR1cm4gW3NjaGVtZVszXVswXSwgc2NoZW1lWzNdWzJdXTsgLy8gZmF2b3IgZGl2ZXJnaW5nIGV4dHJlbWFcbiAgICBuID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcihuKSk7XG4gICAgcmV0dXJuIG4gPiAxMSA/IHF1YW50aXplKGludGVycG9sYXRlLCBuKSA6IHNjaGVtZVtuXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2NoZW1lMTFyKHNjaGVtZSwgaW50ZXJwb2xhdGUpIHtcbiAgcmV0dXJuICh7bGVuZ3RoOiBufSkgPT4ge1xuICAgIGlmIChuID09PSAyKSByZXR1cm4gW3NjaGVtZVszXVsyXSwgc2NoZW1lWzNdWzBdXTsgLy8gZmF2b3IgZGl2ZXJnaW5nIGV4dHJlbWFcbiAgICBuID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcihuKSk7XG4gICAgcmV0dXJuIG4gPiAxMSA/IHF1YW50aXplKCh0KSA9PiBpbnRlcnBvbGF0ZSgxIC0gdCksIG4pIDogc2NoZW1lW25dLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzY2hlbWVpKGludGVycG9sYXRlKSB7XG4gIHJldHVybiAoe2xlbmd0aDogbn0pID0+IHF1YW50aXplKGludGVycG9sYXRlLCBNYXRoLm1heCgyLCBNYXRoLmZsb29yKG4pKSk7XG59XG5cbmZ1bmN0aW9uIHNjaGVtZWljeWNsaWNhbChpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gKHtsZW5ndGg6IG59KSA9PiBxdWFudGl6ZShpbnRlcnBvbGF0ZSwgTWF0aC5mbG9vcihuKSArIDEpLnNsaWNlKDAsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxTY2hlbWUoc2NoZW1lKSB7XG4gIGNvbnN0IHMgPSBgJHtzY2hlbWV9YC50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIW9yZGluYWxTY2hlbWVzLmhhcyhzKSkgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG9yZGluYWwgc2NoZW1lOiAke3N9YCk7XG4gIHJldHVybiBvcmRpbmFsU2NoZW1lcy5nZXQocyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsUmFuZ2Uoc2NoZW1lLCBsZW5ndGgpIHtcbiAgY29uc3QgcyA9IG9yZGluYWxTY2hlbWUoc2NoZW1lKTtcbiAgY29uc3QgciA9IHR5cGVvZiBzID09PSBcImZ1bmN0aW9uXCIgPyBzKHtsZW5ndGh9KSA6IHM7XG4gIHJldHVybiByLmxlbmd0aCAhPT0gbGVuZ3RoID8gci5zbGljZSgwLCBsZW5ndGgpIDogcjtcbn1cblxuLy8gSWYgdGhlIHNwZWNpZmllZCBkb21haW4gY29udGFpbnMgb25seSBib29sZWFucyAoaWdub3JpbmcgbnVsbCBhbmQgdW5kZWZpbmVkKSxcbi8vIHJldHVybnMgYSBjb3JyZXNwb25kaW5nIHJhbmdlIHdoZXJlIGZhbHNlIGlzIG1hcHBlZCB0byB0aGUgbG93IGNvbG9yIGFuZCB0cnVlXG4vLyBpcyBtYXBwZWQgdG8gdGhlIGhpZ2ggY29sb3Igb2YgdGhlIHNwZWNpZmllZCBzY2hlbWUuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVCb29sZWFuUmFuZ2UoZG9tYWluLCBzY2hlbWUgPSBcImdyZXlzXCIpIHtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IFtmLCB0XSA9IG9yZGluYWxSYW5nZShzY2hlbWUsIDIpO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRvbWFpbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHJhbmdlLmFkZCh0KTtcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJhbmdlLmFkZChmKTtcbiAgICBlbHNlIHJldHVybjtcbiAgfVxuICByZXR1cm4gWy4uLnJhbmdlXTtcbn1cblxuY29uc3QgcXVhbnRpdGF0aXZlU2NoZW1lcyA9IG5ldyBNYXAoW1xuICAvLyBkaXZlcmdpbmdcbiAgW1wiYnJiZ1wiLCBpbnRlcnBvbGF0ZUJyQkddLFxuICBbXCJwcmduXCIsIGludGVycG9sYXRlUFJHbl0sXG4gIFtcInBpeWdcIiwgaW50ZXJwb2xhdGVQaVlHXSxcbiAgW1wicHVvclwiLCBpbnRlcnBvbGF0ZVB1T3JdLFxuICBbXCJyZGJ1XCIsIGludGVycG9sYXRlUmRCdV0sXG4gIFtcInJkZ3lcIiwgaW50ZXJwb2xhdGVSZEd5XSxcbiAgW1wicmR5bGJ1XCIsIGludGVycG9sYXRlUmRZbEJ1XSxcbiAgW1wicmR5bGduXCIsIGludGVycG9sYXRlUmRZbEduXSxcbiAgW1wic3BlY3RyYWxcIiwgaW50ZXJwb2xhdGVTcGVjdHJhbF0sXG5cbiAgLy8gcmV2ZXJzZWQgZGl2ZXJnaW5nIChmb3IgdGVtcGVyYXR1cmUgZGF0YSlcbiAgW1wiYnVyZFwiLCAodCkgPT4gaW50ZXJwb2xhdGVSZEJ1KDEgLSB0KV0sXG4gIFtcImJ1eWxyZFwiLCAodCkgPT4gaW50ZXJwb2xhdGVSZFlsQnUoMSAtIHQpXSxcblxuICAvLyBzZXF1ZW50aWFsIChzaW5nbGUtaHVlKVxuICBbXCJibHVlc1wiLCBpbnRlcnBvbGF0ZUJsdWVzXSxcbiAgW1wiZ3JlZW5zXCIsIGludGVycG9sYXRlR3JlZW5zXSxcbiAgW1wiZ3JleXNcIiwgaW50ZXJwb2xhdGVHcmV5c10sXG4gIFtcInB1cnBsZXNcIiwgaW50ZXJwb2xhdGVQdXJwbGVzXSxcbiAgW1wicmVkc1wiLCBpbnRlcnBvbGF0ZVJlZHNdLFxuICBbXCJvcmFuZ2VzXCIsIGludGVycG9sYXRlT3Jhbmdlc10sXG5cbiAgLy8gc2VxdWVudGlhbCAobXVsdGktaHVlKVxuICBbXCJ0dXJib1wiLCBpbnRlcnBvbGF0ZVR1cmJvXSxcbiAgW1widmlyaWRpc1wiLCBpbnRlcnBvbGF0ZVZpcmlkaXNdLFxuICBbXCJtYWdtYVwiLCBpbnRlcnBvbGF0ZU1hZ21hXSxcbiAgW1wiaW5mZXJub1wiLCBpbnRlcnBvbGF0ZUluZmVybm9dLFxuICBbXCJwbGFzbWFcIiwgaW50ZXJwb2xhdGVQbGFzbWFdLFxuICBbXCJjaXZpZGlzXCIsIGludGVycG9sYXRlQ2l2aWRpc10sXG4gIFtcImN1YmVoZWxpeFwiLCBpbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHRdLFxuICBbXCJ3YXJtXCIsIGludGVycG9sYXRlV2FybV0sXG4gIFtcImNvb2xcIiwgaW50ZXJwb2xhdGVDb29sXSxcbiAgW1wiYnVnblwiLCBpbnRlcnBvbGF0ZUJ1R25dLFxuICBbXCJidXB1XCIsIGludGVycG9sYXRlQnVQdV0sXG4gIFtcImduYnVcIiwgaW50ZXJwb2xhdGVHbkJ1XSxcbiAgW1wib3JyZFwiLCBpbnRlcnBvbGF0ZU9yUmRdLFxuICBbXCJwdWJ1Z25cIiwgaW50ZXJwb2xhdGVQdUJ1R25dLFxuICBbXCJwdWJ1XCIsIGludGVycG9sYXRlUHVCdV0sXG4gIFtcInB1cmRcIiwgaW50ZXJwb2xhdGVQdVJkXSxcbiAgW1wicmRwdVwiLCBpbnRlcnBvbGF0ZVJkUHVdLFxuICBbXCJ5bGduYnVcIiwgaW50ZXJwb2xhdGVZbEduQnVdLFxuICBbXCJ5bGduXCIsIGludGVycG9sYXRlWWxHbl0sXG4gIFtcInlsb3JiclwiLCBpbnRlcnBvbGF0ZVlsT3JCcl0sXG4gIFtcInlsb3JyZFwiLCBpbnRlcnBvbGF0ZVlsT3JSZF0sXG5cbiAgLy8gY3ljbGljYWxcbiAgW1wicmFpbmJvd1wiLCBpbnRlcnBvbGF0ZVJhaW5ib3ddLFxuICBbXCJzaW5lYm93XCIsIGludGVycG9sYXRlU2luZWJvd11cbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpdGF0aXZlU2NoZW1lKHNjaGVtZSkge1xuICBjb25zdCBzID0gYCR7c2NoZW1lfWAudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFxdWFudGl0YXRpdmVTY2hlbWVzLmhhcyhzKSkgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHF1YW50aXRhdGl2ZSBzY2hlbWU6ICR7c31gKTtcbiAgcmV0dXJuIHF1YW50aXRhdGl2ZVNjaGVtZXMuZ2V0KHMpO1xufVxuXG5jb25zdCBkaXZlcmdpbmdTY2hlbWVzID0gbmV3IFNldChbXG4gIFwiYnJiZ1wiLFxuICBcInByZ25cIixcbiAgXCJwaXlnXCIsXG4gIFwicHVvclwiLFxuICBcInJkYnVcIixcbiAgXCJyZGd5XCIsXG4gIFwicmR5bGJ1XCIsXG4gIFwicmR5bGduXCIsXG4gIFwic3BlY3RyYWxcIixcbiAgXCJidXJkXCIsXG4gIFwiYnV5bHJkXCJcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXZlcmdpbmdTY2hlbWUoc2NoZW1lKSB7XG4gIHJldHVybiBzY2hlbWUgIT0gbnVsbCAmJiBkaXZlcmdpbmdTY2hlbWVzLmhhcyhgJHtzY2hlbWV9YC50b0xvd2VyQ2FzZSgpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/schemes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/scales/temporal.js":
/*!****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/scales/temporal.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScaleTime: () => (/* binding */ createScaleTime),\n/* harmony export */   createScaleUtc: () => (/* binding */ createScaleUtc)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _quantitative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quantitative.js */ \"(ssr)/./node_modules/@observablehq/plot/src/scales/quantitative.js\");\n\n\n\nfunction createScaleT(key, scale, channels, options) {\n  return (0,_quantitative_js__WEBPACK_IMPORTED_MODULE_1__.createScaleQ)(key, scale, channels, options);\n}\n\nfunction createScaleTime(key, channels, options) {\n  return createScaleT(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleTime)(), channels, options);\n}\n\nfunction createScaleUtc(key, channels, options) {\n  return createScaleT(key, (0,d3__WEBPACK_IMPORTED_MODULE_0__.scaleUtc)(), channels, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zY2FsZXMvdGVtcG9yYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUNROztBQUUvQztBQUNBLFNBQVMsOERBQVk7QUFDckI7O0FBRU87QUFDUCwyQkFBMkIsNkNBQVM7QUFDcEM7O0FBRU87QUFDUCwyQkFBMkIsNENBQVE7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3NjYWxlcy90ZW1wb3JhbC5qcz9kOGY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c2NhbGVUaW1lLCBzY2FsZVV0Y30gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NyZWF0ZVNjYWxlUX0gZnJvbSBcIi4vcXVhbnRpdGF0aXZlLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlVChrZXksIHNjYWxlLCBjaGFubmVscywgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlU2NhbGVRKGtleSwgc2NhbGUsIGNoYW5uZWxzLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlVGltZShrZXksIGNoYW5uZWxzLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVTY2FsZVQoa2V5LCBzY2FsZVRpbWUoKSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVVdGMoa2V5LCBjaGFubmVscywgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlU2NhbGVUKGtleSwgc2NhbGVVdGMoKSwgY2hhbm5lbHMsIG9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/scales/temporal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/stats.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/stats.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   betacf: () => (/* binding */ betacf),\n/* harmony export */   gammaln: () => (/* binding */ gammaln),\n/* harmony export */   ibeta: () => (/* binding */ ibeta),\n/* harmony export */   ibetainv: () => (/* binding */ ibetainv),\n/* harmony export */   qt: () => (/* binding */ qt)\n/* harmony export */ });\n// https://github.com/jstat/jstat\n//\n// Copyright (c) 2013 jStat\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nfunction ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0) return 0;\n  if (p >= 1) return 1;\n  if (a >= 1 && b >= 1) {\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5) x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h)) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w) x = Math.pow(a * w * p, 1 / a);\n    else x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);\n  for (; j < 10; j++) {\n    if (x === 0 || x === 1) return x;\n    err = ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));\n    if (x <= 0) x = 0.5 * (x + t);\n    if (x >= 1) x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0) break;\n  }\n  return x;\n}\n\nfunction ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt =\n    x === 0 || x === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x) + b * Math.log(1 - x));\n  if (x < 0 || x > 1) return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return (bt * betacf(x, a, b)) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - (bt * betacf(1 - x, b, a)) / b;\n}\n\nfunction betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - (qab * x) / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin) d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = (m * (b - m) * x) / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin) d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin) c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = (-(a + m) * (qab + m) * x) / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin) d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin) c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7) break;\n  }\n\n  return h;\n}\n\nfunction gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.5053203294167, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2,\n    -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++) ser += cof[j] / ++y;\n  return Math.log((2.506628274631 * ser) / xx) - tmp;\n}\n\nfunction qt(p, dof) {\n  var x = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n  x = Math.sqrt((dof * (1 - x)) / x);\n  return p > 0.5 ? x : -x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zdGF0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zdGF0cy5qcz9kZDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3RhdC9qc3RhdFxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMyBqU3RhdFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5cbmV4cG9ydCBmdW5jdGlvbiBpYmV0YWludihwLCBhLCBiKSB7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgYTEgPSBhIC0gMTtcbiAgdmFyIGIxID0gYiAtIDE7XG4gIHZhciBqID0gMDtcbiAgdmFyIGxuYSwgbG5iLCBwcCwgdCwgdSwgZXJyLCB4LCBhbCwgaCwgdywgYWZhYztcbiAgaWYgKHAgPD0gMCkgcmV0dXJuIDA7XG4gIGlmIChwID49IDEpIHJldHVybiAxO1xuICBpZiAoYSA+PSAxICYmIGIgPj0gMSkge1xuICAgIHBwID0gcCA8IDAuNSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KSB4ID0gLXg7XG4gICAgYWwgPSAoeCAqIHggLSAzKSAvIDY7XG4gICAgaCA9IDIgLyAoMSAvICgyICogYSAtIDEpICsgMSAvICgyICogYiAtIDEpKTtcbiAgICB3ID0gKHggKiBNYXRoLnNxcnQoYWwgKyBoKSkgLyBoIC0gKDEgLyAoMiAqIGIgLSAxKSAtIDEgLyAoMiAqIGEgLSAxKSkgKiAoYWwgKyA1IC8gNiAtIDIgLyAoMyAqIGgpKTtcbiAgICB4ID0gYSAvIChhICsgYiAqIE1hdGguZXhwKDIgKiB3KSk7XG4gIH0gZWxzZSB7XG4gICAgbG5hID0gTWF0aC5sb2coYSAvIChhICsgYikpO1xuICAgIGxuYiA9IE1hdGgubG9nKGIgLyAoYSArIGIpKTtcbiAgICB0ID0gTWF0aC5leHAoYSAqIGxuYSkgLyBhO1xuICAgIHUgPSBNYXRoLmV4cChiICogbG5iKSAvIGI7XG4gICAgdyA9IHQgKyB1O1xuICAgIGlmIChwIDwgdCAvIHcpIHggPSBNYXRoLnBvdyhhICogdyAqIHAsIDEgLyBhKTtcbiAgICBlbHNlIHggPSAxIC0gTWF0aC5wb3coYiAqIHcgKiAoMSAtIHApLCAxIC8gYik7XG4gIH1cbiAgYWZhYyA9IC1nYW1tYWxuKGEpIC0gZ2FtbWFsbihiKSArIGdhbW1hbG4oYSArIGIpO1xuICBmb3IgKDsgaiA8IDEwOyBqKyspIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKSByZXR1cm4geDtcbiAgICBlcnIgPSBpYmV0YSh4LCBhLCBiKSAtIHA7XG4gICAgdCA9IE1hdGguZXhwKGExICogTWF0aC5sb2coeCkgKyBiMSAqIE1hdGgubG9nKDEgLSB4KSArIGFmYWMpO1xuICAgIHUgPSBlcnIgLyB0O1xuICAgIHggLT0gdCA9IHUgLyAoMSAtIDAuNSAqIE1hdGgubWluKDEsIHUgKiAoYTEgLyB4IC0gYjEgLyAoMSAtIHgpKSkpO1xuICAgIGlmICh4IDw9IDApIHggPSAwLjUgKiAoeCArIHQpO1xuICAgIGlmICh4ID49IDEpIHggPSAwLjUgKiAoeCArIHQgKyAxKTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4ICYmIGogPiAwKSBicmVhaztcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGliZXRhKHgsIGEsIGIpIHtcbiAgLy8gRmFjdG9ycyBpbiBmcm9udCBvZiB0aGUgY29udGludWVkIGZyYWN0aW9uLlxuICB2YXIgYnQgPVxuICAgIHggPT09IDAgfHwgeCA9PT0gMSA/IDAgOiBNYXRoLmV4cChnYW1tYWxuKGEgKyBiKSAtIGdhbW1hbG4oYSkgLSBnYW1tYWxuKGIpICsgYSAqIE1hdGgubG9nKHgpICsgYiAqIE1hdGgubG9nKDEgLSB4KSk7XG4gIGlmICh4IDwgMCB8fCB4ID4gMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeCA8IChhICsgMSkgLyAoYSArIGIgKyAyKSlcbiAgICAvLyBVc2UgY29udGludWVkIGZyYWN0aW9uIGRpcmVjdGx5LlxuICAgIHJldHVybiAoYnQgKiBiZXRhY2YoeCwgYSwgYikpIC8gYTtcbiAgLy8gZWxzZSB1c2UgY29udGludWVkIGZyYWN0aW9uIGFmdGVyIG1ha2luZyB0aGUgc3ltbWV0cnkgdHJhbnNmb3JtYXRpb24uXG4gIHJldHVybiAxIC0gKGJ0ICogYmV0YWNmKDEgLSB4LCBiLCBhKSkgLyBiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmV0YWNmKHgsIGEsIGIpIHtcbiAgdmFyIGZwbWluID0gMWUtMzA7XG4gIHZhciBtID0gMTtcbiAgdmFyIHFhYiA9IGEgKyBiO1xuICB2YXIgcWFwID0gYSArIDE7XG4gIHZhciBxYW0gPSBhIC0gMTtcbiAgdmFyIGMgPSAxO1xuICB2YXIgZCA9IDEgLSAocWFiICogeCkgLyBxYXA7XG4gIHZhciBtMiwgYWEsIGRlbCwgaDtcblxuICAvLyBUaGVzZSBxJ3Mgd2lsbCBiZSB1c2VkIGluIGZhY3RvcnMgdGhhdCBvY2N1ciBpbiB0aGUgY29lZmZpY2llbnRzXG4gIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKSBkID0gZnBtaW47XG4gIGQgPSAxIC8gZDtcbiAgaCA9IGQ7XG5cbiAgZm9yICg7IG0gPD0gMTAwOyBtKyspIHtcbiAgICBtMiA9IDIgKiBtO1xuICAgIGFhID0gKG0gKiAoYiAtIG0pICogeCkgLyAoKHFhbSArIG0yKSAqIChhICsgbTIpKTtcbiAgICAvLyBPbmUgc3RlcCAodGhlIGV2ZW4gb25lKSBvZiB0aGUgcmVjdXJyZW5jZVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKSBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pIGMgPSBmcG1pbjtcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgICBhYSA9ICgtKGEgKyBtKSAqIChxYWIgKyBtKSAqIHgpIC8gKChhICsgbTIpICogKHFhcCArIG0yKSk7XG4gICAgLy8gTmV4dCBzdGVwIG9mIHRoZSByZWN1cnJlbmNlICh0aGUgb2RkIG9uZSlcbiAgICBkID0gMSArIGFhICogZDtcbiAgICBpZiAoTWF0aC5hYnMoZCkgPCBmcG1pbikgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKSBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGRlbCA9IGQgKiBjO1xuICAgIGggKj0gZGVsO1xuICAgIGlmIChNYXRoLmFicyhkZWwgLSAxLjApIDwgM2UtNykgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gaDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hbG4oeCkge1xuICB2YXIgaiA9IDA7XG4gIHZhciBjb2YgPSBbXG4gICAgNzYuMTgwMDkxNzI5NDcxNDYsIC04Ni41MDUzMjAzMjk0MTY3LCAyNC4wMTQwOTgyNDA4MzA5MSwgLTEuMjMxNzM5NTcyNDUwMTU1LCAwLjEyMDg2NTA5NzM4NjYxNzllLTIsXG4gICAgLTAuNTM5NTIzOTM4NDk1M2UtNVxuICBdO1xuICB2YXIgc2VyID0gMS4wMDAwMDAwMDAxOTAwMTU7XG4gIHZhciB4eCwgeSwgdG1wO1xuICB0bXAgPSAoeSA9IHh4ID0geCkgKyA1LjU7XG4gIHRtcCAtPSAoeHggKyAwLjUpICogTWF0aC5sb2codG1wKTtcbiAgZm9yICg7IGogPCA2OyBqKyspIHNlciArPSBjb2Zbal0gLyArK3k7XG4gIHJldHVybiBNYXRoLmxvZygoMi41MDY2MjgyNzQ2MzEgKiBzZXIpIC8geHgpIC0gdG1wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXQocCwgZG9mKSB7XG4gIHZhciB4ID0gaWJldGFpbnYoMiAqIE1hdGgubWluKHAsIDEgLSBwKSwgMC41ICogZG9mLCAwLjUpO1xuICB4ID0gTWF0aC5zcXJ0KChkb2YgKiAoMSAtIHgpKSAvIHgpO1xuICByZXR1cm4gcCA+IDAuNSA/IHggOiAteDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/style.js":
/*!******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/style.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAttr: () => (/* binding */ applyAttr),\n/* harmony export */   applyChannelStyles: () => (/* binding */ applyChannelStyles),\n/* harmony export */   applyDirectStyles: () => (/* binding */ applyDirectStyles),\n/* harmony export */   applyFrameAnchor: () => (/* binding */ applyFrameAnchor),\n/* harmony export */   applyGroupedChannelStyles: () => (/* binding */ applyGroupedChannelStyles),\n/* harmony export */   applyIndirectStyles: () => (/* binding */ applyIndirectStyles),\n/* harmony export */   applyInlineStyles: () => (/* binding */ applyInlineStyles),\n/* harmony export */   applyStyle: () => (/* binding */ applyStyle),\n/* harmony export */   applyText: () => (/* binding */ applyText),\n/* harmony export */   applyTextGroup: () => (/* binding */ applyTextGroup),\n/* harmony export */   applyTitle: () => (/* binding */ applyTitle),\n/* harmony export */   applyTitleGroup: () => (/* binding */ applyTitleGroup),\n/* harmony export */   applyTransform: () => (/* binding */ applyTransform),\n/* harmony export */   getClipId: () => (/* binding */ getClipId),\n/* harmony export */   getPatternId: () => (/* binding */ getPatternId),\n/* harmony export */   groupIndex: () => (/* binding */ groupIndex),\n/* harmony export */   groupZ: () => (/* binding */ groupZ),\n/* harmony export */   impliedNumber: () => (/* binding */ impliedNumber),\n/* harmony export */   impliedString: () => (/* binding */ impliedString),\n/* harmony export */   maybeClassName: () => (/* binding */ maybeClassName),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   styles: () => (/* binding */ styles)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context.js */ \"(ssr)/./node_modules/@observablehq/plot/src/context.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/@observablehq/plot/src/format.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n\n\n\n\n\n\n\n\nconst offset = (typeof window !== \"undefined\" ? window.devicePixelRatio > 1 : typeof it === \"undefined\") ? 0 : 0.5; // prettier-ignore\n\nlet nextClipId = 0;\nlet nextPatternId = 0;\n\nfunction getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\n\nfunction getPatternId() {\n  return `plot-pattern-${++nextPatternId}`;\n}\n\nfunction styles(\n  mark,\n  {\n    title,\n    href,\n    ariaLabel: variaLabel,\n    ariaDescription,\n    ariaHidden,\n    target,\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    opacity,\n    mixBlendMode,\n    imageFilter,\n    paintOrder,\n    pointerEvents,\n    shapeRendering,\n    channels\n  },\n  {\n    ariaLabel: cariaLabel,\n    fill: defaultFill = \"currentColor\",\n    fillOpacity: defaultFillOpacity,\n    stroke: defaultStroke = \"none\",\n    strokeOpacity: defaultStrokeOpacity,\n    strokeWidth: defaultStrokeWidth,\n    strokeLinecap: defaultStrokeLinecap,\n    strokeLinejoin: defaultStrokeLinejoin,\n    strokeMiterlimit: defaultStrokeMiterlimit,\n    paintOrder: defaultPaintOrder\n  }\n) {\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n\n  // Some marks default to fill with no stroke, while others default to stroke\n  // with no fill. For example, bar and area default to fill, while dot and line\n  // default to stroke. For marks that fill by default, the default fill only\n  // applies if the stroke is (constant) none; if you set a stroke, then the\n  // default fill becomes none. Similarly for marks that stroke by stroke, the\n  // default stroke only applies if the fill is (constant) none.\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(defaultFill)) {\n    if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(defaultStroke) && (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(fill) || channels?.fill)) defaultStroke = \"none\";\n  } else {\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(defaultStroke) && (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNoneish)(stroke) || channels?.stroke)) defaultFill = \"none\";\n  }\n\n  const [vfill, cfill] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(opacity);\n\n  // For styles that have no effect if there is no stroke, only apply the\n  // defaults if the stroke is not the constant none. (If stroke is a channel,\n  // then cstroke will be undefined, but there’s still a stroke; hence we don’t\n  // use isNoneish here.)\n  if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNone)(cstroke)) {\n    if (strokeWidth === undefined) strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === undefined) strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === undefined) strokeLinejoin = defaultStrokeLinejoin;\n\n    // The default stroke miterlimit need not be applied if the current stroke\n    // is the constant round; this only has effect on miter joins.\n    if (strokeMiterlimit === undefined && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isRound)(strokeLinejoin)) strokeMiterlimit = defaultStrokeMiterlimit;\n\n    // The paint order only takes effect if there is both a fill and a stroke\n    // (at least if we ignore markers, which no built-in marks currently use).\n    if (!(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isNone)(cfill) && paintOrder === undefined) paintOrder = defaultPaintOrder;\n  }\n\n  const [vstrokeWidth, cstrokeWidth] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNumberChannel)(strokeWidth);\n\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n\n  mark.target = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(target);\n  mark.ariaLabel = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(cariaLabel);\n  mark.ariaDescription = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(ariaDescription);\n  mark.ariaHidden = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.imageFilter = impliedString(imageFilter, \"none\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n\n  return {\n    title: {value: title, optional: true, filter: null},\n    href: {value: href, optional: true, filter: null},\n    ariaLabel: {value: variaLabel, optional: true, filter: null},\n    fill: {value: vfill, scale: \"auto\", optional: true},\n    fillOpacity: {value: vfillOpacity, scale: \"auto\", optional: true},\n    stroke: {value: vstroke, scale: \"auto\", optional: true},\n    strokeOpacity: {value: vstrokeOpacity, scale: \"auto\", optional: true},\n    strokeWidth: {value: vstrokeWidth, optional: true},\n    opacity: {value: vopacity, scale: \"auto\", optional: true}\n  };\n}\n\n// Applies the specified titles via selection.call.\nfunction applyTitle(selection, L) {\n  if (L)\n    selection\n      .filter((i) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_2__.nonempty)(L[i]))\n      .append(\"title\")\n      .call(applyText, L);\n}\n\n// Like applyTitle, but for grouped data (lines, areas).\nfunction applyTitleGroup(selection, L) {\n  if (L)\n    selection\n      .filter(([i]) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_2__.nonempty)(L[i]))\n      .append(\"title\")\n      .call(applyTextGroup, L);\n}\n\nfunction applyText(selection, T) {\n  if (T) selection.text((i) => (0,_format_js__WEBPACK_IMPORTED_MODULE_3__.formatDefault)(T[i]));\n}\n\nfunction applyTextGroup(selection, T) {\n  if (T) selection.text(([i]) => (0,_format_js__WEBPACK_IMPORTED_MODULE_3__.formatDefault)(T[i]));\n}\n\nfunction applyChannelStyles(\n  selection,\n  {target, tip},\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  }\n) {\n  if (AL) applyAttr(selection, \"aria-label\", (i) => AL[i]);\n  if (F) applyAttr(selection, \"fill\", (i) => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", (i) => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", (i) => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", (i) => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", (i) => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", (i) => O[i]);\n  if (H) applyHref(selection, (i) => H[i], target);\n  if (!tip) applyTitle(selection, T);\n}\n\nfunction applyGroupedChannelStyles(\n  selection,\n  {target, tip},\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  }\n) {\n  if (AL) applyAttr(selection, \"aria-label\", ([i]) => AL[i]);\n  if (F) applyAttr(selection, \"fill\", ([i]) => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", ([i]) => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", ([i]) => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", ([i]) => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", ([i]) => O[i]);\n  if (H) applyHref(selection, ([i]) => H[i], target);\n  if (!tip) applyTitleGroup(selection, T);\n}\n\nfunction groupAesthetics(\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  },\n  {tip}\n) {\n  return [AL, tip ? undefined : T, F, FO, S, SO, SW, O, H].filter((c) => c !== undefined);\n}\n\nfunction groupZ(I, Z, z) {\n  const G = (0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(I, (i) => Z[i]);\n  if (z === undefined && G.size > (1 + I.length) >> 1) {\n    (0,_warnings_js__WEBPACK_IMPORTED_MODULE_4__.warn)(\n      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`\n    );\n  }\n  return G.values();\n}\n\nfunction* groupIndex(I, position, mark, channels) {\n  const {z} = mark;\n  const {z: Z} = channels; // group channel\n  const A = groupAesthetics(channels, mark); // aesthetic channels\n  const C = [...position, ...A]; // all channels\n\n  // Group the current index by Z (if any).\n  for (const G of Z ? groupZ(I, Z, z) : [I]) {\n    let Ag; // the A-values (aesthetics) of the current group, if any\n    let Gg; // the current group index (a subset of G, and I), if any\n    out: for (const i of G) {\n      // If any channel has an undefined value for this index, skip it.\n      for (const c of C) {\n        if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__.defined)(c[i])) {\n          if (Gg) Gg.push(-1);\n          continue out;\n        }\n      }\n\n      // Otherwise, if this is a new group, record the aesthetics for this\n      // group. Yield the current group and start a new one.\n      if (Ag === undefined) {\n        if (Gg) yield Gg;\n        (Ag = A.map((c) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyof)(c[i]))), (Gg = [i]);\n        continue;\n      }\n\n      // Otherwise, add the current index to the current group. Then, if any of\n      // the aesthetics don’t match the current group, yield the current group\n      // and start a new group of the current index.\n      Gg.push(i);\n      for (let j = 0; j < A.length; ++j) {\n        const k = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyof)(A[j][i]);\n        if (k !== Ag[j]) {\n          yield Gg;\n          (Ag = A.map((c) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.keyof)(c[i]))), (Gg = [i]);\n          continue out;\n        }\n      }\n    }\n\n    // Yield the current group, if any.\n    if (Gg) yield Gg;\n  }\n}\n\n// Note: may mutate selection.node!\nfunction applyClip(selection, mark, dimensions, context) {\n  let clipUrl;\n  const {clip = context.clip} = mark;\n  if (clip === \"frame\") {\n    // Wrap the G element with another (untransformed) G element, applying the\n    // clip to the parent G element so that the clip path is not affected by\n    // the mark’s transform. To simplify the adoption of this fix, mutate the\n    // passed-in selection.node to return the parent G element.\n    selection = (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.create)(\"svg:g\", context).each(function () {\n      this.appendChild(selection.node());\n      selection.node = () => this; // Note: mutation!\n    });\n    clipUrl = getFrameClip(context, dimensions);\n  } else if (clip) {\n    clipUrl = getGeoClip(clip, context);\n  }\n\n  // Here we’re careful to apply the ARIA attributes to the outer G element when\n  // clipping is applied, and to apply the ARIA attributes before any other\n  // attributes (for readability).\n  applyAttr(selection, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection, \"clip-path\", clipUrl);\n}\n\nfunction memoizeClip(clip) {\n  const cache = new WeakMap();\n  return (context, dimensions) => {\n    let url = cache.get(context);\n    if (!url) {\n      const id = getClipId();\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(context.ownerSVGElement).append(\"clipPath\").attr(\"id\", id).call(clip, context, dimensions);\n      cache.set(context, (url = `url(#${id})`));\n    }\n    return url;\n  };\n}\n\nconst getFrameClip = memoizeClip((clipPath, context, dimensions) => {\n  const {width, height, marginLeft, marginRight, marginTop, marginBottom} = dimensions;\n  clipPath\n    .append(\"rect\")\n    .attr(\"x\", marginLeft)\n    .attr(\"y\", marginTop)\n    .attr(\"width\", width - marginRight - marginLeft)\n    .attr(\"height\", height - marginTop - marginBottom);\n});\n\nconst geoClipCache = new WeakMap();\nconst sphere = {type: \"Sphere\"};\n\nfunction getGeoClip(geo, context) {\n  let cache, url;\n  if (!(cache = geoClipCache.get(context))) geoClipCache.set(context, (cache = new WeakMap()));\n  if (geo.type === \"Sphere\") geo = sphere; // coalesce all spheres\n  if (!(url = cache.get(geo))) {\n    const id = getClipId();\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(context.ownerSVGElement).append(\"clipPath\").attr(\"id\", id).append(\"path\").attr(\"d\", context.path()(geo));\n    cache.set(geo, (url = `url(#${id})`));\n  }\n  return url;\n}\n\n// Note: may mutate selection.node!\nfunction applyIndirectStyles(selection, mark, dimensions, context) {\n  applyClip(selection, mark, dimensions, context);\n  applyAttr(selection, \"class\", mark.className);\n  applyAttr(selection, \"fill\", mark.fill);\n  applyAttr(selection, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection, \"stroke\", mark.stroke);\n  applyAttr(selection, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection, \"filter\", mark.imageFilter);\n  applyAttr(selection, \"paint-order\", mark.paintOrder);\n  const {pointerEvents = context.pointerSticky === false ? \"none\" : undefined} = mark;\n  applyAttr(selection, \"pointer-events\", pointerEvents);\n}\n\nfunction applyDirectStyles(selection, mark) {\n  applyStyle(selection, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection, \"opacity\", mark.opacity);\n}\n\nfunction applyHref(selection, href, target) {\n  selection.each(function (i) {\n    const h = href(i);\n    if (h != null) {\n      const a = this.ownerDocument.createElementNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.svg, \"a\");\n      a.setAttribute(\"fill\", \"inherit\");\n      a.setAttributeNS(d3__WEBPACK_IMPORTED_MODULE_0__.namespaces.xlink, \"href\", h);\n      if (target != null) a.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a, this).appendChild(this);\n    }\n  });\n}\n\nfunction applyAttr(selection, name, value) {\n  if (value != null) selection.attr(name, value);\n}\n\nfunction applyStyle(selection, name, value) {\n  if (value != null) selection.style(name, value);\n}\n\nfunction applyTransform(selection, mark, {x, y}, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x?.bandwidth) tx += x.bandwidth() / 2;\n  if (y?.bandwidth) ty += y.bandwidth() / 2;\n  if (tx || ty) selection.attr(\"transform\", `translate(${tx},${ty})`);\n}\n\nfunction impliedString(value, impliedValue) {\n  if ((value = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.string)(value)) !== impliedValue) return value;\n}\n\nfunction impliedNumber(value, impliedValue) {\n  if ((value = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(value)) !== impliedValue) return value;\n}\n\n// https://www.w3.org/TR/CSS21/grammar.html\nconst validClassName =\n  /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/i;\n\nfunction maybeClassName(name) {\n  // The default should be changed whenever the default styles are changed, so\n  // as to avoid conflict when multiple versions of Plot are on the page.\n  if (name === undefined) return \"plot-d6a7b5\";\n  name = `${name}`;\n  if (!validClassName.test(name)) throw new Error(`invalid class name: ${name}`);\n  return name;\n}\n\nfunction applyInlineStyles(selection, style) {\n  if (typeof style === \"string\") {\n    selection.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection) {\n      Object.assign(element.style, style);\n    }\n  }\n}\n\nfunction applyFrameAnchor({frameAnchor}, {width, height, marginTop, marginRight, marginBottom, marginLeft}) {\n  return [\n    /left$/.test(frameAnchor)\n      ? marginLeft\n      : /right$/.test(frameAnchor)\n      ? width - marginRight\n      : (marginLeft + width - marginRight) / 2,\n    /^top/.test(frameAnchor)\n      ? marginTop\n      : /^bottom/.test(frameAnchor)\n      ? height - marginBottom\n      : (marginTop + height - marginBottom) / 2\n  ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zdHlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ1Q7QUFDVztBQUNMO0FBQ3FEO0FBQzVDO0FBQ2hCOztBQUU1QixvSEFBb0g7O0FBRTNIO0FBQ0E7O0FBRU87QUFDUCxzQkFBc0IsYUFBYTtBQUNuQzs7QUFFTztBQUNQLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLE1BQU0sc0RBQVM7QUFDZixTQUFTLHNEQUFTLHFCQUFxQixzREFBUztBQUNoRCxJQUFJO0FBQ0osUUFBUSxzREFBUyxxQkFBcUIsc0RBQVM7QUFDL0M7O0FBRUEseUJBQXlCLDhEQUFpQjtBQUMxQyx1Q0FBdUMsK0RBQWtCO0FBQ3pELDZCQUE2Qiw4REFBaUI7QUFDOUMsMkNBQTJDLCtEQUFrQjtBQUM3RCwrQkFBK0IsK0RBQWtCOztBQUVqRDtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsT0FBTyxtREFBTTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QiwyQ0FBMkMsb0RBQU87O0FBRWxEO0FBQ0E7QUFDQSxTQUFTLG1EQUFNO0FBQ2Y7O0FBRUEsdUNBQXVDLCtEQUFrQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtREFBTTtBQUN0QixtQkFBbUIsbURBQU07QUFDekIseUJBQXlCLG1EQUFNO0FBQy9CLG9CQUFvQixtREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDJDQUEyQztBQUN2RCxXQUFXLDBDQUEwQztBQUNyRCxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLFdBQVcsNENBQTRDO0FBQ3ZELGtCQUFrQixtREFBbUQ7QUFDckUsYUFBYSw4Q0FBOEM7QUFDM0Qsb0JBQW9CLHFEQUFxRDtBQUN6RSxrQkFBa0Isb0NBQW9DO0FBQ3RELGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0EscUJBQXFCLHFEQUFRO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixxREFBUTtBQUMvQjtBQUNBO0FBQ0E7O0FBRU87QUFDUCwrQkFBK0IseURBQWE7QUFDNUM7O0FBRU87QUFDUCxpQ0FBaUMseURBQWE7QUFDOUM7O0FBRU87QUFDUDtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxHQUFHLFlBQVk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRU87QUFDUCxZQUFZLHlDQUFLO0FBQ2pCO0FBQ0EsSUFBSSxrREFBSTtBQUNSLDRQQUE0UDtBQUM1UDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFNBQVMsR0FBRztBQUNaLFNBQVMsTUFBTSxZQUFZO0FBQzNCLDZDQUE2QztBQUM3QyxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQUs7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLGtCQUFrQixrREFBSztBQUN2QjtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQU07QUFDdEI7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBDQUFNO0FBQ1osd0NBQXdDLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGlFQUFpRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLElBQUksMENBQU07QUFDVixrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0VBQXNFO0FBQy9FO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMENBQVU7QUFDN0Q7QUFDQSx1QkFBdUIsMENBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU8sMENBQTBDLEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsR0FBRyxHQUFHLEdBQUc7QUFDbEU7O0FBRU87QUFDUCxlQUFlLG1EQUFNO0FBQ3JCOztBQUVPO0FBQ1AsZUFBZSxtREFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLElBQUkseUVBQXlFLElBQUk7O0FBRS9HO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLHlFQUF5RSxLQUFLO0FBQzlFO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sMkJBQTJCLFlBQVksR0FBRyxnRUFBZ0U7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3N0eWxlLmpzPzI0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtncm91cCwgbmFtZXNwYWNlcywgc2VsZWN0fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7Y3JlYXRlfSBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQge2RlZmluZWQsIG5vbmVtcHR5fSBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge2Zvcm1hdERlZmF1bHR9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHtpc05vbmUsIGlzTm9uZWlzaCwgaXNSb3VuZCwgbWF5YmVDb2xvckNoYW5uZWwsIG1heWJlTnVtYmVyQ2hhbm5lbH0gZnJvbSBcIi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtrZXlvZiwgbnVtYmVyLCBzdHJpbmd9IGZyb20gXCIuL29wdGlvbnMuanNcIjtcbmltcG9ydCB7d2Fybn0gZnJvbSBcIi4vd2FybmluZ3MuanNcIjtcblxuZXhwb3J0IGNvbnN0IG9mZnNldCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxIDogdHlwZW9mIGl0ID09PSBcInVuZGVmaW5lZFwiKSA/IDAgOiAwLjU7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5sZXQgbmV4dENsaXBJZCA9IDA7XG5sZXQgbmV4dFBhdHRlcm5JZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGlwSWQoKSB7XG4gIHJldHVybiBgcGxvdC1jbGlwLSR7KytuZXh0Q2xpcElkfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuSWQoKSB7XG4gIHJldHVybiBgcGxvdC1wYXR0ZXJuLSR7KytuZXh0UGF0dGVybklkfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZXMoXG4gIG1hcmssXG4gIHtcbiAgICB0aXRsZSxcbiAgICBocmVmLFxuICAgIGFyaWFMYWJlbDogdmFyaWFMYWJlbCxcbiAgICBhcmlhRGVzY3JpcHRpb24sXG4gICAgYXJpYUhpZGRlbixcbiAgICB0YXJnZXQsXG4gICAgZmlsbCxcbiAgICBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eSxcbiAgICBzdHJva2VMaW5lam9pbixcbiAgICBzdHJva2VMaW5lY2FwLFxuICAgIHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZURhc2hvZmZzZXQsXG4gICAgb3BhY2l0eSxcbiAgICBtaXhCbGVuZE1vZGUsXG4gICAgaW1hZ2VGaWx0ZXIsXG4gICAgcGFpbnRPcmRlcixcbiAgICBwb2ludGVyRXZlbnRzLFxuICAgIHNoYXBlUmVuZGVyaW5nLFxuICAgIGNoYW5uZWxzXG4gIH0sXG4gIHtcbiAgICBhcmlhTGFiZWw6IGNhcmlhTGFiZWwsXG4gICAgZmlsbDogZGVmYXVsdEZpbGwgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxPcGFjaXR5OiBkZWZhdWx0RmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBkZWZhdWx0U3Ryb2tlID0gXCJub25lXCIsXG4gICAgc3Ryb2tlT3BhY2l0eTogZGVmYXVsdFN0cm9rZU9wYWNpdHksXG4gICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aCxcbiAgICBzdHJva2VMaW5lY2FwOiBkZWZhdWx0U3Ryb2tlTGluZWNhcCxcbiAgICBzdHJva2VMaW5lam9pbjogZGVmYXVsdFN0cm9rZUxpbmVqb2luLFxuICAgIHN0cm9rZU1pdGVybGltaXQ6IGRlZmF1bHRTdHJva2VNaXRlcmxpbWl0LFxuICAgIHBhaW50T3JkZXI6IGRlZmF1bHRQYWludE9yZGVyXG4gIH1cbikge1xuICAvLyBTb21lIG1hcmtzIGRvbuKAmXQgc3VwcG9ydCBmaWxsIChlLmcuLCB0aWNrIGFuZCBydWxlKS5cbiAgaWYgKGRlZmF1bHRGaWxsID09PSBudWxsKSB7XG4gICAgZmlsbCA9IG51bGw7XG4gICAgZmlsbE9wYWNpdHkgPSBudWxsO1xuICB9XG5cbiAgLy8gU29tZSBtYXJrcyBkb27igJl0IHN1cHBvcnQgc3Ryb2tlIChlLmcuLCBpbWFnZSkuXG4gIGlmIChkZWZhdWx0U3Ryb2tlID09PSBudWxsKSB7XG4gICAgc3Ryb2tlID0gbnVsbDtcbiAgICBzdHJva2VPcGFjaXR5ID0gbnVsbDtcbiAgfVxuXG4gIC8vIFNvbWUgbWFya3MgZGVmYXVsdCB0byBmaWxsIHdpdGggbm8gc3Ryb2tlLCB3aGlsZSBvdGhlcnMgZGVmYXVsdCB0byBzdHJva2VcbiAgLy8gd2l0aCBubyBmaWxsLiBGb3IgZXhhbXBsZSwgYmFyIGFuZCBhcmVhIGRlZmF1bHQgdG8gZmlsbCwgd2hpbGUgZG90IGFuZCBsaW5lXG4gIC8vIGRlZmF1bHQgdG8gc3Ryb2tlLiBGb3IgbWFya3MgdGhhdCBmaWxsIGJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0IGZpbGwgb25seVxuICAvLyBhcHBsaWVzIGlmIHRoZSBzdHJva2UgaXMgKGNvbnN0YW50KSBub25lOyBpZiB5b3Ugc2V0IGEgc3Ryb2tlLCB0aGVuIHRoZVxuICAvLyBkZWZhdWx0IGZpbGwgYmVjb21lcyBub25lLiBTaW1pbGFybHkgZm9yIG1hcmtzIHRoYXQgc3Ryb2tlIGJ5IHN0cm9rZSwgdGhlXG4gIC8vIGRlZmF1bHQgc3Ryb2tlIG9ubHkgYXBwbGllcyBpZiB0aGUgZmlsbCBpcyAoY29uc3RhbnQpIG5vbmUuXG4gIGlmIChpc05vbmVpc2goZGVmYXVsdEZpbGwpKSB7XG4gICAgaWYgKCFpc05vbmVpc2goZGVmYXVsdFN0cm9rZSkgJiYgKCFpc05vbmVpc2goZmlsbCkgfHwgY2hhbm5lbHM/LmZpbGwpKSBkZWZhdWx0U3Ryb2tlID0gXCJub25lXCI7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzTm9uZWlzaChkZWZhdWx0U3Ryb2tlKSAmJiAoIWlzTm9uZWlzaChzdHJva2UpIHx8IGNoYW5uZWxzPy5zdHJva2UpKSBkZWZhdWx0RmlsbCA9IFwibm9uZVwiO1xuICB9XG5cbiAgY29uc3QgW3ZmaWxsLCBjZmlsbF0gPSBtYXliZUNvbG9yQ2hhbm5lbChmaWxsLCBkZWZhdWx0RmlsbCk7XG4gIGNvbnN0IFt2ZmlsbE9wYWNpdHksIGNmaWxsT3BhY2l0eV0gPSBtYXliZU51bWJlckNoYW5uZWwoZmlsbE9wYWNpdHksIGRlZmF1bHRGaWxsT3BhY2l0eSk7XG4gIGNvbnN0IFt2c3Ryb2tlLCBjc3Ryb2tlXSA9IG1heWJlQ29sb3JDaGFubmVsKHN0cm9rZSwgZGVmYXVsdFN0cm9rZSk7XG4gIGNvbnN0IFt2c3Ryb2tlT3BhY2l0eSwgY3N0cm9rZU9wYWNpdHldID0gbWF5YmVOdW1iZXJDaGFubmVsKHN0cm9rZU9wYWNpdHksIGRlZmF1bHRTdHJva2VPcGFjaXR5KTtcbiAgY29uc3QgW3ZvcGFjaXR5LCBjb3BhY2l0eV0gPSBtYXliZU51bWJlckNoYW5uZWwob3BhY2l0eSk7XG5cbiAgLy8gRm9yIHN0eWxlcyB0aGF0IGhhdmUgbm8gZWZmZWN0IGlmIHRoZXJlIGlzIG5vIHN0cm9rZSwgb25seSBhcHBseSB0aGVcbiAgLy8gZGVmYXVsdHMgaWYgdGhlIHN0cm9rZSBpcyBub3QgdGhlIGNvbnN0YW50IG5vbmUuIChJZiBzdHJva2UgaXMgYSBjaGFubmVsLFxuICAvLyB0aGVuIGNzdHJva2Ugd2lsbCBiZSB1bmRlZmluZWQsIGJ1dCB0aGVyZeKAmXMgc3RpbGwgYSBzdHJva2U7IGhlbmNlIHdlIGRvbuKAmXRcbiAgLy8gdXNlIGlzTm9uZWlzaCBoZXJlLilcbiAgaWYgKCFpc05vbmUoY3N0cm9rZSkpIHtcbiAgICBpZiAoc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCkgc3Ryb2tlV2lkdGggPSBkZWZhdWx0U3Ryb2tlV2lkdGg7XG4gICAgaWYgKHN0cm9rZUxpbmVjYXAgPT09IHVuZGVmaW5lZCkgc3Ryb2tlTGluZWNhcCA9IGRlZmF1bHRTdHJva2VMaW5lY2FwO1xuICAgIGlmIChzdHJva2VMaW5lam9pbiA9PT0gdW5kZWZpbmVkKSBzdHJva2VMaW5lam9pbiA9IGRlZmF1bHRTdHJva2VMaW5lam9pbjtcblxuICAgIC8vIFRoZSBkZWZhdWx0IHN0cm9rZSBtaXRlcmxpbWl0IG5lZWQgbm90IGJlIGFwcGxpZWQgaWYgdGhlIGN1cnJlbnQgc3Ryb2tlXG4gICAgLy8gaXMgdGhlIGNvbnN0YW50IHJvdW5kOyB0aGlzIG9ubHkgaGFzIGVmZmVjdCBvbiBtaXRlciBqb2lucy5cbiAgICBpZiAoc3Ryb2tlTWl0ZXJsaW1pdCA9PT0gdW5kZWZpbmVkICYmICFpc1JvdW5kKHN0cm9rZUxpbmVqb2luKSkgc3Ryb2tlTWl0ZXJsaW1pdCA9IGRlZmF1bHRTdHJva2VNaXRlcmxpbWl0O1xuXG4gICAgLy8gVGhlIHBhaW50IG9yZGVyIG9ubHkgdGFrZXMgZWZmZWN0IGlmIHRoZXJlIGlzIGJvdGggYSBmaWxsIGFuZCBhIHN0cm9rZVxuICAgIC8vIChhdCBsZWFzdCBpZiB3ZSBpZ25vcmUgbWFya2Vycywgd2hpY2ggbm8gYnVpbHQtaW4gbWFya3MgY3VycmVudGx5IHVzZSkuXG4gICAgaWYgKCFpc05vbmUoY2ZpbGwpICYmIHBhaW50T3JkZXIgPT09IHVuZGVmaW5lZCkgcGFpbnRPcmRlciA9IGRlZmF1bHRQYWludE9yZGVyO1xuICB9XG5cbiAgY29uc3QgW3ZzdHJva2VXaWR0aCwgY3N0cm9rZVdpZHRoXSA9IG1heWJlTnVtYmVyQ2hhbm5lbChzdHJva2VXaWR0aCk7XG5cbiAgLy8gU29tZSBtYXJrcyBkb27igJl0IHN1cHBvcnQgZmlsbCAoZS5nLiwgdGljayBhbmQgcnVsZSkuXG4gIGlmIChkZWZhdWx0RmlsbCAhPT0gbnVsbCkge1xuICAgIG1hcmsuZmlsbCA9IGltcGxpZWRTdHJpbmcoY2ZpbGwsIFwiY3VycmVudENvbG9yXCIpO1xuICAgIG1hcmsuZmlsbE9wYWNpdHkgPSBpbXBsaWVkTnVtYmVyKGNmaWxsT3BhY2l0eSwgMSk7XG4gIH1cblxuICAvLyBTb21lIG1hcmtzIGRvbuKAmXQgc3VwcG9ydCBzdHJva2UgKGUuZy4sIGltYWdlKS5cbiAgaWYgKGRlZmF1bHRTdHJva2UgIT09IG51bGwpIHtcbiAgICBtYXJrLnN0cm9rZSA9IGltcGxpZWRTdHJpbmcoY3N0cm9rZSwgXCJub25lXCIpO1xuICAgIG1hcmsuc3Ryb2tlV2lkdGggPSBpbXBsaWVkTnVtYmVyKGNzdHJva2VXaWR0aCwgMSk7XG4gICAgbWFyay5zdHJva2VPcGFjaXR5ID0gaW1wbGllZE51bWJlcihjc3Ryb2tlT3BhY2l0eSwgMSk7XG4gICAgbWFyay5zdHJva2VMaW5lam9pbiA9IGltcGxpZWRTdHJpbmcoc3Ryb2tlTGluZWpvaW4sIFwibWl0ZXJcIik7XG4gICAgbWFyay5zdHJva2VMaW5lY2FwID0gaW1wbGllZFN0cmluZyhzdHJva2VMaW5lY2FwLCBcImJ1dHRcIik7XG4gICAgbWFyay5zdHJva2VNaXRlcmxpbWl0ID0gaW1wbGllZE51bWJlcihzdHJva2VNaXRlcmxpbWl0LCA0KTtcbiAgICBtYXJrLnN0cm9rZURhc2hhcnJheSA9IGltcGxpZWRTdHJpbmcoc3Ryb2tlRGFzaGFycmF5LCBcIm5vbmVcIik7XG4gICAgbWFyay5zdHJva2VEYXNob2Zmc2V0ID0gaW1wbGllZFN0cmluZyhzdHJva2VEYXNob2Zmc2V0LCBcIjBcIik7XG4gIH1cblxuICBtYXJrLnRhcmdldCA9IHN0cmluZyh0YXJnZXQpO1xuICBtYXJrLmFyaWFMYWJlbCA9IHN0cmluZyhjYXJpYUxhYmVsKTtcbiAgbWFyay5hcmlhRGVzY3JpcHRpb24gPSBzdHJpbmcoYXJpYURlc2NyaXB0aW9uKTtcbiAgbWFyay5hcmlhSGlkZGVuID0gc3RyaW5nKGFyaWFIaWRkZW4pO1xuICBtYXJrLm9wYWNpdHkgPSBpbXBsaWVkTnVtYmVyKGNvcGFjaXR5LCAxKTtcbiAgbWFyay5taXhCbGVuZE1vZGUgPSBpbXBsaWVkU3RyaW5nKG1peEJsZW5kTW9kZSwgXCJub3JtYWxcIik7XG4gIG1hcmsuaW1hZ2VGaWx0ZXIgPSBpbXBsaWVkU3RyaW5nKGltYWdlRmlsdGVyLCBcIm5vbmVcIik7XG4gIG1hcmsucGFpbnRPcmRlciA9IGltcGxpZWRTdHJpbmcocGFpbnRPcmRlciwgXCJub3JtYWxcIik7XG4gIG1hcmsucG9pbnRlckV2ZW50cyA9IGltcGxpZWRTdHJpbmcocG9pbnRlckV2ZW50cywgXCJhdXRvXCIpO1xuICBtYXJrLnNoYXBlUmVuZGVyaW5nID0gaW1wbGllZFN0cmluZyhzaGFwZVJlbmRlcmluZywgXCJhdXRvXCIpO1xuXG4gIHJldHVybiB7XG4gICAgdGl0bGU6IHt2YWx1ZTogdGl0bGUsIG9wdGlvbmFsOiB0cnVlLCBmaWx0ZXI6IG51bGx9LFxuICAgIGhyZWY6IHt2YWx1ZTogaHJlZiwgb3B0aW9uYWw6IHRydWUsIGZpbHRlcjogbnVsbH0sXG4gICAgYXJpYUxhYmVsOiB7dmFsdWU6IHZhcmlhTGFiZWwsIG9wdGlvbmFsOiB0cnVlLCBmaWx0ZXI6IG51bGx9LFxuICAgIGZpbGw6IHt2YWx1ZTogdmZpbGwsIHNjYWxlOiBcImF1dG9cIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgIGZpbGxPcGFjaXR5OiB7dmFsdWU6IHZmaWxsT3BhY2l0eSwgc2NhbGU6IFwiYXV0b1wiLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgc3Ryb2tlOiB7dmFsdWU6IHZzdHJva2UsIHNjYWxlOiBcImF1dG9cIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgIHN0cm9rZU9wYWNpdHk6IHt2YWx1ZTogdnN0cm9rZU9wYWNpdHksIHNjYWxlOiBcImF1dG9cIiwgb3B0aW9uYWw6IHRydWV9LFxuICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IHZzdHJva2VXaWR0aCwgb3B0aW9uYWw6IHRydWV9LFxuICAgIG9wYWNpdHk6IHt2YWx1ZTogdm9wYWNpdHksIHNjYWxlOiBcImF1dG9cIiwgb3B0aW9uYWw6IHRydWV9XG4gIH07XG59XG5cbi8vIEFwcGxpZXMgdGhlIHNwZWNpZmllZCB0aXRsZXMgdmlhIHNlbGVjdGlvbi5jYWxsLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGl0bGUoc2VsZWN0aW9uLCBMKSB7XG4gIGlmIChMKVxuICAgIHNlbGVjdGlvblxuICAgICAgLmZpbHRlcigoaSkgPT4gbm9uZW1wdHkoTFtpXSkpXG4gICAgICAuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgIC5jYWxsKGFwcGx5VGV4dCwgTCk7XG59XG5cbi8vIExpa2UgYXBwbHlUaXRsZSwgYnV0IGZvciBncm91cGVkIGRhdGEgKGxpbmVzLCBhcmVhcykuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlUaXRsZUdyb3VwKHNlbGVjdGlvbiwgTCkge1xuICBpZiAoTClcbiAgICBzZWxlY3Rpb25cbiAgICAgIC5maWx0ZXIoKFtpXSkgPT4gbm9uZW1wdHkoTFtpXSkpXG4gICAgICAuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgIC5jYWxsKGFwcGx5VGV4dEdyb3VwLCBMKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGV4dChzZWxlY3Rpb24sIFQpIHtcbiAgaWYgKFQpIHNlbGVjdGlvbi50ZXh0KChpKSA9PiBmb3JtYXREZWZhdWx0KFRbaV0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGV4dEdyb3VwKHNlbGVjdGlvbiwgVCkge1xuICBpZiAoVCkgc2VsZWN0aW9uLnRleHQoKFtpXSkgPT4gZm9ybWF0RGVmYXVsdChUW2ldKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNoYW5uZWxTdHlsZXMoXG4gIHNlbGVjdGlvbixcbiAge3RhcmdldCwgdGlwfSxcbiAge1xuICAgIGFyaWFMYWJlbDogQUwsXG4gICAgdGl0bGU6IFQsXG4gICAgZmlsbDogRixcbiAgICBmaWxsT3BhY2l0eTogRk8sXG4gICAgc3Ryb2tlOiBTLFxuICAgIHN0cm9rZU9wYWNpdHk6IFNPLFxuICAgIHN0cm9rZVdpZHRoOiBTVyxcbiAgICBvcGFjaXR5OiBPLFxuICAgIGhyZWY6IEhcbiAgfVxuKSB7XG4gIGlmIChBTCkgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJhcmlhLWxhYmVsXCIsIChpKSA9PiBBTFtpXSk7XG4gIGlmIChGKSBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImZpbGxcIiwgKGkpID0+IEZbaV0pO1xuICBpZiAoRk8pIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZmlsbC1vcGFjaXR5XCIsIChpKSA9PiBGT1tpXSk7XG4gIGlmIChTKSBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInN0cm9rZVwiLCAoaSkgPT4gU1tpXSk7XG4gIGlmIChTTykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2Utb3BhY2l0eVwiLCAoaSkgPT4gU09baV0pO1xuICBpZiAoU1cpIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwic3Ryb2tlLXdpZHRoXCIsIChpKSA9PiBTV1tpXSk7XG4gIGlmIChPKSBhcHBseUF0dHIoc2VsZWN0aW9uLCBcIm9wYWNpdHlcIiwgKGkpID0+IE9baV0pO1xuICBpZiAoSCkgYXBwbHlIcmVmKHNlbGVjdGlvbiwgKGkpID0+IEhbaV0sIHRhcmdldCk7XG4gIGlmICghdGlwKSBhcHBseVRpdGxlKHNlbGVjdGlvbiwgVCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUdyb3VwZWRDaGFubmVsU3R5bGVzKFxuICBzZWxlY3Rpb24sXG4gIHt0YXJnZXQsIHRpcH0sXG4gIHtcbiAgICBhcmlhTGFiZWw6IEFMLFxuICAgIHRpdGxlOiBULFxuICAgIGZpbGw6IEYsXG4gICAgZmlsbE9wYWNpdHk6IEZPLFxuICAgIHN0cm9rZTogUyxcbiAgICBzdHJva2VPcGFjaXR5OiBTTyxcbiAgICBzdHJva2VXaWR0aDogU1csXG4gICAgb3BhY2l0eTogTyxcbiAgICBocmVmOiBIXG4gIH1cbikge1xuICBpZiAoQUwpIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiYXJpYS1sYWJlbFwiLCAoW2ldKSA9PiBBTFtpXSk7XG4gIGlmIChGKSBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImZpbGxcIiwgKFtpXSkgPT4gRltpXSk7XG4gIGlmIChGTykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJmaWxsLW9wYWNpdHlcIiwgKFtpXSkgPT4gRk9baV0pO1xuICBpZiAoUykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2VcIiwgKFtpXSkgPT4gU1tpXSk7XG4gIGlmIChTTykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2Utb3BhY2l0eVwiLCAoW2ldKSA9PiBTT1tpXSk7XG4gIGlmIChTVykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2Utd2lkdGhcIiwgKFtpXSkgPT4gU1dbaV0pO1xuICBpZiAoTykgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJvcGFjaXR5XCIsIChbaV0pID0+IE9baV0pO1xuICBpZiAoSCkgYXBwbHlIcmVmKHNlbGVjdGlvbiwgKFtpXSkgPT4gSFtpXSwgdGFyZ2V0KTtcbiAgaWYgKCF0aXApIGFwcGx5VGl0bGVHcm91cChzZWxlY3Rpb24sIFQpO1xufVxuXG5mdW5jdGlvbiBncm91cEFlc3RoZXRpY3MoXG4gIHtcbiAgICBhcmlhTGFiZWw6IEFMLFxuICAgIHRpdGxlOiBULFxuICAgIGZpbGw6IEYsXG4gICAgZmlsbE9wYWNpdHk6IEZPLFxuICAgIHN0cm9rZTogUyxcbiAgICBzdHJva2VPcGFjaXR5OiBTTyxcbiAgICBzdHJva2VXaWR0aDogU1csXG4gICAgb3BhY2l0eTogTyxcbiAgICBocmVmOiBIXG4gIH0sXG4gIHt0aXB9XG4pIHtcbiAgcmV0dXJuIFtBTCwgdGlwID8gdW5kZWZpbmVkIDogVCwgRiwgRk8sIFMsIFNPLCBTVywgTywgSF0uZmlsdGVyKChjKSA9PiBjICE9PSB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBaKEksIFosIHopIHtcbiAgY29uc3QgRyA9IGdyb3VwKEksIChpKSA9PiBaW2ldKTtcbiAgaWYgKHogPT09IHVuZGVmaW5lZCAmJiBHLnNpemUgPiAoMSArIEkubGVuZ3RoKSA+PiAxKSB7XG4gICAgd2FybihcbiAgICAgIGBXYXJuaW5nOiB0aGUgaW1wbGljaXQgeiBjaGFubmVsIGhhcyBoaWdoIGNhcmRpbmFsaXR5LiBUaGlzIG1heSBvY2N1ciB3aGVuIHRoZSBmaWxsIG9yIHN0cm9rZSBjaGFubmVsIGlzIGFzc29jaWF0ZWQgd2l0aCBxdWFudGl0YXRpdmUgZGF0YSByYXRoZXIgdGhhbiBvcmRpbmFsIG9yIGNhdGVnb3JpY2FsIGRhdGEuIFlvdSBjYW4gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGJ5IHNldHRpbmcgdGhlIHogb3B0aW9uIGV4cGxpY2l0bHk7IGlmIHRoaXMgZGF0YSByZXByZXNlbnRzIGEgc2luZ2xlIHNlcmllcywgc2V0IHogdG8gbnVsbC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gRy52YWx1ZXMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBncm91cEluZGV4KEksIHBvc2l0aW9uLCBtYXJrLCBjaGFubmVscykge1xuICBjb25zdCB7en0gPSBtYXJrO1xuICBjb25zdCB7ejogWn0gPSBjaGFubmVsczsgLy8gZ3JvdXAgY2hhbm5lbFxuICBjb25zdCBBID0gZ3JvdXBBZXN0aGV0aWNzKGNoYW5uZWxzLCBtYXJrKTsgLy8gYWVzdGhldGljIGNoYW5uZWxzXG4gIGNvbnN0IEMgPSBbLi4ucG9zaXRpb24sIC4uLkFdOyAvLyBhbGwgY2hhbm5lbHNcblxuICAvLyBHcm91cCB0aGUgY3VycmVudCBpbmRleCBieSBaIChpZiBhbnkpLlxuICBmb3IgKGNvbnN0IEcgb2YgWiA/IGdyb3VwWihJLCBaLCB6KSA6IFtJXSkge1xuICAgIGxldCBBZzsgLy8gdGhlIEEtdmFsdWVzIChhZXN0aGV0aWNzKSBvZiB0aGUgY3VycmVudCBncm91cCwgaWYgYW55XG4gICAgbGV0IEdnOyAvLyB0aGUgY3VycmVudCBncm91cCBpbmRleCAoYSBzdWJzZXQgb2YgRywgYW5kIEkpLCBpZiBhbnlcbiAgICBvdXQ6IGZvciAoY29uc3QgaSBvZiBHKSB7XG4gICAgICAvLyBJZiBhbnkgY2hhbm5lbCBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGZvciB0aGlzIGluZGV4LCBza2lwIGl0LlxuICAgICAgZm9yIChjb25zdCBjIG9mIEMpIHtcbiAgICAgICAgaWYgKCFkZWZpbmVkKGNbaV0pKSB7XG4gICAgICAgICAgaWYgKEdnKSBHZy5wdXNoKC0xKTtcbiAgICAgICAgICBjb250aW51ZSBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGlzIGlzIGEgbmV3IGdyb3VwLCByZWNvcmQgdGhlIGFlc3RoZXRpY3MgZm9yIHRoaXNcbiAgICAgIC8vIGdyb3VwLiBZaWVsZCB0aGUgY3VycmVudCBncm91cCBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICAgICAgaWYgKEFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEdnKSB5aWVsZCBHZztcbiAgICAgICAgKEFnID0gQS5tYXAoKGMpID0+IGtleW9mKGNbaV0pKSksIChHZyA9IFtpXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFkZCB0aGUgY3VycmVudCBpbmRleCB0byB0aGUgY3VycmVudCBncm91cC4gVGhlbiwgaWYgYW55IG9mXG4gICAgICAvLyB0aGUgYWVzdGhldGljcyBkb27igJl0IG1hdGNoIHRoZSBjdXJyZW50IGdyb3VwLCB5aWVsZCB0aGUgY3VycmVudCBncm91cFxuICAgICAgLy8gYW5kIHN0YXJ0IGEgbmV3IGdyb3VwIG9mIHRoZSBjdXJyZW50IGluZGV4LlxuICAgICAgR2cucHVzaChpKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgQS5sZW5ndGg7ICsraikge1xuICAgICAgICBjb25zdCBrID0ga2V5b2YoQVtqXVtpXSk7XG4gICAgICAgIGlmIChrICE9PSBBZ1tqXSkge1xuICAgICAgICAgIHlpZWxkIEdnO1xuICAgICAgICAgIChBZyA9IEEubWFwKChjKSA9PiBrZXlvZihjW2ldKSkpLCAoR2cgPSBbaV0pO1xuICAgICAgICAgIGNvbnRpbnVlIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFlpZWxkIHRoZSBjdXJyZW50IGdyb3VwLCBpZiBhbnkuXG4gICAgaWYgKEdnKSB5aWVsZCBHZztcbiAgfVxufVxuXG4vLyBOb3RlOiBtYXkgbXV0YXRlIHNlbGVjdGlvbi5ub2RlIVxuZnVuY3Rpb24gYXBwbHlDbGlwKHNlbGVjdGlvbiwgbWFyaywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICBsZXQgY2xpcFVybDtcbiAgY29uc3Qge2NsaXAgPSBjb250ZXh0LmNsaXB9ID0gbWFyaztcbiAgaWYgKGNsaXAgPT09IFwiZnJhbWVcIikge1xuICAgIC8vIFdyYXAgdGhlIEcgZWxlbWVudCB3aXRoIGFub3RoZXIgKHVudHJhbnNmb3JtZWQpIEcgZWxlbWVudCwgYXBwbHlpbmcgdGhlXG4gICAgLy8gY2xpcCB0byB0aGUgcGFyZW50IEcgZWxlbWVudCBzbyB0aGF0IHRoZSBjbGlwIHBhdGggaXMgbm90IGFmZmVjdGVkIGJ5XG4gICAgLy8gdGhlIG1hcmvigJlzIHRyYW5zZm9ybS4gVG8gc2ltcGxpZnkgdGhlIGFkb3B0aW9uIG9mIHRoaXMgZml4LCBtdXRhdGUgdGhlXG4gICAgLy8gcGFzc2VkLWluIHNlbGVjdGlvbi5ub2RlIHRvIHJldHVybiB0aGUgcGFyZW50IEcgZWxlbWVudC5cbiAgICBzZWxlY3Rpb24gPSBjcmVhdGUoXCJzdmc6Z1wiLCBjb250ZXh0KS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc2VsZWN0aW9uLm5vZGUoKSk7XG4gICAgICBzZWxlY3Rpb24ubm9kZSA9ICgpID0+IHRoaXM7IC8vIE5vdGU6IG11dGF0aW9uIVxuICAgIH0pO1xuICAgIGNsaXBVcmwgPSBnZXRGcmFtZUNsaXAoY29udGV4dCwgZGltZW5zaW9ucyk7XG4gIH0gZWxzZSBpZiAoY2xpcCkge1xuICAgIGNsaXBVcmwgPSBnZXRHZW9DbGlwKGNsaXAsIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gSGVyZSB3ZeKAmXJlIGNhcmVmdWwgdG8gYXBwbHkgdGhlIEFSSUEgYXR0cmlidXRlcyB0byB0aGUgb3V0ZXIgRyBlbGVtZW50IHdoZW5cbiAgLy8gY2xpcHBpbmcgaXMgYXBwbGllZCwgYW5kIHRvIGFwcGx5IHRoZSBBUklBIGF0dHJpYnV0ZXMgYmVmb3JlIGFueSBvdGhlclxuICAvLyBhdHRyaWJ1dGVzIChmb3IgcmVhZGFiaWxpdHkpLlxuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImFyaWEtbGFiZWxcIiwgbWFyay5hcmlhTGFiZWwpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImFyaWEtZGVzY3JpcHRpb25cIiwgbWFyay5hcmlhRGVzY3JpcHRpb24pO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImFyaWEtaGlkZGVuXCIsIG1hcmsuYXJpYUhpZGRlbik7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiY2xpcC1wYXRoXCIsIGNsaXBVcmwpO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplQ2xpcChjbGlwKSB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIChjb250ZXh0LCBkaW1lbnNpb25zKSA9PiB7XG4gICAgbGV0IHVybCA9IGNhY2hlLmdldChjb250ZXh0KTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgY29uc3QgaWQgPSBnZXRDbGlwSWQoKTtcbiAgICAgIHNlbGVjdChjb250ZXh0Lm93bmVyU1ZHRWxlbWVudCkuYXBwZW5kKFwiY2xpcFBhdGhcIikuYXR0cihcImlkXCIsIGlkKS5jYWxsKGNsaXAsIGNvbnRleHQsIGRpbWVuc2lvbnMpO1xuICAgICAgY2FjaGUuc2V0KGNvbnRleHQsICh1cmwgPSBgdXJsKCMke2lkfSlgKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH07XG59XG5cbmNvbnN0IGdldEZyYW1lQ2xpcCA9IG1lbW9pemVDbGlwKChjbGlwUGF0aCwgY29udGV4dCwgZGltZW5zaW9ucykgPT4ge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgbWFyZ2luTGVmdCwgbWFyZ2luUmlnaHQsIG1hcmdpblRvcCwgbWFyZ2luQm90dG9tfSA9IGRpbWVuc2lvbnM7XG4gIGNsaXBQYXRoXG4gICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAuYXR0cihcInhcIiwgbWFyZ2luTGVmdClcbiAgICAuYXR0cihcInlcIiwgbWFyZ2luVG9wKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggLSBtYXJnaW5SaWdodCAtIG1hcmdpbkxlZnQpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tKTtcbn0pO1xuXG5jb25zdCBnZW9DbGlwQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc3BoZXJlID0ge3R5cGU6IFwiU3BoZXJlXCJ9O1xuXG5mdW5jdGlvbiBnZXRHZW9DbGlwKGdlbywgY29udGV4dCkge1xuICBsZXQgY2FjaGUsIHVybDtcbiAgaWYgKCEoY2FjaGUgPSBnZW9DbGlwQ2FjaGUuZ2V0KGNvbnRleHQpKSkgZ2VvQ2xpcENhY2hlLnNldChjb250ZXh0LCAoY2FjaGUgPSBuZXcgV2Vha01hcCgpKSk7XG4gIGlmIChnZW8udHlwZSA9PT0gXCJTcGhlcmVcIikgZ2VvID0gc3BoZXJlOyAvLyBjb2FsZXNjZSBhbGwgc3BoZXJlc1xuICBpZiAoISh1cmwgPSBjYWNoZS5nZXQoZ2VvKSkpIHtcbiAgICBjb25zdCBpZCA9IGdldENsaXBJZCgpO1xuICAgIHNlbGVjdChjb250ZXh0Lm93bmVyU1ZHRWxlbWVudCkuYXBwZW5kKFwiY2xpcFBhdGhcIikuYXR0cihcImlkXCIsIGlkKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIGNvbnRleHQucGF0aCgpKGdlbykpO1xuICAgIGNhY2hlLnNldChnZW8sICh1cmwgPSBgdXJsKCMke2lkfSlgKSk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuLy8gTm90ZTogbWF5IG11dGF0ZSBzZWxlY3Rpb24ubm9kZSFcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUluZGlyZWN0U3R5bGVzKHNlbGVjdGlvbiwgbWFyaywgZGltZW5zaW9ucywgY29udGV4dCkge1xuICBhcHBseUNsaXAoc2VsZWN0aW9uLCBtYXJrLCBkaW1lbnNpb25zLCBjb250ZXh0KTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJjbGFzc1wiLCBtYXJrLmNsYXNzTmFtZSk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZmlsbFwiLCBtYXJrLmZpbGwpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcImZpbGwtb3BhY2l0eVwiLCBtYXJrLmZpbGxPcGFjaXR5KTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2VcIiwgbWFyay5zdHJva2UpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInN0cm9rZS13aWR0aFwiLCBtYXJrLnN0cm9rZVdpZHRoKTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2Utb3BhY2l0eVwiLCBtYXJrLnN0cm9rZU9wYWNpdHkpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInN0cm9rZS1saW5lam9pblwiLCBtYXJrLnN0cm9rZUxpbmVqb2luKTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzdHJva2UtbGluZWNhcFwiLCBtYXJrLnN0cm9rZUxpbmVjYXApO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIG1hcmsuc3Ryb2tlTWl0ZXJsaW1pdCk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBtYXJrLnN0cm9rZURhc2hhcnJheSk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgbWFyay5zdHJva2VEYXNob2Zmc2V0KTtcbiAgYXBwbHlBdHRyKHNlbGVjdGlvbiwgXCJzaGFwZS1yZW5kZXJpbmdcIiwgbWFyay5zaGFwZVJlbmRlcmluZyk7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwiZmlsdGVyXCIsIG1hcmsuaW1hZ2VGaWx0ZXIpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcInBhaW50LW9yZGVyXCIsIG1hcmsucGFpbnRPcmRlcik7XG4gIGNvbnN0IHtwb2ludGVyRXZlbnRzID0gY29udGV4dC5wb2ludGVyU3RpY2t5ID09PSBmYWxzZSA/IFwibm9uZVwiIDogdW5kZWZpbmVkfSA9IG1hcms7XG4gIGFwcGx5QXR0cihzZWxlY3Rpb24sIFwicG9pbnRlci1ldmVudHNcIiwgcG9pbnRlckV2ZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURpcmVjdFN0eWxlcyhzZWxlY3Rpb24sIG1hcmspIHtcbiAgYXBwbHlTdHlsZShzZWxlY3Rpb24sIFwibWl4LWJsZW5kLW1vZGVcIiwgbWFyay5taXhCbGVuZE1vZGUpO1xuICBhcHBseUF0dHIoc2VsZWN0aW9uLCBcIm9wYWNpdHlcIiwgbWFyay5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlIcmVmKHNlbGVjdGlvbiwgaHJlZiwgdGFyZ2V0KSB7XG4gIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgY29uc3QgaCA9IGhyZWYoaSk7XG4gICAgaWYgKGggIT0gbnVsbCkge1xuICAgICAgY29uc3QgYSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlcy5zdmcsIFwiYVwiKTtcbiAgICAgIGEuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcImluaGVyaXRcIik7XG4gICAgICBhLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZXMueGxpbmssIFwiaHJlZlwiLCBoKTtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkgYS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgdGhpcykuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QXR0cihzZWxlY3Rpb24sIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSBzZWxlY3Rpb24uYXR0cihuYW1lLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKHNlbGVjdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHNlbGVjdGlvbi5zdHlsZShuYW1lLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShzZWxlY3Rpb24sIG1hcmssIHt4LCB5fSwgdHggPSBvZmZzZXQsIHR5ID0gb2Zmc2V0KSB7XG4gIHR4ICs9IG1hcmsuZHg7XG4gIHR5ICs9IG1hcmsuZHk7XG4gIGlmICh4Py5iYW5kd2lkdGgpIHR4ICs9IHguYmFuZHdpZHRoKCkgLyAyO1xuICBpZiAoeT8uYmFuZHdpZHRoKSB0eSArPSB5LmJhbmR3aWR0aCgpIC8gMjtcbiAgaWYgKHR4IHx8IHR5KSBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7dHh9LCR7dHl9KWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW1wbGllZFN0cmluZyh2YWx1ZSwgaW1wbGllZFZhbHVlKSB7XG4gIGlmICgodmFsdWUgPSBzdHJpbmcodmFsdWUpKSAhPT0gaW1wbGllZFZhbHVlKSByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbXBsaWVkTnVtYmVyKHZhbHVlLCBpbXBsaWVkVmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSA9IG51bWJlcih2YWx1ZSkpICE9PSBpbXBsaWVkVmFsdWUpIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUzIxL2dyYW1tYXIuaHRtbFxuY29uc3QgdmFsaWRDbGFzc05hbWUgPVxuICAvXi0/KFtfYS16XXxbXFwyNDAtXFwzNzddfFxcXFxbMC05YS1mXXsxLDZ9KFxcclxcbnxbIFxcdFxcclxcblxcZl0pP3xcXFxcW15cXHJcXG5cXGYwLTlhLWZdKShbX2EtejAtOS1dfFtcXDI0MC1cXDM3N118XFxcXFswLTlhLWZdezEsNn0oXFxyXFxufFsgXFx0XFxyXFxuXFxmXSk/fFxcXFxbXlxcclxcblxcZjAtOWEtZl0pKiQvaTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQ2xhc3NOYW1lKG5hbWUpIHtcbiAgLy8gVGhlIGRlZmF1bHQgc2hvdWxkIGJlIGNoYW5nZWQgd2hlbmV2ZXIgdGhlIGRlZmF1bHQgc3R5bGVzIGFyZSBjaGFuZ2VkLCBzb1xuICAvLyBhcyB0byBhdm9pZCBjb25mbGljdCB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mIFBsb3QgYXJlIG9uIHRoZSBwYWdlLlxuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJwbG90LWQ2YTdiNVwiO1xuICBuYW1lID0gYCR7bmFtZX1gO1xuICBpZiAoIXZhbGlkQ2xhc3NOYW1lLnRlc3QobmFtZSkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjbGFzcyBuYW1lOiAke25hbWV9YCk7XG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlJbmxpbmVTdHlsZXMoc2VsZWN0aW9uLCBzdHlsZSkge1xuICBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwic3R5bGVcIiwgc3R5bGUpO1xuICB9IGVsc2UgaWYgKHN0eWxlICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygc2VsZWN0aW9uKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RnJhbWVBbmNob3Ioe2ZyYW1lQW5jaG9yfSwge3dpZHRoLCBoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdH0pIHtcbiAgcmV0dXJuIFtcbiAgICAvbGVmdCQvLnRlc3QoZnJhbWVBbmNob3IpXG4gICAgICA/IG1hcmdpbkxlZnRcbiAgICAgIDogL3JpZ2h0JC8udGVzdChmcmFtZUFuY2hvcilcbiAgICAgID8gd2lkdGggLSBtYXJnaW5SaWdodFxuICAgICAgOiAobWFyZ2luTGVmdCArIHdpZHRoIC0gbWFyZ2luUmlnaHQpIC8gMixcbiAgICAvXnRvcC8udGVzdChmcmFtZUFuY2hvcilcbiAgICAgID8gbWFyZ2luVG9wXG4gICAgICA6IC9eYm90dG9tLy50ZXN0KGZyYW1lQW5jaG9yKVxuICAgICAgPyBoZWlnaHQgLSBtYXJnaW5Cb3R0b21cbiAgICAgIDogKG1hcmdpblRvcCArIGhlaWdodCAtIG1hcmdpbkJvdHRvbSkgLyAyXG4gIF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/symbol.js":
/*!*******************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/symbol.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSymbol: () => (/* binding */ isSymbol),\n/* harmony export */   maybeSymbol: () => (/* binding */ maybeSymbol),\n/* harmony export */   maybeSymbolChannel: () => (/* binding */ maybeSymbolChannel),\n/* harmony export */   sqrt3: () => (/* binding */ sqrt3),\n/* harmony export */   sqrt4_3: () => (/* binding */ sqrt4_3)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n\n\n\nconst sqrt3 = Math.sqrt(3);\nconst sqrt4_3 = 2 / sqrt3;\n\nconst symbolHexagon = {\n  draw(context, size) {\n    const rx = Math.sqrt(size / Math.PI),\n      ry = rx * sqrt4_3,\n      hy = ry / 2;\n    context.moveTo(0, ry);\n    context.lineTo(rx, hy);\n    context.lineTo(rx, -hy);\n    context.lineTo(0, -ry);\n    context.lineTo(-rx, -hy);\n    context.lineTo(-rx, hy);\n    context.closePath();\n  }\n};\n\nconst symbols = new Map([\n  [\"asterisk\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolAsterisk],\n  [\"circle\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolCircle],\n  [\"cross\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolCross],\n  [\"diamond\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolDiamond],\n  [\"diamond2\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolDiamond2],\n  [\"hexagon\", symbolHexagon],\n  [\"plus\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolPlus],\n  [\"square\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolSquare],\n  [\"square2\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolSquare2],\n  [\"star\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolStar],\n  [\"times\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolTimes],\n  [\"triangle\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolTriangle],\n  [\"triangle2\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolTriangle2],\n  [\"wye\", d3__WEBPACK_IMPORTED_MODULE_0__.symbolWye]\n]);\n\nfunction isSymbolObject(value) {\n  return value && typeof value.draw === \"function\";\n}\n\nfunction isSymbol(value) {\n  if (isSymbolObject(value)) return true;\n  if (typeof value !== \"string\") return false;\n  return symbols.has(value.toLowerCase());\n}\n\nfunction maybeSymbol(symbol) {\n  if (symbol == null || isSymbolObject(symbol)) return symbol;\n  const value = symbols.get(`${symbol}`.toLowerCase());\n  if (value) return value;\n  throw new Error(`invalid symbol: ${symbol}`);\n}\n\nfunction maybeSymbolChannel(symbol) {\n  if (symbol == null || isSymbolObject(symbol)) return [undefined, symbol];\n  if (typeof symbol === \"string\") {\n    const value = symbols.get(`${symbol}`.toLowerCase());\n    if (value) return [undefined, value];\n  }\n  return [symbol, undefined];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zeW1ib2wuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJHO0FBQ007O0FBRTFHO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsOENBQWM7QUFDN0IsYUFBYSw0Q0FBWTtBQUN6QixZQUFZLDJDQUFXO0FBQ3ZCLGNBQWMsNkNBQWE7QUFDM0IsZUFBZSw4Q0FBYztBQUM3QjtBQUNBLFdBQVcsMENBQVU7QUFDckIsYUFBYSw0Q0FBWTtBQUN6QixjQUFjLDZDQUFhO0FBQzNCLFdBQVcsMENBQVU7QUFDckIsWUFBWSwyQ0FBVztBQUN2QixlQUFlLDhDQUFjO0FBQzdCLGdCQUFnQiwrQ0FBZTtBQUMvQixVQUFVLHlDQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLHFDQUFxQyxPQUFPO0FBQzVDOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy9zeW1ib2wuanM/MDJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3N5bWJvbEFzdGVyaXNrLCBzeW1ib2xEaWFtb25kMiwgc3ltYm9sUGx1cywgc3ltYm9sU3F1YXJlMiwgc3ltYm9sVHJpYW5nbGUyLCBzeW1ib2xUaW1lc30gZnJvbSBcImQzXCI7XG5pbXBvcnQge3N5bWJvbENpcmNsZSwgc3ltYm9sQ3Jvc3MsIHN5bWJvbERpYW1vbmQsIHN5bWJvbFNxdWFyZSwgc3ltYm9sU3Rhciwgc3ltYm9sVHJpYW5nbGUsIHN5bWJvbFd5ZX0gZnJvbSBcImQzXCI7XG5cbmV4cG9ydCBjb25zdCBzcXJ0MyA9IE1hdGguc3FydCgzKTtcbmV4cG9ydCBjb25zdCBzcXJ0NF8zID0gMiAvIHNxcnQzO1xuXG5jb25zdCBzeW1ib2xIZXhhZ29uID0ge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByeCA9IE1hdGguc3FydChzaXplIC8gTWF0aC5QSSksXG4gICAgICByeSA9IHJ4ICogc3FydDRfMyxcbiAgICAgIGh5ID0gcnkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHJ5KTtcbiAgICBjb250ZXh0LmxpbmVUbyhyeCwgaHkpO1xuICAgIGNvbnRleHQubGluZVRvKHJ4LCAtaHkpO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1yeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXJ4LCAtaHkpO1xuICAgIGNvbnRleHQubGluZVRvKC1yeCwgaHkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgTWFwKFtcbiAgW1wiYXN0ZXJpc2tcIiwgc3ltYm9sQXN0ZXJpc2tdLFxuICBbXCJjaXJjbGVcIiwgc3ltYm9sQ2lyY2xlXSxcbiAgW1wiY3Jvc3NcIiwgc3ltYm9sQ3Jvc3NdLFxuICBbXCJkaWFtb25kXCIsIHN5bWJvbERpYW1vbmRdLFxuICBbXCJkaWFtb25kMlwiLCBzeW1ib2xEaWFtb25kMl0sXG4gIFtcImhleGFnb25cIiwgc3ltYm9sSGV4YWdvbl0sXG4gIFtcInBsdXNcIiwgc3ltYm9sUGx1c10sXG4gIFtcInNxdWFyZVwiLCBzeW1ib2xTcXVhcmVdLFxuICBbXCJzcXVhcmUyXCIsIHN5bWJvbFNxdWFyZTJdLFxuICBbXCJzdGFyXCIsIHN5bWJvbFN0YXJdLFxuICBbXCJ0aW1lc1wiLCBzeW1ib2xUaW1lc10sXG4gIFtcInRyaWFuZ2xlXCIsIHN5bWJvbFRyaWFuZ2xlXSxcbiAgW1widHJpYW5nbGUyXCIsIHN5bWJvbFRyaWFuZ2xlMl0sXG4gIFtcInd5ZVwiLCBzeW1ib2xXeWVdXG5dKTtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5kcmF3ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICBpZiAoaXNTeW1ib2xPYmplY3QodmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc3ltYm9scy5oYXModmFsdWUudG9Mb3dlckNhc2UoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVN5bWJvbChzeW1ib2wpIHtcbiAgaWYgKHN5bWJvbCA9PSBudWxsIHx8IGlzU3ltYm9sT2JqZWN0KHN5bWJvbCkpIHJldHVybiBzeW1ib2w7XG4gIGNvbnN0IHZhbHVlID0gc3ltYm9scy5nZXQoYCR7c3ltYm9sfWAudG9Mb3dlckNhc2UoKSk7XG4gIGlmICh2YWx1ZSkgcmV0dXJuIHZhbHVlO1xuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc3ltYm9sOiAke3N5bWJvbH1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlU3ltYm9sQ2hhbm5lbChzeW1ib2wpIHtcbiAgaWYgKHN5bWJvbCA9PSBudWxsIHx8IGlzU3ltYm9sT2JqZWN0KHN5bWJvbCkpIHJldHVybiBbdW5kZWZpbmVkLCBzeW1ib2xdO1xuICBpZiAodHlwZW9mIHN5bWJvbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHZhbHVlID0gc3ltYm9scy5nZXQoYCR7c3ltYm9sfWAudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKHZhbHVlKSByZXR1cm4gW3VuZGVmaW5lZCwgdmFsdWVdO1xuICB9XG4gIHJldHVybiBbc3ltYm9sLCB1bmRlZmluZWRdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/symbol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/template.js":
/*!*********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/template.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   template: () => (/* binding */ template)\n/* harmony export */ });\nfunction template(strings, ...parts) {\n  let n = parts.length;\n\n  // If any of the interpolated parameters are strings rather than functions,\n  // bake them into the template to optimize performance during render.\n  for (let j = 0, copy = true; j < n; ++j) {\n    if (typeof parts[j] !== \"function\") {\n      if (copy) {\n        strings = strings.slice(); // copy before mutate\n        copy = false;\n      }\n      strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);\n      parts.splice(j, 1);\n      --j, --n;\n    }\n  }\n\n  return (i) => {\n    let s = strings[0];\n    for (let j = 0; j < n; ++j) {\n      s += parts[j](i) + strings[j + 1];\n    }\n    return s;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90ZW1wbGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdGVtcGxhdGUuanM/MzI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5ncywgLi4ucGFydHMpIHtcbiAgbGV0IG4gPSBwYXJ0cy5sZW5ndGg7XG5cbiAgLy8gSWYgYW55IG9mIHRoZSBpbnRlcnBvbGF0ZWQgcGFyYW1ldGVycyBhcmUgc3RyaW5ncyByYXRoZXIgdGhhbiBmdW5jdGlvbnMsXG4gIC8vIGJha2UgdGhlbSBpbnRvIHRoZSB0ZW1wbGF0ZSB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBkdXJpbmcgcmVuZGVyLlxuICBmb3IgKGxldCBqID0gMCwgY29weSA9IHRydWU7IGogPCBuOyArK2opIHtcbiAgICBpZiAodHlwZW9mIHBhcnRzW2pdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIHN0cmluZ3MgPSBzdHJpbmdzLnNsaWNlKCk7IC8vIGNvcHkgYmVmb3JlIG11dGF0ZVxuICAgICAgICBjb3B5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdHJpbmdzLnNwbGljZShqLCAyLCBzdHJpbmdzW2pdICsgcGFydHNbal0gKyBzdHJpbmdzW2ogKyAxXSk7XG4gICAgICBwYXJ0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAtLWosIC0tbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGkpID0+IHtcbiAgICBsZXQgcyA9IHN0cmluZ3NbMF07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgIHMgKz0gcGFydHNbal0oaSkgKyBzdHJpbmdzW2ogKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/template.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/time.js":
/*!*****************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/time.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generalizeTimeInterval: () => (/* binding */ generalizeTimeInterval),\n/* harmony export */   inferTimeFormat: () => (/* binding */ inferTimeFormat),\n/* harmony export */   intervalDuration: () => (/* binding */ intervalDuration),\n/* harmony export */   intervalType: () => (/* binding */ intervalType),\n/* harmony export */   parseTimeInterval: () => (/* binding */ parseTimeInterval),\n/* harmony export */   timeInterval: () => (/* binding */ timeInterval),\n/* harmony export */   utcInterval: () => (/* binding */ utcInterval)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./order.js */ \"(ssr)/./node_modules/@observablehq/plot/src/order.js\");\n\n\n\n\n\n\n\nconst durationSecond = 1000;\nconst durationMinute = durationSecond * 60;\nconst durationHour = durationMinute * 60;\nconst durationDay = durationHour * 24;\nconst durationWeek = durationDay * 7;\nconst durationMonth = durationDay * 30;\nconst durationYear = durationDay * 365;\n\n// See https://github.com/d3/d3-time/blob/9e8dc940f38f78d7588aad68a54a25b1f0c2d97b/src/ticks.js#L14-L33\nconst tickIntervals = [\n  [\"millisecond\", 1],\n  [\"2 milliseconds\", 2],\n  [\"5 milliseconds\", 5],\n  [\"10 milliseconds\", 10],\n  [\"20 milliseconds\", 20],\n  [\"50 milliseconds\", 50],\n  [\"100 milliseconds\", 100],\n  [\"200 milliseconds\", 200],\n  [\"500 milliseconds\", 500],\n  [\"second\", durationSecond],\n  [\"5 seconds\", 5 * durationSecond],\n  [\"15 seconds\", 15 * durationSecond],\n  [\"30 seconds\", 30 * durationSecond],\n  [\"minute\", durationMinute],\n  [\"5 minutes\", 5 * durationMinute],\n  [\"15 minutes\", 15 * durationMinute],\n  [\"30 minutes\", 30 * durationMinute],\n  [\"hour\", durationHour],\n  [\"3 hours\", 3 * durationHour],\n  [\"6 hours\", 6 * durationHour],\n  [\"12 hours\", 12 * durationHour],\n  [\"day\", durationDay],\n  [\"2 days\", 2 * durationDay],\n  [\"week\", durationWeek],\n  [\"2 weeks\", 2 * durationWeek], // https://github.com/d3/d3-time/issues/46\n  [\"month\", durationMonth],\n  [\"3 months\", 3 * durationMonth],\n  [\"6 months\", 6 * durationMonth], // https://github.com/d3/d3-time/issues/46\n  [\"year\", durationYear],\n  [\"2 years\", 2 * durationYear],\n  [\"5 years\", 5 * durationYear],\n  [\"10 years\", 10 * durationYear],\n  [\"20 years\", 20 * durationYear],\n  [\"50 years\", 50 * durationYear],\n  [\"100 years\", 100 * durationYear] // TODO generalize to longer time scales\n];\n\nconst durations = new Map([\n  [\"second\", durationSecond],\n  [\"minute\", durationMinute],\n  [\"hour\", durationHour],\n  [\"day\", durationDay],\n  [\"monday\", durationWeek],\n  [\"tuesday\", durationWeek],\n  [\"wednesday\", durationWeek],\n  [\"thursday\", durationWeek],\n  [\"friday\", durationWeek],\n  [\"saturday\", durationWeek],\n  [\"sunday\", durationWeek],\n  [\"week\", durationWeek],\n  [\"month\", durationMonth],\n  [\"year\", durationYear]\n]);\n\nconst timeIntervals = new Map([\n  [\"second\", d3__WEBPACK_IMPORTED_MODULE_0__.timeSecond],\n  [\"minute\", d3__WEBPACK_IMPORTED_MODULE_0__.timeMinute],\n  [\"hour\", d3__WEBPACK_IMPORTED_MODULE_0__.timeHour],\n  [\"day\", d3__WEBPACK_IMPORTED_MODULE_0__.timeDay], // https://github.com/d3/d3-time/issues/62\n  [\"monday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeMonday],\n  [\"tuesday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeTuesday],\n  [\"wednesday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeWednesday],\n  [\"thursday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeThursday],\n  [\"friday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeFriday],\n  [\"saturday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeSaturday],\n  [\"sunday\", d3__WEBPACK_IMPORTED_MODULE_0__.timeSunday],\n  [\"week\", d3__WEBPACK_IMPORTED_MODULE_0__.timeWeek],\n  [\"month\", d3__WEBPACK_IMPORTED_MODULE_0__.timeMonth],\n  [\"year\", d3__WEBPACK_IMPORTED_MODULE_0__.timeYear]\n]);\n\nconst utcIntervals = new Map([\n  [\"second\", d3__WEBPACK_IMPORTED_MODULE_0__.utcSecond],\n  [\"minute\", d3__WEBPACK_IMPORTED_MODULE_0__.utcMinute],\n  [\"hour\", d3__WEBPACK_IMPORTED_MODULE_0__.utcHour],\n  [\"day\", d3__WEBPACK_IMPORTED_MODULE_0__.unixDay],\n  [\"monday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcMonday],\n  [\"tuesday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcTuesday],\n  [\"wednesday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcWednesday],\n  [\"thursday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcThursday],\n  [\"friday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcFriday],\n  [\"saturday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcSaturday],\n  [\"sunday\", d3__WEBPACK_IMPORTED_MODULE_0__.utcSunday],\n  [\"week\", d3__WEBPACK_IMPORTED_MODULE_0__.utcWeek],\n  [\"month\", d3__WEBPACK_IMPORTED_MODULE_0__.utcMonth],\n  [\"year\", d3__WEBPACK_IMPORTED_MODULE_0__.utcYear]\n]);\n\n// These hidden fields describe standard intervals so that we can, for example,\n// generalize a scale’s time interval to a larger ticks time interval to reduce\n// the number of displayed ticks. TODO We could instead allow the interval\n// implementation to expose a “generalize” method that returns a larger, aligned\n// interval; that would allow us to move this logic to D3, and allow\n// generalization even when a custom interval is provided.\nconst intervalDuration = Symbol(\"intervalDuration\");\nconst intervalType = Symbol(\"intervalType\");\n\n// We greedily mutate D3’s standard intervals on load so that the hidden fields\n// are available even if specified as e.g. d3.utcMonth instead of \"month\".\nfor (const [name, interval] of timeIntervals) {\n  interval[intervalDuration] = durations.get(name);\n  interval[intervalType] = \"time\";\n}\nfor (const [name, interval] of utcIntervals) {\n  interval[intervalDuration] = durations.get(name);\n  interval[intervalType] = \"utc\";\n}\n\nconst utcFormatIntervals = [\n  [\"year\", d3__WEBPACK_IMPORTED_MODULE_0__.utcYear, \"utc\"],\n  [\"month\", d3__WEBPACK_IMPORTED_MODULE_0__.utcMonth, \"utc\"],\n  [\"day\", d3__WEBPACK_IMPORTED_MODULE_0__.unixDay, \"utc\", 6 * durationMonth],\n  [\"hour\", d3__WEBPACK_IMPORTED_MODULE_0__.utcHour, \"utc\", 3 * durationDay],\n  [\"minute\", d3__WEBPACK_IMPORTED_MODULE_0__.utcMinute, \"utc\", 6 * durationHour],\n  [\"second\", d3__WEBPACK_IMPORTED_MODULE_0__.utcSecond, \"utc\", 30 * durationMinute]\n];\n\nconst timeFormatIntervals = [\n  [\"year\", d3__WEBPACK_IMPORTED_MODULE_0__.timeYear, \"time\"],\n  [\"month\", d3__WEBPACK_IMPORTED_MODULE_0__.timeMonth, \"time\"],\n  [\"day\", d3__WEBPACK_IMPORTED_MODULE_0__.timeDay, \"time\", 6 * durationMonth],\n  [\"hour\", d3__WEBPACK_IMPORTED_MODULE_0__.timeHour, \"time\", 3 * durationDay],\n  [\"minute\", d3__WEBPACK_IMPORTED_MODULE_0__.timeMinute, \"time\", 6 * durationHour],\n  [\"second\", d3__WEBPACK_IMPORTED_MODULE_0__.timeSecond, \"time\", 30 * durationMinute]\n];\n\n// An interleaved array of UTC and local time intervals, in descending order\n// from largest to smallest, used to determine the most specific standard time\n// format for a given array of dates. This is a subset of the tick intervals\n// listed above; we only need the breakpoints where the format changes.\nconst formatIntervals = [\n  utcFormatIntervals[0],\n  timeFormatIntervals[0],\n  utcFormatIntervals[1],\n  timeFormatIntervals[1],\n  utcFormatIntervals[2],\n  timeFormatIntervals[2],\n  // Below day, local time typically has an hourly offset from UTC and hence the\n  // two are aligned and indistinguishable; therefore, we only consider UTC, and\n  // we don’t consider these if the domain only has a single value.\n  ...utcFormatIntervals.slice(3)\n];\n\nfunction parseTimeInterval(input) {\n  let name = `${input}`.toLowerCase();\n  if (name.endsWith(\"s\")) name = name.slice(0, -1); // drop plural\n  let period = 1;\n  const match = /^(?:(\\d+)\\s+)/.exec(name);\n  if (match) {\n    name = name.slice(match[0].length);\n    period = +match[1];\n  }\n  switch (name) {\n    case \"quarter\":\n      name = \"month\";\n      period *= 3;\n      break;\n    case \"half\":\n      name = \"month\";\n      period *= 6;\n      break;\n  }\n  let interval = utcIntervals.get(name);\n  if (!interval) throw new Error(`unknown interval: ${input}`);\n  if (period > 1 && !interval.every) throw new Error(`non-periodic interval: ${name}`);\n  return [name, period];\n}\n\nfunction timeInterval(input) {\n  return asInterval(parseTimeInterval(input), \"time\");\n}\n\nfunction utcInterval(input) {\n  return asInterval(parseTimeInterval(input), \"utc\");\n}\n\nfunction asInterval([name, period], type) {\n  let interval = (type === \"time\" ? timeIntervals : utcIntervals).get(name);\n  if (period > 1) {\n    interval = interval.every(period);\n    interval[intervalDuration] = durations.get(name) * period;\n    interval[intervalType] = type;\n  }\n  return interval;\n}\n\n// If the given interval is a standard time interval, we may be able to promote\n// it a larger aligned time interval, rather than showing every nth tick.\nfunction generalizeTimeInterval(interval, n) {\n  if (!(n > 1)) return; // no need to generalize\n  const duration = interval[intervalDuration];\n  if (!tickIntervals.some(([, d]) => d === duration)) return; // nonstandard or unknown interval\n  if (duration % durationDay === 0 && durationDay < duration && duration < durationMonth) return; // not generalizable\n  const [i] = tickIntervals[(0,d3__WEBPACK_IMPORTED_MODULE_0__.bisector)(([, step]) => Math.log(step)).center(tickIntervals, Math.log(duration * n))];\n  return (interval[intervalType] === \"time\" ? timeInterval : utcInterval)(i);\n}\n\nfunction formatTimeInterval(name, type, anchor) {\n  const format = type === \"time\" ? d3__WEBPACK_IMPORTED_MODULE_0__.timeFormat : d3__WEBPACK_IMPORTED_MODULE_0__.utcFormat;\n  // For tips and legends, use a format that doesn’t require context.\n  if (anchor == null) {\n    return format(\n      name === \"year\"\n        ? \"%Y\"\n        : name === \"month\"\n        ? \"%Y-%m\"\n        : name === \"day\"\n        ? \"%Y-%m-%d\"\n        : name === \"hour\" || name === \"minute\"\n        ? \"%Y-%m-%dT%H:%M\"\n        : name === \"second\"\n        ? \"%Y-%m-%dT%H:%M:%S\"\n        : \"%Y-%m-%dT%H:%M:%S.%L\"\n    );\n  }\n  // Otherwise, assume that this is for axis ticks.\n  const template = getTimeTemplate(anchor);\n  switch (name) {\n    case \"millisecond\":\n      return formatConditional(format(\".%L\"), format(\":%M:%S\"), template);\n    case \"second\":\n      return formatConditional(format(\":%S\"), format(\"%-I:%M\"), template);\n    case \"minute\":\n      return formatConditional(format(\"%-I:%M\"), format(\"%p\"), template);\n    case \"hour\":\n      return formatConditional(format(\"%-I %p\"), format(\"%b %-d\"), template);\n    case \"day\":\n      return formatConditional(format(\"%-d\"), format(\"%b\"), template);\n    case \"month\":\n      return formatConditional(format(\"%b\"), format(\"%Y\"), template);\n    case \"year\":\n      return format(\"%Y\");\n  }\n  throw new Error(\"unable to format time ticks\");\n}\n\nfunction getTimeTemplate(anchor) {\n  return anchor === \"left\" || anchor === \"right\"\n    ? (f1, f2) => `\\n${f1}\\n${f2}` // extra newline to keep f1 centered\n    : anchor === \"top\"\n    ? (f1, f2) => `${f2}\\n${f1}`\n    : (f1, f2) => `${f1}\\n${f2}`;\n}\n\nfunction getFormatIntervals(type) {\n  return type === \"time\" ? timeFormatIntervals : type === \"utc\" ? utcFormatIntervals : formatIntervals;\n}\n\n// Given an array of dates, returns the largest compatible standard time\n// interval. If no standard interval is compatible (other than milliseconds,\n// which is universally compatible), returns undefined.\nfunction inferTimeFormat(type, dates, anchor) {\n  const step = (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)((0,d3__WEBPACK_IMPORTED_MODULE_0__.pairs)(dates, (a, b) => Math.abs(b - a))); // maybe undefined!\n  if (step < 1000) return formatTimeInterval(\"millisecond\", \"utc\", anchor);\n  for (const [name, interval, intervalType, maxStep] of getFormatIntervals(type)) {\n    if (step > maxStep) break; // e.g., 52 weeks\n    if (name === \"hour\" && !step) break; // e.g., domain with a single date\n    if (dates.every((d) => interval.floor(d) >= d)) return formatTimeInterval(name, intervalType, anchor);\n  }\n}\n\nfunction formatConditional(format1, format2, template) {\n  return (x, i, X) => {\n    const f1 = format1(x, i); // always shown\n    const f2 = format2(x, i); // only shown if different\n    const j = i - (0,_order_js__WEBPACK_IMPORTED_MODULE_1__.orderof)(X); // detect reversed domains\n    return i !== j && X[j] !== undefined && f2 === format2(X[j], j) ? f1 : template(f1, f2);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErRDtBQUN1QjtBQUNpQjtBQUNYO0FBQ2tCO0FBQzNFOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQ0FBVTtBQUN2QixhQUFhLDBDQUFVO0FBQ3ZCLFdBQVcsd0NBQVE7QUFDbkIsVUFBVSx1Q0FBTztBQUNqQixhQUFhLDBDQUFVO0FBQ3ZCLGNBQWMsMkNBQVc7QUFDekIsZ0JBQWdCLDZDQUFhO0FBQzdCLGVBQWUsNENBQVk7QUFDM0IsYUFBYSwwQ0FBVTtBQUN2QixlQUFlLDRDQUFZO0FBQzNCLGFBQWEsMENBQVU7QUFDdkIsV0FBVyx3Q0FBUTtBQUNuQixZQUFZLHlDQUFTO0FBQ3JCLFdBQVcsd0NBQVE7QUFDbkI7O0FBRUE7QUFDQSxhQUFhLHlDQUFTO0FBQ3RCLGFBQWEseUNBQVM7QUFDdEIsV0FBVyx1Q0FBTztBQUNsQixVQUFVLHVDQUFPO0FBQ2pCLGFBQWEseUNBQVM7QUFDdEIsY0FBYywwQ0FBVTtBQUN4QixnQkFBZ0IsNENBQVk7QUFDNUIsZUFBZSwyQ0FBVztBQUMxQixhQUFhLHlDQUFTO0FBQ3RCLGVBQWUsMkNBQVc7QUFDMUIsYUFBYSx5Q0FBUztBQUN0QixXQUFXLHVDQUFPO0FBQ2xCLFlBQVksd0NBQVE7QUFDcEIsV0FBVyx1Q0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHVDQUFPO0FBQ2xCLFlBQVksd0NBQVE7QUFDcEIsVUFBVSx1Q0FBTztBQUNqQixXQUFXLHVDQUFPO0FBQ2xCLGFBQWEseUNBQVM7QUFDdEIsYUFBYSx5Q0FBUztBQUN0Qjs7QUFFQTtBQUNBLFdBQVcsd0NBQVE7QUFDbkIsWUFBWSx5Q0FBUztBQUNyQixVQUFVLHVDQUFPO0FBQ2pCLFdBQVcsd0NBQVE7QUFDbkIsYUFBYSwwQ0FBVTtBQUN2QixhQUFhLDBDQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGdCQUFnQixNQUFNO0FBQ3RCLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQsK0VBQStFLEtBQUs7QUFDcEY7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUCx3QkFBd0I7QUFDeEI7QUFDQSw4REFBOEQ7QUFDOUQsa0dBQWtHO0FBQ2xHLDRCQUE0Qiw0Q0FBUTtBQUNwQztBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBDQUFVLEdBQUcseUNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRyxJQUFJLEdBQUc7QUFDakM7QUFDQSxxQkFBcUIsR0FBRyxJQUFJLEdBQUc7QUFDL0IscUJBQXFCLEdBQUcsSUFBSSxHQUFHO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsdUNBQUcsQ0FBQyx5Q0FBSyxxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGtCQUFrQixrREFBTyxLQUFLO0FBQzlCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdGltZS5qcz8wOWYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YmlzZWN0b3IsIG1heCwgcGFpcnMsIHRpbWVGb3JtYXQsIHV0Y0Zvcm1hdH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge3V0Y1NlY29uZCwgdXRjTWludXRlLCB1dGNIb3VyLCB1bml4RGF5LCB1dGNXZWVrLCB1dGNNb250aCwgdXRjWWVhcn0gZnJvbSBcImQzXCI7XG5pbXBvcnQge3V0Y01vbmRheSwgdXRjVHVlc2RheSwgdXRjV2VkbmVzZGF5LCB1dGNUaHVyc2RheSwgdXRjRnJpZGF5LCB1dGNTYXR1cmRheSwgdXRjU3VuZGF5fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7dGltZVNlY29uZCwgdGltZU1pbnV0ZSwgdGltZUhvdXIsIHRpbWVEYXksIHRpbWVXZWVrLCB0aW1lTW9udGgsIHRpbWVZZWFyfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7dGltZU1vbmRheSwgdGltZVR1ZXNkYXksIHRpbWVXZWRuZXNkYXksIHRpbWVUaHVyc2RheSwgdGltZUZyaWRheSwgdGltZVNhdHVyZGF5LCB0aW1lU3VuZGF5fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7b3JkZXJvZn0gZnJvbSBcIi4vb3JkZXIuanNcIjtcblxuY29uc3QgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xuY29uc3QgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwO1xuY29uc3QgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbmNvbnN0IGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG5jb25zdCBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDc7XG5jb25zdCBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbmNvbnN0IGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUvYmxvYi85ZThkYzk0MGYzOGY3OGQ3NTg4YWFkNjhhNTRhMjViMWYwYzJkOTdiL3NyYy90aWNrcy5qcyNMMTQtTDMzXG5jb25zdCB0aWNrSW50ZXJ2YWxzID0gW1xuICBbXCJtaWxsaXNlY29uZFwiLCAxXSxcbiAgW1wiMiBtaWxsaXNlY29uZHNcIiwgMl0sXG4gIFtcIjUgbWlsbGlzZWNvbmRzXCIsIDVdLFxuICBbXCIxMCBtaWxsaXNlY29uZHNcIiwgMTBdLFxuICBbXCIyMCBtaWxsaXNlY29uZHNcIiwgMjBdLFxuICBbXCI1MCBtaWxsaXNlY29uZHNcIiwgNTBdLFxuICBbXCIxMDAgbWlsbGlzZWNvbmRzXCIsIDEwMF0sXG4gIFtcIjIwMCBtaWxsaXNlY29uZHNcIiwgMjAwXSxcbiAgW1wiNTAwIG1pbGxpc2Vjb25kc1wiLCA1MDBdLFxuICBbXCJzZWNvbmRcIiwgZHVyYXRpb25TZWNvbmRdLFxuICBbXCI1IHNlY29uZHNcIiwgNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgW1wiMTUgc2Vjb25kc1wiLCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgW1wiMzAgc2Vjb25kc1wiLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgW1wibWludXRlXCIsIGR1cmF0aW9uTWludXRlXSxcbiAgW1wiNSBtaW51dGVzXCIsIDUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gIFtcIjE1IG1pbnV0ZXNcIiwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gIFtcIjMwIG1pbnV0ZXNcIiwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gIFtcImhvdXJcIiwgZHVyYXRpb25Ib3VyXSxcbiAgW1wiMyBob3Vyc1wiLCAzICogZHVyYXRpb25Ib3VyXSxcbiAgW1wiNiBob3Vyc1wiLCA2ICogZHVyYXRpb25Ib3VyXSxcbiAgW1wiMTIgaG91cnNcIiwgMTIgKiBkdXJhdGlvbkhvdXJdLFxuICBbXCJkYXlcIiwgZHVyYXRpb25EYXldLFxuICBbXCIyIGRheXNcIiwgMiAqIGR1cmF0aW9uRGF5XSxcbiAgW1wid2Vla1wiLCBkdXJhdGlvbldlZWtdLFxuICBbXCIyIHdlZWtzXCIsIDIgKiBkdXJhdGlvbldlZWtdLCAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS9pc3N1ZXMvNDZcbiAgW1wibW9udGhcIiwgZHVyYXRpb25Nb250aF0sXG4gIFtcIjMgbW9udGhzXCIsIDMgKiBkdXJhdGlvbk1vbnRoXSxcbiAgW1wiNiBtb250aHNcIiwgNiAqIGR1cmF0aW9uTW9udGhdLCAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS9pc3N1ZXMvNDZcbiAgW1wieWVhclwiLCBkdXJhdGlvblllYXJdLFxuICBbXCIyIHllYXJzXCIsIDIgKiBkdXJhdGlvblllYXJdLFxuICBbXCI1IHllYXJzXCIsIDUgKiBkdXJhdGlvblllYXJdLFxuICBbXCIxMCB5ZWFyc1wiLCAxMCAqIGR1cmF0aW9uWWVhcl0sXG4gIFtcIjIwIHllYXJzXCIsIDIwICogZHVyYXRpb25ZZWFyXSxcbiAgW1wiNTAgeWVhcnNcIiwgNTAgKiBkdXJhdGlvblllYXJdLFxuICBbXCIxMDAgeWVhcnNcIiwgMTAwICogZHVyYXRpb25ZZWFyXSAvLyBUT0RPIGdlbmVyYWxpemUgdG8gbG9uZ2VyIHRpbWUgc2NhbGVzXG5dO1xuXG5jb25zdCBkdXJhdGlvbnMgPSBuZXcgTWFwKFtcbiAgW1wic2Vjb25kXCIsIGR1cmF0aW9uU2Vjb25kXSxcbiAgW1wibWludXRlXCIsIGR1cmF0aW9uTWludXRlXSxcbiAgW1wiaG91clwiLCBkdXJhdGlvbkhvdXJdLFxuICBbXCJkYXlcIiwgZHVyYXRpb25EYXldLFxuICBbXCJtb25kYXlcIiwgZHVyYXRpb25XZWVrXSxcbiAgW1widHVlc2RheVwiLCBkdXJhdGlvbldlZWtdLFxuICBbXCJ3ZWRuZXNkYXlcIiwgZHVyYXRpb25XZWVrXSxcbiAgW1widGh1cnNkYXlcIiwgZHVyYXRpb25XZWVrXSxcbiAgW1wiZnJpZGF5XCIsIGR1cmF0aW9uV2Vla10sXG4gIFtcInNhdHVyZGF5XCIsIGR1cmF0aW9uV2Vla10sXG4gIFtcInN1bmRheVwiLCBkdXJhdGlvbldlZWtdLFxuICBbXCJ3ZWVrXCIsIGR1cmF0aW9uV2Vla10sXG4gIFtcIm1vbnRoXCIsIGR1cmF0aW9uTW9udGhdLFxuICBbXCJ5ZWFyXCIsIGR1cmF0aW9uWWVhcl1cbl0pO1xuXG5jb25zdCB0aW1lSW50ZXJ2YWxzID0gbmV3IE1hcChbXG4gIFtcInNlY29uZFwiLCB0aW1lU2Vjb25kXSxcbiAgW1wibWludXRlXCIsIHRpbWVNaW51dGVdLFxuICBbXCJob3VyXCIsIHRpbWVIb3VyXSxcbiAgW1wiZGF5XCIsIHRpbWVEYXldLCAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS9pc3N1ZXMvNjJcbiAgW1wibW9uZGF5XCIsIHRpbWVNb25kYXldLFxuICBbXCJ0dWVzZGF5XCIsIHRpbWVUdWVzZGF5XSxcbiAgW1wid2VkbmVzZGF5XCIsIHRpbWVXZWRuZXNkYXldLFxuICBbXCJ0aHVyc2RheVwiLCB0aW1lVGh1cnNkYXldLFxuICBbXCJmcmlkYXlcIiwgdGltZUZyaWRheV0sXG4gIFtcInNhdHVyZGF5XCIsIHRpbWVTYXR1cmRheV0sXG4gIFtcInN1bmRheVwiLCB0aW1lU3VuZGF5XSxcbiAgW1wid2Vla1wiLCB0aW1lV2Vla10sXG4gIFtcIm1vbnRoXCIsIHRpbWVNb250aF0sXG4gIFtcInllYXJcIiwgdGltZVllYXJdXG5dKTtcblxuY29uc3QgdXRjSW50ZXJ2YWxzID0gbmV3IE1hcChbXG4gIFtcInNlY29uZFwiLCB1dGNTZWNvbmRdLFxuICBbXCJtaW51dGVcIiwgdXRjTWludXRlXSxcbiAgW1wiaG91clwiLCB1dGNIb3VyXSxcbiAgW1wiZGF5XCIsIHVuaXhEYXldLFxuICBbXCJtb25kYXlcIiwgdXRjTW9uZGF5XSxcbiAgW1widHVlc2RheVwiLCB1dGNUdWVzZGF5XSxcbiAgW1wid2VkbmVzZGF5XCIsIHV0Y1dlZG5lc2RheV0sXG4gIFtcInRodXJzZGF5XCIsIHV0Y1RodXJzZGF5XSxcbiAgW1wiZnJpZGF5XCIsIHV0Y0ZyaWRheV0sXG4gIFtcInNhdHVyZGF5XCIsIHV0Y1NhdHVyZGF5XSxcbiAgW1wic3VuZGF5XCIsIHV0Y1N1bmRheV0sXG4gIFtcIndlZWtcIiwgdXRjV2Vla10sXG4gIFtcIm1vbnRoXCIsIHV0Y01vbnRoXSxcbiAgW1wieWVhclwiLCB1dGNZZWFyXVxuXSk7XG5cbi8vIFRoZXNlIGhpZGRlbiBmaWVsZHMgZGVzY3JpYmUgc3RhbmRhcmQgaW50ZXJ2YWxzIHNvIHRoYXQgd2UgY2FuLCBmb3IgZXhhbXBsZSxcbi8vIGdlbmVyYWxpemUgYSBzY2FsZeKAmXMgdGltZSBpbnRlcnZhbCB0byBhIGxhcmdlciB0aWNrcyB0aW1lIGludGVydmFsIHRvIHJlZHVjZVxuLy8gdGhlIG51bWJlciBvZiBkaXNwbGF5ZWQgdGlja3MuIFRPRE8gV2UgY291bGQgaW5zdGVhZCBhbGxvdyB0aGUgaW50ZXJ2YWxcbi8vIGltcGxlbWVudGF0aW9uIHRvIGV4cG9zZSBhIOKAnGdlbmVyYWxpemXigJ0gbWV0aG9kIHRoYXQgcmV0dXJucyBhIGxhcmdlciwgYWxpZ25lZFxuLy8gaW50ZXJ2YWw7IHRoYXQgd291bGQgYWxsb3cgdXMgdG8gbW92ZSB0aGlzIGxvZ2ljIHRvIEQzLCBhbmQgYWxsb3dcbi8vIGdlbmVyYWxpemF0aW9uIGV2ZW4gd2hlbiBhIGN1c3RvbSBpbnRlcnZhbCBpcyBwcm92aWRlZC5cbmV4cG9ydCBjb25zdCBpbnRlcnZhbER1cmF0aW9uID0gU3ltYm9sKFwiaW50ZXJ2YWxEdXJhdGlvblwiKTtcbmV4cG9ydCBjb25zdCBpbnRlcnZhbFR5cGUgPSBTeW1ib2woXCJpbnRlcnZhbFR5cGVcIik7XG5cbi8vIFdlIGdyZWVkaWx5IG11dGF0ZSBEM+KAmXMgc3RhbmRhcmQgaW50ZXJ2YWxzIG9uIGxvYWQgc28gdGhhdCB0aGUgaGlkZGVuIGZpZWxkc1xuLy8gYXJlIGF2YWlsYWJsZSBldmVuIGlmIHNwZWNpZmllZCBhcyBlLmcuIGQzLnV0Y01vbnRoIGluc3RlYWQgb2YgXCJtb250aFwiLlxuZm9yIChjb25zdCBbbmFtZSwgaW50ZXJ2YWxdIG9mIHRpbWVJbnRlcnZhbHMpIHtcbiAgaW50ZXJ2YWxbaW50ZXJ2YWxEdXJhdGlvbl0gPSBkdXJhdGlvbnMuZ2V0KG5hbWUpO1xuICBpbnRlcnZhbFtpbnRlcnZhbFR5cGVdID0gXCJ0aW1lXCI7XG59XG5mb3IgKGNvbnN0IFtuYW1lLCBpbnRlcnZhbF0gb2YgdXRjSW50ZXJ2YWxzKSB7XG4gIGludGVydmFsW2ludGVydmFsRHVyYXRpb25dID0gZHVyYXRpb25zLmdldChuYW1lKTtcbiAgaW50ZXJ2YWxbaW50ZXJ2YWxUeXBlXSA9IFwidXRjXCI7XG59XG5cbmNvbnN0IHV0Y0Zvcm1hdEludGVydmFscyA9IFtcbiAgW1wieWVhclwiLCB1dGNZZWFyLCBcInV0Y1wiXSxcbiAgW1wibW9udGhcIiwgdXRjTW9udGgsIFwidXRjXCJdLFxuICBbXCJkYXlcIiwgdW5peERheSwgXCJ1dGNcIiwgNiAqIGR1cmF0aW9uTW9udGhdLFxuICBbXCJob3VyXCIsIHV0Y0hvdXIsIFwidXRjXCIsIDMgKiBkdXJhdGlvbkRheV0sXG4gIFtcIm1pbnV0ZVwiLCB1dGNNaW51dGUsIFwidXRjXCIsIDYgKiBkdXJhdGlvbkhvdXJdLFxuICBbXCJzZWNvbmRcIiwgdXRjU2Vjb25kLCBcInV0Y1wiLCAzMCAqIGR1cmF0aW9uTWludXRlXVxuXTtcblxuY29uc3QgdGltZUZvcm1hdEludGVydmFscyA9IFtcbiAgW1wieWVhclwiLCB0aW1lWWVhciwgXCJ0aW1lXCJdLFxuICBbXCJtb250aFwiLCB0aW1lTW9udGgsIFwidGltZVwiXSxcbiAgW1wiZGF5XCIsIHRpbWVEYXksIFwidGltZVwiLCA2ICogZHVyYXRpb25Nb250aF0sXG4gIFtcImhvdXJcIiwgdGltZUhvdXIsIFwidGltZVwiLCAzICogZHVyYXRpb25EYXldLFxuICBbXCJtaW51dGVcIiwgdGltZU1pbnV0ZSwgXCJ0aW1lXCIsIDYgKiBkdXJhdGlvbkhvdXJdLFxuICBbXCJzZWNvbmRcIiwgdGltZVNlY29uZCwgXCJ0aW1lXCIsIDMwICogZHVyYXRpb25NaW51dGVdXG5dO1xuXG4vLyBBbiBpbnRlcmxlYXZlZCBhcnJheSBvZiBVVEMgYW5kIGxvY2FsIHRpbWUgaW50ZXJ2YWxzLCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3QsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBtb3N0IHNwZWNpZmljIHN0YW5kYXJkIHRpbWVcbi8vIGZvcm1hdCBmb3IgYSBnaXZlbiBhcnJheSBvZiBkYXRlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgdGljayBpbnRlcnZhbHNcbi8vIGxpc3RlZCBhYm92ZTsgd2Ugb25seSBuZWVkIHRoZSBicmVha3BvaW50cyB3aGVyZSB0aGUgZm9ybWF0IGNoYW5nZXMuXG5jb25zdCBmb3JtYXRJbnRlcnZhbHMgPSBbXG4gIHV0Y0Zvcm1hdEludGVydmFsc1swXSxcbiAgdGltZUZvcm1hdEludGVydmFsc1swXSxcbiAgdXRjRm9ybWF0SW50ZXJ2YWxzWzFdLFxuICB0aW1lRm9ybWF0SW50ZXJ2YWxzWzFdLFxuICB1dGNGb3JtYXRJbnRlcnZhbHNbMl0sXG4gIHRpbWVGb3JtYXRJbnRlcnZhbHNbMl0sXG4gIC8vIEJlbG93IGRheSwgbG9jYWwgdGltZSB0eXBpY2FsbHkgaGFzIGFuIGhvdXJseSBvZmZzZXQgZnJvbSBVVEMgYW5kIGhlbmNlIHRoZVxuICAvLyB0d28gYXJlIGFsaWduZWQgYW5kIGluZGlzdGluZ3Vpc2hhYmxlOyB0aGVyZWZvcmUsIHdlIG9ubHkgY29uc2lkZXIgVVRDLCBhbmRcbiAgLy8gd2UgZG9u4oCZdCBjb25zaWRlciB0aGVzZSBpZiB0aGUgZG9tYWluIG9ubHkgaGFzIGEgc2luZ2xlIHZhbHVlLlxuICAuLi51dGNGb3JtYXRJbnRlcnZhbHMuc2xpY2UoMylcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRpbWVJbnRlcnZhbChpbnB1dCkge1xuICBsZXQgbmFtZSA9IGAke2lucHV0fWAudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG5hbWUuZW5kc1dpdGgoXCJzXCIpKSBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7IC8vIGRyb3AgcGx1cmFsXG4gIGxldCBwZXJpb2QgPSAxO1xuICBjb25zdCBtYXRjaCA9IC9eKD86KFxcZCspXFxzKykvLmV4ZWMobmFtZSk7XG4gIGlmIChtYXRjaCkge1xuICAgIG5hbWUgPSBuYW1lLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgcGVyaW9kID0gK21hdGNoWzFdO1xuICB9XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgXCJxdWFydGVyXCI6XG4gICAgICBuYW1lID0gXCJtb250aFwiO1xuICAgICAgcGVyaW9kICo9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaGFsZlwiOlxuICAgICAgbmFtZSA9IFwibW9udGhcIjtcbiAgICAgIHBlcmlvZCAqPSA2O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgbGV0IGludGVydmFsID0gdXRjSW50ZXJ2YWxzLmdldChuYW1lKTtcbiAgaWYgKCFpbnRlcnZhbCkgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGludGVydmFsOiAke2lucHV0fWApO1xuICBpZiAocGVyaW9kID4gMSAmJiAhaW50ZXJ2YWwuZXZlcnkpIHRocm93IG5ldyBFcnJvcihgbm9uLXBlcmlvZGljIGludGVydmFsOiAke25hbWV9YCk7XG4gIHJldHVybiBbbmFtZSwgcGVyaW9kXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVJbnRlcnZhbChpbnB1dCkge1xuICByZXR1cm4gYXNJbnRlcnZhbChwYXJzZVRpbWVJbnRlcnZhbChpbnB1dCksIFwidGltZVwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHV0Y0ludGVydmFsKGlucHV0KSB7XG4gIHJldHVybiBhc0ludGVydmFsKHBhcnNlVGltZUludGVydmFsKGlucHV0KSwgXCJ1dGNcIik7XG59XG5cbmZ1bmN0aW9uIGFzSW50ZXJ2YWwoW25hbWUsIHBlcmlvZF0sIHR5cGUpIHtcbiAgbGV0IGludGVydmFsID0gKHR5cGUgPT09IFwidGltZVwiID8gdGltZUludGVydmFscyA6IHV0Y0ludGVydmFscykuZ2V0KG5hbWUpO1xuICBpZiAocGVyaW9kID4gMSkge1xuICAgIGludGVydmFsID0gaW50ZXJ2YWwuZXZlcnkocGVyaW9kKTtcbiAgICBpbnRlcnZhbFtpbnRlcnZhbER1cmF0aW9uXSA9IGR1cmF0aW9ucy5nZXQobmFtZSkgKiBwZXJpb2Q7XG4gICAgaW50ZXJ2YWxbaW50ZXJ2YWxUeXBlXSA9IHR5cGU7XG4gIH1cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG4vLyBJZiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgaXMgYSBzdGFuZGFyZCB0aW1lIGludGVydmFsLCB3ZSBtYXkgYmUgYWJsZSB0byBwcm9tb3RlXG4vLyBpdCBhIGxhcmdlciBhbGlnbmVkIHRpbWUgaW50ZXJ2YWwsIHJhdGhlciB0aGFuIHNob3dpbmcgZXZlcnkgbnRoIHRpY2suXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhbGl6ZVRpbWVJbnRlcnZhbChpbnRlcnZhbCwgbikge1xuICBpZiAoIShuID4gMSkpIHJldHVybjsgLy8gbm8gbmVlZCB0byBnZW5lcmFsaXplXG4gIGNvbnN0IGR1cmF0aW9uID0gaW50ZXJ2YWxbaW50ZXJ2YWxEdXJhdGlvbl07XG4gIGlmICghdGlja0ludGVydmFscy5zb21lKChbLCBkXSkgPT4gZCA9PT0gZHVyYXRpb24pKSByZXR1cm47IC8vIG5vbnN0YW5kYXJkIG9yIHVua25vd24gaW50ZXJ2YWxcbiAgaWYgKGR1cmF0aW9uICUgZHVyYXRpb25EYXkgPT09IDAgJiYgZHVyYXRpb25EYXkgPCBkdXJhdGlvbiAmJiBkdXJhdGlvbiA8IGR1cmF0aW9uTW9udGgpIHJldHVybjsgLy8gbm90IGdlbmVyYWxpemFibGVcbiAgY29uc3QgW2ldID0gdGlja0ludGVydmFsc1tiaXNlY3RvcigoWywgc3RlcF0pID0+IE1hdGgubG9nKHN0ZXApKS5jZW50ZXIodGlja0ludGVydmFscywgTWF0aC5sb2coZHVyYXRpb24gKiBuKSldO1xuICByZXR1cm4gKGludGVydmFsW2ludGVydmFsVHlwZV0gPT09IFwidGltZVwiID8gdGltZUludGVydmFsIDogdXRjSW50ZXJ2YWwpKGkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lSW50ZXJ2YWwobmFtZSwgdHlwZSwgYW5jaG9yKSB7XG4gIGNvbnN0IGZvcm1hdCA9IHR5cGUgPT09IFwidGltZVwiID8gdGltZUZvcm1hdCA6IHV0Y0Zvcm1hdDtcbiAgLy8gRm9yIHRpcHMgYW5kIGxlZ2VuZHMsIHVzZSBhIGZvcm1hdCB0aGF0IGRvZXNu4oCZdCByZXF1aXJlIGNvbnRleHQuXG4gIGlmIChhbmNob3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBmb3JtYXQoXG4gICAgICBuYW1lID09PSBcInllYXJcIlxuICAgICAgICA/IFwiJVlcIlxuICAgICAgICA6IG5hbWUgPT09IFwibW9udGhcIlxuICAgICAgICA/IFwiJVktJW1cIlxuICAgICAgICA6IG5hbWUgPT09IFwiZGF5XCJcbiAgICAgICAgPyBcIiVZLSVtLSVkXCJcbiAgICAgICAgOiBuYW1lID09PSBcImhvdXJcIiB8fCBuYW1lID09PSBcIm1pbnV0ZVwiXG4gICAgICAgID8gXCIlWS0lbS0lZFQlSDolTVwiXG4gICAgICAgIDogbmFtZSA9PT0gXCJzZWNvbmRcIlxuICAgICAgICA/IFwiJVktJW0tJWRUJUg6JU06JVNcIlxuICAgICAgICA6IFwiJVktJW0tJWRUJUg6JU06JVMuJUxcIlxuICAgICk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgdGhhdCB0aGlzIGlzIGZvciBheGlzIHRpY2tzLlxuICBjb25zdCB0ZW1wbGF0ZSA9IGdldFRpbWVUZW1wbGF0ZShhbmNob3IpO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgIHJldHVybiBmb3JtYXRDb25kaXRpb25hbChmb3JtYXQoXCIuJUxcIiksIGZvcm1hdChcIjolTTolU1wiKSwgdGVtcGxhdGUpO1xuICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgIHJldHVybiBmb3JtYXRDb25kaXRpb25hbChmb3JtYXQoXCI6JVNcIiksIGZvcm1hdChcIiUtSTolTVwiKSwgdGVtcGxhdGUpO1xuICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgIHJldHVybiBmb3JtYXRDb25kaXRpb25hbChmb3JtYXQoXCIlLUk6JU1cIiksIGZvcm1hdChcIiVwXCIpLCB0ZW1wbGF0ZSk7XG4gICAgY2FzZSBcImhvdXJcIjpcbiAgICAgIHJldHVybiBmb3JtYXRDb25kaXRpb25hbChmb3JtYXQoXCIlLUkgJXBcIiksIGZvcm1hdChcIiViICUtZFwiKSwgdGVtcGxhdGUpO1xuICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgIHJldHVybiBmb3JtYXRDb25kaXRpb25hbChmb3JtYXQoXCIlLWRcIiksIGZvcm1hdChcIiViXCIpLCB0ZW1wbGF0ZSk7XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICByZXR1cm4gZm9ybWF0Q29uZGl0aW9uYWwoZm9ybWF0KFwiJWJcIiksIGZvcm1hdChcIiVZXCIpLCB0ZW1wbGF0ZSk7XG4gICAgY2FzZSBcInllYXJcIjpcbiAgICAgIHJldHVybiBmb3JtYXQoXCIlWVwiKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gZm9ybWF0IHRpbWUgdGlja3NcIik7XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVUZW1wbGF0ZShhbmNob3IpIHtcbiAgcmV0dXJuIGFuY2hvciA9PT0gXCJsZWZ0XCIgfHwgYW5jaG9yID09PSBcInJpZ2h0XCJcbiAgICA/IChmMSwgZjIpID0+IGBcXG4ke2YxfVxcbiR7ZjJ9YCAvLyBleHRyYSBuZXdsaW5lIHRvIGtlZXAgZjEgY2VudGVyZWRcbiAgICA6IGFuY2hvciA9PT0gXCJ0b3BcIlxuICAgID8gKGYxLCBmMikgPT4gYCR7ZjJ9XFxuJHtmMX1gXG4gICAgOiAoZjEsIGYyKSA9PiBgJHtmMX1cXG4ke2YyfWA7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdEludGVydmFscyh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSBcInRpbWVcIiA/IHRpbWVGb3JtYXRJbnRlcnZhbHMgOiB0eXBlID09PSBcInV0Y1wiID8gdXRjRm9ybWF0SW50ZXJ2YWxzIDogZm9ybWF0SW50ZXJ2YWxzO1xufVxuXG4vLyBHaXZlbiBhbiBhcnJheSBvZiBkYXRlcywgcmV0dXJucyB0aGUgbGFyZ2VzdCBjb21wYXRpYmxlIHN0YW5kYXJkIHRpbWVcbi8vIGludGVydmFsLiBJZiBubyBzdGFuZGFyZCBpbnRlcnZhbCBpcyBjb21wYXRpYmxlIChvdGhlciB0aGFuIG1pbGxpc2Vjb25kcyxcbi8vIHdoaWNoIGlzIHVuaXZlcnNhbGx5IGNvbXBhdGlibGUpLCByZXR1cm5zIHVuZGVmaW5lZC5cbmV4cG9ydCBmdW5jdGlvbiBpbmZlclRpbWVGb3JtYXQodHlwZSwgZGF0ZXMsIGFuY2hvcikge1xuICBjb25zdCBzdGVwID0gbWF4KHBhaXJzKGRhdGVzLCAoYSwgYikgPT4gTWF0aC5hYnMoYiAtIGEpKSk7IC8vIG1heWJlIHVuZGVmaW5lZCFcbiAgaWYgKHN0ZXAgPCAxMDAwKSByZXR1cm4gZm9ybWF0VGltZUludGVydmFsKFwibWlsbGlzZWNvbmRcIiwgXCJ1dGNcIiwgYW5jaG9yKTtcbiAgZm9yIChjb25zdCBbbmFtZSwgaW50ZXJ2YWwsIGludGVydmFsVHlwZSwgbWF4U3RlcF0gb2YgZ2V0Rm9ybWF0SW50ZXJ2YWxzKHR5cGUpKSB7XG4gICAgaWYgKHN0ZXAgPiBtYXhTdGVwKSBicmVhazsgLy8gZS5nLiwgNTIgd2Vla3NcbiAgICBpZiAobmFtZSA9PT0gXCJob3VyXCIgJiYgIXN0ZXApIGJyZWFrOyAvLyBlLmcuLCBkb21haW4gd2l0aCBhIHNpbmdsZSBkYXRlXG4gICAgaWYgKGRhdGVzLmV2ZXJ5KChkKSA9PiBpbnRlcnZhbC5mbG9vcihkKSA+PSBkKSkgcmV0dXJuIGZvcm1hdFRpbWVJbnRlcnZhbChuYW1lLCBpbnRlcnZhbFR5cGUsIGFuY2hvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Q29uZGl0aW9uYWwoZm9ybWF0MSwgZm9ybWF0MiwgdGVtcGxhdGUpIHtcbiAgcmV0dXJuICh4LCBpLCBYKSA9PiB7XG4gICAgY29uc3QgZjEgPSBmb3JtYXQxKHgsIGkpOyAvLyBhbHdheXMgc2hvd25cbiAgICBjb25zdCBmMiA9IGZvcm1hdDIoeCwgaSk7IC8vIG9ubHkgc2hvd24gaWYgZGlmZmVyZW50XG4gICAgY29uc3QgaiA9IGkgLSBvcmRlcm9mKFgpOyAvLyBkZXRlY3QgcmV2ZXJzZWQgZG9tYWluc1xuICAgIHJldHVybiBpICE9PSBqICYmIFhbal0gIT09IHVuZGVmaW5lZCAmJiBmMiA9PT0gZm9ybWF0MihYW2pdLCBqKSA/IGYxIDogdGVtcGxhdGUoZjEsIGYyKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/basic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   basic: () => (/* binding */ basic),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   initializer: () => (/* binding */ initializer),\n/* harmony export */   reverse: () => (/* binding */ reverse),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   sort: () => (/* binding */ sort)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n\n\n\n\n\nfunction basic({filter: f1, sort: s1, reverse: r1, transform: t1, initializer: i1, ...options} = {}, transform) {\n  // If both t1 and t2 are defined, returns a composite transform that first\n  // applies t1 and then applies t2.\n  if (t1 === undefined) {\n    // explicit transform overrides filter, sort, and reverse\n    if (f1 != null) t1 = filterTransform(f1);\n    if (s1 != null && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(s1)) t1 = composeTransform(t1, sortTransform(s1));\n    if (r1) t1 = composeTransform(t1, reverseTransform);\n  }\n  if (transform != null && i1 != null) throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...options,\n    ...((s1 === null || (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(s1)) && {sort: s1}),\n    transform: composeTransform(t1, transform)\n  };\n}\n\nfunction initializer({filter: f1, sort: s1, reverse: r1, initializer: i1, ...options} = {}, initializer) {\n  // If both i1 and i2 are defined, returns a composite initializer that first\n  // applies i1 and then applies i2.\n  if (i1 === undefined) {\n    // explicit initializer overrides filter, sort, and reverse\n    if (f1 != null) i1 = filterTransform(f1);\n    if (s1 != null && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(s1)) i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1) i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...options,\n    ...((s1 === null || (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(s1)) && {sort: s1}),\n    initializer: composeInitializer(i1, initializer)\n  };\n}\n\nfunction composeTransform(t1, t2) {\n  if (t1 == null) return t2 === null ? undefined : t2;\n  if (t2 == null) return t1 === null ? undefined : t1;\n  return function (data, facets, plotOptions) {\n    ({data, facets} = t1.call(this, data, facets, plotOptions));\n    return t2.call(this, (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.dataify)(data), facets, plotOptions);\n  };\n}\n\nfunction composeInitializer(i1, i2) {\n  if (i1 == null) return i2 === null ? undefined : i2;\n  if (i2 == null) return i1 === null ? undefined : i1;\n  return function (data, facets, channels, ...args) {\n    let c1, d1, f1, c2, d2, f2;\n    ({data: d1 = data, facets: f1 = facets, channels: c1} = i1.call(this, data, facets, channels, ...args));\n    ({data: d2 = d1, facets: f2 = f1, channels: c2} = i2.call(this, d1, f1, {...channels, ...c1}, ...args));\n    return {data: d2, facets: f2, channels: {...c1, ...c2}};\n  };\n}\n\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\n\nfunction filter(test, options) {\n  return apply(options, filterTransform(test));\n}\n\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, value);\n    return {data, facets: facets.map((I) => I.filter((i) => V[i]))};\n  };\n}\n\nfunction reverse({sort, ...options} = {}) {\n  return {\n    ...apply(options, reverseTransform),\n    sort: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(sort) ? sort : null\n  };\n}\n\nfunction reverseTransform(data, facets) {\n  return {data, facets: facets.map((I) => I.slice().reverse())};\n}\n\nfunction shuffle({seed, sort, ...options} = {}) {\n  return {\n    ...apply(options, sortValue(seed == null ? Math.random : (0,d3__WEBPACK_IMPORTED_MODULE_0__.randomLcg)(seed))),\n    sort: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(sort) ? sort : null\n  };\n}\n\nfunction sort(order, {sort, ...options} = {}) {\n  return {\n    ...((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isOptions)(order) && order.channel !== undefined ? initializer : apply)(options, sortTransform(order)),\n    sort: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isDomainSort)(sort) ? sort : null\n  };\n}\n\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\n\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(data)\n      ? (i, j) => compare(data[i], data[j])\n      : (i, j) => compare(data.get(i), data.get(j));\n    return {data, facets: facets.map((I) => I.slice().sort(compareData))};\n  };\n}\n\nfunction sortValue(value) {\n  let channel, order;\n  ({channel, value, order} = {...(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeValue)(value)});\n  const negate = channel?.startsWith(\"-\");\n  if (negate) channel = channel.slice(1);\n  if (order === undefined) order = negate ? _defined_js__WEBPACK_IMPORTED_MODULE_2__.descendingDefined : _defined_js__WEBPACK_IMPORTED_MODULE_2__.ascendingDefined;\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = _defined_js__WEBPACK_IMPORTED_MODULE_2__.ascendingDefined;\n        break;\n      case \"descending\":\n        order = _defined_js__WEBPACK_IMPORTED_MODULE_2__.descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === undefined) {\n      V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, value);\n    } else {\n      if (channels === undefined) throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V) return {}; // ignore missing channel\n      V = V.value;\n    }\n    const compareValue = (i, j) => order(V[i], V[j]);\n    return {data, facets: facets.map((I) => I.slice().sort(compareValue))};\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2Jhc2ljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNxQztBQUNIO0FBQ0o7O0FBRXBELGdCQUFnQiwrRUFBK0UsSUFBSTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVksVUFBVSxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFTyxzQkFBc0IsZ0VBQWdFLElBQUk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBWSxVQUFVLFNBQVM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCLHlCQUF5QixvREFBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFvRDtBQUMxRCxNQUFNLDhDQUE4Qyx5QkFBeUIsbUJBQW1CO0FBQ2hHLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvREFBTztBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFTyxrQkFBa0Isa0JBQWtCLElBQUk7QUFDL0M7QUFDQTtBQUNBLFVBQVUseURBQVk7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFTyxrQkFBa0Isd0JBQXdCLElBQUk7QUFDckQ7QUFDQSw2REFBNkQsNkNBQVM7QUFDdEUsVUFBVSx5REFBWTtBQUN0QjtBQUNBOztBQUVPLHNCQUFzQixrQkFBa0IsSUFBSTtBQUNuRDtBQUNBLFFBQVEsc0RBQVM7QUFDakIsVUFBVSx5REFBWTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFPO0FBQy9CO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUIsR0FBRyxHQUFHLHVEQUFVLFFBQVE7QUFDbkQ7QUFDQTtBQUNBLDRDQUE0QywwREFBaUIsR0FBRyx5REFBZ0I7QUFDaEY7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxnQkFBZ0IseURBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWlCO0FBQ2pDO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTztBQUNqQixNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9iYXNpYy5qcz85NTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cmFuZG9tTGNnfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7YXNjZW5kaW5nRGVmaW5lZCwgZGVzY2VuZGluZ0RlZmluZWR9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge2lzQXJyYXksIGlzRG9tYWluU29ydCwgaXNPcHRpb25zfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtkYXRhaWZ5LCBtYXliZVZhbHVlLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gYmFzaWMoe2ZpbHRlcjogZjEsIHNvcnQ6IHMxLCByZXZlcnNlOiByMSwgdHJhbnNmb3JtOiB0MSwgaW5pdGlhbGl6ZXI6IGkxLCAuLi5vcHRpb25zfSA9IHt9LCB0cmFuc2Zvcm0pIHtcbiAgLy8gSWYgYm90aCB0MSBhbmQgdDIgYXJlIGRlZmluZWQsIHJldHVybnMgYSBjb21wb3NpdGUgdHJhbnNmb3JtIHRoYXQgZmlyc3RcbiAgLy8gYXBwbGllcyB0MSBhbmQgdGhlbiBhcHBsaWVzIHQyLlxuICBpZiAodDEgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGV4cGxpY2l0IHRyYW5zZm9ybSBvdmVycmlkZXMgZmlsdGVyLCBzb3J0LCBhbmQgcmV2ZXJzZVxuICAgIGlmIChmMSAhPSBudWxsKSB0MSA9IGZpbHRlclRyYW5zZm9ybShmMSk7XG4gICAgaWYgKHMxICE9IG51bGwgJiYgIWlzRG9tYWluU29ydChzMSkpIHQxID0gY29tcG9zZVRyYW5zZm9ybSh0MSwgc29ydFRyYW5zZm9ybShzMSkpO1xuICAgIGlmIChyMSkgdDEgPSBjb21wb3NlVHJhbnNmb3JtKHQxLCByZXZlcnNlVHJhbnNmb3JtKTtcbiAgfVxuICBpZiAodHJhbnNmb3JtICE9IG51bGwgJiYgaTEgIT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNmb3JtcyBjYW5ub3QgYmUgYXBwbGllZCBhZnRlciBpbml0aWFsaXplcnNcIik7XG4gIHJldHVybiB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICAuLi4oKHMxID09PSBudWxsIHx8IGlzRG9tYWluU29ydChzMSkpICYmIHtzb3J0OiBzMX0pLFxuICAgIHRyYW5zZm9ybTogY29tcG9zZVRyYW5zZm9ybSh0MSwgdHJhbnNmb3JtKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZXIoe2ZpbHRlcjogZjEsIHNvcnQ6IHMxLCByZXZlcnNlOiByMSwgaW5pdGlhbGl6ZXI6IGkxLCAuLi5vcHRpb25zfSA9IHt9LCBpbml0aWFsaXplcikge1xuICAvLyBJZiBib3RoIGkxIGFuZCBpMiBhcmUgZGVmaW5lZCwgcmV0dXJucyBhIGNvbXBvc2l0ZSBpbml0aWFsaXplciB0aGF0IGZpcnN0XG4gIC8vIGFwcGxpZXMgaTEgYW5kIHRoZW4gYXBwbGllcyBpMi5cbiAgaWYgKGkxID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBleHBsaWNpdCBpbml0aWFsaXplciBvdmVycmlkZXMgZmlsdGVyLCBzb3J0LCBhbmQgcmV2ZXJzZVxuICAgIGlmIChmMSAhPSBudWxsKSBpMSA9IGZpbHRlclRyYW5zZm9ybShmMSk7XG4gICAgaWYgKHMxICE9IG51bGwgJiYgIWlzRG9tYWluU29ydChzMSkpIGkxID0gY29tcG9zZUluaXRpYWxpemVyKGkxLCBzb3J0VHJhbnNmb3JtKHMxKSk7XG4gICAgaWYgKHIxKSBpMSA9IGNvbXBvc2VJbml0aWFsaXplcihpMSwgcmV2ZXJzZVRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIC4uLigoczEgPT09IG51bGwgfHwgaXNEb21haW5Tb3J0KHMxKSkgJiYge3NvcnQ6IHMxfSksXG4gICAgaW5pdGlhbGl6ZXI6IGNvbXBvc2VJbml0aWFsaXplcihpMSwgaW5pdGlhbGl6ZXIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2VUcmFuc2Zvcm0odDEsIHQyKSB7XG4gIGlmICh0MSA9PSBudWxsKSByZXR1cm4gdDIgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0MjtcbiAgaWYgKHQyID09IG51bGwpIHJldHVybiB0MSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHQxO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIGZhY2V0cywgcGxvdE9wdGlvbnMpIHtcbiAgICAoe2RhdGEsIGZhY2V0c30gPSB0MS5jYWxsKHRoaXMsIGRhdGEsIGZhY2V0cywgcGxvdE9wdGlvbnMpKTtcbiAgICByZXR1cm4gdDIuY2FsbCh0aGlzLCBkYXRhaWZ5KGRhdGEpLCBmYWNldHMsIHBsb3RPcHRpb25zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZUluaXRpYWxpemVyKGkxLCBpMikge1xuICBpZiAoaTEgPT0gbnVsbCkgcmV0dXJuIGkyID09PSBudWxsID8gdW5kZWZpbmVkIDogaTI7XG4gIGlmIChpMiA9PSBudWxsKSByZXR1cm4gaTEgPT09IG51bGwgPyB1bmRlZmluZWQgOiBpMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCBmYWNldHMsIGNoYW5uZWxzLCAuLi5hcmdzKSB7XG4gICAgbGV0IGMxLCBkMSwgZjEsIGMyLCBkMiwgZjI7XG4gICAgKHtkYXRhOiBkMSA9IGRhdGEsIGZhY2V0czogZjEgPSBmYWNldHMsIGNoYW5uZWxzOiBjMX0gPSBpMS5jYWxsKHRoaXMsIGRhdGEsIGZhY2V0cywgY2hhbm5lbHMsIC4uLmFyZ3MpKTtcbiAgICAoe2RhdGE6IGQyID0gZDEsIGZhY2V0czogZjIgPSBmMSwgY2hhbm5lbHM6IGMyfSA9IGkyLmNhbGwodGhpcywgZDEsIGYxLCB7Li4uY2hhbm5lbHMsIC4uLmMxfSwgLi4uYXJncykpO1xuICAgIHJldHVybiB7ZGF0YTogZDIsIGZhY2V0czogZjIsIGNoYW5uZWxzOiB7Li4uYzEsIC4uLmMyfX07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFwcGx5KG9wdGlvbnMsIHQpIHtcbiAgcmV0dXJuIChvcHRpb25zLmluaXRpYWxpemVyICE9IG51bGwgPyBpbml0aWFsaXplciA6IGJhc2ljKShvcHRpb25zLCB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcih0ZXN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBhcHBseShvcHRpb25zLCBmaWx0ZXJUcmFuc2Zvcm0odGVzdCkpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIChkYXRhLCBmYWNldHMpID0+IHtcbiAgICBjb25zdCBWID0gdmFsdWVvZihkYXRhLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHM6IGZhY2V0cy5tYXAoKEkpID0+IEkuZmlsdGVyKChpKSA9PiBWW2ldKSl9O1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZSh7c29ydCwgLi4ub3B0aW9uc30gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIC4uLmFwcGx5KG9wdGlvbnMsIHJldmVyc2VUcmFuc2Zvcm0pLFxuICAgIHNvcnQ6IGlzRG9tYWluU29ydChzb3J0KSA/IHNvcnQgOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VUcmFuc2Zvcm0oZGF0YSwgZmFjZXRzKSB7XG4gIHJldHVybiB7ZGF0YSwgZmFjZXRzOiBmYWNldHMubWFwKChJKSA9PiBJLnNsaWNlKCkucmV2ZXJzZSgpKX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKHtzZWVkLCBzb3J0LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uYXBwbHkob3B0aW9ucywgc29ydFZhbHVlKHNlZWQgPT0gbnVsbCA/IE1hdGgucmFuZG9tIDogcmFuZG9tTGNnKHNlZWQpKSksXG4gICAgc29ydDogaXNEb21haW5Tb3J0KHNvcnQpID8gc29ydCA6IG51bGxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnQob3JkZXIsIHtzb3J0LCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uKGlzT3B0aW9ucyhvcmRlcikgJiYgb3JkZXIuY2hhbm5lbCAhPT0gdW5kZWZpbmVkID8gaW5pdGlhbGl6ZXIgOiBhcHBseSkob3B0aW9ucywgc29ydFRyYW5zZm9ybShvcmRlcikpLFxuICAgIHNvcnQ6IGlzRG9tYWluU29ydChzb3J0KSA/IHNvcnQgOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNvcnRUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5sZW5ndGggIT09IDEgPyBzb3J0RGF0YSA6IHNvcnRWYWx1ZSkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzb3J0RGF0YShjb21wYXJlKSB7XG4gIHJldHVybiAoZGF0YSwgZmFjZXRzKSA9PiB7XG4gICAgY29uc3QgY29tcGFyZURhdGEgPSBpc0FycmF5KGRhdGEpXG4gICAgICA/IChpLCBqKSA9PiBjb21wYXJlKGRhdGFbaV0sIGRhdGFbal0pXG4gICAgICA6IChpLCBqKSA9PiBjb21wYXJlKGRhdGEuZ2V0KGkpLCBkYXRhLmdldChqKSk7XG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHM6IGZhY2V0cy5tYXAoKEkpID0+IEkuc2xpY2UoKS5zb3J0KGNvbXBhcmVEYXRhKSl9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBzb3J0VmFsdWUodmFsdWUpIHtcbiAgbGV0IGNoYW5uZWwsIG9yZGVyO1xuICAoe2NoYW5uZWwsIHZhbHVlLCBvcmRlcn0gPSB7Li4ubWF5YmVWYWx1ZSh2YWx1ZSl9KTtcbiAgY29uc3QgbmVnYXRlID0gY2hhbm5lbD8uc3RhcnRzV2l0aChcIi1cIik7XG4gIGlmIChuZWdhdGUpIGNoYW5uZWwgPSBjaGFubmVsLnNsaWNlKDEpO1xuICBpZiAob3JkZXIgPT09IHVuZGVmaW5lZCkgb3JkZXIgPSBuZWdhdGUgPyBkZXNjZW5kaW5nRGVmaW5lZCA6IGFzY2VuZGluZ0RlZmluZWQ7XG4gIGlmICh0eXBlb2Ygb3JkZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN3aXRjaCAoYCR7b3JkZXJ9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwiYXNjZW5kaW5nXCI6XG4gICAgICAgIG9yZGVyID0gYXNjZW5kaW5nRGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVzY2VuZGluZ1wiOlxuICAgICAgICBvcmRlciA9IGRlc2NlbmRpbmdEZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcmRlcjogJHtvcmRlcn1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChkYXRhLCBmYWNldHMsIGNoYW5uZWxzKSA9PiB7XG4gICAgbGV0IFY7XG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgViA9IHZhbHVlb2YoZGF0YSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhbm5lbHMgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBzb3J0IHJlcXVpcmVzIGFuIGluaXRpYWxpemVyXCIpO1xuICAgICAgViA9IGNoYW5uZWxzW2NoYW5uZWxdO1xuICAgICAgaWYgKCFWKSByZXR1cm4ge307IC8vIGlnbm9yZSBtaXNzaW5nIGNoYW5uZWxcbiAgICAgIFYgPSBWLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBjb21wYXJlVmFsdWUgPSAoaSwgaikgPT4gb3JkZXIoVltpXSwgVltqXSk7XG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHM6IGZhY2V0cy5tYXAoKEkpID0+IEkuc2xpY2UoKS5zb3J0KGNvbXBhcmVWYWx1ZSkpfTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/bin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bin: () => (/* binding */ bin),\n/* harmony export */   binX: () => (/* binding */ binX),\n/* harmony export */   binY: () => (/* binding */ binY),\n/* harmony export */   maybeDenseIntervalX: () => (/* binding */ maybeDenseIntervalX),\n/* harmony export */   maybeDenseIntervalY: () => (/* binding */ maybeDenseIntervalY),\n/* harmony export */   maybeThresholds: () => (/* binding */ maybeThresholds)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../time.js */ \"(ssr)/./node_modules/@observablehq/plot/src/time.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n/* harmony import */ var _inset_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inset.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/inset.js\");\n\n\n\n\n\n\n\n\n// Group on {z, fill, stroke}, then optionally on y, then bin x.\nfunction binX(outputs = {y: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = options;\n  return binn(maybeBinValue(x, options, _options_js__WEBPACK_IMPORTED_MODULE_1__.identity), null, null, y, outputs, (0,_inset_js__WEBPACK_IMPORTED_MODULE_2__.maybeInsetX)(options));\n}\n\n// Group on {z, fill, stroke}, then optionally on x, then bin y.\nfunction binY(outputs = {x: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = options;\n  return binn(null, maybeBinValue(y, options, _options_js__WEBPACK_IMPORTED_MODULE_1__.identity), x, null, outputs, (0,_inset_js__WEBPACK_IMPORTED_MODULE_2__.maybeInsetY)(options));\n}\n\n// Group on {z, fill, stroke}, then bin on x and y.\nfunction bin(outputs = {fill: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = maybeBinValueTuple(options);\n  return binn(x, y, null, null, outputs, (0,_inset_js__WEBPACK_IMPORTED_MODULE_2__.maybeInsetX)((0,_inset_js__WEBPACK_IMPORTED_MODULE_2__.maybeInsetY)(options)));\n}\n\nfunction maybeDenseInterval(bin, k, options = {}) {\n  if (options?.interval == null) return options;\n  const {reduce = _group_js__WEBPACK_IMPORTED_MODULE_3__.reduceFirst} = options;\n  const outputs = {filter: null};\n  if (options[k] != null) outputs[k] = reduce;\n  if (options[`${k}1`] != null) outputs[`${k}1`] = reduce;\n  if (options[`${k}2`] != null) outputs[`${k}2`] = reduce;\n  return bin(outputs, options);\n}\n\nfunction maybeDenseIntervalX(options = {}) {\n  return maybeDenseInterval(binX, \"y\", (0,_mark_js__WEBPACK_IMPORTED_MODULE_4__.withTip)(options, \"x\"));\n}\n\nfunction maybeDenseIntervalY(options = {}) {\n  return maybeDenseInterval(binY, \"x\", (0,_mark_js__WEBPACK_IMPORTED_MODULE_4__.withTip)(options, \"y\"));\n}\n\nfunction binn(\n  bx, // optionally bin on x (exclusive with gx)\n  by, // optionally bin on y (exclusive with gy)\n  gx, // optionally group on x (exclusive with bx and gy)\n  gy, // optionally group on y (exclusive with by and gx)\n  {\n    data: reduceData = _group_js__WEBPACK_IMPORTED_MODULE_3__.reduceIdentity, // TODO avoid materializing when unused?\n    filter = _group_js__WEBPACK_IMPORTED_MODULE_3__.reduceCount, // return only non-empty bins by default\n    sort,\n    reverse,\n    ...outputs // output channel definitions\n  } = {},\n  inputs = {} // input channels and options\n) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n\n  // Compute the outputs.\n  outputs = maybeBinOutputs(outputs, inputs);\n  reduceData = maybeBinReduce(reduceData, _options_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n  sort = sort == null ? undefined : maybeBinOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeBinEvaluator(\"filter\", filter, inputs);\n\n  // Don’t group on a channel if an output requires it as an input!\n  if (gx != null && (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.hasOutput)(outputs, \"x\", \"x1\", \"x2\")) gx = null;\n  if (gy != null && (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.hasOutput)(outputs, \"y\", \"y1\", \"y2\")) gy = null;\n\n  // Produce x1, x2, y1, and y2 output channels as appropriate (when binning).\n  const [BX1, setBX1] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(bx);\n  const [BX2, setBX2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(bx);\n  const [BY1, setBY1] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(by);\n  const [BY2, setBY2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(by);\n\n  // Produce x or y output channels as appropriate (when grouping).\n  const [k, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(k);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once. We also want to consume options that should\n  // only apply to this transform rather than passing them through to the next.\n  const {\n    x,\n    y,\n    z,\n    fill,\n    stroke,\n    x1,\n    x2, // consumed if x is an output\n    y1,\n    y2, // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(z);\n  const [vfill] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(fill);\n  const [vstroke] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(stroke);\n  const [GF, setGF] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(vfill);\n  const [GS, setGS] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(vstroke);\n\n  return {\n    ...(\"z\" in inputs && {z: GZ || z}),\n    ...(\"fill\" in inputs && {fill: GF || fill}),\n    ...(\"stroke\" in inputs && {stroke: GS || stroke}),\n    ...(0,_basic_js__WEBPACK_IMPORTED_MODULE_5__.basic)(options, (data, facets, plotOptions) => {\n      const K = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeApplyInterval)((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, k), plotOptions?.[gk]);\n      const Z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, z);\n      const F = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, vfill);\n      const S = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, vstroke);\n      const G = (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeSubgroup)(outputs, {z: Z, fill: F, stroke: S});\n      const groupFacets = [];\n      const groupData = [];\n      const GK = K && setGK([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      const BX1 = bx && setBX1([]);\n      const BX2 = bx && setBX2([]);\n      const BY1 = by && setBY1([]);\n      const BY2 = by && setBY2([]);\n      const bin = bing(bx, by, data);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeGroup)(facet, G)) {\n          for (const [k, g] of (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeGroup)(I, K)) {\n            for (const [b, extent] of bin(g)) {\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(b, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(b, data, extent));\n              if (K) GK.push(k);\n              if (Z) GZ.push(G === Z ? f : Z[(b.length > 0 ? b : g)[0]]);\n              if (F) GF.push(G === F ? f : F[(b.length > 0 ? b : g)[0]]);\n              if (S) GS.push(G === S ? f : S[(b.length > 0 ? b : g)[0]]);\n              if (BX1) BX1.push(extent.x1), BX2.push(extent.x2);\n              if (BY1) BY1.push(extent.y1), BY2.push(extent.y2);\n              for (const o of outputs) o.reduce(b, extent);\n              if (sort) sort.reduce(b, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeSort)(groupFacets, sort, reverse);\n      return {data: groupData, facets: groupFacets};\n    }),\n    ...(!(0,_group_js__WEBPACK_IMPORTED_MODULE_3__.hasOutput)(outputs, \"x\") && (BX1 ? {x1: BX1, x2: BX2, x: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.mid)(BX1, BX2)} : {x, x1, x2})),\n    ...(!(0,_group_js__WEBPACK_IMPORTED_MODULE_3__.hasOutput)(outputs, \"y\") && (BY1 ? {y1: BY1, y2: BY2, y: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.mid)(BY1, BY2)} : {y, y1, y2})),\n    ...(GK && {[gk]: GK}),\n    ...Object.fromEntries(outputs.map(({name, output}) => [name, output]))\n  };\n}\n\n// Allow bin options to be specified as part of outputs; merge them into options.\nfunction mergeOptions({cumulative, domain, thresholds, interval, ...outputs}, options) {\n  return [outputs, {cumulative, domain, thresholds, interval, ...options}];\n}\n\nfunction maybeBinValue(value, {cumulative, domain, thresholds, interval}, defaultValue) {\n  value = {...(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeValue)(value)};\n  if (value.domain === undefined) value.domain = domain;\n  if (value.cumulative === undefined) value.cumulative = cumulative;\n  if (value.thresholds === undefined) value.thresholds = thresholds;\n  if (value.interval === undefined) value.interval = interval;\n  if (value.value === undefined) value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\n\nfunction maybeBinValueTuple(options) {\n  let {x, y} = options;\n  x = maybeBinValue(x, options);\n  y = maybeBinValue(y, options);\n  [x.value, y.value] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeTuple)(x.value, y.value);\n  return {x, y};\n}\n\nfunction maybeBin(options) {\n  if (options == null) return;\n  const {value, cumulative, domain = d3__WEBPACK_IMPORTED_MODULE_0__.extent, thresholds} = options;\n  const bin = (data) => {\n    let V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, value);\n    let T; // bin thresholds\n    if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(V) || isTimeThresholds(thresholds)) {\n      V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.map)(V, _options_js__WEBPACK_IMPORTED_MODULE_1__.coerceDate, Float64Array); // like coerceDates, but faster\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isInterval)(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") t = (0,d3__WEBPACK_IMPORTED_MODULE_0__.utcTickInterval)(min, max, t);\n      if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isInterval)(t)) {\n        if (domain === d3__WEBPACK_IMPORTED_MODULE_0__.extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    } else {\n      V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.coerceNumbers)(V);\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isInterval)(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") {\n        // This differs from d3.ticks with regard to exclusive bounds: we want a\n        // first threshold less than or equal to the minimum, and a last\n        // threshold (strictly) greater than the maximum.\n        if (domain === d3__WEBPACK_IMPORTED_MODULE_0__.extent) {\n          let step = (0,d3__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(min, max, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min / step);\n              let r1 = Math.round(max / step);\n              if (!(r0 * step <= min)) --r0;\n              if (!(r1 * step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min * step);\n              let r1 = Math.round(max * step);\n              if (!(r0 / step <= min)) --r0;\n              if (!(r1 / step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) / step;\n            } else {\n              t = [min];\n            }\n          } else {\n            t = [min];\n          }\n        } else {\n          t = (0,d3__WEBPACK_IMPORTED_MODULE_0__.ticks)(min, max, t);\n        }\n      } else if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isInterval)(t)) {\n        if (domain === d3__WEBPACK_IMPORTED_MODULE_0__.extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    }\n    const E = [];\n    if (T.length === 1) E.push([T[0], T[0]]); // collapsed domain\n    else for (let i = 1; i < T.length; ++i) E.push([T[i - 1], T[i]]);\n    E.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E, T, V);\n    return E;\n  };\n  bin.label = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.labelof)(value);\n  return bin;\n}\n\nfunction maybeThresholds(thresholds, interval, defaultThresholds = thresholdAuto) {\n  if (thresholds === undefined) {\n    return interval === undefined ? defaultThresholds : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeRangeInterval)(interval);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return d3__WEBPACK_IMPORTED_MODULE_0__.thresholdFreedmanDiaconis;\n      case \"scott\":\n        return d3__WEBPACK_IMPORTED_MODULE_0__.thresholdScott;\n      case \"sturges\":\n        return d3__WEBPACK_IMPORTED_MODULE_0__.thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    return (0,_time_js__WEBPACK_IMPORTED_MODULE_6__.utcInterval)(thresholds);\n  }\n  return thresholds; // pass array, count, or function to bin.thresholds\n}\n\nfunction maybeBinOutputs(outputs, inputs) {\n  return (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeOutputs)(outputs, inputs, maybeBinOutput);\n}\n\nfunction maybeBinOutput(name, reduce, inputs) {\n  return (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeOutput)(name, reduce, inputs, maybeBinEvaluator);\n}\n\nfunction maybeBinEvaluator(name, reduce, inputs) {\n  return (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeEvaluator)(name, reduce, inputs, maybeBinReduce);\n}\n\nfunction maybeBinReduce(reduce, value) {\n  return (0,_group_js__WEBPACK_IMPORTED_MODULE_3__.maybeReduce)(reduce, value, maybeBinReduceFallback);\n}\n\nfunction maybeBinReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n    case \"z\":\n      return _group_js__WEBPACK_IMPORTED_MODULE_3__.reduceZ;\n  }\n  throw new Error(`invalid bin reduce: ${reduce}`);\n}\n\nfunction thresholdAuto(values, min, max) {\n  return Math.min(200, (0,d3__WEBPACK_IMPORTED_MODULE_0__.thresholdScott)(values, min, max));\n}\n\nfunction isTimeThresholds(t) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTimeInterval)(t) || ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isIterable)(t) && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(t));\n}\n\nfunction bing(bx, by, data) {\n  const EX = bx?.(data);\n  const EY = by?.(data);\n  return EX && EY\n    ? function* (I) {\n        const X = EX.bin(I); // first bin on x\n        for (const [ix, [x1, x2]] of EX.entries()) {\n          const Y = EY.bin(X[ix]); // then bin on y\n          for (const [iy, [y1, y2]] of EY.entries()) {\n            yield [Y[iy], {data, x1, y1, x2, y2}];\n          }\n        }\n      }\n    : EX\n    ? function* (I) {\n        const X = EX.bin(I);\n        for (const [i, [x1, x2]] of EX.entries()) {\n          yield [X[i], {data, x1, x2}];\n        }\n      }\n    : function* (I) {\n        const Y = EY.bin(I);\n        for (const [i, [y1, y2]] of EY.entries()) {\n          yield [Y[i], {data, y1, y2}];\n        }\n      };\n}\n\n// non-cumulative distribution\nfunction bin1(E, T, V) {\n  T = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.coerceNumbers)(T); // for faster bisection\n  return (I) => {\n    const B = E.map(() => []);\n    for (const i of I) B[(0,d3__WEBPACK_IMPORTED_MODULE_0__.bisect)(T, V[i]) - 1]?.push(i); // TODO quantization?\n    return B;\n  };\n}\n\n// cumulative distribution\nfunction bin1cp(E, T, V) {\n  const bin = bin1(E, T, V);\n  return (I) => {\n    const B = bin(I);\n    for (let i = 1, n = B.length; i < n; ++i) {\n      const C = B[i - 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\n\n// complementary cumulative distribution\nfunction bin1cn(E, T, V) {\n  const bin = bin1(E, T, V);\n  return (I) => {\n    const B = bin(I);\n    for (let i = B.length - 2; i >= 0; --i) {\n      const C = B[i + 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\n\nfunction mid1(x1, x2) {\n  const m = (+x1 + +x2) / 2;\n  return x1 instanceof Date ? new Date(m) : m;\n}\n\nconst reduceX = {\n  reduceIndex(I, X, {x1, x2}) {\n    return mid1(x1, x2);\n  }\n};\n\nconst reduceY = {\n  reduceIndex(I, X, {y1, y2}) {\n    return mid1(y1, y2);\n  }\n};\n\nconst reduceX1 = {\n  reduceIndex(I, X, {x1}) {\n    return x1;\n  }\n};\n\nconst reduceX2 = {\n  reduceIndex(I, X, {x2}) {\n    return x2;\n  }\n};\n\nconst reduceY1 = {\n  reduceIndex(I, X, {y1}) {\n    return y1;\n  }\n};\n\nconst reduceY2 = {\n  reduceIndex(I, X, {y2}) {\n    return y2;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2Jpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBU1k7QUFDdUI7QUFtQlo7QUFDZ0I7QUFDTjtBQWNiO0FBQ2dDOztBQUVwRCxhQUFhLGdCQUFnQjtBQUN0Qix5QkFBeUIsV0FBVyxjQUFjO0FBQ3pEO0FBQ0EsU0FBUyxNQUFNO0FBQ2Ysd0NBQXdDLGlEQUFRLDJCQUEyQixzREFBVztBQUN0Rjs7QUFFQSxhQUFhLGdCQUFnQjtBQUN0Qix5QkFBeUIsV0FBVyxjQUFjO0FBQ3pEO0FBQ0EsU0FBUyxNQUFNO0FBQ2YsOENBQThDLGlEQUFRLHFCQUFxQixzREFBVztBQUN0Rjs7QUFFQSxhQUFhLGdCQUFnQjtBQUN0Qix3QkFBd0IsY0FBYyxjQUFjO0FBQzNEO0FBQ0EsU0FBUyxNQUFNO0FBQ2YseUNBQXlDLHNEQUFXLENBQUMsc0RBQVc7QUFDaEU7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0EsU0FBUyxTQUFTLGtEQUFXLEVBQUU7QUFDL0IsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCLEVBQUUsd0JBQXdCLEVBQUU7QUFDN0MsaUJBQWlCLEVBQUUsd0JBQXdCLEVBQUU7QUFDN0M7QUFDQTs7QUFFTyx5Q0FBeUM7QUFDaEQsdUNBQXVDLGlEQUFPO0FBQzlDOztBQUVPLHlDQUF5QztBQUNoRCx1Q0FBdUMsaURBQU87QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFjO0FBQ3JDLGFBQWEsa0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1IsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0RBQVM7QUFDN0Isb0JBQW9CLG9EQUFTOztBQUU3QjtBQUNBLHdCQUF3Qix3REFBVztBQUNuQyx3QkFBd0Isd0RBQVc7QUFDbkMsd0JBQXdCLHdEQUFXO0FBQ25DLHdCQUF3Qix3REFBVzs7QUFFbkM7QUFDQTtBQUNBLHNCQUFzQix3REFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLHdEQUFXO0FBQ2pDLGtCQUFrQiw4REFBaUI7QUFDbkMsb0JBQW9CLDhEQUFpQjtBQUNyQyxzQkFBc0Isd0RBQVc7QUFDakMsc0JBQXNCLHdEQUFXOztBQUVqQztBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLDZCQUE2QixpQkFBaUI7QUFDOUMsK0JBQStCLHFCQUFxQjtBQUNwRCxPQUFPLGdEQUFLO0FBQ1osZ0JBQWdCLCtEQUFrQixDQUFDLG9EQUFPO0FBQzFDLGdCQUFnQixvREFBTztBQUN2QixnQkFBZ0Isb0RBQU87QUFDdkIsZ0JBQWdCLG9EQUFPO0FBQ3ZCLGdCQUFnQix3REFBYSxXQUFXLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFVO0FBQ3ZDLCtCQUErQixxREFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFTO0FBQ2YsY0FBYztBQUNkLEtBQUs7QUFDTCxTQUFTLG9EQUFTLDBCQUEwQixxQkFBcUIsZ0RBQUcsWUFBWSxHQUFHLFVBQVU7QUFDN0YsU0FBUyxvREFBUywwQkFBMEIscUJBQXFCLGdEQUFHLFlBQVksR0FBRyxVQUFVO0FBQzdGLGVBQWUsU0FBUztBQUN4Qix3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RCx1QkFBdUIscURBQXFEO0FBQzVFLG9CQUFvQixxREFBcUQ7QUFDekU7O0FBRUEsK0JBQStCLHlDQUF5QztBQUN4RSxXQUFXLEdBQUcsdURBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVU7QUFDakMsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixzQ0FBTSxjQUFjO0FBQ3pEO0FBQ0EsWUFBWSxvREFBTztBQUNuQixXQUFXO0FBQ1gsUUFBUSx1REFBVTtBQUNsQixVQUFVLGdEQUFHLElBQUksbURBQVUsaUJBQWlCO0FBQzVDO0FBQ0EsbURBQW1ELHVEQUFVO0FBQzdELHFDQUFxQyxtREFBZTtBQUNwRCxVQUFVLHVEQUFVO0FBQ3BCLHVCQUF1QixzQ0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSwwREFBYTtBQUN2QjtBQUNBLG1EQUFtRCx1REFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBTTtBQUM3QixxQkFBcUIsaURBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyx5Q0FBSztBQUNuQjtBQUNBLFFBQVEsU0FBUyx1REFBVTtBQUMzQix1QkFBdUIsc0NBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFPO0FBQ3JCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLHdEQUF3RCwrREFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUF5QjtBQUN4QztBQUNBLGVBQWUsOENBQWM7QUFDN0I7QUFDQSxlQUFlLGdEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFXO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsU0FBUyx1REFBWTtBQUNyQjs7QUFFQTtBQUNBLFNBQVMsc0RBQVc7QUFDcEI7O0FBRUE7QUFDQSxTQUFTLHlEQUFjO0FBQ3ZCOztBQUVBO0FBQ0EsU0FBUyxzREFBVztBQUNwQjs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQU87QUFDcEI7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDs7QUFFQTtBQUNBLHVCQUF1QixrREFBYztBQUNyQzs7QUFFQTtBQUNBLFNBQVMsMkRBQWMsUUFBUSx1REFBVSxPQUFPLHVEQUFVO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwwREFBYSxLQUFLO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU0seUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2Jpbi5qcz84ZDQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGJpc2VjdCxcbiAgZXh0ZW50LFxuICB0aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzLFxuICB0aHJlc2hvbGRTY290dCxcbiAgdGhyZXNob2xkU3R1cmdlcyxcbiAgdGlja0luY3JlbWVudCxcbiAgdGlja3MsXG4gIHV0Y1RpY2tJbnRlcnZhbFxufSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7d2l0aFRpcH0gZnJvbSBcIi4uL21hcmsuanNcIjtcbmltcG9ydCB7XG4gIGNvZXJjZURhdGUsXG4gIGNvZXJjZU51bWJlcnMsXG4gIGlkZW50aXR5LFxuICBpc0ludGVydmFsLFxuICBpc0l0ZXJhYmxlLFxuICBpc1RlbXBvcmFsLFxuICBpc1RpbWVJbnRlcnZhbCxcbiAgbGFiZWxvZixcbiAgbWFwLFxuICBtYXliZUFwcGx5SW50ZXJ2YWwsXG4gIG1heWJlQ29sb3JDaGFubmVsLFxuICBtYXliZUNvbHVtbixcbiAgbWF5YmVSYW5nZUludGVydmFsLFxuICBtYXliZVR1cGxlLFxuICBtYXliZVZhbHVlLFxuICBtaWQsXG4gIHZhbHVlb2Zcbn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7dXRjSW50ZXJ2YWx9IGZyb20gXCIuLi90aW1lLmpzXCI7XG5pbXBvcnQge2Jhc2ljfSBmcm9tIFwiLi9iYXNpYy5qc1wiO1xuaW1wb3J0IHtcbiAgaGFzT3V0cHV0LFxuICBtYXliZUV2YWx1YXRvcixcbiAgbWF5YmVHcm91cCxcbiAgbWF5YmVPdXRwdXQsXG4gIG1heWJlT3V0cHV0cyxcbiAgbWF5YmVSZWR1Y2UsXG4gIG1heWJlU29ydCxcbiAgbWF5YmVTdWJncm91cCxcbiAgcmVkdWNlQ291bnQsXG4gIHJlZHVjZUZpcnN0LFxuICByZWR1Y2VJZGVudGl0eSxcbiAgcmVkdWNlWlxufSBmcm9tIFwiLi9ncm91cC5qc1wiO1xuaW1wb3J0IHttYXliZUluc2V0WCwgbWF5YmVJbnNldFl9IGZyb20gXCIuL2luc2V0LmpzXCI7XG5cbi8vIEdyb3VwIG9uIHt6LCBmaWxsLCBzdHJva2V9LCB0aGVuIG9wdGlvbmFsbHkgb24geSwgdGhlbiBiaW4geC5cbmV4cG9ydCBmdW5jdGlvbiBiaW5YKG91dHB1dHMgPSB7eTogXCJjb3VudFwifSwgb3B0aW9ucyA9IHt9KSB7XG4gIFtvdXRwdXRzLCBvcHRpb25zXSA9IG1lcmdlT3B0aW9ucyhvdXRwdXRzLCBvcHRpb25zKTtcbiAgY29uc3Qge3gsIHl9ID0gb3B0aW9ucztcbiAgcmV0dXJuIGJpbm4obWF5YmVCaW5WYWx1ZSh4LCBvcHRpb25zLCBpZGVudGl0eSksIG51bGwsIG51bGwsIHksIG91dHB1dHMsIG1heWJlSW5zZXRYKG9wdGlvbnMpKTtcbn1cblxuLy8gR3JvdXAgb24ge3osIGZpbGwsIHN0cm9rZX0sIHRoZW4gb3B0aW9uYWxseSBvbiB4LCB0aGVuIGJpbiB5LlxuZXhwb3J0IGZ1bmN0aW9uIGJpblkob3V0cHV0cyA9IHt4OiBcImNvdW50XCJ9LCBvcHRpb25zID0ge30pIHtcbiAgW291dHB1dHMsIG9wdGlvbnNdID0gbWVyZ2VPcHRpb25zKG91dHB1dHMsIG9wdGlvbnMpO1xuICBjb25zdCB7eCwgeX0gPSBvcHRpb25zO1xuICByZXR1cm4gYmlubihudWxsLCBtYXliZUJpblZhbHVlKHksIG9wdGlvbnMsIGlkZW50aXR5KSwgeCwgbnVsbCwgb3V0cHV0cywgbWF5YmVJbnNldFkob3B0aW9ucykpO1xufVxuXG4vLyBHcm91cCBvbiB7eiwgZmlsbCwgc3Ryb2tlfSwgdGhlbiBiaW4gb24geCBhbmQgeS5cbmV4cG9ydCBmdW5jdGlvbiBiaW4ob3V0cHV0cyA9IHtmaWxsOiBcImNvdW50XCJ9LCBvcHRpb25zID0ge30pIHtcbiAgW291dHB1dHMsIG9wdGlvbnNdID0gbWVyZ2VPcHRpb25zKG91dHB1dHMsIG9wdGlvbnMpO1xuICBjb25zdCB7eCwgeX0gPSBtYXliZUJpblZhbHVlVHVwbGUob3B0aW9ucyk7XG4gIHJldHVybiBiaW5uKHgsIHksIG51bGwsIG51bGwsIG91dHB1dHMsIG1heWJlSW5zZXRYKG1heWJlSW5zZXRZKG9wdGlvbnMpKSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlRGVuc2VJbnRlcnZhbChiaW4sIGssIG9wdGlvbnMgPSB7fSkge1xuICBpZiAob3B0aW9ucz8uaW50ZXJ2YWwgPT0gbnVsbCkgcmV0dXJuIG9wdGlvbnM7XG4gIGNvbnN0IHtyZWR1Y2UgPSByZWR1Y2VGaXJzdH0gPSBvcHRpb25zO1xuICBjb25zdCBvdXRwdXRzID0ge2ZpbHRlcjogbnVsbH07XG4gIGlmIChvcHRpb25zW2tdICE9IG51bGwpIG91dHB1dHNba10gPSByZWR1Y2U7XG4gIGlmIChvcHRpb25zW2Ake2t9MWBdICE9IG51bGwpIG91dHB1dHNbYCR7a30xYF0gPSByZWR1Y2U7XG4gIGlmIChvcHRpb25zW2Ake2t9MmBdICE9IG51bGwpIG91dHB1dHNbYCR7a30yYF0gPSByZWR1Y2U7XG4gIHJldHVybiBiaW4ob3V0cHV0cywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZURlbnNlSW50ZXJ2YWxYKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbWF5YmVEZW5zZUludGVydmFsKGJpblgsIFwieVwiLCB3aXRoVGlwKG9wdGlvbnMsIFwieFwiKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZURlbnNlSW50ZXJ2YWxZKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbWF5YmVEZW5zZUludGVydmFsKGJpblksIFwieFwiLCB3aXRoVGlwKG9wdGlvbnMsIFwieVwiKSk7XG59XG5cbmZ1bmN0aW9uIGJpbm4oXG4gIGJ4LCAvLyBvcHRpb25hbGx5IGJpbiBvbiB4IChleGNsdXNpdmUgd2l0aCBneClcbiAgYnksIC8vIG9wdGlvbmFsbHkgYmluIG9uIHkgKGV4Y2x1c2l2ZSB3aXRoIGd5KVxuICBneCwgLy8gb3B0aW9uYWxseSBncm91cCBvbiB4IChleGNsdXNpdmUgd2l0aCBieCBhbmQgZ3kpXG4gIGd5LCAvLyBvcHRpb25hbGx5IGdyb3VwIG9uIHkgKGV4Y2x1c2l2ZSB3aXRoIGJ5IGFuZCBneClcbiAge1xuICAgIGRhdGE6IHJlZHVjZURhdGEgPSByZWR1Y2VJZGVudGl0eSwgLy8gVE9ETyBhdm9pZCBtYXRlcmlhbGl6aW5nIHdoZW4gdW51c2VkP1xuICAgIGZpbHRlciA9IHJlZHVjZUNvdW50LCAvLyByZXR1cm4gb25seSBub24tZW1wdHkgYmlucyBieSBkZWZhdWx0XG4gICAgc29ydCxcbiAgICByZXZlcnNlLFxuICAgIC4uLm91dHB1dHMgLy8gb3V0cHV0IGNoYW5uZWwgZGVmaW5pdGlvbnNcbiAgfSA9IHt9LFxuICBpbnB1dHMgPSB7fSAvLyBpbnB1dCBjaGFubmVscyBhbmQgb3B0aW9uc1xuKSB7XG4gIGJ4ID0gbWF5YmVCaW4oYngpO1xuICBieSA9IG1heWJlQmluKGJ5KTtcblxuICAvLyBDb21wdXRlIHRoZSBvdXRwdXRzLlxuICBvdXRwdXRzID0gbWF5YmVCaW5PdXRwdXRzKG91dHB1dHMsIGlucHV0cyk7XG4gIHJlZHVjZURhdGEgPSBtYXliZUJpblJlZHVjZShyZWR1Y2VEYXRhLCBpZGVudGl0eSk7XG4gIHNvcnQgPSBzb3J0ID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXliZUJpbk91dHB1dChcInNvcnRcIiwgc29ydCwgaW5wdXRzKTtcbiAgZmlsdGVyID0gZmlsdGVyID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXliZUJpbkV2YWx1YXRvcihcImZpbHRlclwiLCBmaWx0ZXIsIGlucHV0cyk7XG5cbiAgLy8gRG9u4oCZdCBncm91cCBvbiBhIGNoYW5uZWwgaWYgYW4gb3V0cHV0IHJlcXVpcmVzIGl0IGFzIGFuIGlucHV0IVxuICBpZiAoZ3ggIT0gbnVsbCAmJiBoYXNPdXRwdXQob3V0cHV0cywgXCJ4XCIsIFwieDFcIiwgXCJ4MlwiKSkgZ3ggPSBudWxsO1xuICBpZiAoZ3kgIT0gbnVsbCAmJiBoYXNPdXRwdXQob3V0cHV0cywgXCJ5XCIsIFwieTFcIiwgXCJ5MlwiKSkgZ3kgPSBudWxsO1xuXG4gIC8vIFByb2R1Y2UgeDEsIHgyLCB5MSwgYW5kIHkyIG91dHB1dCBjaGFubmVscyBhcyBhcHByb3ByaWF0ZSAod2hlbiBiaW5uaW5nKS5cbiAgY29uc3QgW0JYMSwgc2V0QlgxXSA9IG1heWJlQ29sdW1uKGJ4KTtcbiAgY29uc3QgW0JYMiwgc2V0QlgyXSA9IG1heWJlQ29sdW1uKGJ4KTtcbiAgY29uc3QgW0JZMSwgc2V0QlkxXSA9IG1heWJlQ29sdW1uKGJ5KTtcbiAgY29uc3QgW0JZMiwgc2V0QlkyXSA9IG1heWJlQ29sdW1uKGJ5KTtcblxuICAvLyBQcm9kdWNlIHggb3IgeSBvdXRwdXQgY2hhbm5lbHMgYXMgYXBwcm9wcmlhdGUgKHdoZW4gZ3JvdXBpbmcpLlxuICBjb25zdCBbaywgZ2tdID0gZ3ggIT0gbnVsbCA/IFtneCwgXCJ4XCJdIDogZ3kgIT0gbnVsbCA/IFtneSwgXCJ5XCJdIDogW107XG4gIGNvbnN0IFtHSywgc2V0R0tdID0gbWF5YmVDb2x1bW4oayk7XG5cbiAgLy8gR3JlZWRpbHkgbWF0ZXJpYWxpemUgdGhlIHosIGZpbGwsIGFuZCBzdHJva2UgY2hhbm5lbHMgKGlmIGNoYW5uZWxzIGFuZCBub3RcbiAgLy8gY29uc3RhbnRzKSBzbyB0aGF0IHdlIGNhbiByZWZlcmVuY2UgdGhlbSBmb3Igc3ViZGl2aWRpbmcgZ3JvdXBzIHdpdGhvdXRcbiAgLy8gY29tcHV0aW5nIHRoZW0gbW9yZSB0aGFuIG9uY2UuIFdlIGFsc28gd2FudCB0byBjb25zdW1lIG9wdGlvbnMgdGhhdCBzaG91bGRcbiAgLy8gb25seSBhcHBseSB0byB0aGlzIHRyYW5zZm9ybSByYXRoZXIgdGhhbiBwYXNzaW5nIHRoZW0gdGhyb3VnaCB0byB0aGUgbmV4dC5cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB6LFxuICAgIGZpbGwsXG4gICAgc3Ryb2tlLFxuICAgIHgxLFxuICAgIHgyLCAvLyBjb25zdW1lZCBpZiB4IGlzIGFuIG91dHB1dFxuICAgIHkxLFxuICAgIHkyLCAvLyBjb25zdW1lZCBpZiB5IGlzIGFuIG91dHB1dFxuICAgIGRvbWFpbixcbiAgICBjdW11bGF0aXZlLFxuICAgIHRocmVzaG9sZHMsXG4gICAgaW50ZXJ2YWwsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0gaW5wdXRzO1xuICBjb25zdCBbR1osIHNldEdaXSA9IG1heWJlQ29sdW1uKHopO1xuICBjb25zdCBbdmZpbGxdID0gbWF5YmVDb2xvckNoYW5uZWwoZmlsbCk7XG4gIGNvbnN0IFt2c3Ryb2tlXSA9IG1heWJlQ29sb3JDaGFubmVsKHN0cm9rZSk7XG4gIGNvbnN0IFtHRiwgc2V0R0ZdID0gbWF5YmVDb2x1bW4odmZpbGwpO1xuICBjb25zdCBbR1MsIHNldEdTXSA9IG1heWJlQ29sdW1uKHZzdHJva2UpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uKFwielwiIGluIGlucHV0cyAmJiB7ejogR1ogfHwgen0pLFxuICAgIC4uLihcImZpbGxcIiBpbiBpbnB1dHMgJiYge2ZpbGw6IEdGIHx8IGZpbGx9KSxcbiAgICAuLi4oXCJzdHJva2VcIiBpbiBpbnB1dHMgJiYge3N0cm9rZTogR1MgfHwgc3Ryb2tlfSksXG4gICAgLi4uYmFzaWMob3B0aW9ucywgKGRhdGEsIGZhY2V0cywgcGxvdE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IEsgPSBtYXliZUFwcGx5SW50ZXJ2YWwodmFsdWVvZihkYXRhLCBrKSwgcGxvdE9wdGlvbnM/Lltna10pO1xuICAgICAgY29uc3QgWiA9IHZhbHVlb2YoZGF0YSwgeik7XG4gICAgICBjb25zdCBGID0gdmFsdWVvZihkYXRhLCB2ZmlsbCk7XG4gICAgICBjb25zdCBTID0gdmFsdWVvZihkYXRhLCB2c3Ryb2tlKTtcbiAgICAgIGNvbnN0IEcgPSBtYXliZVN1Ymdyb3VwKG91dHB1dHMsIHt6OiBaLCBmaWxsOiBGLCBzdHJva2U6IFN9KTtcbiAgICAgIGNvbnN0IGdyb3VwRmFjZXRzID0gW107XG4gICAgICBjb25zdCBncm91cERhdGEgPSBbXTtcbiAgICAgIGNvbnN0IEdLID0gSyAmJiBzZXRHSyhbXSk7XG4gICAgICBjb25zdCBHWiA9IFogJiYgc2V0R1ooW10pO1xuICAgICAgY29uc3QgR0YgPSBGICYmIHNldEdGKFtdKTtcbiAgICAgIGNvbnN0IEdTID0gUyAmJiBzZXRHUyhbXSk7XG4gICAgICBjb25zdCBCWDEgPSBieCAmJiBzZXRCWDEoW10pO1xuICAgICAgY29uc3QgQlgyID0gYnggJiYgc2V0QlgyKFtdKTtcbiAgICAgIGNvbnN0IEJZMSA9IGJ5ICYmIHNldEJZMShbXSk7XG4gICAgICBjb25zdCBCWTIgPSBieSAmJiBzZXRCWTIoW10pO1xuICAgICAgY29uc3QgYmluID0gYmluZyhieCwgYnksIGRhdGEpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIG8uaW5pdGlhbGl6ZShkYXRhKTtcbiAgICAgIGlmIChzb3J0KSBzb3J0LmluaXRpYWxpemUoZGF0YSk7XG4gICAgICBpZiAoZmlsdGVyKSBmaWx0ZXIuaW5pdGlhbGl6ZShkYXRhKTtcbiAgICAgIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwRmFjZXQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIG8uc2NvcGUoXCJmYWNldFwiLCBmYWNldCk7XG4gICAgICAgIGlmIChzb3J0KSBzb3J0LnNjb3BlKFwiZmFjZXRcIiwgZmFjZXQpO1xuICAgICAgICBpZiAoZmlsdGVyKSBmaWx0ZXIuc2NvcGUoXCJmYWNldFwiLCBmYWNldCk7XG4gICAgICAgIGZvciAoY29uc3QgW2YsIEldIG9mIG1heWJlR3JvdXAoZmFjZXQsIEcpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbaywgZ10gb2YgbWF5YmVHcm91cChJLCBLKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYiwgZXh0ZW50XSBvZiBiaW4oZykpIHtcbiAgICAgICAgICAgICAgaWYgKEcpIGV4dGVudC56ID0gZjtcbiAgICAgICAgICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLnJlZHVjZShiLCBleHRlbnQpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgZ3JvdXBGYWNldC5wdXNoKGkrKyk7XG4gICAgICAgICAgICAgIGdyb3VwRGF0YS5wdXNoKHJlZHVjZURhdGEucmVkdWNlSW5kZXgoYiwgZGF0YSwgZXh0ZW50KSk7XG4gICAgICAgICAgICAgIGlmIChLKSBHSy5wdXNoKGspO1xuICAgICAgICAgICAgICBpZiAoWikgR1oucHVzaChHID09PSBaID8gZiA6IFpbKGIubGVuZ3RoID4gMCA/IGIgOiBnKVswXV0pO1xuICAgICAgICAgICAgICBpZiAoRikgR0YucHVzaChHID09PSBGID8gZiA6IEZbKGIubGVuZ3RoID4gMCA/IGIgOiBnKVswXV0pO1xuICAgICAgICAgICAgICBpZiAoUykgR1MucHVzaChHID09PSBTID8gZiA6IFNbKGIubGVuZ3RoID4gMCA/IGIgOiBnKVswXV0pO1xuICAgICAgICAgICAgICBpZiAoQlgxKSBCWDEucHVzaChleHRlbnQueDEpLCBCWDIucHVzaChleHRlbnQueDIpO1xuICAgICAgICAgICAgICBpZiAoQlkxKSBCWTEucHVzaChleHRlbnQueTEpLCBCWTIucHVzaChleHRlbnQueTIpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG8gb2Ygb3V0cHV0cykgby5yZWR1Y2UoYiwgZXh0ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHNvcnQpIHNvcnQucmVkdWNlKGIsIGV4dGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdyb3VwRmFjZXRzLnB1c2goZ3JvdXBGYWNldCk7XG4gICAgICB9XG4gICAgICBtYXliZVNvcnQoZ3JvdXBGYWNldHMsIHNvcnQsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIHtkYXRhOiBncm91cERhdGEsIGZhY2V0czogZ3JvdXBGYWNldHN9O1xuICAgIH0pLFxuICAgIC4uLighaGFzT3V0cHV0KG91dHB1dHMsIFwieFwiKSAmJiAoQlgxID8ge3gxOiBCWDEsIHgyOiBCWDIsIHg6IG1pZChCWDEsIEJYMil9IDoge3gsIHgxLCB4Mn0pKSxcbiAgICAuLi4oIWhhc091dHB1dChvdXRwdXRzLCBcInlcIikgJiYgKEJZMSA/IHt5MTogQlkxLCB5MjogQlkyLCB5OiBtaWQoQlkxLCBCWTIpfSA6IHt5LCB5MSwgeTJ9KSksXG4gICAgLi4uKEdLICYmIHtbZ2tdOiBHS30pLFxuICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhvdXRwdXRzLm1hcCgoe25hbWUsIG91dHB1dH0pID0+IFtuYW1lLCBvdXRwdXRdKSlcbiAgfTtcbn1cblxuLy8gQWxsb3cgYmluIG9wdGlvbnMgdG8gYmUgc3BlY2lmaWVkIGFzIHBhcnQgb2Ygb3V0cHV0czsgbWVyZ2UgdGhlbSBpbnRvIG9wdGlvbnMuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoe2N1bXVsYXRpdmUsIGRvbWFpbiwgdGhyZXNob2xkcywgaW50ZXJ2YWwsIC4uLm91dHB1dHN9LCBvcHRpb25zKSB7XG4gIHJldHVybiBbb3V0cHV0cywge2N1bXVsYXRpdmUsIGRvbWFpbiwgdGhyZXNob2xkcywgaW50ZXJ2YWwsIC4uLm9wdGlvbnN9XTtcbn1cblxuZnVuY3Rpb24gbWF5YmVCaW5WYWx1ZSh2YWx1ZSwge2N1bXVsYXRpdmUsIGRvbWFpbiwgdGhyZXNob2xkcywgaW50ZXJ2YWx9LCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFsdWUgPSB7Li4ubWF5YmVWYWx1ZSh2YWx1ZSl9O1xuICBpZiAodmFsdWUuZG9tYWluID09PSB1bmRlZmluZWQpIHZhbHVlLmRvbWFpbiA9IGRvbWFpbjtcbiAgaWYgKHZhbHVlLmN1bXVsYXRpdmUgPT09IHVuZGVmaW5lZCkgdmFsdWUuY3VtdWxhdGl2ZSA9IGN1bXVsYXRpdmU7XG4gIGlmICh2YWx1ZS50aHJlc2hvbGRzID09PSB1bmRlZmluZWQpIHZhbHVlLnRocmVzaG9sZHMgPSB0aHJlc2hvbGRzO1xuICBpZiAodmFsdWUuaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCkgdmFsdWUuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgaWYgKHZhbHVlLnZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB2YWx1ZS50aHJlc2hvbGRzID0gbWF5YmVUaHJlc2hvbGRzKHZhbHVlLnRocmVzaG9sZHMsIHZhbHVlLmludGVydmFsKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXliZUJpblZhbHVlVHVwbGUob3B0aW9ucykge1xuICBsZXQge3gsIHl9ID0gb3B0aW9ucztcbiAgeCA9IG1heWJlQmluVmFsdWUoeCwgb3B0aW9ucyk7XG4gIHkgPSBtYXliZUJpblZhbHVlKHksIG9wdGlvbnMpO1xuICBbeC52YWx1ZSwgeS52YWx1ZV0gPSBtYXliZVR1cGxlKHgudmFsdWUsIHkudmFsdWUpO1xuICByZXR1cm4ge3gsIHl9O1xufVxuXG5mdW5jdGlvbiBtYXliZUJpbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHJldHVybjtcbiAgY29uc3Qge3ZhbHVlLCBjdW11bGF0aXZlLCBkb21haW4gPSBleHRlbnQsIHRocmVzaG9sZHN9ID0gb3B0aW9ucztcbiAgY29uc3QgYmluID0gKGRhdGEpID0+IHtcbiAgICBsZXQgViA9IHZhbHVlb2YoZGF0YSwgdmFsdWUpO1xuICAgIGxldCBUOyAvLyBiaW4gdGhyZXNob2xkc1xuICAgIGlmIChpc1RlbXBvcmFsKFYpIHx8IGlzVGltZVRocmVzaG9sZHModGhyZXNob2xkcykpIHtcbiAgICAgIFYgPSBtYXAoViwgY29lcmNlRGF0ZSwgRmxvYXQ2NEFycmF5KTsgLy8gbGlrZSBjb2VyY2VEYXRlcywgYnV0IGZhc3RlclxuICAgICAgbGV0IFttaW4sIG1heF0gPSB0eXBlb2YgZG9tYWluID09PSBcImZ1bmN0aW9uXCIgPyBkb21haW4oVikgOiBkb21haW47XG4gICAgICBsZXQgdCA9IHR5cGVvZiB0aHJlc2hvbGRzID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzSW50ZXJ2YWwodGhyZXNob2xkcykgPyB0aHJlc2hvbGRzKFYsIG1pbiwgbWF4KSA6IHRocmVzaG9sZHM7XG4gICAgICBpZiAodHlwZW9mIHQgPT09IFwibnVtYmVyXCIpIHQgPSB1dGNUaWNrSW50ZXJ2YWwobWluLCBtYXgsIHQpO1xuICAgICAgaWYgKGlzSW50ZXJ2YWwodCkpIHtcbiAgICAgICAgaWYgKGRvbWFpbiA9PT0gZXh0ZW50KSB7XG4gICAgICAgICAgbWluID0gdC5mbG9vcihtaW4pO1xuICAgICAgICAgIG1heCA9IHQub2Zmc2V0KHQuZmxvb3IobWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHQucmFuZ2UobWluLCB0Lm9mZnNldChtYXgpKTtcbiAgICAgIH1cbiAgICAgIFQgPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBWID0gY29lcmNlTnVtYmVycyhWKTtcbiAgICAgIGxldCBbbWluLCBtYXhdID0gdHlwZW9mIGRvbWFpbiA9PT0gXCJmdW5jdGlvblwiID8gZG9tYWluKFYpIDogZG9tYWluO1xuICAgICAgbGV0IHQgPSB0eXBlb2YgdGhyZXNob2xkcyA9PT0gXCJmdW5jdGlvblwiICYmICFpc0ludGVydmFsKHRocmVzaG9sZHMpID8gdGhyZXNob2xkcyhWLCBtaW4sIG1heCkgOiB0aHJlc2hvbGRzO1xuICAgICAgaWYgKHR5cGVvZiB0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRoaXMgZGlmZmVycyBmcm9tIGQzLnRpY2tzIHdpdGggcmVnYXJkIHRvIGV4Y2x1c2l2ZSBib3VuZHM6IHdlIHdhbnQgYVxuICAgICAgICAvLyBmaXJzdCB0aHJlc2hvbGQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtaW5pbXVtLCBhbmQgYSBsYXN0XG4gICAgICAgIC8vIHRocmVzaG9sZCAoc3RyaWN0bHkpIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bS5cbiAgICAgICAgaWYgKGRvbWFpbiA9PT0gZXh0ZW50KSB7XG4gICAgICAgICAgbGV0IHN0ZXAgPSB0aWNrSW5jcmVtZW50KG1pbiwgbWF4LCB0KTtcbiAgICAgICAgICBpZiAoaXNGaW5pdGUoc3RlcCkpIHtcbiAgICAgICAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICAgICAgICBsZXQgcjAgPSBNYXRoLnJvdW5kKG1pbiAvIHN0ZXApO1xuICAgICAgICAgICAgICBsZXQgcjEgPSBNYXRoLnJvdW5kKG1heCAvIHN0ZXApO1xuICAgICAgICAgICAgICBpZiAoIShyMCAqIHN0ZXAgPD0gbWluKSkgLS1yMDtcbiAgICAgICAgICAgICAgaWYgKCEocjEgKiBzdGVwID4gbWF4KSkgKytyMTtcbiAgICAgICAgICAgICAgbGV0IG4gPSByMSAtIHIwICsgMTtcbiAgICAgICAgICAgICAgdCA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0W2ldID0gKHIwICsgaSkgKiBzdGVwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgICAgICAgICBzdGVwID0gLXN0ZXA7XG4gICAgICAgICAgICAgIGxldCByMCA9IE1hdGgucm91bmQobWluICogc3RlcCk7XG4gICAgICAgICAgICAgIGxldCByMSA9IE1hdGgucm91bmQobWF4ICogc3RlcCk7XG4gICAgICAgICAgICAgIGlmICghKHIwIC8gc3RlcCA8PSBtaW4pKSAtLXIwO1xuICAgICAgICAgICAgICBpZiAoIShyMSAvIHN0ZXAgPiBtYXgpKSArK3IxO1xuICAgICAgICAgICAgICBsZXQgbiA9IHIxIC0gcjAgKyAxO1xuICAgICAgICAgICAgICB0ID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRbaV0gPSAocjAgKyBpKSAvIHN0ZXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ID0gW21pbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQgPSBbbWluXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IHRpY2tzKG1pbiwgbWF4LCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0ludGVydmFsKHQpKSB7XG4gICAgICAgIGlmIChkb21haW4gPT09IGV4dGVudCkge1xuICAgICAgICAgIG1pbiA9IHQuZmxvb3IobWluKTtcbiAgICAgICAgICBtYXggPSB0Lm9mZnNldCh0LmZsb29yKG1heCkpO1xuICAgICAgICB9XG4gICAgICAgIHQgPSB0LnJhbmdlKG1pbiwgdC5vZmZzZXQobWF4KSk7XG4gICAgICB9XG4gICAgICBUID0gdDtcbiAgICB9XG4gICAgY29uc3QgRSA9IFtdO1xuICAgIGlmIChULmxlbmd0aCA9PT0gMSkgRS5wdXNoKFtUWzBdLCBUWzBdXSk7IC8vIGNvbGxhcHNlZCBkb21haW5cbiAgICBlbHNlIGZvciAobGV0IGkgPSAxOyBpIDwgVC5sZW5ndGg7ICsraSkgRS5wdXNoKFtUW2kgLSAxXSwgVFtpXV0pO1xuICAgIEUuYmluID0gKGN1bXVsYXRpdmUgPCAwID8gYmluMWNuIDogY3VtdWxhdGl2ZSA+IDAgPyBiaW4xY3AgOiBiaW4xKShFLCBULCBWKTtcbiAgICByZXR1cm4gRTtcbiAgfTtcbiAgYmluLmxhYmVsID0gbGFiZWxvZih2YWx1ZSk7XG4gIHJldHVybiBiaW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVRocmVzaG9sZHModGhyZXNob2xkcywgaW50ZXJ2YWwsIGRlZmF1bHRUaHJlc2hvbGRzID0gdGhyZXNob2xkQXV0bykge1xuICBpZiAodGhyZXNob2xkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGludGVydmFsID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VGhyZXNob2xkcyA6IG1heWJlUmFuZ2VJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgc3dpdGNoICh0aHJlc2hvbGRzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJmcmVlZG1hbi1kaWFjb25pc1wiOlxuICAgICAgICByZXR1cm4gdGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcztcbiAgICAgIGNhc2UgXCJzY290dFwiOlxuICAgICAgICByZXR1cm4gdGhyZXNob2xkU2NvdHQ7XG4gICAgICBjYXNlIFwic3R1cmdlc1wiOlxuICAgICAgICByZXR1cm4gdGhyZXNob2xkU3R1cmdlcztcbiAgICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRBdXRvO1xuICAgIH1cbiAgICByZXR1cm4gdXRjSW50ZXJ2YWwodGhyZXNob2xkcyk7XG4gIH1cbiAgcmV0dXJuIHRocmVzaG9sZHM7IC8vIHBhc3MgYXJyYXksIGNvdW50LCBvciBmdW5jdGlvbiB0byBiaW4udGhyZXNob2xkc1xufVxuXG5mdW5jdGlvbiBtYXliZUJpbk91dHB1dHMob3V0cHV0cywgaW5wdXRzKSB7XG4gIHJldHVybiBtYXliZU91dHB1dHMob3V0cHV0cywgaW5wdXRzLCBtYXliZUJpbk91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIG1heWJlQmluT3V0cHV0KG5hbWUsIHJlZHVjZSwgaW5wdXRzKSB7XG4gIHJldHVybiBtYXliZU91dHB1dChuYW1lLCByZWR1Y2UsIGlucHV0cywgbWF5YmVCaW5FdmFsdWF0b3IpO1xufVxuXG5mdW5jdGlvbiBtYXliZUJpbkV2YWx1YXRvcihuYW1lLCByZWR1Y2UsIGlucHV0cykge1xuICByZXR1cm4gbWF5YmVFdmFsdWF0b3IobmFtZSwgcmVkdWNlLCBpbnB1dHMsIG1heWJlQmluUmVkdWNlKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVCaW5SZWR1Y2UocmVkdWNlLCB2YWx1ZSkge1xuICByZXR1cm4gbWF5YmVSZWR1Y2UocmVkdWNlLCB2YWx1ZSwgbWF5YmVCaW5SZWR1Y2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIG1heWJlQmluUmVkdWNlRmFsbGJhY2socmVkdWNlKSB7XG4gIHN3aXRjaCAoYCR7cmVkdWNlfWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJ4XCI6XG4gICAgICByZXR1cm4gcmVkdWNlWDtcbiAgICBjYXNlIFwieDFcIjpcbiAgICAgIHJldHVybiByZWR1Y2VYMTtcbiAgICBjYXNlIFwieDJcIjpcbiAgICAgIHJldHVybiByZWR1Y2VYMjtcbiAgICBjYXNlIFwieVwiOlxuICAgICAgcmV0dXJuIHJlZHVjZVk7XG4gICAgY2FzZSBcInkxXCI6XG4gICAgICByZXR1cm4gcmVkdWNlWTE7XG4gICAgY2FzZSBcInkyXCI6XG4gICAgICByZXR1cm4gcmVkdWNlWTI7XG4gICAgY2FzZSBcInpcIjpcbiAgICAgIHJldHVybiByZWR1Y2VaO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBiaW4gcmVkdWNlOiAke3JlZHVjZX1gKTtcbn1cblxuZnVuY3Rpb24gdGhyZXNob2xkQXV0byh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbigyMDAsIHRocmVzaG9sZFNjb3R0KHZhbHVlcywgbWluLCBtYXgpKTtcbn1cblxuZnVuY3Rpb24gaXNUaW1lVGhyZXNob2xkcyh0KSB7XG4gIHJldHVybiBpc1RpbWVJbnRlcnZhbCh0KSB8fCAoaXNJdGVyYWJsZSh0KSAmJiBpc1RlbXBvcmFsKHQpKTtcbn1cblxuZnVuY3Rpb24gYmluZyhieCwgYnksIGRhdGEpIHtcbiAgY29uc3QgRVggPSBieD8uKGRhdGEpO1xuICBjb25zdCBFWSA9IGJ5Py4oZGF0YSk7XG4gIHJldHVybiBFWCAmJiBFWVxuICAgID8gZnVuY3Rpb24qIChJKSB7XG4gICAgICAgIGNvbnN0IFggPSBFWC5iaW4oSSk7IC8vIGZpcnN0IGJpbiBvbiB4XG4gICAgICAgIGZvciAoY29uc3QgW2l4LCBbeDEsIHgyXV0gb2YgRVguZW50cmllcygpKSB7XG4gICAgICAgICAgY29uc3QgWSA9IEVZLmJpbihYW2l4XSk7IC8vIHRoZW4gYmluIG9uIHlcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpeSwgW3kxLCB5Ml1dIG9mIEVZLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgeWllbGQgW1lbaXldLCB7ZGF0YSwgeDEsIHkxLCB4MiwgeTJ9XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IEVYXG4gICAgPyBmdW5jdGlvbiogKEkpIHtcbiAgICAgICAgY29uc3QgWCA9IEVYLmJpbihJKTtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgW3gxLCB4Ml1dIG9mIEVYLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtYW2ldLCB7ZGF0YSwgeDEsIHgyfV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uKiAoSSkge1xuICAgICAgICBjb25zdCBZID0gRVkuYmluKEkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCBbeTEsIHkyXV0gb2YgRVkuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW1lbaV0sIHtkYXRhLCB5MSwgeTJ9XTtcbiAgICAgICAgfVxuICAgICAgfTtcbn1cblxuLy8gbm9uLWN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uXG5mdW5jdGlvbiBiaW4xKEUsIFQsIFYpIHtcbiAgVCA9IGNvZXJjZU51bWJlcnMoVCk7IC8vIGZvciBmYXN0ZXIgYmlzZWN0aW9uXG4gIHJldHVybiAoSSkgPT4ge1xuICAgIGNvbnN0IEIgPSBFLm1hcCgoKSA9PiBbXSk7XG4gICAgZm9yIChjb25zdCBpIG9mIEkpIEJbYmlzZWN0KFQsIFZbaV0pIC0gMV0/LnB1c2goaSk7IC8vIFRPRE8gcXVhbnRpemF0aW9uP1xuICAgIHJldHVybiBCO1xuICB9O1xufVxuXG4vLyBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvblxuZnVuY3Rpb24gYmluMWNwKEUsIFQsIFYpIHtcbiAgY29uc3QgYmluID0gYmluMShFLCBULCBWKTtcbiAgcmV0dXJuIChJKSA9PiB7XG4gICAgY29uc3QgQiA9IGJpbihJKTtcbiAgICBmb3IgKGxldCBpID0gMSwgbiA9IEIubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBDID0gQltpIC0gMV07XG4gICAgICBjb25zdCBiID0gQltpXTtcbiAgICAgIGZvciAoY29uc3QgaiBvZiBDKSBiLnB1c2goaik7XG4gICAgfVxuICAgIHJldHVybiBCO1xuICB9O1xufVxuXG4vLyBjb21wbGVtZW50YXJ5IGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uXG5mdW5jdGlvbiBiaW4xY24oRSwgVCwgVikge1xuICBjb25zdCBiaW4gPSBiaW4xKEUsIFQsIFYpO1xuICByZXR1cm4gKEkpID0+IHtcbiAgICBjb25zdCBCID0gYmluKEkpO1xuICAgIGZvciAobGV0IGkgPSBCLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBDID0gQltpICsgMV07XG4gICAgICBjb25zdCBiID0gQltpXTtcbiAgICAgIGZvciAoY29uc3QgaiBvZiBDKSBiLnB1c2goaik7XG4gICAgfVxuICAgIHJldHVybiBCO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtaWQxKHgxLCB4Mikge1xuICBjb25zdCBtID0gKCt4MSArICt4MikgLyAyO1xuICByZXR1cm4geDEgaW5zdGFuY2VvZiBEYXRlID8gbmV3IERhdGUobSkgOiBtO1xufVxuXG5jb25zdCByZWR1Y2VYID0ge1xuICByZWR1Y2VJbmRleChJLCBYLCB7eDEsIHgyfSkge1xuICAgIHJldHVybiBtaWQxKHgxLCB4Mik7XG4gIH1cbn07XG5cbmNvbnN0IHJlZHVjZVkgPSB7XG4gIHJlZHVjZUluZGV4KEksIFgsIHt5MSwgeTJ9KSB7XG4gICAgcmV0dXJuIG1pZDEoeTEsIHkyKTtcbiAgfVxufTtcblxuY29uc3QgcmVkdWNlWDEgPSB7XG4gIHJlZHVjZUluZGV4KEksIFgsIHt4MX0pIHtcbiAgICByZXR1cm4geDE7XG4gIH1cbn07XG5cbmNvbnN0IHJlZHVjZVgyID0ge1xuICByZWR1Y2VJbmRleChJLCBYLCB7eDJ9KSB7XG4gICAgcmV0dXJuIHgyO1xuICB9XG59O1xuXG5jb25zdCByZWR1Y2VZMSA9IHtcbiAgcmVkdWNlSW5kZXgoSSwgWCwge3kxfSkge1xuICAgIHJldHVybiB5MTtcbiAgfVxufTtcblxuY29uc3QgcmVkdWNlWTIgPSB7XG4gIHJlZHVjZUluZGV4KEksIFgsIHt5Mn0pIHtcbiAgICByZXR1cm4geTI7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/bin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/centroid.js":
/*!********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/centroid.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   centroid: () => (/* binding */ centroid),\n/* harmony export */   geoCentroid: () => (/* binding */ geoCentroid)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../memoize.js */ \"(ssr)/./node_modules/@observablehq/plot/src/memoize.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\nfunction centroid({geometry = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, ...options} = {}) {\n  const getG = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_2__.memoize1)((data) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, geometry));\n  return (0,_basic_js__WEBPACK_IMPORTED_MODULE_3__.initializer)(\n    // Suppress defaults for x and y since they will be computed by the initializer.\n    // Propagate the (memoized) geometry channel in case it’s still needed.\n    {...options, x: null, y: null, geometry: {transform: getG}},\n    (data, facets, channels, scales, dimensions, context) => {\n      const G = getG(data);\n      const n = G.length;\n      const X = new Float64Array(n);\n      const Y = new Float64Array(n);\n      const {centroid} = context.path();\n      for (let i = 0; i < n; ++i) [X[i], Y[i]] = centroid(G[i]);\n      return {\n        data,\n        facets,\n        channels: {x: {value: X, scale: null, source: null}, y: {value: Y, scale: null, source: null}}\n      };\n    }\n  );\n}\n\nfunction geoCentroid({geometry = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, ...options} = {}) {\n  const getG = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_2__.memoize1)((data) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, geometry));\n  const getC = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_2__.memoize1)((data) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(getG(data), d3__WEBPACK_IMPORTED_MODULE_0__.geoCentroid));\n  return {\n    ...options,\n    x: {transform: (data) => Float64Array.from(getC(data), ([x]) => x)},\n    y: {transform: (data) => Float64Array.from(getC(data), ([, y]) => y)},\n    geometry: {transform: getG}\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2NlbnRyb2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUNQO0FBQ1M7QUFDVDs7QUFFaEMsbUJBQW1CLFdBQVcsaURBQVEsY0FBYyxJQUFJO0FBQy9ELGVBQWUscURBQVEsV0FBVyxvREFBTztBQUN6QyxTQUFTLHNEQUFXO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxvQ0FBb0MsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxzQkFBc0IsV0FBVyxpREFBUSxjQUFjLElBQUk7QUFDbEUsZUFBZSxxREFBUSxXQUFXLG9EQUFPO0FBQ3pDLGVBQWUscURBQVEsV0FBVyxvREFBTyxhQUFhLDJDQUFXO0FBQ2pFO0FBQ0E7QUFDQSxRQUFRLCtEQUErRDtBQUN2RSxRQUFRLGlFQUFpRTtBQUN6RSxlQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9jZW50cm9pZC5qcz80N2IyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2VvQ2VudHJvaWQgYXMgR2VvQ2VudHJvaWR9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHttZW1vaXplMX0gZnJvbSBcIi4uL21lbW9pemUuanNcIjtcbmltcG9ydCB7aWRlbnRpdHksIHZhbHVlb2Z9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2luaXRpYWxpemVyfSBmcm9tIFwiLi9iYXNpYy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQoe2dlb21ldHJ5ID0gaWRlbnRpdHksIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgY29uc3QgZ2V0RyA9IG1lbW9pemUxKChkYXRhKSA9PiB2YWx1ZW9mKGRhdGEsIGdlb21ldHJ5KSk7XG4gIHJldHVybiBpbml0aWFsaXplcihcbiAgICAvLyBTdXBwcmVzcyBkZWZhdWx0cyBmb3IgeCBhbmQgeSBzaW5jZSB0aGV5IHdpbGwgYmUgY29tcHV0ZWQgYnkgdGhlIGluaXRpYWxpemVyLlxuICAgIC8vIFByb3BhZ2F0ZSB0aGUgKG1lbW9pemVkKSBnZW9tZXRyeSBjaGFubmVsIGluIGNhc2UgaXTigJlzIHN0aWxsIG5lZWRlZC5cbiAgICB7Li4ub3B0aW9ucywgeDogbnVsbCwgeTogbnVsbCwgZ2VvbWV0cnk6IHt0cmFuc2Zvcm06IGdldEd9fSxcbiAgICAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBHID0gZ2V0RyhkYXRhKTtcbiAgICAgIGNvbnN0IG4gPSBHLmxlbmd0aDtcbiAgICAgIGNvbnN0IFggPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgICAgY29uc3QgWSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgICBjb25zdCB7Y2VudHJvaWR9ID0gY29udGV4dC5wYXRoKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgW1hbaV0sIFlbaV1dID0gY2VudHJvaWQoR1tpXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBmYWNldHMsXG4gICAgICAgIGNoYW5uZWxzOiB7eDoge3ZhbHVlOiBYLCBzY2FsZTogbnVsbCwgc291cmNlOiBudWxsfSwgeToge3ZhbHVlOiBZLCBzY2FsZTogbnVsbCwgc291cmNlOiBudWxsfX1cbiAgICAgIH07XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VvQ2VudHJvaWQoe2dlb21ldHJ5ID0gaWRlbnRpdHksIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgY29uc3QgZ2V0RyA9IG1lbW9pemUxKChkYXRhKSA9PiB2YWx1ZW9mKGRhdGEsIGdlb21ldHJ5KSk7XG4gIGNvbnN0IGdldEMgPSBtZW1vaXplMSgoZGF0YSkgPT4gdmFsdWVvZihnZXRHKGRhdGEpLCBHZW9DZW50cm9pZCkpO1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgeDoge3RyYW5zZm9ybTogKGRhdGEpID0+IEZsb2F0NjRBcnJheS5mcm9tKGdldEMoZGF0YSksIChbeF0pID0+IHgpfSxcbiAgICB5OiB7dHJhbnNmb3JtOiAoZGF0YSkgPT4gRmxvYXQ2NEFycmF5LmZyb20oZ2V0QyhkYXRhKSwgKFssIHldKSA9PiB5KX0sXG4gICAgZ2VvbWV0cnk6IHt0cmFuc2Zvcm06IGdldEd9XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/centroid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/dodge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/dodge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dodgeX: () => (/* binding */ dodgeX),\n/* harmony export */   dodgeY: () => (/* binding */ dodgeY)\n/* harmony export */ });\n/* harmony import */ var interval_tree_1d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interval-tree-1d */ \"(ssr)/./node_modules/interval-tree-1d/interval-tree.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n\n\n\n\n\n\nconst anchorXLeft = ({marginLeft}) => [1, marginLeft];\nconst anchorXRight = ({width, marginRight}) => [-1, width - marginRight];\nconst anchorXMiddle = ({width, marginLeft, marginRight}) => [0, (marginLeft + width - marginRight) / 2];\nconst anchorYTop = ({marginTop}) => [1, marginTop];\nconst anchorYBottom = ({height, marginBottom}) => [-1, height - marginBottom];\nconst anchorYMiddle = ({height, marginTop, marginBottom}) => [0, (marginTop + height - marginBottom) / 2];\n\nfunction maybeAnchor(anchor) {\n  return typeof anchor === \"string\" ? {anchor} : anchor;\n}\n\nfunction dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {anchor = \"left\", padding = 1, r = options.r} = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(padding), r, options);\n}\n\nfunction dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {anchor = \"bottom\", padding = 1, r = options.r} = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(padding), r, options);\n}\n\nfunction mergeOptions(options) {\n  const {anchor, padding, ...rest} = options;\n  const {r} = rest; // don’t consume r; allow it to propagate\n  return [{anchor, padding, r}, rest];\n}\n\nfunction dodge(y, x, anchor, padding, r, options) {\n  if (r != null && typeof r !== \"number\") {\n    let {channels, sort, reverse} = options;\n    channels = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeNamed)(channels);\n    if (channels?.r === undefined) options = {...options, channels: {...channels, r: {value: r, scale: \"r\"}}};\n    if (sort === undefined && reverse === undefined) options.sort = {channel: \"-r\"};\n  }\n  return (0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.initializer)(options, function (data, facets, channels, scales, dimensions, context) {\n    let {[x]: X, r: R} = channels;\n    if (!channels[x]) throw new Error(`missing channel: ${x}`);\n    ({[x]: X} = (0,_projection_js__WEBPACK_IMPORTED_MODULE_3__.applyPosition)(channels, scales, context));\n    const cr = R ? undefined : r !== undefined ? (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.number)(r) : this.r !== undefined ? this.r : 3;\n    if (R) R = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(R.value, scales[R.scale] || _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, Float64Array);\n    let [ky, ty] = anchor(dimensions);\n    const compare = ky ? compareAscending : compareSymmetric;\n    const Y = new Float64Array(X.length);\n    const radius = R ? (i) => R[i] : () => cr;\n    for (let I of facets) {\n      const tree = interval_tree_1d__WEBPACK_IMPORTED_MODULE_0__();\n      I = I.filter(R ? (i) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.finite)(X[i]) && (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.positive)(R[i]) : (i) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.finite)(X[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius(i);\n        const y0 = ky ? ri + padding : 0; // offset baseline for varying radius\n        const l = X[i] - ri;\n        const h = X[i] + ri;\n\n        // The first two positions are 0 to test placing the dot on the baseline.\n        let k = 2;\n\n        // For any previously placed circles that may overlap this circle, compute\n        // the y-positions that place this circle tangent to these other circles.\n        // https://observablehq.com/@mbostock/circle-offset-along-line\n        tree.queryInterval(l - padding, h + padding, ([, , j]) => {\n          const yj = Y[j] - y0;\n          const dx = X[i] - X[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * cr);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k++] = yj - dy;\n          intervals[k++] = yj + dy;\n        });\n\n        // Find the best y-value where this circle can fit.\n        let candidates = intervals.slice(0, k);\n        if (ky) candidates = candidates.filter((y) => y >= 0);\n        out: for (const y of candidates.sort(compare)) {\n          for (let j = 0; j < k; j += 2) {\n            if (intervals[j] + 1e-6 < y && y < intervals[j + 1] - 1e-6) {\n              continue out;\n            }\n          }\n          Y[i] = y + y0;\n          break;\n        }\n\n        // Insert the placed circle into the interval tree.\n        tree.insert([l, h, i]);\n      }\n    }\n    if (!ky) ky = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y[i] = Y[i] * ky + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [y]: {value: Y, source: null}, // don’t show in tooltip\n        [x]: {value: X, source: channels[x]},\n        ...(R && {r: {value: R, source: channels.r}})\n      }\n    };\n  });\n}\n\nfunction compareSymmetric(a, b) {\n  return Math.abs(a) - Math.abs(b);\n}\n\nfunction compareAscending(a, b) {\n  return a - b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2RvZGdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDRztBQUNxQjtBQUM3QjtBQUNROztBQUUvQyxzQkFBc0IsV0FBVztBQUNqQyx1QkFBdUIsbUJBQW1CO0FBQzFDLHdCQUF3QiwrQkFBK0I7QUFDdkQscUJBQXFCLFVBQVU7QUFDL0Isd0JBQXdCLHFCQUFxQjtBQUM3Qyx3QkFBd0IsZ0NBQWdDOztBQUV4RDtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVPLGlDQUFpQyxjQUFjO0FBQ3REO0FBQ0EsT0FBTyw2Q0FBNkM7QUFDcEQsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQSxpQ0FBaUMsbURBQU07QUFDdkM7O0FBRU8saUNBQWlDLGNBQWM7QUFDdEQ7QUFDQSxPQUFPLCtDQUErQztBQUN0RCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBLGlDQUFpQyxtREFBTTtBQUN2Qzs7QUFFQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsR0FBRyxRQUFRLG9CQUFvQjtBQUN4QyxXQUFXLG1CQUFtQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEMsZUFBZSx1REFBVTtBQUN6Qiw4Q0FBOEMsdUJBQXVCLGlCQUFpQjtBQUN0RixxRUFBcUU7QUFDckU7QUFDQSxTQUFTLHNEQUFXO0FBQ3BCLFNBQVMsY0FBYztBQUN2QiwwREFBMEQsRUFBRTtBQUM1RCxNQUFNLFFBQVEsRUFBRSw2REFBYTtBQUM3QixpREFBaUQsbURBQU07QUFDdkQsZUFBZSxvREFBTyw2QkFBNkIsaURBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBWTtBQUMvQiw4QkFBOEIsbURBQU0sVUFBVSxxREFBUSxnQkFBZ0IsbURBQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsY0FBYyw4QkFBOEI7QUFDNUMsa0JBQWtCLElBQUksOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9kb2RnZS5qcz81MTkzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbnRlcnZhbFRyZWUgZnJvbSBcImludGVydmFsLXRyZWUtMWRcIjtcbmltcG9ydCB7ZmluaXRlLCBwb3NpdGl2ZX0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7aWRlbnRpdHksIG1heWJlTmFtZWQsIG51bWJlciwgdmFsdWVvZn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7aW5pdGlhbGl6ZXJ9IGZyb20gXCIuL2Jhc2ljLmpzXCI7XG5pbXBvcnQge2FwcGx5UG9zaXRpb259IGZyb20gXCIuLi9wcm9qZWN0aW9uLmpzXCI7XG5cbmNvbnN0IGFuY2hvclhMZWZ0ID0gKHttYXJnaW5MZWZ0fSkgPT4gWzEsIG1hcmdpbkxlZnRdO1xuY29uc3QgYW5jaG9yWFJpZ2h0ID0gKHt3aWR0aCwgbWFyZ2luUmlnaHR9KSA9PiBbLTEsIHdpZHRoIC0gbWFyZ2luUmlnaHRdO1xuY29uc3QgYW5jaG9yWE1pZGRsZSA9ICh7d2lkdGgsIG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0fSkgPT4gWzAsIChtYXJnaW5MZWZ0ICsgd2lkdGggLSBtYXJnaW5SaWdodCkgLyAyXTtcbmNvbnN0IGFuY2hvcllUb3AgPSAoe21hcmdpblRvcH0pID0+IFsxLCBtYXJnaW5Ub3BdO1xuY29uc3QgYW5jaG9yWUJvdHRvbSA9ICh7aGVpZ2h0LCBtYXJnaW5Cb3R0b219KSA9PiBbLTEsIGhlaWdodCAtIG1hcmdpbkJvdHRvbV07XG5jb25zdCBhbmNob3JZTWlkZGxlID0gKHtoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luQm90dG9tfSkgPT4gWzAsIChtYXJnaW5Ub3AgKyBoZWlnaHQgLSBtYXJnaW5Cb3R0b20pIC8gMl07XG5cbmZ1bmN0aW9uIG1heWJlQW5jaG9yKGFuY2hvcikge1xuICByZXR1cm4gdHlwZW9mIGFuY2hvciA9PT0gXCJzdHJpbmdcIiA/IHthbmNob3J9IDogYW5jaG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZG9kZ2VYKGRvZGdlT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIFtkb2RnZU9wdGlvbnMsIG9wdGlvbnNdID0gbWVyZ2VPcHRpb25zKGRvZGdlT3B0aW9ucyk7XG4gIGxldCB7YW5jaG9yID0gXCJsZWZ0XCIsIHBhZGRpbmcgPSAxLCByID0gb3B0aW9ucy5yfSA9IG1heWJlQW5jaG9yKGRvZGdlT3B0aW9ucyk7XG4gIHN3aXRjaCAoYCR7YW5jaG9yfWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBhbmNob3IgPSBhbmNob3JYTGVmdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgYW5jaG9yID0gYW5jaG9yWFJpZ2h0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgYW5jaG9yID0gYW5jaG9yWE1pZGRsZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gZG9kZ2UgYW5jaG9yOiAke2FuY2hvcn1gKTtcbiAgfVxuICByZXR1cm4gZG9kZ2UoXCJ4XCIsIFwieVwiLCBhbmNob3IsIG51bWJlcihwYWRkaW5nKSwgciwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb2RnZVkoZG9kZ2VPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgW2RvZGdlT3B0aW9ucywgb3B0aW9uc10gPSBtZXJnZU9wdGlvbnMoZG9kZ2VPcHRpb25zKTtcbiAgbGV0IHthbmNob3IgPSBcImJvdHRvbVwiLCBwYWRkaW5nID0gMSwgciA9IG9wdGlvbnMucn0gPSBtYXliZUFuY2hvcihkb2RnZU9wdGlvbnMpO1xuICBzd2l0Y2ggKGAke2FuY2hvcn1gLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICBhbmNob3IgPSBhbmNob3JZVG9wO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgYW5jaG9yID0gYW5jaG9yWUJvdHRvbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgIGFuY2hvciA9IGFuY2hvcllNaWRkbGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGRvZGdlIGFuY2hvcjogJHthbmNob3J9YCk7XG4gIH1cbiAgcmV0dXJuIGRvZGdlKFwieVwiLCBcInhcIiwgYW5jaG9yLCBudW1iZXIocGFkZGluZyksIHIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7YW5jaG9yLCBwYWRkaW5nLCAuLi5yZXN0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtyfSA9IHJlc3Q7IC8vIGRvbuKAmXQgY29uc3VtZSByOyBhbGxvdyBpdCB0byBwcm9wYWdhdGVcbiAgcmV0dXJuIFt7YW5jaG9yLCBwYWRkaW5nLCByfSwgcmVzdF07XG59XG5cbmZ1bmN0aW9uIGRvZGdlKHksIHgsIGFuY2hvciwgcGFkZGluZywgciwgb3B0aW9ucykge1xuICBpZiAociAhPSBudWxsICYmIHR5cGVvZiByICE9PSBcIm51bWJlclwiKSB7XG4gICAgbGV0IHtjaGFubmVscywgc29ydCwgcmV2ZXJzZX0gPSBvcHRpb25zO1xuICAgIGNoYW5uZWxzID0gbWF5YmVOYW1lZChjaGFubmVscyk7XG4gICAgaWYgKGNoYW5uZWxzPy5yID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgY2hhbm5lbHM6IHsuLi5jaGFubmVscywgcjoge3ZhbHVlOiByLCBzY2FsZTogXCJyXCJ9fX07XG4gICAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCAmJiByZXZlcnNlID09PSB1bmRlZmluZWQpIG9wdGlvbnMuc29ydCA9IHtjaGFubmVsOiBcIi1yXCJ9O1xuICB9XG4gIHJldHVybiBpbml0aWFsaXplcihvcHRpb25zLCBmdW5jdGlvbiAoZGF0YSwgZmFjZXRzLCBjaGFubmVscywgc2NhbGVzLCBkaW1lbnNpb25zLCBjb250ZXh0KSB7XG4gICAgbGV0IHtbeF06IFgsIHI6IFJ9ID0gY2hhbm5lbHM7XG4gICAgaWYgKCFjaGFubmVsc1t4XSkgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGNoYW5uZWw6ICR7eH1gKTtcbiAgICAoe1t4XTogWH0gPSBhcHBseVBvc2l0aW9uKGNoYW5uZWxzLCBzY2FsZXMsIGNvbnRleHQpKTtcbiAgICBjb25zdCBjciA9IFIgPyB1bmRlZmluZWQgOiByICE9PSB1bmRlZmluZWQgPyBudW1iZXIocikgOiB0aGlzLnIgIT09IHVuZGVmaW5lZCA/IHRoaXMuciA6IDM7XG4gICAgaWYgKFIpIFIgPSB2YWx1ZW9mKFIudmFsdWUsIHNjYWxlc1tSLnNjYWxlXSB8fCBpZGVudGl0eSwgRmxvYXQ2NEFycmF5KTtcbiAgICBsZXQgW2t5LCB0eV0gPSBhbmNob3IoZGltZW5zaW9ucyk7XG4gICAgY29uc3QgY29tcGFyZSA9IGt5ID8gY29tcGFyZUFzY2VuZGluZyA6IGNvbXBhcmVTeW1tZXRyaWM7XG4gICAgY29uc3QgWSA9IG5ldyBGbG9hdDY0QXJyYXkoWC5sZW5ndGgpO1xuICAgIGNvbnN0IHJhZGl1cyA9IFIgPyAoaSkgPT4gUltpXSA6ICgpID0+IGNyO1xuICAgIGZvciAobGV0IEkgb2YgZmFjZXRzKSB7XG4gICAgICBjb25zdCB0cmVlID0gSW50ZXJ2YWxUcmVlKCk7XG4gICAgICBJID0gSS5maWx0ZXIoUiA/IChpKSA9PiBmaW5pdGUoWFtpXSkgJiYgcG9zaXRpdmUoUltpXSkgOiAoaSkgPT4gZmluaXRlKFhbaV0pKTtcbiAgICAgIGNvbnN0IGludGVydmFscyA9IG5ldyBGbG9hdDY0QXJyYXkoMiAqIEkubGVuZ3RoICsgMik7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgSSkge1xuICAgICAgICBjb25zdCByaSA9IHJhZGl1cyhpKTtcbiAgICAgICAgY29uc3QgeTAgPSBreSA/IHJpICsgcGFkZGluZyA6IDA7IC8vIG9mZnNldCBiYXNlbGluZSBmb3IgdmFyeWluZyByYWRpdXNcbiAgICAgICAgY29uc3QgbCA9IFhbaV0gLSByaTtcbiAgICAgICAgY29uc3QgaCA9IFhbaV0gKyByaTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdHdvIHBvc2l0aW9ucyBhcmUgMCB0byB0ZXN0IHBsYWNpbmcgdGhlIGRvdCBvbiB0aGUgYmFzZWxpbmUuXG4gICAgICAgIGxldCBrID0gMjtcblxuICAgICAgICAvLyBGb3IgYW55IHByZXZpb3VzbHkgcGxhY2VkIGNpcmNsZXMgdGhhdCBtYXkgb3ZlcmxhcCB0aGlzIGNpcmNsZSwgY29tcHV0ZVxuICAgICAgICAvLyB0aGUgeS1wb3NpdGlvbnMgdGhhdCBwbGFjZSB0aGlzIGNpcmNsZSB0YW5nZW50IHRvIHRoZXNlIG90aGVyIGNpcmNsZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svY2lyY2xlLW9mZnNldC1hbG9uZy1saW5lXG4gICAgICAgIHRyZWUucXVlcnlJbnRlcnZhbChsIC0gcGFkZGluZywgaCArIHBhZGRpbmcsIChbLCAsIGpdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeWogPSBZW2pdIC0geTA7XG4gICAgICAgICAgY29uc3QgZHggPSBYW2ldIC0gWFtqXTtcbiAgICAgICAgICBjb25zdCBkciA9IHBhZGRpbmcgKyAoUiA/IFJbaV0gKyBSW2pdIDogMiAqIGNyKTtcbiAgICAgICAgICBjb25zdCBkeSA9IE1hdGguc3FydChkciAqIGRyIC0gZHggKiBkeCk7XG4gICAgICAgICAgaW50ZXJ2YWxzW2srK10gPSB5aiAtIGR5O1xuICAgICAgICAgIGludGVydmFsc1trKytdID0geWogKyBkeTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgYmVzdCB5LXZhbHVlIHdoZXJlIHRoaXMgY2lyY2xlIGNhbiBmaXQuXG4gICAgICAgIGxldCBjYW5kaWRhdGVzID0gaW50ZXJ2YWxzLnNsaWNlKDAsIGspO1xuICAgICAgICBpZiAoa3kpIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigoeSkgPT4geSA+PSAwKTtcbiAgICAgICAgb3V0OiBmb3IgKGNvbnN0IHkgb2YgY2FuZGlkYXRlcy5zb3J0KGNvbXBhcmUpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbHNbal0gKyAxZS02IDwgeSAmJiB5IDwgaW50ZXJ2YWxzW2ogKyAxXSAtIDFlLTYpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBZW2ldID0geSArIHkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBwbGFjZWQgY2lyY2xlIGludG8gdGhlIGludGVydmFsIHRyZWUuXG4gICAgICAgIHRyZWUuaW5zZXJ0KFtsLCBoLCBpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha3kpIGt5ID0gMTtcbiAgICBmb3IgKGNvbnN0IEkgb2YgZmFjZXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgSSkge1xuICAgICAgICBZW2ldID0gWVtpXSAqIGt5ICsgdHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZmFjZXRzLFxuICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgW3ldOiB7dmFsdWU6IFksIHNvdXJjZTogbnVsbH0sIC8vIGRvbuKAmXQgc2hvdyBpbiB0b29sdGlwXG4gICAgICAgIFt4XToge3ZhbHVlOiBYLCBzb3VyY2U6IGNoYW5uZWxzW3hdfSxcbiAgICAgICAgLi4uKFIgJiYge3I6IHt2YWx1ZTogUiwgc291cmNlOiBjaGFubmVscy5yfX0pXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTeW1tZXRyaWMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSkgLSBNYXRoLmFicyhiKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/dodge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exclusiveFacets: () => (/* binding */ exclusiveFacets)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n\n\nfunction exclusiveFacets(data, facets) {\n  if (facets.length === 1) return {data, facets}; // only one facet; trivially exclusive\n\n  const n = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.lengthof)(data);\n  const O = new Uint8Array(n);\n  let overlaps = 0;\n\n  // Count the number of overlapping indexes across facets.\n  for (const facet of facets) {\n    for (const i of facet) {\n      if (O[i]) ++overlaps;\n      O[i] = 1;\n    }\n  }\n\n  // Do nothing if the facets are already exclusive.\n  if (overlaps === 0) return {data, facets}; // facets are exclusive\n\n  // For each overlapping index (duplicate), assign a new unique index at the\n  // end of the existing array, duplicating the datum. For example, [[0, 1, 2],\n  // [2, 1, 3]] would become [[0, 1, 2], [4, 5, 3]]. Also attach a reindex to\n  // the data to preserve the association of channel values specified as arrays.\n  data = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.slice)(data);\n  const R = (data[_options_js__WEBPACK_IMPORTED_MODULE_0__.reindex] = new Uint32Array(n + overlaps));\n  facets = facets.map((facet) => (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.slice)(facet, Uint32Array));\n  let j = n;\n  O.fill(0);\n  for (const facet of facets) {\n    for (let k = 0, m = facet.length; k < m; ++k) {\n      const i = facet[k];\n      if (O[i]) (facet[k] = j), (data[j] = data[i]), (R[j] = i), ++j;\n      else R[i] = i;\n      O[i] = 1;\n    }\n  }\n\n  return {data, facets};\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2V4Y2x1c2l2ZUZhY2V0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDs7QUFFaEQ7QUFDUCxtQ0FBbUMsZUFBZSxtQkFBbUI7O0FBRXJFLFlBQVkscURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixlQUFlOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQUs7QUFDZCxrQkFBa0IsZ0RBQU87QUFDekIsaUNBQWlDLGtEQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3RyYW5zZm9ybXMvZXhjbHVzaXZlRmFjZXRzLmpzPzVjYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtsZW5ndGhvZiwgcmVpbmRleCwgc2xpY2V9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGNsdXNpdmVGYWNldHMoZGF0YSwgZmFjZXRzKSB7XG4gIGlmIChmYWNldHMubGVuZ3RoID09PSAxKSByZXR1cm4ge2RhdGEsIGZhY2V0c307IC8vIG9ubHkgb25lIGZhY2V0OyB0cml2aWFsbHkgZXhjbHVzaXZlXG5cbiAgY29uc3QgbiA9IGxlbmd0aG9mKGRhdGEpO1xuICBjb25zdCBPID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIGxldCBvdmVybGFwcyA9IDA7XG5cbiAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBvdmVybGFwcGluZyBpbmRleGVzIGFjcm9zcyBmYWNldHMuXG4gIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIGZhY2V0KSB7XG4gICAgICBpZiAoT1tpXSkgKytvdmVybGFwcztcbiAgICAgIE9baV0gPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvIG5vdGhpbmcgaWYgdGhlIGZhY2V0cyBhcmUgYWxyZWFkeSBleGNsdXNpdmUuXG4gIGlmIChvdmVybGFwcyA9PT0gMCkgcmV0dXJuIHtkYXRhLCBmYWNldHN9OyAvLyBmYWNldHMgYXJlIGV4Y2x1c2l2ZVxuXG4gIC8vIEZvciBlYWNoIG92ZXJsYXBwaW5nIGluZGV4IChkdXBsaWNhdGUpLCBhc3NpZ24gYSBuZXcgdW5pcXVlIGluZGV4IGF0IHRoZVxuICAvLyBlbmQgb2YgdGhlIGV4aXN0aW5nIGFycmF5LCBkdXBsaWNhdGluZyB0aGUgZGF0dW0uIEZvciBleGFtcGxlLCBbWzAsIDEsIDJdLFxuICAvLyBbMiwgMSwgM11dIHdvdWxkIGJlY29tZSBbWzAsIDEsIDJdLCBbNCwgNSwgM11dLiBBbHNvIGF0dGFjaCBhIHJlaW5kZXggdG9cbiAgLy8gdGhlIGRhdGEgdG8gcHJlc2VydmUgdGhlIGFzc29jaWF0aW9uIG9mIGNoYW5uZWwgdmFsdWVzIHNwZWNpZmllZCBhcyBhcnJheXMuXG4gIGRhdGEgPSBzbGljZShkYXRhKTtcbiAgY29uc3QgUiA9IChkYXRhW3JlaW5kZXhdID0gbmV3IFVpbnQzMkFycmF5KG4gKyBvdmVybGFwcykpO1xuICBmYWNldHMgPSBmYWNldHMubWFwKChmYWNldCkgPT4gc2xpY2UoZmFjZXQsIFVpbnQzMkFycmF5KSk7XG4gIGxldCBqID0gbjtcbiAgTy5maWxsKDApO1xuICBmb3IgKGNvbnN0IGZhY2V0IG9mIGZhY2V0cykge1xuICAgIGZvciAobGV0IGsgPSAwLCBtID0gZmFjZXQubGVuZ3RoOyBrIDwgbTsgKytrKSB7XG4gICAgICBjb25zdCBpID0gZmFjZXRba107XG4gICAgICBpZiAoT1tpXSkgKGZhY2V0W2tdID0gaiksIChkYXRhW2pdID0gZGF0YVtpXSksIChSW2pdID0gaSksICsrajtcbiAgICAgIGVsc2UgUltpXSA9IGk7XG4gICAgICBPW2ldID0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge2RhdGEsIGZhY2V0c307XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/group.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   group: () => (/* binding */ group),\n/* harmony export */   groupX: () => (/* binding */ groupX),\n/* harmony export */   groupY: () => (/* binding */ groupY),\n/* harmony export */   groupZ: () => (/* binding */ groupZ),\n/* harmony export */   hasOutput: () => (/* binding */ hasOutput),\n/* harmony export */   maybeEvaluator: () => (/* binding */ maybeEvaluator),\n/* harmony export */   maybeGroup: () => (/* binding */ maybeGroup),\n/* harmony export */   maybeGroupOutputs: () => (/* binding */ maybeGroupOutputs),\n/* harmony export */   maybeOutput: () => (/* binding */ maybeOutput),\n/* harmony export */   maybeOutputs: () => (/* binding */ maybeOutputs),\n/* harmony export */   maybeReduce: () => (/* binding */ maybeReduce),\n/* harmony export */   maybeSort: () => (/* binding */ maybeSort),\n/* harmony export */   maybeSubgroup: () => (/* binding */ maybeSubgroup),\n/* harmony export */   reduceCount: () => (/* binding */ reduceCount),\n/* harmony export */   reduceFirst: () => (/* binding */ reduceFirst),\n/* harmony export */   reduceIdentity: () => (/* binding */ reduceIdentity),\n/* harmony export */   reduceZ: () => (/* binding */ reduceZ)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\n\n\n\n// Group on {z, fill, stroke}.\nfunction groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x.\nfunction groupX(outputs = {y: \"count\"}, options = {}) {\n  const {x = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity} = options;\n  if (x == null) throw new Error(\"missing channel: x\");\n  return groupn(x, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on y.\nfunction groupY(outputs = {x: \"count\"}, options = {}) {\n  const {y = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity} = options;\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(null, y, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x and y.\nfunction group(outputs = {fill: \"count\"}, options = {}) {\n  let {x, y} = options;\n  [x, y] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeTuple)(x, y);\n  if (x == null) throw new Error(\"missing channel: x\");\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(x, y, outputs, options);\n}\n\nfunction groupn(\n  x, // optionally group on x\n  y, // optionally group on y\n  {\n    data: reduceData = reduceIdentity,\n    filter,\n    sort,\n    reverse,\n    ...outputs // output channel definitions\n  } = {},\n  inputs = {} // input channels and options\n) {\n  // Compute the outputs.\n  outputs = maybeGroupOutputs(outputs, inputs);\n  reduceData = maybeGroupReduce(reduceData, _options_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n  sort = sort == null ? undefined : maybeGroupOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeGroupEvaluator(\"filter\", filter, inputs);\n\n  // Produce x and y output channels as appropriate.\n  const [GX, setGX] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(x);\n  const [GY, setGY] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(y);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once.\n  const {\n    z,\n    fill,\n    stroke,\n    x1,\n    x2, // consumed if x is an output\n    y1,\n    y2, // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(z);\n  const [vfill] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(fill);\n  const [vstroke] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColorChannel)(stroke);\n  const [GF, setGF] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(vfill);\n  const [GS, setGS] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(vstroke);\n\n  return {\n    ...(\"z\" in inputs && {z: GZ || z}),\n    ...(\"fill\" in inputs && {fill: GF || fill}),\n    ...(\"stroke\" in inputs && {stroke: GS || stroke}),\n    ...(0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.basic)(options, (data, facets, plotOptions) => {\n      const X = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeApplyInterval)((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, x), plotOptions?.x);\n      const Y = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeApplyInterval)((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, y), plotOptions?.y);\n      const Z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, z);\n      const F = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, vfill);\n      const S = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, vstroke);\n      const G = maybeSubgroup(outputs, {z: Z, fill: F, stroke: S});\n      const groupFacets = [];\n      const groupData = [];\n      const GX = X && setGX([]);\n      const GY = Y && setGY([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y, gg] of maybeGroup(I, Y)) {\n            for (const [x, g] of maybeGroup(gg, X)) {\n              const extent = {data};\n              if (X) extent.x = x;\n              if (Y) extent.y = y;\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(g, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(g, data, extent));\n              if (X) GX.push(x);\n              if (Y) GY.push(y);\n              if (Z) GZ.push(G === Z ? f : Z[g[0]]);\n              if (F) GF.push(G === F ? f : F[g[0]]);\n              if (S) GS.push(G === S ? f : S[g[0]]);\n              for (const o of outputs) o.reduce(g, extent);\n              if (sort) sort.reduce(g, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort, reverse);\n      return {data: groupData, facets: groupFacets};\n    }),\n    ...(!hasOutput(outputs, \"x\") && (GX ? {x: GX} : {x1, x2})),\n    ...(!hasOutput(outputs, \"y\") && (GY ? {y: GY} : {y1, y2})),\n    ...Object.fromEntries(outputs.map(({name, output}) => [name, output]))\n  };\n}\n\nfunction hasOutput(outputs, ...names) {\n  for (const {name} of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction maybeOutputs(outputs, inputs, asOutput = maybeOutput) {\n  const entries = Object.entries(outputs);\n  // Propagate standard mark channels by default.\n  if (inputs.title != null && outputs.title === undefined) entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === undefined) entries.push([\"href\", reduceFirst]);\n  return entries\n    .filter(([, reduce]) => reduce !== undefined)\n    .map(([name, reduce]) => (reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs)));\n}\n\nfunction maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {\n  let scale; // optional per-channel scale override\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(reduce) && \"reduce\" in reduce) (scale = reduce.scale), (reduce = reduce.reduce); // N.B. array.reduce\n  const evaluator = asEvaluator(name, reduce, inputs);\n  const [output, setOutput] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)(evaluator.label);\n  let O;\n  return {\n    name,\n    output: scale === undefined ? output : {value: output, scale},\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent) {\n      O.push(evaluator.reduce(I, extent));\n    }\n  };\n}\n\nfunction nullOutput(name) {\n  return {name, initialize() {}, scope() {}, reduce() {}};\n}\n\nfunction maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {\n  const input = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeInput)(name, inputs);\n  const reducer = asReduce(reduce, input);\n  let V, context;\n  return {\n    label: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.labelof)(reducer === reduceCount ? null : input, reducer.label),\n    initialize(data) {\n      V = input === undefined ? data : (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, input);\n      if (reducer.scope === \"data\") {\n        context = reducer.reduceIndex((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer.scope === scope) {\n        context = reducer.reduceIndex(I, V);\n      }\n    },\n    reduce(I, extent) {\n      return reducer.scope == null ? reducer.reduceIndex(I, V, extent) : reducer.reduceIndex(I, V, context, extent);\n    }\n  };\n}\n\nfunction maybeGroup(I, X) {\n  return X ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(I, (i) => X[i]) : [[, I]];\n}\n\nfunction maybeReduce(reduce, value, fallback = invalidReduce) {\n  if (reduce == null) return fallback(reduce);\n  if (typeof reduce.reduceIndex === \"function\") return reduce;\n  if (typeof reduce.reduce === \"function\" && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(reduce)) return reduceReduce(reduce); // N.B. array.reduce\n  if (typeof reduce === \"function\") return reduceFunction(reduce);\n  if (/^p\\d{2}$/i.test(reduce)) return reduceAccessor((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.percentile)(reduce));\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"identity\":\n      return reduceIdentity;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.deviation);\n    case \"min\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.min);\n    case \"min-index\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.minIndex);\n    case \"max\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.max);\n    case \"max-index\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.median);\n    case \"variance\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.variance);\n    case \"mode\":\n      return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.mode);\n  }\n  return fallback(reduce);\n}\n\nfunction invalidReduce(reduce) {\n  throw new Error(`invalid reduce: ${reduce}`);\n}\n\nfunction maybeGroupOutputs(outputs, inputs) {\n  return maybeOutputs(outputs, inputs, maybeGroupOutput);\n}\n\nfunction maybeGroupOutput(name, reduce, inputs) {\n  return maybeOutput(name, reduce, inputs, maybeGroupEvaluator);\n}\n\nfunction maybeGroupEvaluator(name, reduce, inputs) {\n  return maybeEvaluator(name, reduce, inputs, maybeGroupReduce);\n}\n\nfunction maybeGroupReduce(reduce, value) {\n  return maybeReduce(reduce, value, maybeGroupReduceFallback);\n}\n\nfunction maybeGroupReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"y\":\n      return reduceY;\n    case \"z\":\n      return reduceZ;\n  }\n  throw new Error(`invalid group reduce: ${reduce}`);\n}\n\nfunction maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== undefined && !outputs.some((o) => o.name === name)) {\n      return value;\n    }\n  }\n}\n\nfunction maybeSort(facets, sort, reverse) {\n  if (sort) {\n    const S = sort.output.transform();\n    const compare = (i, j) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_3__.ascendingDefined)(S[i], S[j]);\n    facets.forEach((f) => f.sort(compare));\n  }\n  if (reverse) {\n    facets.forEach((f) => f.reverse());\n  }\n}\n\nfunction reduceReduce(reduce) {\n  console.warn(\"deprecated reduce interface; implement reduceIndex instead.\");\n  return {...reduce, reduceIndex: reduce.reduce.bind(reduce)};\n}\n\nfunction reduceFunction(f) {\n  return {\n    reduceIndex(I, X, extent) {\n      return f((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.take)(X, I), extent);\n    }\n  };\n}\n\nfunction reduceAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      return f(I, (i) => X[i]);\n    }\n  };\n}\n\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      const x = f(I, (i) => X[i]);\n      return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isTemporal)(X) ? new Date(x) : x;\n    }\n  };\n}\n\nconst reduceIdentity = {\n  reduceIndex(I, X) {\n    return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.take)(X, I);\n  }\n};\n\nconst reduceFirst = {\n  reduceIndex(I, X) {\n    return X[I[0]];\n  }\n};\n\nconst reduceTitle = {\n  reduceIndex(I, X) {\n    const n = 5;\n    const groups = (0,d3__WEBPACK_IMPORTED_MODULE_0__.sort)(\n      (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollup)(\n        I,\n        (V) => V.length,\n        (i) => X[i]\n      ),\n      _options_js__WEBPACK_IMPORTED_MODULE_1__.second\n    );\n    const top = groups.slice(-n).reverse();\n    if (top.length < groups.length) {\n      const bottom = groups.slice(0, 1 - n);\n      top[n - 1] = [`… ${bottom.length.toLocaleString(\"en-US\")} more`, (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(bottom, _options_js__WEBPACK_IMPORTED_MODULE_1__.second)];\n    }\n    return top.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\n\nconst reduceLast = {\n  reduceIndex(I, X) {\n    return X[I[I.length - 1]];\n  }\n};\n\nconst reduceCount = {\n  label: \"Frequency\",\n  reduceIndex(I) {\n    return I.length;\n  }\n};\n\nconst reduceDistinct = {\n  label: \"Distinct\",\n  reduceIndex(I, X) {\n    const s = new d3__WEBPACK_IMPORTED_MODULE_0__.InternSet();\n    for (const i of I) s.add(X[i]);\n    return s.size;\n  }\n};\n\nconst reduceSum = reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.sum);\n\nfunction reduceProportion(value, scope) {\n  return value == null\n    ? {scope, label: \"Frequency\", reduceIndex: (I, V, basis = 1) => I.length / basis}\n    : {scope, reduceIndex: (I, V, basis = 1) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(I, (i) => V[i]) / basis};\n}\n\nconst reduceX = {\n  reduceIndex(I, X, {x}) {\n    return x;\n  }\n};\n\nconst reduceY = {\n  reduceIndex(I, X, {y}) {\n    return y;\n  }\n};\n\nconst reduceZ = {\n  reduceIndex(I, X, {z}) {\n    return z;\n  }\n};\n\nfunction find(test) {\n  if (typeof test !== \"function\") throw new Error(`invalid test function: ${test}`);\n  return {\n    reduceIndex(I, V, {data}) {\n      return V[I.find((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(data) ? (i) => test(data[i], i, data) : (i) => test(data.get(i), i, data))];\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2dyb3VwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDaUM7QUFDL0M7QUFDMEQ7QUFDN0M7QUFDc0M7QUFDakU7O0FBRWpDLGFBQWEsZ0JBQWdCO0FBQ3RCO0FBQ1A7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUN0QiwyQkFBMkIsV0FBVyxjQUFjO0FBQzNELFNBQVMsSUFBSSxpREFBUSxFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUN0QiwyQkFBMkIsV0FBVyxjQUFjO0FBQzNELFNBQVMsSUFBSSxpREFBUSxFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUN0QiwwQkFBMEIsY0FBYyxjQUFjO0FBQzdELE9BQU8sTUFBTTtBQUNiLFdBQVcsdURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBUTtBQUNwRDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdEQUFXO0FBQ2pDLHNCQUFzQix3REFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQix3REFBVztBQUNqQyxrQkFBa0IsOERBQWlCO0FBQ25DLG9CQUFvQiw4REFBaUI7QUFDckMsc0JBQXNCLHdEQUFXO0FBQ2pDLHNCQUFzQix3REFBVzs7QUFFakM7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyw2QkFBNkIsaUJBQWlCO0FBQzlDLCtCQUErQixxQkFBcUI7QUFDcEQsT0FBTyxnREFBSztBQUNaLGdCQUFnQiwrREFBa0IsQ0FBQyxvREFBTztBQUMxQyxnQkFBZ0IsK0RBQWtCLENBQUMsb0RBQU87QUFDMUMsZ0JBQWdCLG9EQUFPO0FBQ3ZCLGdCQUFnQixvREFBTztBQUN2QixnQkFBZ0Isb0RBQU87QUFDdkIsd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsMkNBQTJDLE9BQU8sR0FBRyxPQUFPO0FBQzVELDJDQUEyQyxPQUFPLEdBQUcsT0FBTztBQUM1RCx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBOztBQUVPO0FBQ1AsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxhQUFhO0FBQ2IsTUFBTSxxREFBUSxrRkFBa0Y7QUFDaEc7QUFDQSw4QkFBOEIsbURBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxxQkFBcUIsWUFBWTtBQUMzQzs7QUFFTztBQUNQLGdCQUFnQix1REFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsdUNBQXVDLG9EQUFPO0FBQzlDO0FBQ0Esc0NBQXNDLGtEQUFLO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxhQUFhLHlDQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxxREFBUSx1Q0FBdUM7QUFDNUY7QUFDQSxZQUFZLEVBQUUsd0NBQXdDLHVEQUFVO0FBQ2hFLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlDQUFTO0FBQ3JDO0FBQ0EsNEJBQTRCLG1DQUFHO0FBQy9CO0FBQ0EsNEJBQTRCLHdDQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLG1DQUFHO0FBQy9CO0FBQ0EsNEJBQTRCLHdDQUFRO0FBQ3BDO0FBQ0EseUNBQXlDLG9DQUFJO0FBQzdDO0FBQ0EseUNBQXlDLHNDQUFNO0FBQy9DO0FBQ0EsNEJBQTRCLHdDQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLG9DQUFJO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsOEJBQThCLDZEQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQUk7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFdBQVcsaURBQUk7QUFDZjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdDQUFJO0FBQ3ZCLE1BQU0sMENBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1Q0FBdUMsT0FBTyx1Q0FBRyxTQUFTLCtDQUFNO0FBQ3pGO0FBQ0Esd0NBQXdDLEtBQUssR0FBRyw4QkFBOEI7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1DQUFHOztBQUVwQztBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU8seUNBQXlDLHVDQUFHO0FBQ25EOztBQUVBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBOztBQUVPO0FBQ1AscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBOztBQUVPO0FBQ1AsNEVBQTRFLEtBQUs7QUFDakY7QUFDQSx1QkFBdUIsS0FBSztBQUM1QixzQkFBc0Isb0RBQU87QUFDN0I7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2dyb3VwLmpzP2Q0MGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbnRlcm5TZXQsIGdyb3VwIGFzIGdyb3VwZXIsIHJvbGx1cCwgc29ydH0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2RldmlhdGlvbiwgbWF4LCBtYXhJbmRleCwgbWVhbiwgbWVkaWFuLCBtaW4sIG1pbkluZGV4LCBtb2RlLCBzdW0sIHZhcmlhbmNlfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7YXNjZW5kaW5nRGVmaW5lZH0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7bWF5YmVBcHBseUludGVydmFsLCBtYXliZUNvbG9yQ2hhbm5lbCwgbWF5YmVDb2x1bW4sIG1heWJlSW5wdXQsIG1heWJlVHVwbGV9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0LCBpc1RlbXBvcmFsfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtjb2x1bW4sIGlkZW50aXR5LCBsYWJlbG9mLCBwZXJjZW50aWxlLCByYW5nZSwgc2Vjb25kLCB0YWtlLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtiYXNpY30gZnJvbSBcIi4vYmFzaWMuanNcIjtcblxuLy8gR3JvdXAgb24ge3osIGZpbGwsIHN0cm9rZX0uXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBaKG91dHB1dHMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdyb3VwbihudWxsLCBudWxsLCBvdXRwdXRzLCBvcHRpb25zKTtcbn1cblxuLy8gR3JvdXAgb24ge3osIGZpbGwsIHN0cm9rZX0sIHRoZW4gb24geC5cbmV4cG9ydCBmdW5jdGlvbiBncm91cFgob3V0cHV0cyA9IHt5OiBcImNvdW50XCJ9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge3ggPSBpZGVudGl0eX0gPSBvcHRpb25zO1xuICBpZiAoeCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGNoYW5uZWw6IHhcIik7XG4gIHJldHVybiBncm91cG4oeCwgbnVsbCwgb3V0cHV0cywgb3B0aW9ucyk7XG59XG5cbi8vIEdyb3VwIG9uIHt6LCBmaWxsLCBzdHJva2V9LCB0aGVuIG9uIHkuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBZKG91dHB1dHMgPSB7eDogXCJjb3VudFwifSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHt5ID0gaWRlbnRpdHl9ID0gb3B0aW9ucztcbiAgaWYgKHkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsOiB5XCIpO1xuICByZXR1cm4gZ3JvdXBuKG51bGwsIHksIG91dHB1dHMsIG9wdGlvbnMpO1xufVxuXG4vLyBHcm91cCBvbiB7eiwgZmlsbCwgc3Ryb2tlfSwgdGhlbiBvbiB4IGFuZCB5LlxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwKG91dHB1dHMgPSB7ZmlsbDogXCJjb3VudFwifSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7eCwgeX0gPSBvcHRpb25zO1xuICBbeCwgeV0gPSBtYXliZVR1cGxlKHgsIHkpO1xuICBpZiAoeCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGNoYW5uZWw6IHhcIik7XG4gIGlmICh5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hhbm5lbDogeVwiKTtcbiAgcmV0dXJuIGdyb3Vwbih4LCB5LCBvdXRwdXRzLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBuKFxuICB4LCAvLyBvcHRpb25hbGx5IGdyb3VwIG9uIHhcbiAgeSwgLy8gb3B0aW9uYWxseSBncm91cCBvbiB5XG4gIHtcbiAgICBkYXRhOiByZWR1Y2VEYXRhID0gcmVkdWNlSWRlbnRpdHksXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgcmV2ZXJzZSxcbiAgICAuLi5vdXRwdXRzIC8vIG91dHB1dCBjaGFubmVsIGRlZmluaXRpb25zXG4gIH0gPSB7fSxcbiAgaW5wdXRzID0ge30gLy8gaW5wdXQgY2hhbm5lbHMgYW5kIG9wdGlvbnNcbikge1xuICAvLyBDb21wdXRlIHRoZSBvdXRwdXRzLlxuICBvdXRwdXRzID0gbWF5YmVHcm91cE91dHB1dHMob3V0cHV0cywgaW5wdXRzKTtcbiAgcmVkdWNlRGF0YSA9IG1heWJlR3JvdXBSZWR1Y2UocmVkdWNlRGF0YSwgaWRlbnRpdHkpO1xuICBzb3J0ID0gc29ydCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWF5YmVHcm91cE91dHB1dChcInNvcnRcIiwgc29ydCwgaW5wdXRzKTtcbiAgZmlsdGVyID0gZmlsdGVyID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXliZUdyb3VwRXZhbHVhdG9yKFwiZmlsdGVyXCIsIGZpbHRlciwgaW5wdXRzKTtcblxuICAvLyBQcm9kdWNlIHggYW5kIHkgb3V0cHV0IGNoYW5uZWxzIGFzIGFwcHJvcHJpYXRlLlxuICBjb25zdCBbR1gsIHNldEdYXSA9IG1heWJlQ29sdW1uKHgpO1xuICBjb25zdCBbR1ksIHNldEdZXSA9IG1heWJlQ29sdW1uKHkpO1xuXG4gIC8vIEdyZWVkaWx5IG1hdGVyaWFsaXplIHRoZSB6LCBmaWxsLCBhbmQgc3Ryb2tlIGNoYW5uZWxzIChpZiBjaGFubmVscyBhbmQgbm90XG4gIC8vIGNvbnN0YW50cykgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIHRoZW0gZm9yIHN1YmRpdmlkaW5nIGdyb3VwcyB3aXRob3V0XG4gIC8vIGNvbXB1dGluZyB0aGVtIG1vcmUgdGhhbiBvbmNlLlxuICBjb25zdCB7XG4gICAgeixcbiAgICBmaWxsLFxuICAgIHN0cm9rZSxcbiAgICB4MSxcbiAgICB4MiwgLy8gY29uc3VtZWQgaWYgeCBpcyBhbiBvdXRwdXRcbiAgICB5MSxcbiAgICB5MiwgLy8gY29uc3VtZWQgaWYgeSBpcyBhbiBvdXRwdXRcbiAgICAuLi5vcHRpb25zXG4gIH0gPSBpbnB1dHM7XG4gIGNvbnN0IFtHWiwgc2V0R1pdID0gbWF5YmVDb2x1bW4oeik7XG4gIGNvbnN0IFt2ZmlsbF0gPSBtYXliZUNvbG9yQ2hhbm5lbChmaWxsKTtcbiAgY29uc3QgW3ZzdHJva2VdID0gbWF5YmVDb2xvckNoYW5uZWwoc3Ryb2tlKTtcbiAgY29uc3QgW0dGLCBzZXRHRl0gPSBtYXliZUNvbHVtbih2ZmlsbCk7XG4gIGNvbnN0IFtHUywgc2V0R1NdID0gbWF5YmVDb2x1bW4odnN0cm9rZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi4oXCJ6XCIgaW4gaW5wdXRzICYmIHt6OiBHWiB8fCB6fSksXG4gICAgLi4uKFwiZmlsbFwiIGluIGlucHV0cyAmJiB7ZmlsbDogR0YgfHwgZmlsbH0pLFxuICAgIC4uLihcInN0cm9rZVwiIGluIGlucHV0cyAmJiB7c3Ryb2tlOiBHUyB8fCBzdHJva2V9KSxcbiAgICAuLi5iYXNpYyhvcHRpb25zLCAoZGF0YSwgZmFjZXRzLCBwbG90T3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgWCA9IG1heWJlQXBwbHlJbnRlcnZhbCh2YWx1ZW9mKGRhdGEsIHgpLCBwbG90T3B0aW9ucz8ueCk7XG4gICAgICBjb25zdCBZID0gbWF5YmVBcHBseUludGVydmFsKHZhbHVlb2YoZGF0YSwgeSksIHBsb3RPcHRpb25zPy55KTtcbiAgICAgIGNvbnN0IFogPSB2YWx1ZW9mKGRhdGEsIHopO1xuICAgICAgY29uc3QgRiA9IHZhbHVlb2YoZGF0YSwgdmZpbGwpO1xuICAgICAgY29uc3QgUyA9IHZhbHVlb2YoZGF0YSwgdnN0cm9rZSk7XG4gICAgICBjb25zdCBHID0gbWF5YmVTdWJncm91cChvdXRwdXRzLCB7ejogWiwgZmlsbDogRiwgc3Ryb2tlOiBTfSk7XG4gICAgICBjb25zdCBncm91cEZhY2V0cyA9IFtdO1xuICAgICAgY29uc3QgZ3JvdXBEYXRhID0gW107XG4gICAgICBjb25zdCBHWCA9IFggJiYgc2V0R1goW10pO1xuICAgICAgY29uc3QgR1kgPSBZICYmIHNldEdZKFtdKTtcbiAgICAgIGNvbnN0IEdaID0gWiAmJiBzZXRHWihbXSk7XG4gICAgICBjb25zdCBHRiA9IEYgJiYgc2V0R0YoW10pO1xuICAgICAgY29uc3QgR1MgPSBTICYmIHNldEdTKFtdKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvLmluaXRpYWxpemUoZGF0YSk7XG4gICAgICBpZiAoc29ydCkgc29ydC5pbml0aWFsaXplKGRhdGEpO1xuICAgICAgaWYgKGZpbHRlcikgZmlsdGVyLmluaXRpYWxpemUoZGF0YSk7XG4gICAgICBmb3IgKGNvbnN0IGZhY2V0IG9mIGZhY2V0cykge1xuICAgICAgICBjb25zdCBncm91cEZhY2V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvLnNjb3BlKFwiZmFjZXRcIiwgZmFjZXQpO1xuICAgICAgICBpZiAoc29ydCkgc29ydC5zY29wZShcImZhY2V0XCIsIGZhY2V0KTtcbiAgICAgICAgaWYgKGZpbHRlcikgZmlsdGVyLnNjb3BlKFwiZmFjZXRcIiwgZmFjZXQpO1xuICAgICAgICBmb3IgKGNvbnN0IFtmLCBJXSBvZiBtYXliZUdyb3VwKGZhY2V0LCBHKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW3ksIGdnXSBvZiBtYXliZUdyb3VwKEksIFkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt4LCBnXSBvZiBtYXliZUdyb3VwKGdnLCBYKSkge1xuICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSB7ZGF0YX07XG4gICAgICAgICAgICAgIGlmIChYKSBleHRlbnQueCA9IHg7XG4gICAgICAgICAgICAgIGlmIChZKSBleHRlbnQueSA9IHk7XG4gICAgICAgICAgICAgIGlmIChHKSBleHRlbnQueiA9IGY7XG4gICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5yZWR1Y2UoZywgZXh0ZW50KSkgY29udGludWU7XG4gICAgICAgICAgICAgIGdyb3VwRmFjZXQucHVzaChpKyspO1xuICAgICAgICAgICAgICBncm91cERhdGEucHVzaChyZWR1Y2VEYXRhLnJlZHVjZUluZGV4KGcsIGRhdGEsIGV4dGVudCkpO1xuICAgICAgICAgICAgICBpZiAoWCkgR1gucHVzaCh4KTtcbiAgICAgICAgICAgICAgaWYgKFkpIEdZLnB1c2goeSk7XG4gICAgICAgICAgICAgIGlmIChaKSBHWi5wdXNoKEcgPT09IFogPyBmIDogWltnWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChGKSBHRi5wdXNoKEcgPT09IEYgPyBmIDogRltnWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChTKSBHUy5wdXNoKEcgPT09IFMgPyBmIDogU1tnWzBdXSk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvLnJlZHVjZShnLCBleHRlbnQpO1xuICAgICAgICAgICAgICBpZiAoc29ydCkgc29ydC5yZWR1Y2UoZywgZXh0ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBGYWNldHMucHVzaChncm91cEZhY2V0KTtcbiAgICAgIH1cbiAgICAgIG1heWJlU29ydChncm91cEZhY2V0cywgc29ydCwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4ge2RhdGE6IGdyb3VwRGF0YSwgZmFjZXRzOiBncm91cEZhY2V0c307XG4gICAgfSksXG4gICAgLi4uKCFoYXNPdXRwdXQob3V0cHV0cywgXCJ4XCIpICYmIChHWCA/IHt4OiBHWH0gOiB7eDEsIHgyfSkpLFxuICAgIC4uLighaGFzT3V0cHV0KG91dHB1dHMsIFwieVwiKSAmJiAoR1kgPyB7eTogR1l9IDoge3kxLCB5Mn0pKSxcbiAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMob3V0cHV0cy5tYXAoKHtuYW1lLCBvdXRwdXR9KSA9PiBbbmFtZSwgb3V0cHV0XSkpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPdXRwdXQob3V0cHV0cywgLi4ubmFtZXMpIHtcbiAgZm9yIChjb25zdCB7bmFtZX0gb2Ygb3V0cHV0cykge1xuICAgIGlmIChuYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlT3V0cHV0cyhvdXRwdXRzLCBpbnB1dHMsIGFzT3V0cHV0ID0gbWF5YmVPdXRwdXQpIHtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG91dHB1dHMpO1xuICAvLyBQcm9wYWdhdGUgc3RhbmRhcmQgbWFyayBjaGFubmVscyBieSBkZWZhdWx0LlxuICBpZiAoaW5wdXRzLnRpdGxlICE9IG51bGwgJiYgb3V0cHV0cy50aXRsZSA9PT0gdW5kZWZpbmVkKSBlbnRyaWVzLnB1c2goW1widGl0bGVcIiwgcmVkdWNlVGl0bGVdKTtcbiAgaWYgKGlucHV0cy5ocmVmICE9IG51bGwgJiYgb3V0cHV0cy5ocmVmID09PSB1bmRlZmluZWQpIGVudHJpZXMucHVzaChbXCJocmVmXCIsIHJlZHVjZUZpcnN0XSk7XG4gIHJldHVybiBlbnRyaWVzXG4gICAgLmZpbHRlcigoWywgcmVkdWNlXSkgPT4gcmVkdWNlICE9PSB1bmRlZmluZWQpXG4gICAgLm1hcCgoW25hbWUsIHJlZHVjZV0pID0+IChyZWR1Y2UgPT09IG51bGwgPyBudWxsT3V0cHV0KG5hbWUpIDogYXNPdXRwdXQobmFtZSwgcmVkdWNlLCBpbnB1dHMpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZU91dHB1dChuYW1lLCByZWR1Y2UsIGlucHV0cywgYXNFdmFsdWF0b3IgPSBtYXliZUV2YWx1YXRvcikge1xuICBsZXQgc2NhbGU7IC8vIG9wdGlvbmFsIHBlci1jaGFubmVsIHNjYWxlIG92ZXJyaWRlXG4gIGlmIChpc09iamVjdChyZWR1Y2UpICYmIFwicmVkdWNlXCIgaW4gcmVkdWNlKSAoc2NhbGUgPSByZWR1Y2Uuc2NhbGUpLCAocmVkdWNlID0gcmVkdWNlLnJlZHVjZSk7IC8vIE4uQi4gYXJyYXkucmVkdWNlXG4gIGNvbnN0IGV2YWx1YXRvciA9IGFzRXZhbHVhdG9yKG5hbWUsIHJlZHVjZSwgaW5wdXRzKTtcbiAgY29uc3QgW291dHB1dCwgc2V0T3V0cHV0XSA9IGNvbHVtbihldmFsdWF0b3IubGFiZWwpO1xuICBsZXQgTztcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIG91dHB1dDogc2NhbGUgPT09IHVuZGVmaW5lZCA/IG91dHB1dCA6IHt2YWx1ZTogb3V0cHV0LCBzY2FsZX0sXG4gICAgaW5pdGlhbGl6ZShkYXRhKSB7XG4gICAgICBldmFsdWF0b3IuaW5pdGlhbGl6ZShkYXRhKTtcbiAgICAgIE8gPSBzZXRPdXRwdXQoW10pO1xuICAgIH0sXG4gICAgc2NvcGUoc2NvcGUsIEkpIHtcbiAgICAgIGV2YWx1YXRvci5zY29wZShzY29wZSwgSSk7XG4gICAgfSxcbiAgICByZWR1Y2UoSSwgZXh0ZW50KSB7XG4gICAgICBPLnB1c2goZXZhbHVhdG9yLnJlZHVjZShJLCBleHRlbnQpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG51bGxPdXRwdXQobmFtZSkge1xuICByZXR1cm4ge25hbWUsIGluaXRpYWxpemUoKSB7fSwgc2NvcGUoKSB7fSwgcmVkdWNlKCkge319O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVFdmFsdWF0b3IobmFtZSwgcmVkdWNlLCBpbnB1dHMsIGFzUmVkdWNlID0gbWF5YmVSZWR1Y2UpIHtcbiAgY29uc3QgaW5wdXQgPSBtYXliZUlucHV0KG5hbWUsIGlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZXIgPSBhc1JlZHVjZShyZWR1Y2UsIGlucHV0KTtcbiAgbGV0IFYsIGNvbnRleHQ7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6IGxhYmVsb2YocmVkdWNlciA9PT0gcmVkdWNlQ291bnQgPyBudWxsIDogaW5wdXQsIHJlZHVjZXIubGFiZWwpLFxuICAgIGluaXRpYWxpemUoZGF0YSkge1xuICAgICAgViA9IGlucHV0ID09PSB1bmRlZmluZWQgPyBkYXRhIDogdmFsdWVvZihkYXRhLCBpbnB1dCk7XG4gICAgICBpZiAocmVkdWNlci5zY29wZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgY29udGV4dCA9IHJlZHVjZXIucmVkdWNlSW5kZXgocmFuZ2UoZGF0YSksIFYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2NvcGUoc2NvcGUsIEkpIHtcbiAgICAgIGlmIChyZWR1Y2VyLnNjb3BlID09PSBzY29wZSkge1xuICAgICAgICBjb250ZXh0ID0gcmVkdWNlci5yZWR1Y2VJbmRleChJLCBWKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZHVjZShJLCBleHRlbnQpIHtcbiAgICAgIHJldHVybiByZWR1Y2VyLnNjb3BlID09IG51bGwgPyByZWR1Y2VyLnJlZHVjZUluZGV4KEksIFYsIGV4dGVudCkgOiByZWR1Y2VyLnJlZHVjZUluZGV4KEksIFYsIGNvbnRleHQsIGV4dGVudCk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHcm91cChJLCBYKSB7XG4gIHJldHVybiBYID8gZ3JvdXBlcihJLCAoaSkgPT4gWFtpXSkgOiBbWywgSV1dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVSZWR1Y2UocmVkdWNlLCB2YWx1ZSwgZmFsbGJhY2sgPSBpbnZhbGlkUmVkdWNlKSB7XG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmV0dXJuIGZhbGxiYWNrKHJlZHVjZSk7XG4gIGlmICh0eXBlb2YgcmVkdWNlLnJlZHVjZUluZGV4ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiByZWR1Y2U7XG4gIGlmICh0eXBlb2YgcmVkdWNlLnJlZHVjZSA9PT0gXCJmdW5jdGlvblwiICYmIGlzT2JqZWN0KHJlZHVjZSkpIHJldHVybiByZWR1Y2VSZWR1Y2UocmVkdWNlKTsgLy8gTi5CLiBhcnJheS5yZWR1Y2VcbiAgaWYgKHR5cGVvZiByZWR1Y2UgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHJlZHVjZUZ1bmN0aW9uKHJlZHVjZSk7XG4gIGlmICgvXnBcXGR7Mn0kL2kudGVzdChyZWR1Y2UpKSByZXR1cm4gcmVkdWNlQWNjZXNzb3IocGVyY2VudGlsZShyZWR1Y2UpKTtcbiAgc3dpdGNoIChgJHtyZWR1Y2V9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImZpcnN0XCI6XG4gICAgICByZXR1cm4gcmVkdWNlRmlyc3Q7XG4gICAgY2FzZSBcImxhc3RcIjpcbiAgICAgIHJldHVybiByZWR1Y2VMYXN0O1xuICAgIGNhc2UgXCJpZGVudGl0eVwiOlxuICAgICAgcmV0dXJuIHJlZHVjZUlkZW50aXR5O1xuICAgIGNhc2UgXCJjb3VudFwiOlxuICAgICAgcmV0dXJuIHJlZHVjZUNvdW50O1xuICAgIGNhc2UgXCJkaXN0aW5jdFwiOlxuICAgICAgcmV0dXJuIHJlZHVjZURpc3RpbmN0O1xuICAgIGNhc2UgXCJzdW1cIjpcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gcmVkdWNlQ291bnQgOiByZWR1Y2VTdW07XG4gICAgY2FzZSBcInByb3BvcnRpb25cIjpcbiAgICAgIHJldHVybiByZWR1Y2VQcm9wb3J0aW9uKHZhbHVlLCBcImRhdGFcIik7XG4gICAgY2FzZSBcInByb3BvcnRpb24tZmFjZXRcIjpcbiAgICAgIHJldHVybiByZWR1Y2VQcm9wb3J0aW9uKHZhbHVlLCBcImZhY2V0XCIpO1xuICAgIGNhc2UgXCJkZXZpYXRpb25cIjpcbiAgICAgIHJldHVybiByZWR1Y2VBY2Nlc3NvcihkZXZpYXRpb24pO1xuICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgIHJldHVybiByZWR1Y2VBY2Nlc3NvcihtaW4pO1xuICAgIGNhc2UgXCJtaW4taW5kZXhcIjpcbiAgICAgIHJldHVybiByZWR1Y2VBY2Nlc3NvcihtaW5JbmRleCk7XG4gICAgY2FzZSBcIm1heFwiOlxuICAgICAgcmV0dXJuIHJlZHVjZUFjY2Vzc29yKG1heCk7XG4gICAgY2FzZSBcIm1heC1pbmRleFwiOlxuICAgICAgcmV0dXJuIHJlZHVjZUFjY2Vzc29yKG1heEluZGV4KTtcbiAgICBjYXNlIFwibWVhblwiOlxuICAgICAgcmV0dXJuIHJlZHVjZU1heWJlVGVtcG9yYWxBY2Nlc3NvcihtZWFuKTtcbiAgICBjYXNlIFwibWVkaWFuXCI6XG4gICAgICByZXR1cm4gcmVkdWNlTWF5YmVUZW1wb3JhbEFjY2Vzc29yKG1lZGlhbik7XG4gICAgY2FzZSBcInZhcmlhbmNlXCI6XG4gICAgICByZXR1cm4gcmVkdWNlQWNjZXNzb3IodmFyaWFuY2UpO1xuICAgIGNhc2UgXCJtb2RlXCI6XG4gICAgICByZXR1cm4gcmVkdWNlQWNjZXNzb3IobW9kZSk7XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrKHJlZHVjZSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRSZWR1Y2UocmVkdWNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCByZWR1Y2U6ICR7cmVkdWNlfWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHcm91cE91dHB1dHMob3V0cHV0cywgaW5wdXRzKSB7XG4gIHJldHVybiBtYXliZU91dHB1dHMob3V0cHV0cywgaW5wdXRzLCBtYXliZUdyb3VwT3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gbWF5YmVHcm91cE91dHB1dChuYW1lLCByZWR1Y2UsIGlucHV0cykge1xuICByZXR1cm4gbWF5YmVPdXRwdXQobmFtZSwgcmVkdWNlLCBpbnB1dHMsIG1heWJlR3JvdXBFdmFsdWF0b3IpO1xufVxuXG5mdW5jdGlvbiBtYXliZUdyb3VwRXZhbHVhdG9yKG5hbWUsIHJlZHVjZSwgaW5wdXRzKSB7XG4gIHJldHVybiBtYXliZUV2YWx1YXRvcihuYW1lLCByZWR1Y2UsIGlucHV0cywgbWF5YmVHcm91cFJlZHVjZSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlR3JvdXBSZWR1Y2UocmVkdWNlLCB2YWx1ZSkge1xuICByZXR1cm4gbWF5YmVSZWR1Y2UocmVkdWNlLCB2YWx1ZSwgbWF5YmVHcm91cFJlZHVjZUZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVHcm91cFJlZHVjZUZhbGxiYWNrKHJlZHVjZSkge1xuICBzd2l0Y2ggKGAke3JlZHVjZX1gLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwieFwiOlxuICAgICAgcmV0dXJuIHJlZHVjZVg7XG4gICAgY2FzZSBcInlcIjpcbiAgICAgIHJldHVybiByZWR1Y2VZO1xuICAgIGNhc2UgXCJ6XCI6XG4gICAgICByZXR1cm4gcmVkdWNlWjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3JvdXAgcmVkdWNlOiAke3JlZHVjZX1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlU3ViZ3JvdXAob3V0cHV0cywgaW5wdXRzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBpbnB1dHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlucHV0c1tuYW1lXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhb3V0cHV0cy5zb21lKChvKSA9PiBvLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVNvcnQoZmFjZXRzLCBzb3J0LCByZXZlcnNlKSB7XG4gIGlmIChzb3J0KSB7XG4gICAgY29uc3QgUyA9IHNvcnQub3V0cHV0LnRyYW5zZm9ybSgpO1xuICAgIGNvbnN0IGNvbXBhcmUgPSAoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChTW2ldLCBTW2pdKTtcbiAgICBmYWNldHMuZm9yRWFjaCgoZikgPT4gZi5zb3J0KGNvbXBhcmUpKTtcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIGZhY2V0cy5mb3JFYWNoKChmKSA9PiBmLnJldmVyc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlUmVkdWNlKHJlZHVjZSkge1xuICBjb25zb2xlLndhcm4oXCJkZXByZWNhdGVkIHJlZHVjZSBpbnRlcmZhY2U7IGltcGxlbWVudCByZWR1Y2VJbmRleCBpbnN0ZWFkLlwiKTtcbiAgcmV0dXJuIHsuLi5yZWR1Y2UsIHJlZHVjZUluZGV4OiByZWR1Y2UucmVkdWNlLmJpbmQocmVkdWNlKX07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VJbmRleChJLCBYLCBleHRlbnQpIHtcbiAgICAgIHJldHVybiBmKHRha2UoWCwgSSksIGV4dGVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWR1Y2VBY2Nlc3NvcihmKSB7XG4gIHJldHVybiB7XG4gICAgcmVkdWNlSW5kZXgoSSwgWCkge1xuICAgICAgcmV0dXJuIGYoSSwgKGkpID0+IFhbaV0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlTWF5YmVUZW1wb3JhbEFjY2Vzc29yKGYpIHtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VJbmRleChJLCBYKSB7XG4gICAgICBjb25zdCB4ID0gZihJLCAoaSkgPT4gWFtpXSk7XG4gICAgICByZXR1cm4gaXNUZW1wb3JhbChYKSA/IG5ldyBEYXRlKHgpIDogeDtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VJZGVudGl0eSA9IHtcbiAgcmVkdWNlSW5kZXgoSSwgWCkge1xuICAgIHJldHVybiB0YWtlKFgsIEkpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlRmlyc3QgPSB7XG4gIHJlZHVjZUluZGV4KEksIFgpIHtcbiAgICByZXR1cm4gWFtJWzBdXTtcbiAgfVxufTtcblxuY29uc3QgcmVkdWNlVGl0bGUgPSB7XG4gIHJlZHVjZUluZGV4KEksIFgpIHtcbiAgICBjb25zdCBuID0gNTtcbiAgICBjb25zdCBncm91cHMgPSBzb3J0KFxuICAgICAgcm9sbHVwKFxuICAgICAgICBJLFxuICAgICAgICAoVikgPT4gVi5sZW5ndGgsXG4gICAgICAgIChpKSA9PiBYW2ldXG4gICAgICApLFxuICAgICAgc2Vjb25kXG4gICAgKTtcbiAgICBjb25zdCB0b3AgPSBncm91cHMuc2xpY2UoLW4pLnJldmVyc2UoKTtcbiAgICBpZiAodG9wLmxlbmd0aCA8IGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGdyb3Vwcy5zbGljZSgwLCAxIC0gbik7XG4gICAgICB0b3BbbiAtIDFdID0gW2DigKYgJHtib3R0b20ubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIil9IG1vcmVgLCBzdW0oYm90dG9tLCBzZWNvbmQpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fSAoJHt2YWx1ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIpfSlgKS5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xuXG5jb25zdCByZWR1Y2VMYXN0ID0ge1xuICByZWR1Y2VJbmRleChJLCBYKSB7XG4gICAgcmV0dXJuIFhbSVtJLmxlbmd0aCAtIDFdXTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUNvdW50ID0ge1xuICBsYWJlbDogXCJGcmVxdWVuY3lcIixcbiAgcmVkdWNlSW5kZXgoSSkge1xuICAgIHJldHVybiBJLmxlbmd0aDtcbiAgfVxufTtcblxuY29uc3QgcmVkdWNlRGlzdGluY3QgPSB7XG4gIGxhYmVsOiBcIkRpc3RpbmN0XCIsXG4gIHJlZHVjZUluZGV4KEksIFgpIHtcbiAgICBjb25zdCBzID0gbmV3IEludGVyblNldCgpO1xuICAgIGZvciAoY29uc3QgaSBvZiBJKSBzLmFkZChYW2ldKTtcbiAgICByZXR1cm4gcy5zaXplO1xuICB9XG59O1xuXG5jb25zdCByZWR1Y2VTdW0gPSByZWR1Y2VBY2Nlc3NvcihzdW0pO1xuXG5mdW5jdGlvbiByZWR1Y2VQcm9wb3J0aW9uKHZhbHVlLCBzY29wZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgID8ge3Njb3BlLCBsYWJlbDogXCJGcmVxdWVuY3lcIiwgcmVkdWNlSW5kZXg6IChJLCBWLCBiYXNpcyA9IDEpID0+IEkubGVuZ3RoIC8gYmFzaXN9XG4gICAgOiB7c2NvcGUsIHJlZHVjZUluZGV4OiAoSSwgViwgYmFzaXMgPSAxKSA9PiBzdW0oSSwgKGkpID0+IFZbaV0pIC8gYmFzaXN9O1xufVxuXG5jb25zdCByZWR1Y2VYID0ge1xuICByZWR1Y2VJbmRleChJLCBYLCB7eH0pIHtcbiAgICByZXR1cm4geDtcbiAgfVxufTtcblxuY29uc3QgcmVkdWNlWSA9IHtcbiAgcmVkdWNlSW5kZXgoSSwgWCwge3l9KSB7XG4gICAgcmV0dXJuIHk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VaID0ge1xuICByZWR1Y2VJbmRleChJLCBYLCB7en0pIHtcbiAgICByZXR1cm4gejtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmQodGVzdCkge1xuICBpZiAodHlwZW9mIHRlc3QgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRlc3QgZnVuY3Rpb246ICR7dGVzdH1gKTtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VJbmRleChJLCBWLCB7ZGF0YX0pIHtcbiAgICAgIHJldHVybiBWW0kuZmluZChpc0FycmF5KGRhdGEpID8gKGkpID0+IHRlc3QoZGF0YVtpXSwgaSwgZGF0YSkgOiAoaSkgPT4gdGVzdChkYXRhLmdldChpKSwgaSwgZGF0YSkpXTtcbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/hexbin.js":
/*!******************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/hexbin.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hexbin: () => (/* binding */ hexbin),\n/* harmony export */   ox: () => (/* binding */ ox),\n/* harmony export */   oy: () => (/* binding */ oy)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../projection.js */ \"(ssr)/./node_modules/@observablehq/plot/src/projection.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../symbol.js */ \"(ssr)/./node_modules/@observablehq/plot/src/symbol.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/group.js\");\n\n\n\n\n\n\n// We don’t want the hexagons to align with the edges of the plot frame, as that\n// would cause extreme x-values (the upper bound of the default x-scale domain)\n// to be rounded up into a floating bin to the right of the plot. Therefore,\n// rather than centering the origin hexagon around ⟨0,0⟩ in screen coordinates,\n// we offset slightly to ⟨0.5,0⟩. The hexgrid mark uses the same origin.\nconst ox = 0.5,\n  oy = 0;\n\nfunction hexbin(outputs = {fill: \"count\"}, {binWidth, ...options} = {}) {\n  const {z} = options;\n\n  // TODO filter e.g. to show empty hexbins?\n  binWidth = binWidth === undefined ? 20 : (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.number)(binWidth);\n  outputs = (0,_group_js__WEBPACK_IMPORTED_MODULE_1__.maybeGroupOutputs)(outputs, options);\n\n  // A fill output means a fill channel; declaring the channel here instead of\n  // waiting for the initializer allows the mark constructor to determine that\n  // the stroke should default to none (assuming a mark that defaults to fill\n  // and no stroke, such as dot). Note that it’s safe to mutate options here\n  // because we just created it with the rest operator above.\n  if ((0,_group_js__WEBPACK_IMPORTED_MODULE_1__.hasOutput)(outputs, \"fill\")) options.channels = {...options.channels, fill: {value: []}};\n\n  // Populate default values for the r and symbol options, as appropriate.\n  if (options.symbol === undefined) options.symbol = \"hexagon\";\n  if (options.r === undefined && !(0,_group_js__WEBPACK_IMPORTED_MODULE_1__.hasOutput)(outputs, \"r\")) options.r = binWidth / 2;\n\n  return (0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.initializer)(options, (data, facets, channels, scales, _, context) => {\n    let {x: X, y: Y, z: Z, fill: F, stroke: S, symbol: Q} = channels;\n    if (X === undefined) throw new Error(\"missing channel: x\");\n    if (Y === undefined) throw new Error(\"missing channel: y\");\n\n    // Get the (either scaled or projected) xy channels.\n    ({x: X, y: Y} = (0,_projection_js__WEBPACK_IMPORTED_MODULE_3__.applyPosition)(channels, scales, context));\n\n    // Extract the values for channels that are eligible for grouping; not all\n    // marks define a z channel, so compute one if it not already computed. If z\n    // was explicitly set to null, ensure that we don’t subdivide bins.\n    Z = Z ? Z.value : (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.valueof)(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n\n    // Group on the first of z, fill, stroke, and symbol. Implicitly reduce\n    // these channels using the first corresponding value for each bin.\n    const G = (0,_group_js__WEBPACK_IMPORTED_MODULE_1__.maybeSubgroup)(outputs, {z: Z, fill: F, stroke: S, symbol: Q});\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n\n    // Construct the hexbins and populate the output channels.\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs) o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs) o.scope(\"facet\", facet);\n      for (const [f, I] of (0,_group_js__WEBPACK_IMPORTED_MODULE_1__.maybeGroup)(facet, G)) {\n        for (const {index: b, extent} of hbin(data, I, X, Y, binWidth)) {\n          binFacet.push(++i);\n          BX.push(extent.x);\n          BY.push(extent.y);\n          if (Z) GZ.push(G === Z ? f : Z[b[0]]);\n          if (F) GF.push(G === F ? f : F[b[0]]);\n          if (S) GS.push(G === S ? f : S[b[0]]);\n          if (Q) GQ.push(G === Q ? f : Q[b[0]]);\n          for (const o of outputs) o.reduce(b, extent);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n\n    // Construct the output channels, and populate the radius scale hint.\n    const sx = channels.x.scale;\n    const sy = channels.y.scale;\n    const binChannels = {\n      x: {value: BX, source: scales[sx] ? {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.map)(BX, scales[sx].invert), scale: sx} : null},\n      y: {value: BY, source: scales[sy] ? {value: (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.map)(BY, scales[sy].invert), scale: sy} : null},\n      ...(Z && {z: {value: GZ}}),\n      ...(F && {fill: {value: GF, scale: \"auto\"}}),\n      ...(S && {stroke: {value: GS, scale: \"auto\"}}),\n      ...(Q && {symbol: {value: GQ, scale: \"auto\"}}),\n      ...Object.fromEntries(\n        outputs.map(({name, output}) => [\n          name,\n          {\n            scale: \"auto\",\n            label: output.label,\n            radius: name === \"r\" ? binWidth / 2 : undefined,\n            value: output.transform()\n          }\n        ])\n      )\n    };\n\n    return {data, facets: binFacets, channels: binChannels};\n  });\n}\n\nfunction hbin(data, I, X, Y, dx) {\n  const dy = dx * (1.5 / _symbol_js__WEBPACK_IMPORTED_MODULE_4__.sqrt3);\n  const bins = new Map();\n  for (const i of I) {\n    let px = X[i],\n      py = Y[i];\n    if (isNaN(px) || isNaN(py)) continue;\n    let pj = Math.round((py = (py - oy) / dy)),\n      pi = Math.round((px = (px - ox) / dx - (pj & 1) / 2)),\n      py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi,\n        pi2 = pi + (px < pi ? -1 : 1) / 2,\n        pj2 = pj + (py < pj ? -1 : 1),\n        px2 = px - pi2,\n        py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) (pi = pi2 + (pj & 1 ? 1 : -1) / 2), (pj = pj2);\n    }\n    const key = `${pi},${pj}`;\n    let bin = bins.get(key);\n    if (bin === undefined) {\n      bin = {index: [], extent: {data, x: (pi + (pj & 1) / 2) * dx + ox, y: pj * dy + oy}};\n      bins.set(key, bin);\n    }\n    bin.index.push(i);\n  }\n  return bins.values();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2hleGJpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFtRDtBQUNKO0FBQ1o7QUFDSTtBQUM0Qzs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRU8sMkJBQTJCLGNBQWMsR0FBRyxzQkFBc0IsSUFBSTtBQUM3RSxTQUFTLEdBQUc7O0FBRVo7QUFDQSwyQ0FBMkMsbURBQU07QUFDakQsWUFBWSw0REFBaUI7O0FBRTdCLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVMsdUNBQXVDLDRCQUE0Qjs7QUFFbEY7QUFDQTtBQUNBLGtDQUFrQyxvREFBUzs7QUFFM0MsU0FBUyxzREFBVztBQUNwQixTQUFTLGlEQUFpRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxZQUFZLEVBQUUsNkRBQWE7O0FBRWpDLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFPO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx3REFBYSxXQUFXLG9DQUFvQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQyxPQUFPLGdEQUFHLG9DQUFvQyxPQUFPO0FBQ2hHLFVBQVUsaUNBQWlDLE9BQU8sZ0RBQUcsb0NBQW9DLE9BQU87QUFDaEcsZ0JBQWdCLElBQUksV0FBVztBQUMvQixnQkFBZ0IsT0FBTywwQkFBMEI7QUFDakQsZ0JBQWdCLFNBQVMsMEJBQTBCO0FBQ25ELGdCQUFnQixTQUFTLDBCQUEwQjtBQUNuRDtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWixHQUFHO0FBQ0g7O0FBRUE7QUFDQSx5QkFBeUIsNkNBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRyxHQUFHLEdBQUc7QUFDNUI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9oZXhiaW4uanM/ZWNmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge21hcCwgbnVtYmVyLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHthcHBseVBvc2l0aW9ufSBmcm9tIFwiLi4vcHJvamVjdGlvbi5qc1wiO1xuaW1wb3J0IHtzcXJ0M30gZnJvbSBcIi4uL3N5bWJvbC5qc1wiO1xuaW1wb3J0IHtpbml0aWFsaXplcn0gZnJvbSBcIi4vYmFzaWMuanNcIjtcbmltcG9ydCB7aGFzT3V0cHV0LCBtYXliZUdyb3VwLCBtYXliZUdyb3VwT3V0cHV0cywgbWF5YmVTdWJncm91cH0gZnJvbSBcIi4vZ3JvdXAuanNcIjtcblxuLy8gV2UgZG9u4oCZdCB3YW50IHRoZSBoZXhhZ29ucyB0byBhbGlnbiB3aXRoIHRoZSBlZGdlcyBvZiB0aGUgcGxvdCBmcmFtZSwgYXMgdGhhdFxuLy8gd291bGQgY2F1c2UgZXh0cmVtZSB4LXZhbHVlcyAodGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBkZWZhdWx0IHgtc2NhbGUgZG9tYWluKVxuLy8gdG8gYmUgcm91bmRlZCB1cCBpbnRvIGEgZmxvYXRpbmcgYmluIHRvIHRoZSByaWdodCBvZiB0aGUgcGxvdC4gVGhlcmVmb3JlLFxuLy8gcmF0aGVyIHRoYW4gY2VudGVyaW5nIHRoZSBvcmlnaW4gaGV4YWdvbiBhcm91bmQg4p+oMCww4p+pIGluIHNjcmVlbiBjb29yZGluYXRlcyxcbi8vIHdlIG9mZnNldCBzbGlnaHRseSB0byDin6gwLjUsMOKfqS4gVGhlIGhleGdyaWQgbWFyayB1c2VzIHRoZSBzYW1lIG9yaWdpbi5cbmV4cG9ydCBjb25zdCBveCA9IDAuNSxcbiAgb3kgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gaGV4YmluKG91dHB1dHMgPSB7ZmlsbDogXCJjb3VudFwifSwge2JpbldpZHRoLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIGNvbnN0IHt6fSA9IG9wdGlvbnM7XG5cbiAgLy8gVE9ETyBmaWx0ZXIgZS5nLiB0byBzaG93IGVtcHR5IGhleGJpbnM/XG4gIGJpbldpZHRoID0gYmluV2lkdGggPT09IHVuZGVmaW5lZCA/IDIwIDogbnVtYmVyKGJpbldpZHRoKTtcbiAgb3V0cHV0cyA9IG1heWJlR3JvdXBPdXRwdXRzKG91dHB1dHMsIG9wdGlvbnMpO1xuXG4gIC8vIEEgZmlsbCBvdXRwdXQgbWVhbnMgYSBmaWxsIGNoYW5uZWw7IGRlY2xhcmluZyB0aGUgY2hhbm5lbCBoZXJlIGluc3RlYWQgb2ZcbiAgLy8gd2FpdGluZyBmb3IgdGhlIGluaXRpYWxpemVyIGFsbG93cyB0aGUgbWFyayBjb25zdHJ1Y3RvciB0byBkZXRlcm1pbmUgdGhhdFxuICAvLyB0aGUgc3Ryb2tlIHNob3VsZCBkZWZhdWx0IHRvIG5vbmUgKGFzc3VtaW5nIGEgbWFyayB0aGF0IGRlZmF1bHRzIHRvIGZpbGxcbiAgLy8gYW5kIG5vIHN0cm9rZSwgc3VjaCBhcyBkb3QpLiBOb3RlIHRoYXQgaXTigJlzIHNhZmUgdG8gbXV0YXRlIG9wdGlvbnMgaGVyZVxuICAvLyBiZWNhdXNlIHdlIGp1c3QgY3JlYXRlZCBpdCB3aXRoIHRoZSByZXN0IG9wZXJhdG9yIGFib3ZlLlxuICBpZiAoaGFzT3V0cHV0KG91dHB1dHMsIFwiZmlsbFwiKSkgb3B0aW9ucy5jaGFubmVscyA9IHsuLi5vcHRpb25zLmNoYW5uZWxzLCBmaWxsOiB7dmFsdWU6IFtdfX07XG5cbiAgLy8gUG9wdWxhdGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSByIGFuZCBzeW1ib2wgb3B0aW9ucywgYXMgYXBwcm9wcmlhdGUuXG4gIGlmIChvcHRpb25zLnN5bWJvbCA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLnN5bWJvbCA9IFwiaGV4YWdvblwiO1xuICBpZiAob3B0aW9ucy5yID09PSB1bmRlZmluZWQgJiYgIWhhc091dHB1dChvdXRwdXRzLCBcInJcIikpIG9wdGlvbnMuciA9IGJpbldpZHRoIC8gMjtcblxuICByZXR1cm4gaW5pdGlhbGl6ZXIob3B0aW9ucywgKGRhdGEsIGZhY2V0cywgY2hhbm5lbHMsIHNjYWxlcywgXywgY29udGV4dCkgPT4ge1xuICAgIGxldCB7eDogWCwgeTogWSwgejogWiwgZmlsbDogRiwgc3Ryb2tlOiBTLCBzeW1ib2w6IFF9ID0gY2hhbm5lbHM7XG4gICAgaWYgKFggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsOiB4XCIpO1xuICAgIGlmIChZID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hhbm5lbDogeVwiKTtcblxuICAgIC8vIEdldCB0aGUgKGVpdGhlciBzY2FsZWQgb3IgcHJvamVjdGVkKSB4eSBjaGFubmVscy5cbiAgICAoe3g6IFgsIHk6IFl9ID0gYXBwbHlQb3NpdGlvbihjaGFubmVscywgc2NhbGVzLCBjb250ZXh0KSk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSB2YWx1ZXMgZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGVsaWdpYmxlIGZvciBncm91cGluZzsgbm90IGFsbFxuICAgIC8vIG1hcmtzIGRlZmluZSBhIHogY2hhbm5lbCwgc28gY29tcHV0ZSBvbmUgaWYgaXQgbm90IGFscmVhZHkgY29tcHV0ZWQuIElmIHpcbiAgICAvLyB3YXMgZXhwbGljaXRseSBzZXQgdG8gbnVsbCwgZW5zdXJlIHRoYXQgd2UgZG9u4oCZdCBzdWJkaXZpZGUgYmlucy5cbiAgICBaID0gWiA/IFoudmFsdWUgOiB2YWx1ZW9mKGRhdGEsIHopO1xuICAgIEYgPSBGPy52YWx1ZTtcbiAgICBTID0gUz8udmFsdWU7XG4gICAgUSA9IFE/LnZhbHVlO1xuXG4gICAgLy8gR3JvdXAgb24gdGhlIGZpcnN0IG9mIHosIGZpbGwsIHN0cm9rZSwgYW5kIHN5bWJvbC4gSW1wbGljaXRseSByZWR1Y2VcbiAgICAvLyB0aGVzZSBjaGFubmVscyB1c2luZyB0aGUgZmlyc3QgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgZWFjaCBiaW4uXG4gICAgY29uc3QgRyA9IG1heWJlU3ViZ3JvdXAob3V0cHV0cywge3o6IFosIGZpbGw6IEYsIHN0cm9rZTogUywgc3ltYm9sOiBRfSk7XG4gICAgY29uc3QgR1ogPSBaICYmIFtdO1xuICAgIGNvbnN0IEdGID0gRiAmJiBbXTtcbiAgICBjb25zdCBHUyA9IFMgJiYgW107XG4gICAgY29uc3QgR1EgPSBRICYmIFtdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBoZXhiaW5zIGFuZCBwb3B1bGF0ZSB0aGUgb3V0cHV0IGNoYW5uZWxzLlxuICAgIGNvbnN0IGJpbkZhY2V0cyA9IFtdO1xuICAgIGNvbnN0IEJYID0gW107XG4gICAgY29uc3QgQlkgPSBbXTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvLmluaXRpYWxpemUoZGF0YSk7XG4gICAgZm9yIChjb25zdCBmYWNldCBvZiBmYWNldHMpIHtcbiAgICAgIGNvbnN0IGJpbkZhY2V0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IG8gb2Ygb3V0cHV0cykgby5zY29wZShcImZhY2V0XCIsIGZhY2V0KTtcbiAgICAgIGZvciAoY29uc3QgW2YsIEldIG9mIG1heWJlR3JvdXAoZmFjZXQsIEcpKSB7XG4gICAgICAgIGZvciAoY29uc3Qge2luZGV4OiBiLCBleHRlbnR9IG9mIGhiaW4oZGF0YSwgSSwgWCwgWSwgYmluV2lkdGgpKSB7XG4gICAgICAgICAgYmluRmFjZXQucHVzaCgrK2kpO1xuICAgICAgICAgIEJYLnB1c2goZXh0ZW50LngpO1xuICAgICAgICAgIEJZLnB1c2goZXh0ZW50LnkpO1xuICAgICAgICAgIGlmIChaKSBHWi5wdXNoKEcgPT09IFogPyBmIDogWltiWzBdXSk7XG4gICAgICAgICAgaWYgKEYpIEdGLnB1c2goRyA9PT0gRiA/IGYgOiBGW2JbMF1dKTtcbiAgICAgICAgICBpZiAoUykgR1MucHVzaChHID09PSBTID8gZiA6IFNbYlswXV0pO1xuICAgICAgICAgIGlmIChRKSBHUS5wdXNoKEcgPT09IFEgPyBmIDogUVtiWzBdXSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIG8ucmVkdWNlKGIsIGV4dGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJpbkZhY2V0cy5wdXNoKGJpbkZhY2V0KTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIG91dHB1dCBjaGFubmVscywgYW5kIHBvcHVsYXRlIHRoZSByYWRpdXMgc2NhbGUgaGludC5cbiAgICBjb25zdCBzeCA9IGNoYW5uZWxzLnguc2NhbGU7XG4gICAgY29uc3Qgc3kgPSBjaGFubmVscy55LnNjYWxlO1xuICAgIGNvbnN0IGJpbkNoYW5uZWxzID0ge1xuICAgICAgeDoge3ZhbHVlOiBCWCwgc291cmNlOiBzY2FsZXNbc3hdID8ge3ZhbHVlOiBtYXAoQlgsIHNjYWxlc1tzeF0uaW52ZXJ0KSwgc2NhbGU6IHN4fSA6IG51bGx9LFxuICAgICAgeToge3ZhbHVlOiBCWSwgc291cmNlOiBzY2FsZXNbc3ldID8ge3ZhbHVlOiBtYXAoQlksIHNjYWxlc1tzeV0uaW52ZXJ0KSwgc2NhbGU6IHN5fSA6IG51bGx9LFxuICAgICAgLi4uKFogJiYge3o6IHt2YWx1ZTogR1p9fSksXG4gICAgICAuLi4oRiAmJiB7ZmlsbDoge3ZhbHVlOiBHRiwgc2NhbGU6IFwiYXV0b1wifX0pLFxuICAgICAgLi4uKFMgJiYge3N0cm9rZToge3ZhbHVlOiBHUywgc2NhbGU6IFwiYXV0b1wifX0pLFxuICAgICAgLi4uKFEgJiYge3N5bWJvbDoge3ZhbHVlOiBHUSwgc2NhbGU6IFwiYXV0b1wifX0pLFxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBvdXRwdXRzLm1hcCgoe25hbWUsIG91dHB1dH0pID0+IFtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjYWxlOiBcImF1dG9cIixcbiAgICAgICAgICAgIGxhYmVsOiBvdXRwdXQubGFiZWwsXG4gICAgICAgICAgICByYWRpdXM6IG5hbWUgPT09IFwiclwiID8gYmluV2lkdGggLyAyIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsdWU6IG91dHB1dC50cmFuc2Zvcm0oKVxuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgIClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtkYXRhLCBmYWNldHM6IGJpbkZhY2V0cywgY2hhbm5lbHM6IGJpbkNoYW5uZWxzfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhiaW4oZGF0YSwgSSwgWCwgWSwgZHgpIHtcbiAgY29uc3QgZHkgPSBkeCAqICgxLjUgLyBzcXJ0Myk7XG4gIGNvbnN0IGJpbnMgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaSBvZiBJKSB7XG4gICAgbGV0IHB4ID0gWFtpXSxcbiAgICAgIHB5ID0gWVtpXTtcbiAgICBpZiAoaXNOYU4ocHgpIHx8IGlzTmFOKHB5KSkgY29udGludWU7XG4gICAgbGV0IHBqID0gTWF0aC5yb3VuZCgocHkgPSAocHkgLSBveSkgLyBkeSkpLFxuICAgICAgcGkgPSBNYXRoLnJvdW5kKChweCA9IChweCAtIG94KSAvIGR4IC0gKHBqICYgMSkgLyAyKSksXG4gICAgICBweTEgPSBweSAtIHBqO1xuICAgIGlmIChNYXRoLmFicyhweTEpICogMyA+IDEpIHtcbiAgICAgIGxldCBweDEgPSBweCAtIHBpLFxuICAgICAgICBwaTIgPSBwaSArIChweCA8IHBpID8gLTEgOiAxKSAvIDIsXG4gICAgICAgIHBqMiA9IHBqICsgKHB5IDwgcGogPyAtMSA6IDEpLFxuICAgICAgICBweDIgPSBweCAtIHBpMixcbiAgICAgICAgcHkyID0gcHkgLSBwajI7XG4gICAgICBpZiAocHgxICogcHgxICsgcHkxICogcHkxID4gcHgyICogcHgyICsgcHkyICogcHkyKSAocGkgPSBwaTIgKyAocGogJiAxID8gMSA6IC0xKSAvIDIpLCAocGogPSBwajIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBgJHtwaX0sJHtwan1gO1xuICAgIGxldCBiaW4gPSBiaW5zLmdldChrZXkpO1xuICAgIGlmIChiaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluID0ge2luZGV4OiBbXSwgZXh0ZW50OiB7ZGF0YSwgeDogKHBpICsgKHBqICYgMSkgLyAyKSAqIGR4ICsgb3gsIHk6IHBqICogZHkgKyBveX19O1xuICAgICAgYmlucy5zZXQoa2V5LCBiaW4pO1xuICAgIH1cbiAgICBiaW4uaW5kZXgucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYmlucy52YWx1ZXMoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/hexbin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js":
/*!********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/identity.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeIdentityX: () => (/* binding */ maybeIdentityX),\n/* harmony export */   maybeIdentityY: () => (/* binding */ maybeIdentityY)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n\n\nfunction maybeIdentityX(options = {}, k = \"x\") {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.hasX)(options) ? options : {...options, [k]: _options_js__WEBPACK_IMPORTED_MODULE_0__.identity};\n}\n\nfunction maybeIdentityY(options = {}, k = \"y\") {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.hasY)(options) ? options : {...options, [k]: _options_js__WEBPACK_IMPORTED_MODULE_0__.identity};\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2lkZW50aXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRDs7QUFFNUMsb0NBQW9DO0FBQzNDLFNBQVMsaURBQUksdUJBQXVCLGlCQUFpQixpREFBUTtBQUM3RDs7QUFFTyxvQ0FBb0M7QUFDM0MsU0FBUyxpREFBSSx1QkFBdUIsaUJBQWlCLGlEQUFRO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2lkZW50aXR5LmpzPzIxY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtoYXNYLCBoYXNZLCBpZGVudGl0eX0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlSWRlbnRpdHlYKG9wdGlvbnMgPSB7fSwgayA9IFwieFwiKSB7XG4gIHJldHVybiBoYXNYKG9wdGlvbnMpID8gb3B0aW9ucyA6IHsuLi5vcHRpb25zLCBba106IGlkZW50aXR5fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlSWRlbnRpdHlZKG9wdGlvbnMgPSB7fSwgayA9IFwieVwiKSB7XG4gIHJldHVybiBoYXNZKG9wdGlvbnMpID8gb3B0aW9ucyA6IHsuLi5vcHRpb25zLCBba106IGlkZW50aXR5fTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/identity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/inset.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/inset.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeInsetX: () => (/* binding */ maybeInsetX),\n/* harmony export */   maybeInsetY: () => (/* binding */ maybeInsetY)\n/* harmony export */ });\n/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style.js */ \"(ssr)/./node_modules/@observablehq/plot/src/style.js\");\n\n\nfunction maybeInsetX({inset, insetLeft, insetRight, ...options} = {}) {\n  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);\n  return {inset, insetLeft, insetRight, ...options};\n}\n\nfunction maybeInsetY({inset, insetTop, insetBottom, ...options} = {}) {\n  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);\n  return {inset, insetTop, insetBottom, ...options};\n}\n\nfunction maybeInset(inset, inset1, inset2) {\n  return inset === undefined && inset1 === undefined && inset2 === undefined\n    ? _style_js__WEBPACK_IMPORTED_MODULE_0__.offset\n      ? [1, 0]\n      : [0.5, 0.5]\n    : [inset1, inset2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2luc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQzs7QUFFNUIsc0JBQXNCLDBDQUEwQyxJQUFJO0FBQzNFO0FBQ0EsVUFBVTtBQUNWOztBQUVPLHNCQUFzQiwwQ0FBMEMsSUFBSTtBQUMzRTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw2Q0FBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2luc2V0LmpzP2VlMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtvZmZzZXR9IGZyb20gXCIuLi9zdHlsZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVJbnNldFgoe2luc2V0LCBpbnNldExlZnQsIGluc2V0UmlnaHQsIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgW2luc2V0TGVmdCwgaW5zZXRSaWdodF0gPSBtYXliZUluc2V0KGluc2V0LCBpbnNldExlZnQsIGluc2V0UmlnaHQpO1xuICByZXR1cm4ge2luc2V0LCBpbnNldExlZnQsIGluc2V0UmlnaHQsIC4uLm9wdGlvbnN9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVJbnNldFkoe2luc2V0LCBpbnNldFRvcCwgaW5zZXRCb3R0b20sIC4uLm9wdGlvbnN9ID0ge30pIHtcbiAgW2luc2V0VG9wLCBpbnNldEJvdHRvbV0gPSBtYXliZUluc2V0KGluc2V0LCBpbnNldFRvcCwgaW5zZXRCb3R0b20pO1xuICByZXR1cm4ge2luc2V0LCBpbnNldFRvcCwgaW5zZXRCb3R0b20sIC4uLm9wdGlvbnN9O1xufVxuXG5mdW5jdGlvbiBtYXliZUluc2V0KGluc2V0LCBpbnNldDEsIGluc2V0Mikge1xuICByZXR1cm4gaW5zZXQgPT09IHVuZGVmaW5lZCAmJiBpbnNldDEgPT09IHVuZGVmaW5lZCAmJiBpbnNldDIgPT09IHVuZGVmaW5lZFxuICAgID8gb2Zmc2V0XG4gICAgICA/IFsxLCAwXVxuICAgICAgOiBbMC41LCAwLjVdXG4gICAgOiBbaW5zZXQxLCBpbnNldDJdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/inset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js":
/*!********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/interval.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeIntervalMidX: () => (/* binding */ maybeIntervalMidX),\n/* harmony export */   maybeIntervalMidY: () => (/* binding */ maybeIntervalMidY),\n/* harmony export */   maybeIntervalX: () => (/* binding */ maybeIntervalX),\n/* harmony export */   maybeIntervalY: () => (/* binding */ maybeIntervalY),\n/* harmony export */   maybeTrivialIntervalX: () => (/* binding */ maybeTrivialIntervalX),\n/* harmony export */   maybeTrivialIntervalY: () => (/* binding */ maybeTrivialIntervalY)\n/* harmony export */ });\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _inset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inset.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/inset.js\");\n\n\n\n// The interval may be specified either as x: {value, interval} or as {x,\n// interval}. The former can be used to specify separate intervals for x and y,\n// for example with Plot.rect.\nfunction maybeIntervalValue(value, {interval}) {\n  value = {...(0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeValue)(value)};\n  value.interval = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.maybeInterval)(value.interval === undefined ? interval : value.interval);\n  return value;\n}\n\nfunction maybeIntervalK(k, maybeInsetK, options, trivial) {\n  const {[k]: v, [`${k}1`]: v1, [`${k}2`]: v2} = options;\n  const {value, interval} = maybeIntervalValue(v, options);\n  if (value == null || (interval == null && !trivial)) return options;\n  const label = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.labelof)(v);\n  if (interval == null) {\n    let V;\n    const kv = {transform: (data) => V || (V = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.valueof)(data, value)), label};\n    return {\n      ...options,\n      [k]: undefined,\n      [`${k}1`]: v1 === undefined ? kv : v1,\n      [`${k}2`]: v2 === undefined && !(v1 === v2 && trivial) ? kv : v2\n    };\n  }\n  let D1, V1;\n  function transform(data) {\n    if (V1 !== undefined && data === D1) return V1; // memoize\n    return (V1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.map)((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.valueof)((D1 = data), value), (v) => interval.floor(v)));\n  }\n  return maybeInsetK({\n    ...options,\n    [k]: undefined,\n    [`${k}1`]: v1 === undefined ? {transform, label} : v1,\n    [`${k}2`]: v2 === undefined ? {transform: (data) => transform(data).map((v) => interval.offset(v)), label} : v2\n  });\n}\n\nfunction maybeIntervalMidK(k, maybeInsetK, options) {\n  const {[k]: v} = options;\n  const {value, interval} = maybeIntervalValue(v, options);\n  if (value == null || interval == null) return options;\n  return maybeInsetK({\n    ...options,\n    [k]: {\n      label: (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.labelof)(v),\n      transform: (data) => {\n        const V1 = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.map)((0,_options_js__WEBPACK_IMPORTED_MODULE_0__.valueof)(data, value), (v) => interval.floor(v));\n        const V2 = V1.map((v) => interval.offset(v));\n        return V1.map(\n          (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.isTemporal)(V1)\n            ? (v1, v2) =>\n                v1 == null || isNaN((v1 = +v1)) || ((v2 = V2[v2]), v2 == null) || isNaN((v2 = +v2))\n                  ? undefined\n                  : new Date((v1 + v2) / 2)\n            : (v1, v2) => (v1 == null || ((v2 = V2[v2]), v2 == null) ? NaN : (+v1 + +v2) / 2)\n        );\n      }\n    }\n  });\n}\n\nfunction maybeTrivialIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetX, options, true);\n}\n\nfunction maybeTrivialIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetY, options, true);\n}\n\nfunction maybeIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetX, options);\n}\n\nfunction maybeIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetY, options);\n}\n\nfunction maybeIntervalMidX(options = {}) {\n  return maybeIntervalMidK(\"x\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetX, options);\n}\n\nfunction maybeIntervalMidY(options = {}) {\n  return maybeIntervalMidK(\"y\", _inset_js__WEBPACK_IMPORTED_MODULE_1__.maybeInsetY, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL2ludGVydmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTJGO0FBQ3ZDOztBQUVwRCwrQ0FBK0MsaUJBQWlCLE9BQU87QUFDdkUsWUFBWTtBQUNaO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0MsV0FBVyxHQUFHLHVEQUFVO0FBQ3hCLG1CQUFtQiwwREFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0EsU0FBUyxZQUFZLEVBQUUsYUFBYSxFQUFFLFNBQVM7QUFDL0MsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQSxnQkFBZ0Isb0RBQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0Isb0RBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1osVUFBVSxFQUFFO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsaUJBQWlCLGdEQUFHLENBQUMsb0RBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEVBQUUseUJBQXlCLGtCQUFrQjtBQUNyRCxRQUFRLEVBQUUseUJBQXlCLDRFQUE0RTtBQUMvRyxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLFFBQVE7QUFDakIsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFPO0FBQ3BCO0FBQ0EsbUJBQW1CLGdEQUFHLENBQUMsb0RBQU87QUFDOUI7QUFDQTtBQUNBLFVBQVUsdURBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTywyQ0FBMkM7QUFDbEQsNkJBQTZCLGtEQUFXO0FBQ3hDOztBQUVPLDJDQUEyQztBQUNsRCw2QkFBNkIsa0RBQVc7QUFDeEM7O0FBRU8sb0NBQW9DO0FBQzNDLDZCQUE2QixrREFBVztBQUN4Qzs7QUFFTyxvQ0FBb0M7QUFDM0MsNkJBQTZCLGtEQUFXO0FBQ3hDOztBQUVPLHVDQUF1QztBQUM5QyxnQ0FBZ0Msa0RBQVc7QUFDM0M7O0FBRU8sdUNBQXVDO0FBQzlDLGdDQUFnQyxrREFBVztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9pbnRlcnZhbC5qcz9lZDY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNUZW1wb3JhbCwgbGFiZWxvZiwgbWFwLCBtYXliZUludGVydmFsLCBtYXliZVZhbHVlLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHttYXliZUluc2V0WCwgbWF5YmVJbnNldFl9IGZyb20gXCIuL2luc2V0LmpzXCI7XG5cbi8vIFRoZSBpbnRlcnZhbCBtYXkgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyB4OiB7dmFsdWUsIGludGVydmFsfSBvciBhcyB7eCxcbi8vIGludGVydmFsfS4gVGhlIGZvcm1lciBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHNlcGFyYXRlIGludGVydmFscyBmb3IgeCBhbmQgeSxcbi8vIGZvciBleGFtcGxlIHdpdGggUGxvdC5yZWN0LlxuZnVuY3Rpb24gbWF5YmVJbnRlcnZhbFZhbHVlKHZhbHVlLCB7aW50ZXJ2YWx9KSB7XG4gIHZhbHVlID0gey4uLm1heWJlVmFsdWUodmFsdWUpfTtcbiAgdmFsdWUuaW50ZXJ2YWwgPSBtYXliZUludGVydmFsKHZhbHVlLmludGVydmFsID09PSB1bmRlZmluZWQgPyBpbnRlcnZhbCA6IHZhbHVlLmludGVydmFsKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXliZUludGVydmFsSyhrLCBtYXliZUluc2V0Sywgb3B0aW9ucywgdHJpdmlhbCkge1xuICBjb25zdCB7W2tdOiB2LCBbYCR7a30xYF06IHYxLCBbYCR7a30yYF06IHYyfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt2YWx1ZSwgaW50ZXJ2YWx9ID0gbWF5YmVJbnRlcnZhbFZhbHVlKHYsIG9wdGlvbnMpO1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaW50ZXJ2YWwgPT0gbnVsbCAmJiAhdHJpdmlhbCkpIHJldHVybiBvcHRpb25zO1xuICBjb25zdCBsYWJlbCA9IGxhYmVsb2Yodik7XG4gIGlmIChpbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgbGV0IFY7XG4gICAgY29uc3Qga3YgPSB7dHJhbnNmb3JtOiAoZGF0YSkgPT4gViB8fCAoViA9IHZhbHVlb2YoZGF0YSwgdmFsdWUpKSwgbGFiZWx9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgW2tdOiB1bmRlZmluZWQsXG4gICAgICBbYCR7a30xYF06IHYxID09PSB1bmRlZmluZWQgPyBrdiA6IHYxLFxuICAgICAgW2Ake2t9MmBdOiB2MiA9PT0gdW5kZWZpbmVkICYmICEodjEgPT09IHYyICYmIHRyaXZpYWwpID8ga3YgOiB2MlxuICAgIH07XG4gIH1cbiAgbGV0IEQxLCBWMTtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGEpIHtcbiAgICBpZiAoVjEgIT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSBEMSkgcmV0dXJuIFYxOyAvLyBtZW1vaXplXG4gICAgcmV0dXJuIChWMSA9IG1hcCh2YWx1ZW9mKChEMSA9IGRhdGEpLCB2YWx1ZSksICh2KSA9PiBpbnRlcnZhbC5mbG9vcih2KSkpO1xuICB9XG4gIHJldHVybiBtYXliZUluc2V0Syh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBba106IHVuZGVmaW5lZCxcbiAgICBbYCR7a30xYF06IHYxID09PSB1bmRlZmluZWQgPyB7dHJhbnNmb3JtLCBsYWJlbH0gOiB2MSxcbiAgICBbYCR7a30yYF06IHYyID09PSB1bmRlZmluZWQgPyB7dHJhbnNmb3JtOiAoZGF0YSkgPT4gdHJhbnNmb3JtKGRhdGEpLm1hcCgodikgPT4gaW50ZXJ2YWwub2Zmc2V0KHYpKSwgbGFiZWx9IDogdjJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlSW50ZXJ2YWxNaWRLKGssIG1heWJlSW5zZXRLLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtba106IHZ9ID0gb3B0aW9ucztcbiAgY29uc3Qge3ZhbHVlLCBpbnRlcnZhbH0gPSBtYXliZUludGVydmFsVmFsdWUodiwgb3B0aW9ucyk7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IGludGVydmFsID09IG51bGwpIHJldHVybiBvcHRpb25zO1xuICByZXR1cm4gbWF5YmVJbnNldEsoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgW2tdOiB7XG4gICAgICBsYWJlbDogbGFiZWxvZih2KSxcbiAgICAgIHRyYW5zZm9ybTogKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgVjEgPSBtYXAodmFsdWVvZihkYXRhLCB2YWx1ZSksICh2KSA9PiBpbnRlcnZhbC5mbG9vcih2KSk7XG4gICAgICAgIGNvbnN0IFYyID0gVjEubWFwKCh2KSA9PiBpbnRlcnZhbC5vZmZzZXQodikpO1xuICAgICAgICByZXR1cm4gVjEubWFwKFxuICAgICAgICAgIGlzVGVtcG9yYWwoVjEpXG4gICAgICAgICAgICA/ICh2MSwgdjIpID0+XG4gICAgICAgICAgICAgICAgdjEgPT0gbnVsbCB8fCBpc05hTigodjEgPSArdjEpKSB8fCAoKHYyID0gVjJbdjJdKSwgdjIgPT0gbnVsbCkgfHwgaXNOYU4oKHYyID0gK3YyKSlcbiAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCh2MSArIHYyKSAvIDIpXG4gICAgICAgICAgICA6ICh2MSwgdjIpID0+ICh2MSA9PSBudWxsIHx8ICgodjIgPSBWMlt2Ml0pLCB2MiA9PSBudWxsKSA/IE5hTiA6ICgrdjEgKyArdjIpIC8gMilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVUcml2aWFsSW50ZXJ2YWxYKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbWF5YmVJbnRlcnZhbEsoXCJ4XCIsIG1heWJlSW5zZXRYLCBvcHRpb25zLCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVHJpdmlhbEludGVydmFsWShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG1heWJlSW50ZXJ2YWxLKFwieVwiLCBtYXliZUluc2V0WSwgb3B0aW9ucywgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVydmFsWChvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG1heWJlSW50ZXJ2YWxLKFwieFwiLCBtYXliZUluc2V0WCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVydmFsWShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG1heWJlSW50ZXJ2YWxLKFwieVwiLCBtYXliZUluc2V0WSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVydmFsTWlkWChvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG1heWJlSW50ZXJ2YWxNaWRLKFwieFwiLCBtYXliZUluc2V0WCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUludGVydmFsTWlkWShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG1heWJlSW50ZXJ2YWxNaWRLKFwieVwiLCBtYXliZUluc2V0WSwgb3B0aW9ucyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/interval.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js":
/*!***************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapX: () => (/* binding */ mapX),\n/* harmony export */   mapY: () => (/* binding */ mapY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\nfunction mapX(mapper, options = {}) {\n  let {x, x1, x2} = options;\n  if (x === undefined && x1 === undefined && x2 === undefined) options = {...options, x: (x = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity)};\n  const outputs = {};\n  if (x != null) outputs.x = mapper;\n  if (x1 != null) outputs.x1 = mapper;\n  if (x2 != null) outputs.x2 = mapper;\n  return map(outputs, options);\n}\n\nfunction mapY(mapper, options = {}) {\n  let {y, y1, y2} = options;\n  if (y === undefined && y1 === undefined && y2 === undefined) options = {...options, y: (y = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity)};\n  const outputs = {};\n  if (y != null) outputs.y = mapper;\n  if (y1 != null) outputs.y1 = mapper;\n  if (y2 != null) outputs.y2 = mapper;\n  return map(outputs, options);\n}\n\nfunction map(outputs = {}, options = {}) {\n  const z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeZ)(options);\n  const channels = Object.entries(outputs).map(([key, map]) => {\n    const input = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeInput)(key, options);\n    if (input == null) throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)(input);\n    return {key, input, output, setOutput, map: maybeMap(map)};\n  });\n  return {\n    ...(0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.basic)(options, (data, facets) => {\n      const Z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, z);\n      const X = channels.map(({input}) => (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, input));\n      const MX = channels.map(({setOutput}) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(facet, (i) => Z[i]).values() : [facet]) {\n          channels.forEach(({map}, i) => map.mapIndex(I, X[i], MX[i]));\n        }\n      }\n      return {data, facets};\n    }),\n    ...Object.fromEntries(channels.map(({key, output}) => [key, output]))\n  };\n}\n\nfunction maybeMap(map) {\n  if (map == null) throw new Error(\"missing map\");\n  if (typeof map.mapIndex === \"function\") return map;\n  if (typeof map.map === \"function\" && (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(map)) return mapMap(map); // N.B. array.map\n  if (typeof map === \"function\") return mapFunction((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.taker)(map));\n  switch (`${map}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction((I, V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.rank)(I, (i) => V[i]));\n    case \"quantile\":\n      return mapFunction((I, V) => rankQuantile(I, (i) => V[i]));\n  }\n  throw new Error(`invalid map: ${map}`);\n}\n\nfunction mapMap(map) {\n  console.warn(\"deprecated map interface; implement mapIndex instead.\");\n  return {mapIndex: map.map.bind(map)};\n}\n\nfunction rankQuantile(I, f) {\n  const n = (0,d3__WEBPACK_IMPORTED_MODULE_0__.count)(I, f) - 1;\n  return (0,d3__WEBPACK_IMPORTED_MODULE_0__.rank)(I, f).map((r) => r / n);\n}\n\nfunction mapFunction(f) {\n  return {\n    mapIndex(I, S, T) {\n      const M = f(I, S);\n      if (M.length !== I.length) throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i) T[I[i]] = M[i];\n    }\n  };\n}\n\nconst mapCumsum = {\n  mapIndex(I, S, T) {\n    let sum = 0;\n    for (const i of I) T[i] = sum += S[i];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL21hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDdUQ7QUFDNUQ7O0FBRTFCLGtDQUFrQztBQUN6QyxPQUFPLFdBQVc7QUFDbEIsMEVBQTBFLG9CQUFvQixpREFBUTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sa0NBQWtDO0FBQ3pDLE9BQU8sV0FBVztBQUNsQiwwRUFBMEUsb0JBQW9CLGlEQUFRO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyx5QkFBeUIsY0FBYztBQUM5QyxZQUFZLG1EQUFNO0FBQ2xCO0FBQ0Esa0JBQWtCLHVEQUFVO0FBQzVCLDJEQUEyRCxJQUFJO0FBQy9ELGdDQUFnQyxtREFBTTtBQUN0QyxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0EsT0FBTyxnREFBSztBQUNaLGdCQUFnQixvREFBTztBQUN2QiwrQkFBK0IsTUFBTSxLQUFLLG9EQUFPO0FBQ2pELGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsNEJBQTRCLHlDQUFLO0FBQ2pDLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFEQUFRLDJCQUEyQjtBQUMxRSxvREFBb0Qsa0RBQUs7QUFDekQsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0Qzs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxZQUFZLHlDQUFLO0FBQ2pCLFNBQVMsd0NBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvdHJhbnNmb3Jtcy9tYXAuanM/MGExMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NvdW50LCBncm91cCwgcmFua30gZnJvbSBcImQzXCI7XG5pbXBvcnQge2NvbHVtbiwgaWRlbnRpdHksIGlzT2JqZWN0LCBtYXliZUlucHV0LCBtYXliZVosIHRha2VyLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtiYXNpY30gZnJvbSBcIi4vYmFzaWMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFgobWFwcGVyLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHt4LCB4MSwgeDJ9ID0gb3B0aW9ucztcbiAgaWYgKHggPT09IHVuZGVmaW5lZCAmJiB4MSA9PT0gdW5kZWZpbmVkICYmIHgyID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgeDogKHggPSBpZGVudGl0eSl9O1xuICBjb25zdCBvdXRwdXRzID0ge307XG4gIGlmICh4ICE9IG51bGwpIG91dHB1dHMueCA9IG1hcHBlcjtcbiAgaWYgKHgxICE9IG51bGwpIG91dHB1dHMueDEgPSBtYXBwZXI7XG4gIGlmICh4MiAhPSBudWxsKSBvdXRwdXRzLngyID0gbWFwcGVyO1xuICByZXR1cm4gbWFwKG91dHB1dHMsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwWShtYXBwZXIsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQge3ksIHkxLCB5Mn0gPSBvcHRpb25zO1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkICYmIHkxID09PSB1bmRlZmluZWQgJiYgeTIgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCB5OiAoeSA9IGlkZW50aXR5KX07XG4gIGNvbnN0IG91dHB1dHMgPSB7fTtcbiAgaWYgKHkgIT0gbnVsbCkgb3V0cHV0cy55ID0gbWFwcGVyO1xuICBpZiAoeTEgIT0gbnVsbCkgb3V0cHV0cy55MSA9IG1hcHBlcjtcbiAgaWYgKHkyICE9IG51bGwpIG91dHB1dHMueTIgPSBtYXBwZXI7XG4gIHJldHVybiBtYXAob3V0cHV0cywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXAob3V0cHV0cyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeiA9IG1heWJlWihvcHRpb25zKTtcbiAgY29uc3QgY2hhbm5lbHMgPSBPYmplY3QuZW50cmllcyhvdXRwdXRzKS5tYXAoKFtrZXksIG1hcF0pID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IG1heWJlSW5wdXQoa2V5LCBvcHRpb25zKTtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGNoYW5uZWw6ICR7a2V5fWApO1xuICAgIGNvbnN0IFtvdXRwdXQsIHNldE91dHB1dF0gPSBjb2x1bW4oaW5wdXQpO1xuICAgIHJldHVybiB7a2V5LCBpbnB1dCwgb3V0cHV0LCBzZXRPdXRwdXQsIG1hcDogbWF5YmVNYXAobWFwKX07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmJhc2ljKG9wdGlvbnMsIChkYXRhLCBmYWNldHMpID0+IHtcbiAgICAgIGNvbnN0IFogPSB2YWx1ZW9mKGRhdGEsIHopO1xuICAgICAgY29uc3QgWCA9IGNoYW5uZWxzLm1hcCgoe2lucHV0fSkgPT4gdmFsdWVvZihkYXRhLCBpbnB1dCkpO1xuICAgICAgY29uc3QgTVggPSBjaGFubmVscy5tYXAoKHtzZXRPdXRwdXR9KSA9PiBzZXRPdXRwdXQobmV3IEFycmF5KGRhdGEubGVuZ3RoKSkpO1xuICAgICAgZm9yIChjb25zdCBmYWNldCBvZiBmYWNldHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBJIG9mIFogPyBncm91cChmYWNldCwgKGkpID0+IFpbaV0pLnZhbHVlcygpIDogW2ZhY2V0XSkge1xuICAgICAgICAgIGNoYW5uZWxzLmZvckVhY2goKHttYXB9LCBpKSA9PiBtYXAubWFwSW5kZXgoSSwgWFtpXSwgTVhbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtkYXRhLCBmYWNldHN9O1xuICAgIH0pLFxuICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhjaGFubmVscy5tYXAoKHtrZXksIG91dHB1dH0pID0+IFtrZXksIG91dHB1dF0pKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXliZU1hcChtYXApIHtcbiAgaWYgKG1hcCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG1hcFwiKTtcbiAgaWYgKHR5cGVvZiBtYXAubWFwSW5kZXggPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG1hcDtcbiAgaWYgKHR5cGVvZiBtYXAubWFwID09PSBcImZ1bmN0aW9uXCIgJiYgaXNPYmplY3QobWFwKSkgcmV0dXJuIG1hcE1hcChtYXApOyAvLyBOLkIuIGFycmF5Lm1hcFxuICBpZiAodHlwZW9mIG1hcCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbWFwRnVuY3Rpb24odGFrZXIobWFwKSk7XG4gIHN3aXRjaCAoYCR7bWFwfWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJjdW1zdW1cIjpcbiAgICAgIHJldHVybiBtYXBDdW1zdW07XG4gICAgY2FzZSBcInJhbmtcIjpcbiAgICAgIHJldHVybiBtYXBGdW5jdGlvbigoSSwgVikgPT4gcmFuayhJLCAoaSkgPT4gVltpXSkpO1xuICAgIGNhc2UgXCJxdWFudGlsZVwiOlxuICAgICAgcmV0dXJuIG1hcEZ1bmN0aW9uKChJLCBWKSA9PiByYW5rUXVhbnRpbGUoSSwgKGkpID0+IFZbaV0pKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbWFwOiAke21hcH1gKTtcbn1cblxuZnVuY3Rpb24gbWFwTWFwKG1hcCkge1xuICBjb25zb2xlLndhcm4oXCJkZXByZWNhdGVkIG1hcCBpbnRlcmZhY2U7IGltcGxlbWVudCBtYXBJbmRleCBpbnN0ZWFkLlwiKTtcbiAgcmV0dXJuIHttYXBJbmRleDogbWFwLm1hcC5iaW5kKG1hcCl9O1xufVxuXG5mdW5jdGlvbiByYW5rUXVhbnRpbGUoSSwgZikge1xuICBjb25zdCBuID0gY291bnQoSSwgZikgLSAxO1xuICByZXR1cm4gcmFuayhJLCBmKS5tYXAoKHIpID0+IHIgLyBuKTtcbn1cblxuZnVuY3Rpb24gbWFwRnVuY3Rpb24oZikge1xuICByZXR1cm4ge1xuICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgIGNvbnN0IE0gPSBmKEksIFMpO1xuICAgICAgaWYgKE0ubGVuZ3RoICE9PSBJLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwibWFwIGZ1bmN0aW9uIHJldHVybmVkIGEgbWlzbWF0Y2hlZCBsZW5ndGhcIik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbiA9IEkubGVuZ3RoOyBpIDwgbjsgKytpKSBUW0lbaV1dID0gTVtpXTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IG1hcEN1bXN1bSA9IHtcbiAgbWFwSW5kZXgoSSwgUywgVCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAoY29uc3QgaSBvZiBJKSBUW2ldID0gc3VtICs9IFNbaV07XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/normalize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/normalize.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeX: () => (/* binding */ normalizeX),\n/* harmony export */   normalizeY: () => (/* binding */ normalizeY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n\n\n\n\n\nfunction normalizeX(basis, options) {\n  if (arguments.length === 1) ({basis, ...options} = basis);\n  return (0,_map_js__WEBPACK_IMPORTED_MODULE_1__.mapX)(normalize(basis), options);\n}\n\nfunction normalizeY(basis, options) {\n  if (arguments.length === 1) ({basis, ...options} = basis);\n  return (0,_map_js__WEBPACK_IMPORTED_MODULE_1__.mapY)(normalize(basis), options);\n}\n\nfunction normalize(basis) {\n  if (basis === undefined) return normalizeFirst;\n  if (typeof basis === \"function\") return normalizeBasis((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.taker)(basis));\n  if (/^p\\d{2}$/i.test(basis)) return normalizeAccessor((0,_options_js__WEBPACK_IMPORTED_MODULE_2__.percentile)(basis));\n  switch (`${basis}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis}`);\n}\n\nfunction normalizeBasis(basis) {\n  return {\n    mapIndex(I, S, T) {\n      const b = +basis(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\n\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, (i) => S[i]));\n}\n\nconst normalizeExtent = {\n  mapIndex(I, S, T) {\n    const [s1, s2] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(I, (i) => S[i]);\n    const d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\n\nconst normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s = S[I[i]];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_3__.defined)(s)) return s;\n  }\n});\n\nconst normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s = S[I[i]];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_3__.defined)(s)) return s;\n  }\n});\n\nconst normalizeDeviation = {\n  mapIndex(I, S, T) {\n    const m = (0,d3__WEBPACK_IMPORTED_MODULE_0__.mean)(I, (i) => S[i]);\n    const d = (0,d3__WEBPACK_IMPORTED_MODULE_0__.deviation)(I, (i) => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m) / d : 0;\n    }\n  }\n};\n\nconst normalizeMax = normalizeAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.max);\nconst normalizeMean = normalizeAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.mean);\nconst normalizeMedian = normalizeAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.median);\nconst normalizeMin = normalizeAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.min);\nconst normalizeSum = normalizeAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.sum);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL25vcm1hbGl6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtFO0FBQzVCO0FBQ1U7QUFDWjs7QUFFN0I7QUFDUCxnQ0FBZ0MsbUJBQW1CO0FBQ25ELFNBQVMsNkNBQUk7QUFDYjs7QUFFTztBQUNQLGdDQUFnQyxtQkFBbUI7QUFDbkQsU0FBUyw2Q0FBSTtBQUNiOztBQUVPO0FBQ1A7QUFDQSx5REFBeUQsa0RBQUs7QUFDOUQsWUFBWSxFQUFFLDBDQUEwQyx1REFBVTtBQUNsRSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBLFFBQVEsb0RBQU87QUFDZjtBQUNBLENBQUM7O0FBRUQ7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLFFBQVEsb0RBQU87QUFDZjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGNBQWMsd0NBQUk7QUFDbEIsY0FBYyw2Q0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxtQ0FBRztBQUMxQyx3Q0FBd0Msb0NBQUk7QUFDNUMsMENBQTBDLHNDQUFNO0FBQ2hELHVDQUF1QyxtQ0FBRztBQUMxQyx1Q0FBdUMsbUNBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3RyYW5zZm9ybXMvbm9ybWFsaXplLmpzP2M4MjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtleHRlbnQsIGRldmlhdGlvbiwgbWF4LCBtZWFuLCBtZWRpYW4sIG1pbiwgc3VtfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7ZGVmaW5lZH0gZnJvbSBcIi4uL2RlZmluZWQuanNcIjtcbmltcG9ydCB7cGVyY2VudGlsZSwgdGFrZXJ9IGZyb20gXCIuLi9vcHRpb25zLmpzXCI7XG5pbXBvcnQge21hcFgsIG1hcFl9IGZyb20gXCIuL21hcC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWChiYXNpcywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgKHtiYXNpcywgLi4ub3B0aW9uc30gPSBiYXNpcyk7XG4gIHJldHVybiBtYXBYKG5vcm1hbGl6ZShiYXNpcyksIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWShiYXNpcywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgKHtiYXNpcywgLi4ub3B0aW9uc30gPSBiYXNpcyk7XG4gIHJldHVybiBtYXBZKG5vcm1hbGl6ZShiYXNpcyksIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKGJhc2lzKSB7XG4gIGlmIChiYXNpcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbm9ybWFsaXplRmlyc3Q7XG4gIGlmICh0eXBlb2YgYmFzaXMgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG5vcm1hbGl6ZUJhc2lzKHRha2VyKGJhc2lzKSk7XG4gIGlmICgvXnBcXGR7Mn0kL2kudGVzdChiYXNpcykpIHJldHVybiBub3JtYWxpemVBY2Nlc3NvcihwZXJjZW50aWxlKGJhc2lzKSk7XG4gIHN3aXRjaCAoYCR7YmFzaXN9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImRldmlhdGlvblwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZURldmlhdGlvbjtcbiAgICBjYXNlIFwiZmlyc3RcIjpcbiAgICAgIHJldHVybiBub3JtYWxpemVGaXJzdDtcbiAgICBjYXNlIFwibGFzdFwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUxhc3Q7XG4gICAgY2FzZSBcIm1heFwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZU1heDtcbiAgICBjYXNlIFwibWVhblwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZU1lYW47XG4gICAgY2FzZSBcIm1lZGlhblwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZU1lZGlhbjtcbiAgICBjYXNlIFwibWluXCI6XG4gICAgICByZXR1cm4gbm9ybWFsaXplTWluO1xuICAgIGNhc2UgXCJzdW1cIjpcbiAgICAgIHJldHVybiBub3JtYWxpemVTdW07XG4gICAgY2FzZSBcImV4dGVudFwiOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUV4dGVudDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYmFzaXM6ICR7YmFzaXN9YCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2lzKGJhc2lzKSB7XG4gIHJldHVybiB7XG4gICAgbWFwSW5kZXgoSSwgUywgVCkge1xuICAgICAgY29uc3QgYiA9ICtiYXNpcyhJLCBTKTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBJKSB7XG4gICAgICAgIFRbaV0gPSBTW2ldID09PSBudWxsID8gTmFOIDogU1tpXSAvIGI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBY2Nlc3NvcihmKSB7XG4gIHJldHVybiBub3JtYWxpemVCYXNpcygoSSwgUykgPT4gZihJLCAoaSkgPT4gU1tpXSkpO1xufVxuXG5jb25zdCBub3JtYWxpemVFeHRlbnQgPSB7XG4gIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICBjb25zdCBbczEsIHMyXSA9IGV4dGVudChJLCAoaSkgPT4gU1tpXSk7XG4gICAgY29uc3QgZCA9IHMyIC0gczE7XG4gICAgZm9yIChjb25zdCBpIG9mIEkpIHtcbiAgICAgIFRbaV0gPSBTW2ldID09PSBudWxsID8gTmFOIDogKFNbaV0gLSBzMSkgLyBkO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3Qgbm9ybWFsaXplRmlyc3QgPSBub3JtYWxpemVCYXNpcygoSSwgUykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IEkubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzID0gU1tJW2ldXTtcbiAgICBpZiAoZGVmaW5lZChzKSkgcmV0dXJuIHM7XG4gIH1cbn0pO1xuXG5jb25zdCBub3JtYWxpemVMYXN0ID0gbm9ybWFsaXplQmFzaXMoKEksIFMpID0+IHtcbiAgZm9yIChsZXQgaSA9IEkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBzID0gU1tJW2ldXTtcbiAgICBpZiAoZGVmaW5lZChzKSkgcmV0dXJuIHM7XG4gIH1cbn0pO1xuXG5jb25zdCBub3JtYWxpemVEZXZpYXRpb24gPSB7XG4gIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICBjb25zdCBtID0gbWVhbihJLCAoaSkgPT4gU1tpXSk7XG4gICAgY29uc3QgZCA9IGRldmlhdGlvbihJLCAoaSkgPT4gU1tpXSk7XG4gICAgZm9yIChjb25zdCBpIG9mIEkpIHtcbiAgICAgIFRbaV0gPSBTW2ldID09PSBudWxsID8gTmFOIDogZCA/IChTW2ldIC0gbSkgLyBkIDogMDtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IG5vcm1hbGl6ZU1heCA9IG5vcm1hbGl6ZUFjY2Vzc29yKG1heCk7XG5jb25zdCBub3JtYWxpemVNZWFuID0gbm9ybWFsaXplQWNjZXNzb3IobWVhbik7XG5jb25zdCBub3JtYWxpemVNZWRpYW4gPSBub3JtYWxpemVBY2Nlc3NvcihtZWRpYW4pO1xuY29uc3Qgbm9ybWFsaXplTWluID0gbm9ybWFsaXplQWNjZXNzb3IobWluKTtcbmNvbnN0IG5vcm1hbGl6ZVN1bSA9IG5vcm1hbGl6ZUFjY2Vzc29yKHN1bSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/normalize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/select.js":
/*!******************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/select.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   selectFirst: () => (/* binding */ selectFirst),\n/* harmony export */   selectLast: () => (/* binding */ selectLast),\n/* harmony export */   selectMaxX: () => (/* binding */ selectMaxX),\n/* harmony export */   selectMaxY: () => (/* binding */ selectMaxY),\n/* harmony export */   selectMinX: () => (/* binding */ selectMinX),\n/* harmony export */   selectMinY: () => (/* binding */ selectMinY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\nfunction select(selector, options = {}) {\n  // If specified selector is a string or function, it’s a selector without an\n  // input channel such as first or last.\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  // Otherwise the selector is an option {name: value} where name is a channel\n  // name and value is a selector definition that additionally takes the given\n  // channel values as input. The selector object must have exactly one key.\n  let key, value;\n  for (key in selector) {\n    if (value !== undefined) throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === undefined) throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\n\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\") return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\n\nfunction selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\n\nfunction selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\n\nfunction selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\n\nfunction selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\n\nfunction selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\n\nfunction selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\n\nfunction* selectorFirst(I) {\n  yield I[0];\n}\n\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\n\nfunction* selectorMin(I, X) {\n  yield (0,d3__WEBPACK_IMPORTED_MODULE_0__.least)(I, (i) => X[i]);\n}\n\nfunction* selectorMax(I, X) {\n  yield (0,d3__WEBPACK_IMPORTED_MODULE_0__.greatest)(I, (i) => X[i]);\n}\n\nfunction selectChannel(v, selector, options) {\n  if (v != null) {\n    if (options[v] == null) throw new Error(`missing channel: ${v}`);\n    v = options[v];\n  }\n  const z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeZ)(options);\n  return (0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.basic)(options, (data, facets) => {\n    const Z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, z);\n    const V = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, v);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(facet, (i) => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return {data, facets: selectFacets};\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3NlbGVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ0k7QUFDYjs7QUFFMUIsc0NBQXNDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEseUNBQUs7QUFDYjs7QUFFQTtBQUNBLFFBQVEsNENBQVE7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQSxZQUFZLG1EQUFNO0FBQ2xCLFNBQVMsZ0RBQUs7QUFDZCxjQUFjLG9EQUFPO0FBQ3JCLGNBQWMsb0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3RyYW5zZm9ybXMvc2VsZWN0LmpzPzNkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtncmVhdGVzdCwgZ3JvdXAsIGxlYXN0fSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7bWF5YmVaLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtiYXNpY30gZnJvbSBcIi4vYmFzaWMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdChzZWxlY3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gIC8vIElmIHNwZWNpZmllZCBzZWxlY3RvciBpcyBhIHN0cmluZyBvciBmdW5jdGlvbiwgaXTigJlzIGEgc2VsZWN0b3Igd2l0aG91dCBhblxuICAvLyBpbnB1dCBjaGFubmVsIHN1Y2ggYXMgZmlyc3Qgb3IgbGFzdC5cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHN3aXRjaCAoc2VsZWN0b3IudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcImZpcnN0XCI6XG4gICAgICAgIHJldHVybiBzZWxlY3RGaXJzdChvcHRpb25zKTtcbiAgICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICAgIHJldHVybiBzZWxlY3RMYXN0KG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2VsZWN0Q2hhbm5lbChudWxsLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBpcyBhbiBvcHRpb24ge25hbWU6IHZhbHVlfSB3aGVyZSBuYW1lIGlzIGEgY2hhbm5lbFxuICAvLyBuYW1lIGFuZCB2YWx1ZSBpcyBhIHNlbGVjdG9yIGRlZmluaXRpb24gdGhhdCBhZGRpdGlvbmFsbHkgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGNoYW5uZWwgdmFsdWVzIGFzIGlucHV0LiBUaGUgc2VsZWN0b3Igb2JqZWN0IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBrZXkuXG4gIGxldCBrZXksIHZhbHVlO1xuICBmb3IgKGtleSBpbiBzZWxlY3Rvcikge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXMgc2VsZWN0b3I7IG11bHRpcGxlIGlucHV0c1wiKTtcbiAgICB2YWx1ZSA9IG1heWJlU2VsZWN0b3Ioc2VsZWN0b3Jba2V5XSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWxlY3RvcjogJHtzZWxlY3Rvcn1gKTtcbiAgcmV0dXJuIHNlbGVjdENoYW5uZWwoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG1heWJlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gc2VsZWN0b3I7XG4gIHN3aXRjaCAoYCR7c2VsZWN0b3J9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcIm1pblwiOlxuICAgICAgcmV0dXJuIHNlbGVjdG9yTWluO1xuICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgIHJldHVybiBzZWxlY3Rvck1heDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2VsZWN0b3I6ICR7c2VsZWN0b3J9YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RGaXJzdChvcHRpb25zKSB7XG4gIHJldHVybiBzZWxlY3RDaGFubmVsKG51bGwsIHNlbGVjdG9yRmlyc3QsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0TGFzdChvcHRpb25zKSB7XG4gIHJldHVybiBzZWxlY3RDaGFubmVsKG51bGwsIHNlbGVjdG9yTGFzdCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RNaW5YKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbGVjdENoYW5uZWwoXCJ4XCIsIHNlbGVjdG9yTWluLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdE1pblkob3B0aW9ucykge1xuICByZXR1cm4gc2VsZWN0Q2hhbm5lbChcInlcIiwgc2VsZWN0b3JNaW4sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0TWF4WChvcHRpb25zKSB7XG4gIHJldHVybiBzZWxlY3RDaGFubmVsKFwieFwiLCBzZWxlY3Rvck1heCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RNYXhZKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbGVjdENoYW5uZWwoXCJ5XCIsIHNlbGVjdG9yTWF4LCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24qIHNlbGVjdG9yRmlyc3QoSSkge1xuICB5aWVsZCBJWzBdO1xufVxuXG5mdW5jdGlvbiogc2VsZWN0b3JMYXN0KEkpIHtcbiAgeWllbGQgSVtJLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiogc2VsZWN0b3JNaW4oSSwgWCkge1xuICB5aWVsZCBsZWFzdChJLCAoaSkgPT4gWFtpXSk7XG59XG5cbmZ1bmN0aW9uKiBzZWxlY3Rvck1heChJLCBYKSB7XG4gIHlpZWxkIGdyZWF0ZXN0KEksIChpKSA9PiBYW2ldKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0Q2hhbm5lbCh2LCBzZWxlY3Rvciwgb3B0aW9ucykge1xuICBpZiAodiAhPSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnNbdl0gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGNoYW5uZWw6ICR7dn1gKTtcbiAgICB2ID0gb3B0aW9uc1t2XTtcbiAgfVxuICBjb25zdCB6ID0gbWF5YmVaKG9wdGlvbnMpO1xuICByZXR1cm4gYmFzaWMob3B0aW9ucywgKGRhdGEsIGZhY2V0cykgPT4ge1xuICAgIGNvbnN0IFogPSB2YWx1ZW9mKGRhdGEsIHopO1xuICAgIGNvbnN0IFYgPSB2YWx1ZW9mKGRhdGEsIHYpO1xuICAgIGNvbnN0IHNlbGVjdEZhY2V0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzKSB7XG4gICAgICBjb25zdCBzZWxlY3RGYWNldCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBJIG9mIFogPyBncm91cChmYWNldCwgKGkpID0+IFpbaV0pLnZhbHVlcygpIDogW2ZhY2V0XSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2VsZWN0b3IoSSwgVikpIHtcbiAgICAgICAgICBzZWxlY3RGYWNldC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxlY3RGYWNldHMucHVzaChzZWxlY3RGYWNldCk7XG4gICAgfVxuICAgIHJldHVybiB7ZGF0YSwgZmFjZXRzOiBzZWxlY3RGYWNldHN9O1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/select.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/shift.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/shift.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shiftX: () => (/* binding */ shiftX),\n/* harmony export */   shiftY: () => (/* binding */ shiftY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../time.js */ \"(ssr)/./node_modules/@observablehq/plot/src/time.js\");\n/* harmony import */ var _transforms_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transforms/map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n\n\n\n\n\nfunction shiftX(interval, options) {\n  return shiftK(\"x\", interval, options);\n}\n\nfunction shiftY(interval, options) {\n  return shiftK(\"y\", interval, options);\n}\n\nfunction shiftK(x, interval, options = {}) {\n  let offset;\n  let k = 1;\n  if (typeof interval === \"number\") {\n    k = interval;\n    offset = (x, k) => +x + k;\n  } else {\n    if (typeof interval === \"string\") {\n      const sign = interval.startsWith(\"-\") ? -1 : 1;\n      [interval, k] = (0,_time_js__WEBPACK_IMPORTED_MODULE_1__.parseTimeInterval)(interval.replace(/^[+-]/, \"\"));\n      k *= sign;\n    }\n    interval = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.maybeInterval)(interval);\n    offset = (x, k) => interval.offset(x, k);\n  }\n  const x1 = `${x}1`;\n  const x2 = `${x}2`;\n  const mapped = (0,_transforms_map_js__WEBPACK_IMPORTED_MODULE_3__.map)(\n    {\n      [x1]: (D) => D.map((d) => offset(d, k)),\n      [x2]: (D) => D\n    },\n    options\n  );\n  const t = mapped[x2].transform;\n  mapped[x2].transform = () => {\n    const V = t();\n    const [x0, x1] = (0,d3__WEBPACK_IMPORTED_MODULE_0__.extent)(V);\n    V.domain = k < 0 ? [x0, offset(x1, k)] : [offset(x0, k), x1];\n    return V;\n  };\n  return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3NoaWZ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQjtBQUNrQjtBQUNDO0FBQ0o7O0FBRWxDO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQiwyREFBaUI7QUFDdkM7QUFDQTtBQUNBLGVBQWUsMERBQWE7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCLGdCQUFnQixFQUFFO0FBQ2xCLGlCQUFpQix1REFBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3NoaWZ0LmpzPzVkMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtleHRlbnR9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHttYXliZUludGVydmFsfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtwYXJzZVRpbWVJbnRlcnZhbH0gZnJvbSBcIi4uL3RpbWUuanNcIjtcbmltcG9ydCB7bWFwfSBmcm9tIFwiLi4vdHJhbnNmb3Jtcy9tYXAuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0WChpbnRlcnZhbCwgb3B0aW9ucykge1xuICByZXR1cm4gc2hpZnRLKFwieFwiLCBpbnRlcnZhbCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGlmdFkoaW50ZXJ2YWwsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNoaWZ0SyhcInlcIiwgaW50ZXJ2YWwsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzaGlmdEsoeCwgaW50ZXJ2YWwsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgb2Zmc2V0O1xuICBsZXQgayA9IDE7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICBrID0gaW50ZXJ2YWw7XG4gICAgb2Zmc2V0ID0gKHgsIGspID0+ICt4ICsgaztcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBzaWduID0gaW50ZXJ2YWwuc3RhcnRzV2l0aChcIi1cIikgPyAtMSA6IDE7XG4gICAgICBbaW50ZXJ2YWwsIGtdID0gcGFyc2VUaW1lSW50ZXJ2YWwoaW50ZXJ2YWwucmVwbGFjZSgvXlsrLV0vLCBcIlwiKSk7XG4gICAgICBrICo9IHNpZ247XG4gICAgfVxuICAgIGludGVydmFsID0gbWF5YmVJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgb2Zmc2V0ID0gKHgsIGspID0+IGludGVydmFsLm9mZnNldCh4LCBrKTtcbiAgfVxuICBjb25zdCB4MSA9IGAke3h9MWA7XG4gIGNvbnN0IHgyID0gYCR7eH0yYDtcbiAgY29uc3QgbWFwcGVkID0gbWFwKFxuICAgIHtcbiAgICAgIFt4MV06IChEKSA9PiBELm1hcCgoZCkgPT4gb2Zmc2V0KGQsIGspKSxcbiAgICAgIFt4Ml06IChEKSA9PiBEXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGNvbnN0IHQgPSBtYXBwZWRbeDJdLnRyYW5zZm9ybTtcbiAgbWFwcGVkW3gyXS50cmFuc2Zvcm0gPSAoKSA9PiB7XG4gICAgY29uc3QgViA9IHQoKTtcbiAgICBjb25zdCBbeDAsIHgxXSA9IGV4dGVudChWKTtcbiAgICBWLmRvbWFpbiA9IGsgPCAwID8gW3gwLCBvZmZzZXQoeDEsIGspXSA6IFtvZmZzZXQoeDAsIGspLCB4MV07XG4gICAgcmV0dXJuIFY7XG4gIH07XG4gIHJldHVybiBtYXBwZWQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/shift.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/stack.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeStackX: () => (/* binding */ maybeStackX),\n/* harmony export */   maybeStackY: () => (/* binding */ maybeStackY),\n/* harmony export */   stackX: () => (/* binding */ stackX),\n/* harmony export */   stackX1: () => (/* binding */ stackX1),\n/* harmony export */   stackX2: () => (/* binding */ stackX2),\n/* harmony export */   stackY: () => (/* binding */ stackY),\n/* harmony export */   stackY1: () => (/* binding */ stackY1),\n/* harmony export */   stackY2: () => (/* binding */ stackY2)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _mark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mark.js */ \"(ssr)/./node_modules/@observablehq/plot/src/mark.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n/* harmony import */ var _exclusiveFacets_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exclusiveFacets.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js\");\n\n\n\n\n\n\n\n\nfunction stackX(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x, ...rest} = options; // note: consumes x!\n  const [transform, Y, x1, x2] = stack(y, x, \"y\", \"x\", stackOptions, rest);\n  return {...transform, y1, y: Y, x1, x2, x: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.mid)(x1, x2)};\n}\n\nfunction stackX1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x} = options;\n  const [transform, Y, X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {...transform, y1, y: Y, x: X};\n}\n\nfunction stackX2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x} = options;\n  const [transform, Y, , X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {...transform, y1, y: Y, x: X};\n}\n\nfunction stackY(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y, ...rest} = options; // note: consumes y!\n  const [transform, X, y1, y2] = stack(x, y, \"x\", \"y\", stackOptions, rest);\n  return {...transform, x1, x: X, y1, y2, y: (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.mid)(y1, y2)};\n}\n\nfunction stackY1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y} = options;\n  const [transform, X, Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {...transform, x1, x: X, y: Y};\n}\n\nfunction stackY2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y} = options;\n  const [transform, X, , Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {...transform, x1, x: X, y: Y};\n}\n\nfunction maybeStackX({x, x1, x2, ...options} = {}) {\n  options = (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.withTip)(options, \"y\");\n  if (x1 === undefined && x2 === undefined) return stackX({x, ...options});\n  [x1, x2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeZero)(x, x1, x2);\n  return {...options, x1, x2};\n}\n\nfunction maybeStackY({y, y1, y2, ...options} = {}) {\n  options = (0,_mark_js__WEBPACK_IMPORTED_MODULE_2__.withTip)(options, \"x\");\n  if (y1 === undefined && y2 === undefined) return stackY({y, ...options});\n  [y1, y2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeZero)(y, y1, y2);\n  return {...options, y1, y2};\n}\n\n// The reverse option is ambiguous: it is both a stack option and a basic\n// transform. If only one options object is specified, we interpret it as a\n// stack option, and therefore must remove it from the propagated options.\nfunction mergeOptions(options) {\n  const {offset, order, reverse, ...rest} = options;\n  return [{offset, order, reverse}, rest];\n}\n\n// This is a hint to the tooltip mark that the y1 and y2 channels (for stackY,\n// or conversely x1 and x2 for stackX) represent a stacked length, and that the\n// tooltip should therefore show y2-y1 instead of an extent.\nconst lengthy = {length: true};\n\nfunction stack(x, y = _options_js__WEBPACK_IMPORTED_MODULE_1__.one, kx, ky, {offset, order, reverse}, options) {\n  if (y === null) throw new Error(`stack requires ${ky}`);\n  const z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeZ)(options);\n  const [X, setX] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeColumn)(x);\n  const [Y1, setY1] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)(y);\n  const [Y2, setY2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)(y);\n  Y1.hint = Y2.hint = lengthy;\n  offset = maybeOffset(offset);\n  order = maybeOrder(order, offset, ky);\n  return [\n    (0,_basic_js__WEBPACK_IMPORTED_MODULE_3__.basic)(options, (data, facets, plotOptions) => {\n      ({data, facets} = (0,_exclusiveFacets_js__WEBPACK_IMPORTED_MODULE_4__.exclusiveFacets)(data, facets));\n      const X = x == null ? undefined : setX((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.maybeApplyInterval)((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, x), plotOptions?.[kx]));\n      const Y = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, y, Float64Array);\n      const Z = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, z);\n      const compare = order && order(data, X, Y, Z);\n      const n = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.lengthof)(data);\n      const Y1 = setY1(new Float64Array(n));\n      const Y2 = setY2(new Float64Array(n));\n      const facetstacks = [];\n      for (const facet of facets) {\n        const stacks = X ? Array.from((0,d3__WEBPACK_IMPORTED_MODULE_0__.group)(facet, (i) => X[i]).values()) : [facet];\n        if (compare) for (const stack of stacks) stack.sort(compare);\n        for (const stack of stacks) {\n          let yn = 0;\n          let yp = 0;\n          if (reverse) stack.reverse();\n          for (const i of stack) {\n            const y = Y[i];\n            if (y < 0) yn = Y2[i] = (Y1[i] = yn) + y;\n            else if (y > 0) yp = Y2[i] = (Y1[i] = yp) + y;\n            else Y2[i] = Y1[i] = yp; // NaN or zero\n          }\n        }\n        facetstacks.push(stacks);\n      }\n      if (offset) offset(facetstacks, Y1, Y2, Z);\n      return {data, facets};\n    }),\n    X,\n    Y1,\n    Y2\n  ];\n}\n\nfunction maybeOffset(offset) {\n  if (offset == null) return;\n  if (typeof offset === \"function\") return offset;\n  switch (`${offset}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset}`);\n}\n\n// Given a single stack, returns the minimum and maximum values from the given\n// Y2 column. Note that this relies on Y2 always being the outer column for\n// diverging values.\nfunction extent(stack, Y2) {\n  let min = 0,\n    max = 0;\n  for (const i of stack) {\n    const y = Y2[i];\n    if (y < min) min = y;\n    if (y > max) max = y;\n  }\n  return [min, max];\n}\n\nfunction offsetExpand(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = 1 / (yp - yn || 1);\n        Y1[i] = m * (Y1[i] - yn);\n        Y2[i] = m * (Y2[i] - yn);\n      }\n    }\n  }\n}\n\nfunction offsetCenter(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = (yp + yn) / 2;\n        Y1[i] -= m;\n        Y2[i] -= m;\n      }\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\n\nfunction offsetWiggle(facetstacks, Y1, Y2, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new d3__WEBPACK_IMPORTED_MODULE_0__.InternMap();\n    let y = 0;\n    for (const stack of stacks) {\n      let j = -1;\n      const Fi = stack.map((i) => Math.abs(Y2[i] - Y1[i]));\n      const Df = stack.map((i) => {\n        j = Z ? Z[i] : ++j;\n        const value = Y2[i] - Y1[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...(0,d3__WEBPACK_IMPORTED_MODULE_0__.cumsum)(Df)];\n      for (const i of stack) {\n        Y1[i] += y;\n        Y2[i] += y;\n      }\n      const s1 = (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(Fi);\n      if (s1) y -= (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\n\nfunction offsetZero(stacks, Y1, Y2) {\n  const m = (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(stacks, (stack) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(stack, (i) => Y1[i]));\n  for (const stack of stacks) {\n    for (const i of stack) {\n      Y1[i] -= m;\n      Y2[i] -= m;\n    }\n  }\n}\n\nfunction offsetCenterFacets(facetstacks, Y1, Y2) {\n  const n = facetstacks.length;\n  if (n === 1) return;\n  const facets = facetstacks.map((stacks) => stacks.flat());\n  const m = facets.map((I) => ((0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(I, (i) => Y1[i]) + (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(I, (i) => Y2[i])) / 2);\n  const m0 = (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(m);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m[j];\n    for (const i of facets[j]) {\n      Y1[i] += p;\n      Y2[i] += p;\n    }\n  }\n}\n\nfunction maybeOrder(order, offset, ky) {\n  if (order === undefined && offset === offsetWiggle) return orderInsideOut(_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined);\n  if (order == null) return;\n  if (typeof order === \"string\") {\n    const negate = order.startsWith(\"-\");\n    const compare = negate ? _defined_js__WEBPACK_IMPORTED_MODULE_5__.descendingDefined : _defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined;\n    switch ((negate ? order.slice(1) : order).toLowerCase()) {\n      case \"value\":\n      case ky:\n        return orderY(compare);\n      case \"z\":\n        return orderZ(compare);\n      case \"sum\":\n        return orderSum(compare);\n      case \"appearance\":\n        return orderAppearance(compare);\n      case \"inside-out\":\n        return orderInsideOut(compare);\n    }\n    return orderAccessor((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.field)(order));\n  }\n  if (typeof order === \"function\") return (order.length === 1 ? orderAccessor : orderComparator)(order);\n  if ((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(order)) return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\n\n// by value\nfunction orderY(compare) {\n  return (data, X, Y) => (i, j) => compare(Y[i], Y[j]);\n}\n\n// by location\nfunction orderZ(compare) {\n  return (data, X, Y, Z) => (i, j) => compare(Z[i], Z[j]);\n}\n\n// by sum of value (a.k.a. “ascending”)\nfunction orderSum(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) =>\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.groupSort)(\n      (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(data),\n      (I) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(I, (i) => Y[i]),\n      (i) => Z[i]\n    )\n  );\n}\n\n// by x = argmax of value\nfunction orderAppearance(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) =>\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.groupSort)(\n      (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(data),\n      (I) => X[(0,d3__WEBPACK_IMPORTED_MODULE_0__.greatest)(I, (i) => Y[i])],\n      (i) => Z[i]\n    )\n  );\n}\n\n// by x = argmax of value, but rearranged inside-out by alternating series\n// according to the sign of a running divergence of sums\nfunction orderInsideOut(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) => {\n    const I = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.range)(data);\n    const K = (0,d3__WEBPACK_IMPORTED_MODULE_0__.groupSort)(\n      I,\n      (I) => X[(0,d3__WEBPACK_IMPORTED_MODULE_0__.greatest)(I, (i) => Y[i])],\n      (i) => Z[i]\n    );\n    const sums = (0,d3__WEBPACK_IMPORTED_MODULE_0__.rollup)(\n      I,\n      (I) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.sum)(I, (i) => Y[i]),\n      (i) => Z[i]\n    );\n    const Kp = [],\n      Kn = [];\n    let s = 0;\n    for (const k of K) {\n      if (s < 0) {\n        s += sums.get(k);\n        Kp.push(k);\n      } else {\n        s -= sums.get(k);\n        Kn.push(k);\n      }\n    }\n    return Kn.reverse().concat(Kp);\n  });\n}\n\nfunction orderAccessor(f) {\n  return (data) => {\n    const O = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, f);\n    return (i, j) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined)(O[i], O[j]);\n  };\n}\n\nfunction orderComparator(f) {\n  return (data) => {\n    return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(data) ? (i, j) => f(data[i], data[j]) : (i, j) => f(data.get(i), data.get(j));\n  };\n}\n\nfunction orderGiven(domain) {\n  return orderZDomain(_defined_js__WEBPACK_IMPORTED_MODULE_5__.ascendingDefined, () => domain);\n}\n\n// Given an ordering (domain) of distinct values in z that can be derived from\n// the data, returns a comparator that can be used to sort stacks. Note that\n// this is a series order: it will be consistent across stacks.\nfunction orderZDomain(compare, domain) {\n  return (data, X, Y, Z) => {\n    if (!Z) throw new Error(\"missing channel: z\");\n    const map = new d3__WEBPACK_IMPORTED_MODULE_0__.InternMap(domain(data, X, Y, Z).map((d, i) => [d, i]));\n    return (i, j) => compare(map.get(Z[i]), map.get(Z[j]));\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3N0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdGO0FBQ3RCO0FBQy9CO0FBQzhDO0FBQ1E7QUFDeEQ7QUFDb0I7O0FBRTlDLGlDQUFpQyxjQUFjO0FBQ3REO0FBQ0EsU0FBUyx3QkFBd0IsV0FBVztBQUM1QztBQUNBLFVBQVUsbUNBQW1DLGdEQUFHO0FBQ2hEOztBQUVPLGtDQUFrQyxjQUFjO0FBQ3ZEO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0EsVUFBVTtBQUNWOztBQUVPLGtDQUFrQyxjQUFjO0FBQ3ZEO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0EsVUFBVTtBQUNWOztBQUVPLGlDQUFpQyxjQUFjO0FBQ3REO0FBQ0EsU0FBUyx3QkFBd0IsV0FBVztBQUM1QztBQUNBLFVBQVUsbUNBQW1DLGdEQUFHO0FBQ2hEOztBQUVPLGtDQUFrQyxjQUFjO0FBQ3ZEO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0EsVUFBVTtBQUNWOztBQUVPLGtDQUFrQyxjQUFjO0FBQ3ZEO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0EsVUFBVTtBQUNWOztBQUVPLHNCQUFzQix1QkFBdUIsSUFBSTtBQUN4RCxZQUFZLGlEQUFPO0FBQ25CLDJEQUEyRCxjQUFjO0FBQ3pFLGFBQWEsc0RBQVM7QUFDdEIsVUFBVTtBQUNWOztBQUVPLHNCQUFzQix1QkFBdUIsSUFBSTtBQUN4RCxZQUFZLGlEQUFPO0FBQ25CLDJEQUEyRCxjQUFjO0FBQ3pFLGFBQWEsc0RBQVM7QUFDdEIsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQ0FBaUM7QUFDMUMsV0FBVyx1QkFBdUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQixzQkFBc0IsNENBQUcsV0FBVyx1QkFBdUI7QUFDM0Qsb0RBQW9ELEdBQUc7QUFDdkQsWUFBWSxtREFBTTtBQUNsQixvQkFBb0Isd0RBQVc7QUFDL0Isc0JBQXNCLG1EQUFNO0FBQzVCLHNCQUFzQixtREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVCxRQUFRLGNBQWMsRUFBRSxvRUFBZTtBQUN2Qyw2Q0FBNkMsK0RBQWtCLENBQUMsb0RBQU87QUFDdkUsZ0JBQWdCLG9EQUFPO0FBQ3ZCLGdCQUFnQixvREFBTztBQUN2QjtBQUNBLGdCQUFnQixxREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5Q0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix5Q0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5QkFBeUIsMENBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQUc7QUFDcEIsbUJBQW1CLHVDQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHVDQUFHLG9CQUFvQix1Q0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1Q0FBRyxvQkFBb0IsdUNBQUc7QUFDekQsYUFBYSx1Q0FBRztBQUNoQixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSx5REFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFpQixHQUFHLHlEQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBSztBQUM5QjtBQUNBO0FBQ0EsTUFBTSxvREFBTztBQUNiLG9DQUFvQyxNQUFNO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQVM7QUFDYixNQUFNLGtEQUFLO0FBQ1gsYUFBYSx1Q0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFTO0FBQ2IsTUFBTSxrREFBSztBQUNYLGVBQWUsNENBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFLO0FBQ25CLGNBQWMsNkNBQVM7QUFDdkI7QUFDQSxlQUFlLDRDQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsMENBQU07QUFDdkI7QUFDQSxhQUFhLHVDQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9EQUFPO0FBQ3JCLHFCQUFxQiw2REFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlEQUFnQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVM7QUFDN0I7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3N0YWNrLmpzPzMwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbnRlcm5NYXAsIGN1bXN1bSwgZ3JlYXRlc3QsIGdyb3VwLCBncm91cFNvcnQsIG1heCwgbWluLCByb2xsdXAsIHN1bX0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2FzY2VuZGluZ0RlZmluZWQsIGRlc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IHt3aXRoVGlwfSBmcm9tIFwiLi4vbWFyay5qc1wiO1xuaW1wb3J0IHttYXliZUFwcGx5SW50ZXJ2YWwsIG1heWJlQ29sdW1uLCBtYXliZVosIG1heWJlWmVyb30gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7Y29sdW1uLCBmaWVsZCwgaXNBcnJheSwgbGVuZ3Rob2YsIG1pZCwgb25lLCByYW5nZSwgdmFsdWVvZn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7YmFzaWN9IGZyb20gXCIuL2Jhc2ljLmpzXCI7XG5pbXBvcnQge2V4Y2x1c2l2ZUZhY2V0c30gZnJvbSBcIi4vZXhjbHVzaXZlRmFjZXRzLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFja1goc3RhY2tPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgW3N0YWNrT3B0aW9ucywgb3B0aW9uc10gPSBtZXJnZU9wdGlvbnMoc3RhY2tPcHRpb25zKTtcbiAgY29uc3Qge3kxLCB5ID0geTEsIHgsIC4uLnJlc3R9ID0gb3B0aW9uczsgLy8gbm90ZTogY29uc3VtZXMgeCFcbiAgY29uc3QgW3RyYW5zZm9ybSwgWSwgeDEsIHgyXSA9IHN0YWNrKHksIHgsIFwieVwiLCBcInhcIiwgc3RhY2tPcHRpb25zLCByZXN0KTtcbiAgcmV0dXJuIHsuLi50cmFuc2Zvcm0sIHkxLCB5OiBZLCB4MSwgeDIsIHg6IG1pZCh4MSwgeDIpfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YWNrWDEoc3RhY2tPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgW3N0YWNrT3B0aW9ucywgb3B0aW9uc10gPSBtZXJnZU9wdGlvbnMoc3RhY2tPcHRpb25zKTtcbiAgY29uc3Qge3kxLCB5ID0geTEsIHh9ID0gb3B0aW9ucztcbiAgY29uc3QgW3RyYW5zZm9ybSwgWSwgWF0gPSBzdGFjayh5LCB4LCBcInlcIiwgXCJ4XCIsIHN0YWNrT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB7Li4udHJhbnNmb3JtLCB5MSwgeTogWSwgeDogWH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFja1gyKHN0YWNrT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIFtzdGFja09wdGlvbnMsIG9wdGlvbnNdID0gbWVyZ2VPcHRpb25zKHN0YWNrT3B0aW9ucyk7XG4gIGNvbnN0IHt5MSwgeSA9IHkxLCB4fSA9IG9wdGlvbnM7XG4gIGNvbnN0IFt0cmFuc2Zvcm0sIFksICwgWF0gPSBzdGFjayh5LCB4LCBcInlcIiwgXCJ4XCIsIHN0YWNrT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB7Li4udHJhbnNmb3JtLCB5MSwgeTogWSwgeDogWH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFja1koc3RhY2tPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgW3N0YWNrT3B0aW9ucywgb3B0aW9uc10gPSBtZXJnZU9wdGlvbnMoc3RhY2tPcHRpb25zKTtcbiAgY29uc3Qge3gxLCB4ID0geDEsIHksIC4uLnJlc3R9ID0gb3B0aW9uczsgLy8gbm90ZTogY29uc3VtZXMgeSFcbiAgY29uc3QgW3RyYW5zZm9ybSwgWCwgeTEsIHkyXSA9IHN0YWNrKHgsIHksIFwieFwiLCBcInlcIiwgc3RhY2tPcHRpb25zLCByZXN0KTtcbiAgcmV0dXJuIHsuLi50cmFuc2Zvcm0sIHgxLCB4OiBYLCB5MSwgeTIsIHk6IG1pZCh5MSwgeTIpfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YWNrWTEoc3RhY2tPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgW3N0YWNrT3B0aW9ucywgb3B0aW9uc10gPSBtZXJnZU9wdGlvbnMoc3RhY2tPcHRpb25zKTtcbiAgY29uc3Qge3gxLCB4ID0geDEsIHl9ID0gb3B0aW9ucztcbiAgY29uc3QgW3RyYW5zZm9ybSwgWCwgWV0gPSBzdGFjayh4LCB5LCBcInhcIiwgXCJ5XCIsIHN0YWNrT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB7Li4udHJhbnNmb3JtLCB4MSwgeDogWCwgeTogWX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFja1kyKHN0YWNrT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIFtzdGFja09wdGlvbnMsIG9wdGlvbnNdID0gbWVyZ2VPcHRpb25zKHN0YWNrT3B0aW9ucyk7XG4gIGNvbnN0IHt4MSwgeCA9IHgxLCB5fSA9IG9wdGlvbnM7XG4gIGNvbnN0IFt0cmFuc2Zvcm0sIFgsICwgWV0gPSBzdGFjayh4LCB5LCBcInhcIiwgXCJ5XCIsIHN0YWNrT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB7Li4udHJhbnNmb3JtLCB4MSwgeDogWCwgeTogWX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVN0YWNrWCh7eCwgeDEsIHgyLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIG9wdGlvbnMgPSB3aXRoVGlwKG9wdGlvbnMsIFwieVwiKTtcbiAgaWYgKHgxID09PSB1bmRlZmluZWQgJiYgeDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN0YWNrWCh7eCwgLi4ub3B0aW9uc30pO1xuICBbeDEsIHgyXSA9IG1heWJlWmVybyh4LCB4MSwgeDIpO1xuICByZXR1cm4gey4uLm9wdGlvbnMsIHgxLCB4Mn07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVN0YWNrWSh7eSwgeTEsIHkyLCAuLi5vcHRpb25zfSA9IHt9KSB7XG4gIG9wdGlvbnMgPSB3aXRoVGlwKG9wdGlvbnMsIFwieFwiKTtcbiAgaWYgKHkxID09PSB1bmRlZmluZWQgJiYgeTIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN0YWNrWSh7eSwgLi4ub3B0aW9uc30pO1xuICBbeTEsIHkyXSA9IG1heWJlWmVybyh5LCB5MSwgeTIpO1xuICByZXR1cm4gey4uLm9wdGlvbnMsIHkxLCB5Mn07XG59XG5cbi8vIFRoZSByZXZlcnNlIG9wdGlvbiBpcyBhbWJpZ3VvdXM6IGl0IGlzIGJvdGggYSBzdGFjayBvcHRpb24gYW5kIGEgYmFzaWNcbi8vIHRyYW5zZm9ybS4gSWYgb25seSBvbmUgb3B0aW9ucyBvYmplY3QgaXMgc3BlY2lmaWVkLCB3ZSBpbnRlcnByZXQgaXQgYXMgYVxuLy8gc3RhY2sgb3B0aW9uLCBhbmQgdGhlcmVmb3JlIG11c3QgcmVtb3ZlIGl0IGZyb20gdGhlIHByb3BhZ2F0ZWQgb3B0aW9ucy5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IHtvZmZzZXQsIG9yZGVyLCByZXZlcnNlLCAuLi5yZXN0fSA9IG9wdGlvbnM7XG4gIHJldHVybiBbe29mZnNldCwgb3JkZXIsIHJldmVyc2V9LCByZXN0XTtcbn1cblxuLy8gVGhpcyBpcyBhIGhpbnQgdG8gdGhlIHRvb2x0aXAgbWFyayB0aGF0IHRoZSB5MSBhbmQgeTIgY2hhbm5lbHMgKGZvciBzdGFja1ksXG4vLyBvciBjb252ZXJzZWx5IHgxIGFuZCB4MiBmb3Igc3RhY2tYKSByZXByZXNlbnQgYSBzdGFja2VkIGxlbmd0aCwgYW5kIHRoYXQgdGhlXG4vLyB0b29sdGlwIHNob3VsZCB0aGVyZWZvcmUgc2hvdyB5Mi15MSBpbnN0ZWFkIG9mIGFuIGV4dGVudC5cbmNvbnN0IGxlbmd0aHkgPSB7bGVuZ3RoOiB0cnVlfTtcblxuZnVuY3Rpb24gc3RhY2soeCwgeSA9IG9uZSwga3gsIGt5LCB7b2Zmc2V0LCBvcmRlciwgcmV2ZXJzZX0sIG9wdGlvbnMpIHtcbiAgaWYgKHkgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihgc3RhY2sgcmVxdWlyZXMgJHtreX1gKTtcbiAgY29uc3QgeiA9IG1heWJlWihvcHRpb25zKTtcbiAgY29uc3QgW1gsIHNldFhdID0gbWF5YmVDb2x1bW4oeCk7XG4gIGNvbnN0IFtZMSwgc2V0WTFdID0gY29sdW1uKHkpO1xuICBjb25zdCBbWTIsIHNldFkyXSA9IGNvbHVtbih5KTtcbiAgWTEuaGludCA9IFkyLmhpbnQgPSBsZW5ndGh5O1xuICBvZmZzZXQgPSBtYXliZU9mZnNldChvZmZzZXQpO1xuICBvcmRlciA9IG1heWJlT3JkZXIob3JkZXIsIG9mZnNldCwga3kpO1xuICByZXR1cm4gW1xuICAgIGJhc2ljKG9wdGlvbnMsIChkYXRhLCBmYWNldHMsIHBsb3RPcHRpb25zKSA9PiB7XG4gICAgICAoe2RhdGEsIGZhY2V0c30gPSBleGNsdXNpdmVGYWNldHMoZGF0YSwgZmFjZXRzKSk7XG4gICAgICBjb25zdCBYID0geCA9PSBudWxsID8gdW5kZWZpbmVkIDogc2V0WChtYXliZUFwcGx5SW50ZXJ2YWwodmFsdWVvZihkYXRhLCB4KSwgcGxvdE9wdGlvbnM/LltreF0pKTtcbiAgICAgIGNvbnN0IFkgPSB2YWx1ZW9mKGRhdGEsIHksIEZsb2F0NjRBcnJheSk7XG4gICAgICBjb25zdCBaID0gdmFsdWVvZihkYXRhLCB6KTtcbiAgICAgIGNvbnN0IGNvbXBhcmUgPSBvcmRlciAmJiBvcmRlcihkYXRhLCBYLCBZLCBaKTtcbiAgICAgIGNvbnN0IG4gPSBsZW5ndGhvZihkYXRhKTtcbiAgICAgIGNvbnN0IFkxID0gc2V0WTEobmV3IEZsb2F0NjRBcnJheShuKSk7XG4gICAgICBjb25zdCBZMiA9IHNldFkyKG5ldyBGbG9hdDY0QXJyYXkobikpO1xuICAgICAgY29uc3QgZmFjZXRzdGFja3MgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IFggPyBBcnJheS5mcm9tKGdyb3VwKGZhY2V0LCAoaSkgPT4gWFtpXSkudmFsdWVzKCkpIDogW2ZhY2V0XTtcbiAgICAgICAgaWYgKGNvbXBhcmUpIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSBzdGFjay5zb3J0KGNvbXBhcmUpO1xuICAgICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICAgIGxldCB5biA9IDA7XG4gICAgICAgICAgbGV0IHlwID0gMDtcbiAgICAgICAgICBpZiAocmV2ZXJzZSkgc3RhY2sucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzdGFjaykge1xuICAgICAgICAgICAgY29uc3QgeSA9IFlbaV07XG4gICAgICAgICAgICBpZiAoeSA8IDApIHluID0gWTJbaV0gPSAoWTFbaV0gPSB5bikgKyB5O1xuICAgICAgICAgICAgZWxzZSBpZiAoeSA+IDApIHlwID0gWTJbaV0gPSAoWTFbaV0gPSB5cCkgKyB5O1xuICAgICAgICAgICAgZWxzZSBZMltpXSA9IFkxW2ldID0geXA7IC8vIE5hTiBvciB6ZXJvXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZhY2V0c3RhY2tzLnB1c2goc3RhY2tzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQpIG9mZnNldChmYWNldHN0YWNrcywgWTEsIFkyLCBaKTtcbiAgICAgIHJldHVybiB7ZGF0YSwgZmFjZXRzfTtcbiAgICB9KSxcbiAgICBYLFxuICAgIFkxLFxuICAgIFkyXG4gIF07XG59XG5cbmZ1bmN0aW9uIG1heWJlT2Zmc2V0KG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09IG51bGwpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9mZnNldDtcbiAgc3dpdGNoIChgJHtvZmZzZXR9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImV4cGFuZFwiOlxuICAgIGNhc2UgXCJub3JtYWxpemVcIjpcbiAgICAgIHJldHVybiBvZmZzZXRFeHBhbmQ7XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgIGNhc2UgXCJzaWxob3VldHRlXCI6XG4gICAgICByZXR1cm4gb2Zmc2V0Q2VudGVyO1xuICAgIGNhc2UgXCJ3aWdnbGVcIjpcbiAgICAgIHJldHVybiBvZmZzZXRXaWdnbGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG9mZnNldDogJHtvZmZzZXR9YCk7XG59XG5cbi8vIEdpdmVuIGEgc2luZ2xlIHN0YWNrLCByZXR1cm5zIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBmcm9tIHRoZSBnaXZlblxuLy8gWTIgY29sdW1uLiBOb3RlIHRoYXQgdGhpcyByZWxpZXMgb24gWTIgYWx3YXlzIGJlaW5nIHRoZSBvdXRlciBjb2x1bW4gZm9yXG4vLyBkaXZlcmdpbmcgdmFsdWVzLlxuZnVuY3Rpb24gZXh0ZW50KHN0YWNrLCBZMikge1xuICBsZXQgbWluID0gMCxcbiAgICBtYXggPSAwO1xuICBmb3IgKGNvbnN0IGkgb2Ygc3RhY2spIHtcbiAgICBjb25zdCB5ID0gWTJbaV07XG4gICAgaWYgKHkgPCBtaW4pIG1pbiA9IHk7XG4gICAgaWYgKHkgPiBtYXgpIG1heCA9IHk7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIG9mZnNldEV4cGFuZChmYWNldHN0YWNrcywgWTEsIFkyKSB7XG4gIGZvciAoY29uc3Qgc3RhY2tzIG9mIGZhY2V0c3RhY2tzKSB7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGNvbnN0IFt5biwgeXBdID0gZXh0ZW50KHN0YWNrLCBZMik7XG4gICAgICBmb3IgKGNvbnN0IGkgb2Ygc3RhY2spIHtcbiAgICAgICAgY29uc3QgbSA9IDEgLyAoeXAgLSB5biB8fCAxKTtcbiAgICAgICAgWTFbaV0gPSBtICogKFkxW2ldIC0geW4pO1xuICAgICAgICBZMltpXSA9IG0gKiAoWTJbaV0gLSB5bik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldENlbnRlcihmYWNldHN0YWNrcywgWTEsIFkyKSB7XG4gIGZvciAoY29uc3Qgc3RhY2tzIG9mIGZhY2V0c3RhY2tzKSB7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGNvbnN0IFt5biwgeXBdID0gZXh0ZW50KHN0YWNrLCBZMik7XG4gICAgICBmb3IgKGNvbnN0IGkgb2Ygc3RhY2spIHtcbiAgICAgICAgY29uc3QgbSA9ICh5cCArIHluKSAvIDI7XG4gICAgICAgIFkxW2ldIC09IG07XG4gICAgICAgIFkyW2ldIC09IG07XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldFplcm8oc3RhY2tzLCBZMSwgWTIpO1xuICB9XG4gIG9mZnNldENlbnRlckZhY2V0cyhmYWNldHN0YWNrcywgWTEsIFkyKTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0V2lnZ2xlKGZhY2V0c3RhY2tzLCBZMSwgWTIsIFopIHtcbiAgZm9yIChjb25zdCBzdGFja3Mgb2YgZmFjZXRzdGFja3MpIHtcbiAgICBjb25zdCBwcmV2ID0gbmV3IEludGVybk1hcCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgbGV0IGogPSAtMTtcbiAgICAgIGNvbnN0IEZpID0gc3RhY2subWFwKChpKSA9PiBNYXRoLmFicyhZMltpXSAtIFkxW2ldKSk7XG4gICAgICBjb25zdCBEZiA9IHN0YWNrLm1hcCgoaSkgPT4ge1xuICAgICAgICBqID0gWiA/IFpbaV0gOiArK2o7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gWTJbaV0gLSBZMVtpXTtcbiAgICAgICAgY29uc3QgZGlmZiA9IHByZXYuaGFzKGopID8gdmFsdWUgLSBwcmV2LmdldChqKSA6IDA7XG4gICAgICAgIHByZXYuc2V0KGosIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IENmMSA9IFswLCAuLi5jdW1zdW0oRGYpXTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBzdGFjaykge1xuICAgICAgICBZMVtpXSArPSB5O1xuICAgICAgICBZMltpXSArPSB5O1xuICAgICAgfVxuICAgICAgY29uc3QgczEgPSBzdW0oRmkpO1xuICAgICAgaWYgKHMxKSB5IC09IHN1bShGaSwgKGQsIGkpID0+IChEZltpXSAvIDIgKyBDZjFbaV0pICogZCkgLyBzMTtcbiAgICB9XG4gICAgb2Zmc2V0WmVybyhzdGFja3MsIFkxLCBZMik7XG4gIH1cbiAgb2Zmc2V0Q2VudGVyRmFjZXRzKGZhY2V0c3RhY2tzLCBZMSwgWTIpO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRaZXJvKHN0YWNrcywgWTEsIFkyKSB7XG4gIGNvbnN0IG0gPSBtaW4oc3RhY2tzLCAoc3RhY2spID0+IG1pbihzdGFjaywgKGkpID0+IFkxW2ldKSk7XG4gIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHN0YWNrKSB7XG4gICAgICBZMVtpXSAtPSBtO1xuICAgICAgWTJbaV0gLT0gbTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0Q2VudGVyRmFjZXRzKGZhY2V0c3RhY2tzLCBZMSwgWTIpIHtcbiAgY29uc3QgbiA9IGZhY2V0c3RhY2tzLmxlbmd0aDtcbiAgaWYgKG4gPT09IDEpIHJldHVybjtcbiAgY29uc3QgZmFjZXRzID0gZmFjZXRzdGFja3MubWFwKChzdGFja3MpID0+IHN0YWNrcy5mbGF0KCkpO1xuICBjb25zdCBtID0gZmFjZXRzLm1hcCgoSSkgPT4gKG1pbihJLCAoaSkgPT4gWTFbaV0pICsgbWF4KEksIChpKSA9PiBZMltpXSkpIC8gMik7XG4gIGNvbnN0IG0wID0gbWluKG0pO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG47IGorKykge1xuICAgIGNvbnN0IHAgPSBtMCAtIG1bal07XG4gICAgZm9yIChjb25zdCBpIG9mIGZhY2V0c1tqXSkge1xuICAgICAgWTFbaV0gKz0gcDtcbiAgICAgIFkyW2ldICs9IHA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlT3JkZXIob3JkZXIsIG9mZnNldCwga3kpIHtcbiAgaWYgKG9yZGVyID09PSB1bmRlZmluZWQgJiYgb2Zmc2V0ID09PSBvZmZzZXRXaWdnbGUpIHJldHVybiBvcmRlckluc2lkZU91dChhc2NlbmRpbmdEZWZpbmVkKTtcbiAgaWYgKG9yZGVyID09IG51bGwpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IG5lZ2F0ZSA9IG9yZGVyLnN0YXJ0c1dpdGgoXCItXCIpO1xuICAgIGNvbnN0IGNvbXBhcmUgPSBuZWdhdGUgPyBkZXNjZW5kaW5nRGVmaW5lZCA6IGFzY2VuZGluZ0RlZmluZWQ7XG4gICAgc3dpdGNoICgobmVnYXRlID8gb3JkZXIuc2xpY2UoMSkgOiBvcmRlcikudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICBjYXNlIGt5OlxuICAgICAgICByZXR1cm4gb3JkZXJZKGNvbXBhcmUpO1xuICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgcmV0dXJuIG9yZGVyWihjb21wYXJlKTtcbiAgICAgIGNhc2UgXCJzdW1cIjpcbiAgICAgICAgcmV0dXJuIG9yZGVyU3VtKGNvbXBhcmUpO1xuICAgICAgY2FzZSBcImFwcGVhcmFuY2VcIjpcbiAgICAgICAgcmV0dXJuIG9yZGVyQXBwZWFyYW5jZShjb21wYXJlKTtcbiAgICAgIGNhc2UgXCJpbnNpZGUtb3V0XCI6XG4gICAgICAgIHJldHVybiBvcmRlckluc2lkZU91dChjb21wYXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyQWNjZXNzb3IoZmllbGQob3JkZXIpKTtcbiAgfVxuICBpZiAodHlwZW9mIG9yZGVyID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAob3JkZXIubGVuZ3RoID09PSAxID8gb3JkZXJBY2Nlc3NvciA6IG9yZGVyQ29tcGFyYXRvcikob3JkZXIpO1xuICBpZiAoaXNBcnJheShvcmRlcikpIHJldHVybiBvcmRlckdpdmVuKG9yZGVyKTtcbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9yZGVyOiAke29yZGVyfWApO1xufVxuXG4vLyBieSB2YWx1ZVxuZnVuY3Rpb24gb3JkZXJZKGNvbXBhcmUpIHtcbiAgcmV0dXJuIChkYXRhLCBYLCBZKSA9PiAoaSwgaikgPT4gY29tcGFyZShZW2ldLCBZW2pdKTtcbn1cblxuLy8gYnkgbG9jYXRpb25cbmZ1bmN0aW9uIG9yZGVyWihjb21wYXJlKSB7XG4gIHJldHVybiAoZGF0YSwgWCwgWSwgWikgPT4gKGksIGopID0+IGNvbXBhcmUoWltpXSwgWltqXSk7XG59XG5cbi8vIGJ5IHN1bSBvZiB2YWx1ZSAoYS5rLmEuIOKAnGFzY2VuZGluZ+KAnSlcbmZ1bmN0aW9uIG9yZGVyU3VtKGNvbXBhcmUpIHtcbiAgcmV0dXJuIG9yZGVyWkRvbWFpbihjb21wYXJlLCAoZGF0YSwgWCwgWSwgWikgPT5cbiAgICBncm91cFNvcnQoXG4gICAgICByYW5nZShkYXRhKSxcbiAgICAgIChJKSA9PiBzdW0oSSwgKGkpID0+IFlbaV0pLFxuICAgICAgKGkpID0+IFpbaV1cbiAgICApXG4gICk7XG59XG5cbi8vIGJ5IHggPSBhcmdtYXggb2YgdmFsdWVcbmZ1bmN0aW9uIG9yZGVyQXBwZWFyYW5jZShjb21wYXJlKSB7XG4gIHJldHVybiBvcmRlclpEb21haW4oY29tcGFyZSwgKGRhdGEsIFgsIFksIFopID0+XG4gICAgZ3JvdXBTb3J0KFxuICAgICAgcmFuZ2UoZGF0YSksXG4gICAgICAoSSkgPT4gWFtncmVhdGVzdChJLCAoaSkgPT4gWVtpXSldLFxuICAgICAgKGkpID0+IFpbaV1cbiAgICApXG4gICk7XG59XG5cbi8vIGJ5IHggPSBhcmdtYXggb2YgdmFsdWUsIGJ1dCByZWFycmFuZ2VkIGluc2lkZS1vdXQgYnkgYWx0ZXJuYXRpbmcgc2VyaWVzXG4vLyBhY2NvcmRpbmcgdG8gdGhlIHNpZ24gb2YgYSBydW5uaW5nIGRpdmVyZ2VuY2Ugb2Ygc3Vtc1xuZnVuY3Rpb24gb3JkZXJJbnNpZGVPdXQoY29tcGFyZSkge1xuICByZXR1cm4gb3JkZXJaRG9tYWluKGNvbXBhcmUsIChkYXRhLCBYLCBZLCBaKSA9PiB7XG4gICAgY29uc3QgSSA9IHJhbmdlKGRhdGEpO1xuICAgIGNvbnN0IEsgPSBncm91cFNvcnQoXG4gICAgICBJLFxuICAgICAgKEkpID0+IFhbZ3JlYXRlc3QoSSwgKGkpID0+IFlbaV0pXSxcbiAgICAgIChpKSA9PiBaW2ldXG4gICAgKTtcbiAgICBjb25zdCBzdW1zID0gcm9sbHVwKFxuICAgICAgSSxcbiAgICAgIChJKSA9PiBzdW0oSSwgKGkpID0+IFlbaV0pLFxuICAgICAgKGkpID0+IFpbaV1cbiAgICApO1xuICAgIGNvbnN0IEtwID0gW10sXG4gICAgICBLbiA9IFtdO1xuICAgIGxldCBzID0gMDtcbiAgICBmb3IgKGNvbnN0IGsgb2YgSykge1xuICAgICAgaWYgKHMgPCAwKSB7XG4gICAgICAgIHMgKz0gc3Vtcy5nZXQoayk7XG4gICAgICAgIEtwLnB1c2goayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzIC09IHN1bXMuZ2V0KGspO1xuICAgICAgICBLbi5wdXNoKGspO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gS24ucmV2ZXJzZSgpLmNvbmNhdChLcCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcmRlckFjY2Vzc29yKGYpIHtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgY29uc3QgTyA9IHZhbHVlb2YoZGF0YSwgZik7XG4gICAgcmV0dXJuIChpLCBqKSA9PiBhc2NlbmRpbmdEZWZpbmVkKE9baV0sIE9bal0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvcmRlckNvbXBhcmF0b3IoZikge1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gaXNBcnJheShkYXRhKSA/IChpLCBqKSA9PiBmKGRhdGFbaV0sIGRhdGFbal0pIDogKGksIGopID0+IGYoZGF0YS5nZXQoaSksIGRhdGEuZ2V0KGopKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3JkZXJHaXZlbihkb21haW4pIHtcbiAgcmV0dXJuIG9yZGVyWkRvbWFpbihhc2NlbmRpbmdEZWZpbmVkLCAoKSA9PiBkb21haW4pO1xufVxuXG4vLyBHaXZlbiBhbiBvcmRlcmluZyAoZG9tYWluKSBvZiBkaXN0aW5jdCB2YWx1ZXMgaW4geiB0aGF0IGNhbiBiZSBkZXJpdmVkIGZyb21cbi8vIHRoZSBkYXRhLCByZXR1cm5zIGEgY29tcGFyYXRvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHNvcnQgc3RhY2tzLiBOb3RlIHRoYXRcbi8vIHRoaXMgaXMgYSBzZXJpZXMgb3JkZXI6IGl0IHdpbGwgYmUgY29uc2lzdGVudCBhY3Jvc3Mgc3RhY2tzLlxuZnVuY3Rpb24gb3JkZXJaRG9tYWluKGNvbXBhcmUsIGRvbWFpbikge1xuICByZXR1cm4gKGRhdGEsIFgsIFksIFopID0+IHtcbiAgICBpZiAoIVopIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hhbm5lbDogelwiKTtcbiAgICBjb25zdCBtYXAgPSBuZXcgSW50ZXJuTWFwKGRvbWFpbihkYXRhLCBYLCBZLCBaKS5tYXAoKGQsIGkpID0+IFtkLCBpXSkpO1xuICAgIHJldHVybiAoaSwgaikgPT4gY29tcGFyZShtYXAuZ2V0KFpbaV0pLCBtYXAuZ2V0KFpbal0pKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/tree.js":
/*!****************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/tree.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maybeTreeAnchor: () => (/* binding */ maybeTreeAnchor),\n/* harmony export */   treeLink: () => (/* binding */ treeLink),\n/* harmony export */   treeNode: () => (/* binding */ treeNode)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/basic.js\");\n\n\n\n\n\nfunction treeNode({\n  path = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, // the delimited path\n  delimiter, // how the path is separated\n  frameAnchor,\n  treeLayout = d3__WEBPACK_IMPORTED_MODULE_0__.tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeNodeValue(treeFilter);\n  if (frameAnchor === undefined) frameAnchor = treeAnchor.frameAnchor;\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeNodeValue);\n  const [X, setX] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  const [Y, setY] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  return {\n    x: X,\n    y: Y,\n    frameAnchor,\n    ...(0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.basic)(options, (data, facets) => {\n      const P = normalize((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, path));\n      const X = setX([]);\n      const Y = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = (0,d3__WEBPACK_IMPORTED_MODULE_0__.stratify)().path((i) => P[i]);\n      const setData = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(data)\n        ? (node) => (node.data = data[node.data])\n        : (node) => (node.data = data.get(node.data));\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? _options_js__WEBPACK_IMPORTED_MODULE_1__.one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter((i) => P[i] != null)).each(setData);\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const node of root.descendants()) {\n          if (treeFilter != null && !treeFilter(node)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X, Y);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {data: treeData, facets: treeFacets};\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\n\nfunction treeLink({\n  path = _options_js__WEBPACK_IMPORTED_MODULE_1__.identity, // the delimited path\n  delimiter, // how the path is separated\n  curve = \"bump-x\",\n  stroke = \"#555\",\n  strokeWidth = 1.5,\n  strokeOpacity = 0.5,\n  treeLayout = d3__WEBPACK_IMPORTED_MODULE_0__.tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeLinkValue(treeFilter);\n  options = {curve, stroke, strokeWidth, strokeOpacity, ...options};\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeLinkValue);\n  const [X1, setX1] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  const [X2, setX2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  const [Y1, setY1] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  const [Y2, setY2] = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)();\n  return {\n    x1: X1,\n    x2: X2,\n    y1: Y1,\n    y2: Y2,\n    ...(0,_basic_js__WEBPACK_IMPORTED_MODULE_2__.basic)(options, (data, facets) => {\n      const P = normalize((0,_options_js__WEBPACK_IMPORTED_MODULE_1__.valueof)(data, path));\n      const X1 = setX1([]);\n      const X2 = setX2([]);\n      const Y1 = setY1([]);\n      const Y2 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = (0,d3__WEBPACK_IMPORTED_MODULE_0__.stratify)().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? _options_js__WEBPACK_IMPORTED_MODULE_1__.one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter((i) => P[i] != null)).each((node) => (node.data = data[node.data]));\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const {source, target} of root.links()) {\n          if (treeFilter != null && !treeFilter(target, source)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X1, Y1);\n          treeAnchor.position(target, treeIndex, X2, Y2);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {data: treeData, facets: treeFacets};\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\n\nfunction maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\n\nconst treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({x, y}, i, X, Y) {\n    X[i] = y;\n    Y[i] = -x;\n  }\n};\n\nconst treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({x, y}, i, X, Y) {\n    X[i] = -y;\n    Y[i] = -x;\n  }\n};\n\nfunction maybeTreeSort(sort) {\n  return sort == null || typeof sort === \"function\"\n    ? sort\n    : `${sort}`.trim().toLowerCase().startsWith(\"node:\")\n    ? nodeSort(maybeNodeValue(sort))\n    : nodeSort(nodeData(sort));\n}\n\nfunction nodeSort(value) {\n  return (a, b) => (0,_defined_js__WEBPACK_IMPORTED_MODULE_3__.ascendingDefined)(value(a), value(b));\n}\n\nfunction nodeData(field) {\n  return (node) => node.data?.[field];\n}\n\nfunction normalizer(delimiter = \"/\") {\n  delimiter = `${delimiter}`;\n  if (delimiter === \"/\") return (P) => P; // paths are already slash-separated\n  if (delimiter.length !== 1) throw new Error(\"delimiter must be exactly one character\");\n  const delimiterCode = delimiter.charCodeAt(0);\n  return (P) => P.map((p) => slashDelimiter(p, delimiterCode));\n}\n\nconst CODE_BACKSLASH = 92;\nconst CODE_SLASH = 47;\n\nfunction slashDelimiter(input, delimiterCode) {\n  if (delimiterCode === CODE_BACKSLASH) throw new Error(\"delimiter cannot be backslash\");\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n        break;\n      case delimiterCode:\n        if (afterBackslash) {\n          (input = input.slice(0, i - 1) + input.slice(i)), --i, --n; // remove backslash\n        } else {\n          input = input.slice(0, i) + \"/\" + input.slice(i + 1); // replace delimiter with slash\n        }\n        break;\n      case CODE_SLASH:\n        if (afterBackslash) {\n          (input = input.slice(0, i) + \"\\\\\\\\\" + input.slice(i)), (i += 2), (n += 2); // add two backslashes\n        } else {\n          (input = input.slice(0, i) + \"\\\\\" + input.slice(i)), ++i, ++n; // add backslash\n        }\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\n\nfunction slashUnescape(input) {\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n      // eslint-disable-next-line no-fallthrough\n      case CODE_SLASH:\n        if (afterBackslash) {\n          (input = input.slice(0, i - 1) + input.slice(i)), --i, --n; // remove backslash\n        }\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\n\nfunction isNodeValue(option) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(option) && typeof option.node === \"function\";\n}\n\nfunction isLinkValue(option) {\n  return (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(option) && typeof option.link === \"function\";\n}\n\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value)) return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\")) return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\n\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value)) return value.node;\n  if (isLinkValue(value)) return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\")) return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\n\nfunction nodePath(node) {\n  return node.id;\n}\n\nfunction nodeName(node) {\n  return nameof(node.id);\n}\n\nfunction nodeDepth(node) {\n  return node.depth;\n}\n\nfunction nodeHeight(node) {\n  return node.height;\n}\n\nfunction nodeInternal(node) {\n  return !!node.children;\n}\n\nfunction nodeExternal(node) {\n  return !node.children;\n}\n\nfunction parentValue(evaluate) {\n  return (child, parent) => (parent == null ? undefined : evaluate(parent));\n}\n\n// Walk backwards to find the first slash.\nfunction nameof(path) {\n  let i = path.length;\n  while (--i > 0) if (slash(path, i)) break;\n  return slashUnescape(path.slice(i + 1));\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n\n// These indexes match the array returned by nodeOutputs. The first two elements\n// are always the name of the output and its column value definition so that\n// the outputs can be passed directly to Object.fromEntries.\nconst output_setValues = 2;\nconst output_evaluate = 3;\nconst output_values = 4;\n\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== undefined) {\n      outputs.push([name, ...(0,_options_js__WEBPACK_IMPORTED_MODULE_1__.column)(value), treeValue]);\n    }\n  }\n  return outputs;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3RyZWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNhO0FBQ2lDO0FBQy9DOztBQUUxQjtBQUNQLFNBQVMsaURBQVE7QUFDakI7QUFDQTtBQUNBLGVBQWUsb0NBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBTTtBQUMxQixvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdEQUFLO0FBQ1osMEJBQTBCLG9EQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVE7QUFDN0Isc0JBQXNCLG9EQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDRDQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVPO0FBQ1AsU0FBUyxpREFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07QUFDNUIsc0JBQXNCLG1EQUFNO0FBQzVCLHNCQUFzQixtREFBTTtBQUM1QixzQkFBc0IsbURBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQUs7QUFDWiwwQkFBMEIsb0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVE7QUFDN0I7QUFDQTtBQUNBLGlHQUFpRyw0Q0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVPO0FBQ1AsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw2REFBZ0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLFVBQVU7QUFDVixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsVUFBVTtBQUNWLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxxREFBUTtBQUNqQjs7QUFFQTtBQUNBLFNBQVMscURBQVE7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFmZmljLWZvcmVjYXN0aW5nLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ab2JzZXJ2YWJsZWhxL3Bsb3Qvc3JjL3RyYW5zZm9ybXMvdHJlZS5qcz82MjEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c3RyYXRpZnksIHRyZWV9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHthc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IHtjb2x1bW4sIGlkZW50aXR5LCBpc0FycmF5LCBpc09iamVjdCwgb25lLCB2YWx1ZW9mfSBmcm9tIFwiLi4vb3B0aW9ucy5qc1wiO1xuaW1wb3J0IHtiYXNpY30gZnJvbSBcIi4vYmFzaWMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyZWVOb2RlKHtcbiAgcGF0aCA9IGlkZW50aXR5LCAvLyB0aGUgZGVsaW1pdGVkIHBhdGhcbiAgZGVsaW1pdGVyLCAvLyBob3cgdGhlIHBhdGggaXMgc2VwYXJhdGVkXG4gIGZyYW1lQW5jaG9yLFxuICB0cmVlTGF5b3V0ID0gdHJlZSxcbiAgdHJlZVNvcnQsXG4gIHRyZWVTZXBhcmF0aW9uLFxuICB0cmVlQW5jaG9yLFxuICB0cmVlRmlsdGVyLFxuICAuLi5vcHRpb25zXG59ID0ge30pIHtcbiAgdHJlZUFuY2hvciA9IG1heWJlVHJlZUFuY2hvcih0cmVlQW5jaG9yKTtcbiAgdHJlZVNvcnQgPSBtYXliZVRyZWVTb3J0KHRyZWVTb3J0KTtcbiAgaWYgKHRyZWVGaWx0ZXIgIT0gbnVsbCkgdHJlZUZpbHRlciA9IG1heWJlTm9kZVZhbHVlKHRyZWVGaWx0ZXIpO1xuICBpZiAoZnJhbWVBbmNob3IgPT09IHVuZGVmaW5lZCkgZnJhbWVBbmNob3IgPSB0cmVlQW5jaG9yLmZyYW1lQW5jaG9yO1xuICBjb25zdCBub3JtYWxpemUgPSBub3JtYWxpemVyKGRlbGltaXRlcik7XG4gIGNvbnN0IG91dHB1dHMgPSB0cmVlT3V0cHV0cyhvcHRpb25zLCBtYXliZU5vZGVWYWx1ZSk7XG4gIGNvbnN0IFtYLCBzZXRYXSA9IGNvbHVtbigpO1xuICBjb25zdCBbWSwgc2V0WV0gPSBjb2x1bW4oKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBYLFxuICAgIHk6IFksXG4gICAgZnJhbWVBbmNob3IsXG4gICAgLi4uYmFzaWMob3B0aW9ucywgKGRhdGEsIGZhY2V0cykgPT4ge1xuICAgICAgY29uc3QgUCA9IG5vcm1hbGl6ZSh2YWx1ZW9mKGRhdGEsIHBhdGgpKTtcbiAgICAgIGNvbnN0IFggPSBzZXRYKFtdKTtcbiAgICAgIGNvbnN0IFkgPSBzZXRZKFtdKTtcbiAgICAgIGxldCB0cmVlSW5kZXggPSAtMTtcbiAgICAgIGNvbnN0IHRyZWVEYXRhID0gW107XG4gICAgICBjb25zdCB0cmVlRmFjZXRzID0gW107XG4gICAgICBjb25zdCByb290b2YgPSBzdHJhdGlmeSgpLnBhdGgoKGkpID0+IFBbaV0pO1xuICAgICAgY29uc3Qgc2V0RGF0YSA9IGlzQXJyYXkoZGF0YSlcbiAgICAgICAgPyAobm9kZSkgPT4gKG5vZGUuZGF0YSA9IGRhdGFbbm9kZS5kYXRhXSlcbiAgICAgICAgOiAobm9kZSkgPT4gKG5vZGUuZGF0YSA9IGRhdGEuZ2V0KG5vZGUuZGF0YSkpO1xuICAgICAgY29uc3QgbGF5b3V0ID0gdHJlZUxheW91dCgpO1xuICAgICAgaWYgKGxheW91dC5ub2RlU2l6ZSkgbGF5b3V0Lm5vZGVTaXplKFsxLCAxXSk7XG4gICAgICBpZiAobGF5b3V0LnNlcGFyYXRpb24gJiYgdHJlZVNlcGFyYXRpb24gIT09IHVuZGVmaW5lZCkgbGF5b3V0LnNlcGFyYXRpb24odHJlZVNlcGFyYXRpb24gPz8gb25lKTtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvW291dHB1dF92YWx1ZXNdID0gb1tvdXRwdXRfc2V0VmFsdWVzXShbXSk7XG4gICAgICBmb3IgKGNvbnN0IGZhY2V0IG9mIGZhY2V0cykge1xuICAgICAgICBjb25zdCB0cmVlRmFjZXQgPSBbXTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RvZihmYWNldC5maWx0ZXIoKGkpID0+IFBbaV0gIT0gbnVsbCkpLmVhY2goc2V0RGF0YSk7XG4gICAgICAgIGlmICh0cmVlU29ydCAhPSBudWxsKSByb290LnNvcnQodHJlZVNvcnQpO1xuICAgICAgICBsYXlvdXQocm9vdCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiByb290LmRlc2NlbmRhbnRzKCkpIHtcbiAgICAgICAgICBpZiAodHJlZUZpbHRlciAhPSBudWxsICYmICF0cmVlRmlsdGVyKG5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgICB0cmVlRmFjZXQucHVzaCgrK3RyZWVJbmRleCk7XG4gICAgICAgICAgdHJlZURhdGFbdHJlZUluZGV4XSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICB0cmVlQW5jaG9yLnBvc2l0aW9uKG5vZGUsIHRyZWVJbmRleCwgWCwgWSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIG9bb3V0cHV0X3ZhbHVlc11bdHJlZUluZGV4XSA9IG9bb3V0cHV0X2V2YWx1YXRlXShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0cmVlRmFjZXRzLnB1c2godHJlZUZhY2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7ZGF0YTogdHJlZURhdGEsIGZhY2V0czogdHJlZUZhY2V0c307XG4gICAgfSksXG4gICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKG91dHB1dHMpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmVlTGluayh7XG4gIHBhdGggPSBpZGVudGl0eSwgLy8gdGhlIGRlbGltaXRlZCBwYXRoXG4gIGRlbGltaXRlciwgLy8gaG93IHRoZSBwYXRoIGlzIHNlcGFyYXRlZFxuICBjdXJ2ZSA9IFwiYnVtcC14XCIsXG4gIHN0cm9rZSA9IFwiIzU1NVwiLFxuICBzdHJva2VXaWR0aCA9IDEuNSxcbiAgc3Ryb2tlT3BhY2l0eSA9IDAuNSxcbiAgdHJlZUxheW91dCA9IHRyZWUsXG4gIHRyZWVTb3J0LFxuICB0cmVlU2VwYXJhdGlvbixcbiAgdHJlZUFuY2hvcixcbiAgdHJlZUZpbHRlcixcbiAgLi4ub3B0aW9uc1xufSA9IHt9KSB7XG4gIHRyZWVBbmNob3IgPSBtYXliZVRyZWVBbmNob3IodHJlZUFuY2hvcik7XG4gIHRyZWVTb3J0ID0gbWF5YmVUcmVlU29ydCh0cmVlU29ydCk7XG4gIGlmICh0cmVlRmlsdGVyICE9IG51bGwpIHRyZWVGaWx0ZXIgPSBtYXliZUxpbmtWYWx1ZSh0cmVlRmlsdGVyKTtcbiAgb3B0aW9ucyA9IHtjdXJ2ZSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgLi4ub3B0aW9uc307XG4gIGNvbnN0IG5vcm1hbGl6ZSA9IG5vcm1hbGl6ZXIoZGVsaW1pdGVyKTtcbiAgY29uc3Qgb3V0cHV0cyA9IHRyZWVPdXRwdXRzKG9wdGlvbnMsIG1heWJlTGlua1ZhbHVlKTtcbiAgY29uc3QgW1gxLCBzZXRYMV0gPSBjb2x1bW4oKTtcbiAgY29uc3QgW1gyLCBzZXRYMl0gPSBjb2x1bW4oKTtcbiAgY29uc3QgW1kxLCBzZXRZMV0gPSBjb2x1bW4oKTtcbiAgY29uc3QgW1kyLCBzZXRZMl0gPSBjb2x1bW4oKTtcbiAgcmV0dXJuIHtcbiAgICB4MTogWDEsXG4gICAgeDI6IFgyLFxuICAgIHkxOiBZMSxcbiAgICB5MjogWTIsXG4gICAgLi4uYmFzaWMob3B0aW9ucywgKGRhdGEsIGZhY2V0cykgPT4ge1xuICAgICAgY29uc3QgUCA9IG5vcm1hbGl6ZSh2YWx1ZW9mKGRhdGEsIHBhdGgpKTtcbiAgICAgIGNvbnN0IFgxID0gc2V0WDEoW10pO1xuICAgICAgY29uc3QgWDIgPSBzZXRYMihbXSk7XG4gICAgICBjb25zdCBZMSA9IHNldFkxKFtdKTtcbiAgICAgIGNvbnN0IFkyID0gc2V0WTIoW10pO1xuICAgICAgbGV0IHRyZWVJbmRleCA9IC0xO1xuICAgICAgY29uc3QgdHJlZURhdGEgPSBbXTtcbiAgICAgIGNvbnN0IHRyZWVGYWNldHMgPSBbXTtcbiAgICAgIGNvbnN0IHJvb3RvZiA9IHN0cmF0aWZ5KCkucGF0aCgoaSkgPT4gUFtpXSk7XG4gICAgICBjb25zdCBsYXlvdXQgPSB0cmVlTGF5b3V0KCk7XG4gICAgICBpZiAobGF5b3V0Lm5vZGVTaXplKSBsYXlvdXQubm9kZVNpemUoWzEsIDFdKTtcbiAgICAgIGlmIChsYXlvdXQuc2VwYXJhdGlvbiAmJiB0cmVlU2VwYXJhdGlvbiAhPT0gdW5kZWZpbmVkKSBsYXlvdXQuc2VwYXJhdGlvbih0cmVlU2VwYXJhdGlvbiA/PyBvbmUpO1xuICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIG9bb3V0cHV0X3ZhbHVlc10gPSBvW291dHB1dF9zZXRWYWx1ZXNdKFtdKTtcbiAgICAgIGZvciAoY29uc3QgZmFjZXQgb2YgZmFjZXRzKSB7XG4gICAgICAgIGNvbnN0IHRyZWVGYWNldCA9IFtdO1xuICAgICAgICBjb25zdCByb290ID0gcm9vdG9mKGZhY2V0LmZpbHRlcigoaSkgPT4gUFtpXSAhPSBudWxsKSkuZWFjaCgobm9kZSkgPT4gKG5vZGUuZGF0YSA9IGRhdGFbbm9kZS5kYXRhXSkpO1xuICAgICAgICBpZiAodHJlZVNvcnQgIT0gbnVsbCkgcm9vdC5zb3J0KHRyZWVTb3J0KTtcbiAgICAgICAgbGF5b3V0KHJvb3QpO1xuICAgICAgICBmb3IgKGNvbnN0IHtzb3VyY2UsIHRhcmdldH0gb2Ygcm9vdC5saW5rcygpKSB7XG4gICAgICAgICAgaWYgKHRyZWVGaWx0ZXIgIT0gbnVsbCAmJiAhdHJlZUZpbHRlcih0YXJnZXQsIHNvdXJjZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIHRyZWVGYWNldC5wdXNoKCsrdHJlZUluZGV4KTtcbiAgICAgICAgICB0cmVlRGF0YVt0cmVlSW5kZXhdID0gdGFyZ2V0LmRhdGE7XG4gICAgICAgICAgdHJlZUFuY2hvci5wb3NpdGlvbihzb3VyY2UsIHRyZWVJbmRleCwgWDEsIFkxKTtcbiAgICAgICAgICB0cmVlQW5jaG9yLnBvc2l0aW9uKHRhcmdldCwgdHJlZUluZGV4LCBYMiwgWTIpO1xuICAgICAgICAgIGZvciAoY29uc3QgbyBvZiBvdXRwdXRzKSBvW291dHB1dF92YWx1ZXNdW3RyZWVJbmRleF0gPSBvW291dHB1dF9ldmFsdWF0ZV0odGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRyZWVGYWNldHMucHVzaCh0cmVlRmFjZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtkYXRhOiB0cmVlRGF0YSwgZmFjZXRzOiB0cmVlRmFjZXRzfTtcbiAgICB9KSxcbiAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMob3V0cHV0cylcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVHJlZUFuY2hvcihhbmNob3IgPSBcImxlZnRcIikge1xuICBzd2l0Y2ggKGAke2FuY2hvcn1gLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiB0cmVlQW5jaG9yTGVmdDtcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiB0cmVlQW5jaG9yUmlnaHQ7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRyZWUgYW5jaG9yOiAke2FuY2hvcn1gKTtcbn1cblxuY29uc3QgdHJlZUFuY2hvckxlZnQgPSB7XG4gIGZyYW1lQW5jaG9yOiBcImxlZnRcIixcbiAgZHg6IDYsXG4gIHBvc2l0aW9uKHt4LCB5fSwgaSwgWCwgWSkge1xuICAgIFhbaV0gPSB5O1xuICAgIFlbaV0gPSAteDtcbiAgfVxufTtcblxuY29uc3QgdHJlZUFuY2hvclJpZ2h0ID0ge1xuICBmcmFtZUFuY2hvcjogXCJyaWdodFwiLFxuICBkeDogLTYsXG4gIHBvc2l0aW9uKHt4LCB5fSwgaSwgWCwgWSkge1xuICAgIFhbaV0gPSAteTtcbiAgICBZW2ldID0gLXg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1heWJlVHJlZVNvcnQoc29ydCkge1xuICByZXR1cm4gc29ydCA9PSBudWxsIHx8IHR5cGVvZiBzb3J0ID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IHNvcnRcbiAgICA6IGAke3NvcnR9YC50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwibm9kZTpcIilcbiAgICA/IG5vZGVTb3J0KG1heWJlTm9kZVZhbHVlKHNvcnQpKVxuICAgIDogbm9kZVNvcnQobm9kZURhdGEoc29ydCkpO1xufVxuXG5mdW5jdGlvbiBub2RlU29ydCh2YWx1ZSkge1xuICByZXR1cm4gKGEsIGIpID0+IGFzY2VuZGluZ0RlZmluZWQodmFsdWUoYSksIHZhbHVlKGIpKTtcbn1cblxuZnVuY3Rpb24gbm9kZURhdGEoZmllbGQpIHtcbiAgcmV0dXJuIChub2RlKSA9PiBub2RlLmRhdGE/LltmaWVsZF07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZXIoZGVsaW1pdGVyID0gXCIvXCIpIHtcbiAgZGVsaW1pdGVyID0gYCR7ZGVsaW1pdGVyfWA7XG4gIGlmIChkZWxpbWl0ZXIgPT09IFwiL1wiKSByZXR1cm4gKFApID0+IFA7IC8vIHBhdGhzIGFyZSBhbHJlYWR5IHNsYXNoLXNlcGFyYXRlZFxuICBpZiAoZGVsaW1pdGVyLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IEVycm9yKFwiZGVsaW1pdGVyIG11c3QgYmUgZXhhY3RseSBvbmUgY2hhcmFjdGVyXCIpO1xuICBjb25zdCBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiAoUCkgPT4gUC5tYXAoKHApID0+IHNsYXNoRGVsaW1pdGVyKHAsIGRlbGltaXRlckNvZGUpKTtcbn1cblxuY29uc3QgQ09ERV9CQUNLU0xBU0ggPSA5MjtcbmNvbnN0IENPREVfU0xBU0ggPSA0NztcblxuZnVuY3Rpb24gc2xhc2hEZWxpbWl0ZXIoaW5wdXQsIGRlbGltaXRlckNvZGUpIHtcbiAgaWYgKGRlbGltaXRlckNvZGUgPT09IENPREVfQkFDS1NMQVNIKSB0aHJvdyBuZXcgRXJyb3IoXCJkZWxpbWl0ZXIgY2Fubm90IGJlIGJhY2tzbGFzaFwiKTtcbiAgbGV0IGFmdGVyQmFja3NsYXNoID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBuID0gaW5wdXQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgc3dpdGNoIChpbnB1dC5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIENPREVfQkFDS1NMQVNIOlxuICAgICAgICBpZiAoIWFmdGVyQmFja3NsYXNoKSB7XG4gICAgICAgICAgYWZ0ZXJCYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBkZWxpbWl0ZXJDb2RlOlxuICAgICAgICBpZiAoYWZ0ZXJCYWNrc2xhc2gpIHtcbiAgICAgICAgICAoaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpIC0gMSkgKyBpbnB1dC5zbGljZShpKSksIC0taSwgLS1uOyAvLyByZW1vdmUgYmFja3NsYXNoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpKSArIFwiL1wiICsgaW5wdXQuc2xpY2UoaSArIDEpOyAvLyByZXBsYWNlIGRlbGltaXRlciB3aXRoIHNsYXNoXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENPREVfU0xBU0g6XG4gICAgICAgIGlmIChhZnRlckJhY2tzbGFzaCkge1xuICAgICAgICAgIChpbnB1dCA9IGlucHV0LnNsaWNlKDAsIGkpICsgXCJcXFxcXFxcXFwiICsgaW5wdXQuc2xpY2UoaSkpLCAoaSArPSAyKSwgKG4gKz0gMik7IC8vIGFkZCB0d28gYmFja3NsYXNoZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpKSArIFwiXFxcXFwiICsgaW5wdXQuc2xpY2UoaSkpLCArK2ksICsrbjsgLy8gYWRkIGJhY2tzbGFzaFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBhZnRlckJhY2tzbGFzaCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gc2xhc2hVbmVzY2FwZShpbnB1dCkge1xuICBsZXQgYWZ0ZXJCYWNrc2xhc2ggPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBpbnB1dC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKGlucHV0LmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgIGNhc2UgQ09ERV9CQUNLU0xBU0g6XG4gICAgICAgIGlmICghYWZ0ZXJCYWNrc2xhc2gpIHtcbiAgICAgICAgICBhZnRlckJhY2tzbGFzaCA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgY2FzZSBDT0RFX1NMQVNIOlxuICAgICAgICBpZiAoYWZ0ZXJCYWNrc2xhc2gpIHtcbiAgICAgICAgICAoaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpIC0gMSkgKyBpbnB1dC5zbGljZShpKSksIC0taSwgLS1uOyAvLyByZW1vdmUgYmFja3NsYXNoXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGFmdGVyQmFja3NsYXNoID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBpc05vZGVWYWx1ZShvcHRpb24pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9wdGlvbikgJiYgdHlwZW9mIG9wdGlvbi5ub2RlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzTGlua1ZhbHVlKG9wdGlvbikge1xuICByZXR1cm4gaXNPYmplY3Qob3B0aW9uKSAmJiB0eXBlb2Ygb3B0aW9uLmxpbmsgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gbWF5YmVOb2RlVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzTm9kZVZhbHVlKHZhbHVlKSkgcmV0dXJuIHZhbHVlLm5vZGU7XG4gIHZhbHVlID0gYCR7dmFsdWV9YC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwibm9kZTpcIikpIHJldHVybjtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgXCJub2RlOm5hbWVcIjpcbiAgICAgIHJldHVybiBub2RlTmFtZTtcbiAgICBjYXNlIFwibm9kZTpwYXRoXCI6XG4gICAgICByZXR1cm4gbm9kZVBhdGg7XG4gICAgY2FzZSBcIm5vZGU6aW50ZXJuYWxcIjpcbiAgICAgIHJldHVybiBub2RlSW50ZXJuYWw7XG4gICAgY2FzZSBcIm5vZGU6ZXh0ZXJuYWxcIjpcbiAgICAgIHJldHVybiBub2RlRXh0ZXJuYWw7XG4gICAgY2FzZSBcIm5vZGU6ZGVwdGhcIjpcbiAgICAgIHJldHVybiBub2RlRGVwdGg7XG4gICAgY2FzZSBcIm5vZGU6aGVpZ2h0XCI6XG4gICAgICByZXR1cm4gbm9kZUhlaWdodDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbm9kZSB2YWx1ZTogJHt2YWx1ZX1gKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVMaW5rVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzTm9kZVZhbHVlKHZhbHVlKSkgcmV0dXJuIHZhbHVlLm5vZGU7XG4gIGlmIChpc0xpbmtWYWx1ZSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5saW5rO1xuICB2YWx1ZSA9IGAke3ZhbHVlfWAudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIm5vZGU6XCIpICYmICF2YWx1ZS5zdGFydHNXaXRoKFwicGFyZW50OlwiKSkgcmV0dXJuO1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcInBhcmVudDpuYW1lXCI6XG4gICAgICByZXR1cm4gcGFyZW50VmFsdWUobm9kZU5hbWUpO1xuICAgIGNhc2UgXCJwYXJlbnQ6cGF0aFwiOlxuICAgICAgcmV0dXJuIHBhcmVudFZhbHVlKG5vZGVQYXRoKTtcbiAgICBjYXNlIFwicGFyZW50OmRlcHRoXCI6XG4gICAgICByZXR1cm4gcGFyZW50VmFsdWUobm9kZURlcHRoKTtcbiAgICBjYXNlIFwicGFyZW50OmhlaWdodFwiOlxuICAgICAgcmV0dXJuIHBhcmVudFZhbHVlKG5vZGVIZWlnaHQpO1xuICAgIGNhc2UgXCJub2RlOm5hbWVcIjpcbiAgICAgIHJldHVybiBub2RlTmFtZTtcbiAgICBjYXNlIFwibm9kZTpwYXRoXCI6XG4gICAgICByZXR1cm4gbm9kZVBhdGg7XG4gICAgY2FzZSBcIm5vZGU6aW50ZXJuYWxcIjpcbiAgICAgIHJldHVybiBub2RlSW50ZXJuYWw7XG4gICAgY2FzZSBcIm5vZGU6ZXh0ZXJuYWxcIjpcbiAgICAgIHJldHVybiBub2RlRXh0ZXJuYWw7XG4gICAgY2FzZSBcIm5vZGU6ZGVwdGhcIjpcbiAgICAgIHJldHVybiBub2RlRGVwdGg7XG4gICAgY2FzZSBcIm5vZGU6aGVpZ2h0XCI6XG4gICAgICByZXR1cm4gbm9kZUhlaWdodDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbGluayB2YWx1ZTogJHt2YWx1ZX1gKTtcbn1cblxuZnVuY3Rpb24gbm9kZVBhdGgobm9kZSkge1xuICByZXR1cm4gbm9kZS5pZDtcbn1cblxuZnVuY3Rpb24gbm9kZU5hbWUobm9kZSkge1xuICByZXR1cm4gbmFtZW9mKG5vZGUuaWQpO1xufVxuXG5mdW5jdGlvbiBub2RlRGVwdGgobm9kZSkge1xuICByZXR1cm4gbm9kZS5kZXB0aDtcbn1cblxuZnVuY3Rpb24gbm9kZUhlaWdodChub2RlKSB7XG4gIHJldHVybiBub2RlLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gbm9kZUludGVybmFsKG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZS5jaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbm9kZUV4dGVybmFsKG5vZGUpIHtcbiAgcmV0dXJuICFub2RlLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwYXJlbnRWYWx1ZShldmFsdWF0ZSkge1xuICByZXR1cm4gKGNoaWxkLCBwYXJlbnQpID0+IChwYXJlbnQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGV2YWx1YXRlKHBhcmVudCkpO1xufVxuXG4vLyBXYWxrIGJhY2t3YXJkcyB0byBmaW5kIHRoZSBmaXJzdCBzbGFzaC5cbmZ1bmN0aW9uIG5hbWVvZihwYXRoKSB7XG4gIGxldCBpID0gcGF0aC5sZW5ndGg7XG4gIHdoaWxlICgtLWkgPiAwKSBpZiAoc2xhc2gocGF0aCwgaSkpIGJyZWFrO1xuICByZXR1cm4gc2xhc2hVbmVzY2FwZShwYXRoLnNsaWNlKGkgKyAxKSk7XG59XG5cbi8vIFNsYXNoZXMgY2FuIGJlIGVzY2FwZWQ7IHRvIGRldGVybWluZSB3aGV0aGVyIGEgc2xhc2ggaXMgYSBwYXRoIGRlbGltaXRlciwgd2Vcbi8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJlY2VkaW5nIGJhY2tzbGFzaGVzIGVzY2FwaW5nIHRoZSBmb3J3YXJkIHNsYXNoOiBhbiBvZGRcbi8vIG51bWJlciBpbmRpY2F0ZXMgYW4gZXNjYXBlZCBmb3J3YXJkIHNsYXNoLlxuZnVuY3Rpb24gc2xhc2gocGF0aCwgaSkge1xuICBpZiAocGF0aFtpXSA9PT0gXCIvXCIpIHtcbiAgICBsZXQgayA9IDA7XG4gICAgd2hpbGUgKGkgPiAwICYmIHBhdGhbLS1pXSA9PT0gXCJcXFxcXCIpICsraztcbiAgICBpZiAoKGsgJiAxKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGVzZSBpbmRleGVzIG1hdGNoIHRoZSBhcnJheSByZXR1cm5lZCBieSBub2RlT3V0cHV0cy4gVGhlIGZpcnN0IHR3byBlbGVtZW50c1xuLy8gYXJlIGFsd2F5cyB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0IGFuZCBpdHMgY29sdW1uIHZhbHVlIGRlZmluaXRpb24gc28gdGhhdFxuLy8gdGhlIG91dHB1dHMgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSB0byBPYmplY3QuZnJvbUVudHJpZXMuXG5jb25zdCBvdXRwdXRfc2V0VmFsdWVzID0gMjtcbmNvbnN0IG91dHB1dF9ldmFsdWF0ZSA9IDM7XG5jb25zdCBvdXRwdXRfdmFsdWVzID0gNDtcblxuZnVuY3Rpb24gdHJlZU91dHB1dHMob3B0aW9ucywgbWF5YmVUcmVlVmFsdWUpIHtcbiAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjb25zdCB0cmVlVmFsdWUgPSBtYXliZVRyZWVWYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHRyZWVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvdXRwdXRzLnB1c2goW25hbWUsIC4uLmNvbHVtbih2YWx1ZSksIHRyZWVWYWx1ZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/transforms/window.js":
/*!******************************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/transforms/window.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   window: () => (/* binding */ window),\n/* harmony export */   windowX: () => (/* binding */ windowX),\n/* harmony export */   windowY: () => (/* binding */ windowY)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(ssr)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defined.js */ \"(ssr)/./node_modules/@observablehq/plot/src/defined.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../options.js */ \"(ssr)/./node_modules/@observablehq/plot/src/options.js\");\n/* harmony import */ var _warnings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../warnings.js */ \"(ssr)/./node_modules/@observablehq/plot/src/warnings.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ \"(ssr)/./node_modules/@observablehq/plot/src/transforms/map.js\");\n\n\n\n\n\n\nfunction windowX(windowOptions = {}, options) {\n  if (arguments.length === 1) options = windowOptions;\n  return (0,_map_js__WEBPACK_IMPORTED_MODULE_1__.mapX)(window(windowOptions), options);\n}\n\nfunction windowY(windowOptions = {}, options) {\n  if (arguments.length === 1) options = windowOptions;\n  return (0,_map_js__WEBPACK_IMPORTED_MODULE_1__.mapY)(window(windowOptions), options);\n}\n\nfunction window(options = {}) {\n  if (typeof options === \"number\") options = {k: options};\n  let {k, reduce, shift, anchor, strict} = options;\n  if (anchor === undefined && shift !== undefined) {\n    anchor = maybeShift(shift);\n    (0,_warnings_js__WEBPACK_IMPORTED_MODULE_2__.warn)(`Warning: the shift option is deprecated; please use anchor \"${anchor}\" instead.`);\n  }\n  if (!((k = Math.floor(k)) > 0)) throw new Error(`invalid k: ${k}`);\n  return maybeReduce(reduce)(k, maybeAnchor(anchor, k), strict);\n}\n\nfunction maybeAnchor(anchor = \"middle\", k) {\n  switch (`${anchor}`.toLowerCase()) {\n    case \"middle\":\n      return (k - 1) >> 1;\n    case \"start\":\n      return 0;\n    case \"end\":\n      return k - 1;\n  }\n  throw new Error(`invalid anchor: ${anchor}`);\n}\n\nfunction maybeShift(shift) {\n  switch (`${shift}`.toLowerCase()) {\n    case \"centered\":\n      return \"middle\";\n    case \"leading\":\n      return \"start\";\n    case \"trailing\":\n      return \"end\";\n  }\n  throw new Error(`invalid shift: ${shift}`);\n}\n\nfunction maybeReduce(reduce = \"mean\") {\n  if (typeof reduce === \"string\") {\n    if (/^p\\d{2}$/i.test(reduce)) return reduceAccessor((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.percentile)(reduce));\n    switch (reduce.toLowerCase()) {\n      case \"deviation\":\n        return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.deviation);\n      case \"max\":\n        return reduceArray((I, V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.max)(I, (i) => V[i]));\n      case \"mean\":\n        return reduceMean;\n      case \"median\":\n        return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.median);\n      case \"min\":\n        return reduceArray((I, V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.min)(I, (i) => V[i]));\n      case \"mode\":\n        return reduceArray((I, V) => (0,d3__WEBPACK_IMPORTED_MODULE_0__.mode)(I, (i) => V[i]));\n      case \"sum\":\n        return reduceSum;\n      case \"variance\":\n        return reduceAccessor(d3__WEBPACK_IMPORTED_MODULE_0__.variance);\n      case \"difference\":\n        return reduceDifference;\n      case \"ratio\":\n        return reduceRatio;\n      case \"first\":\n        return reduceFirst;\n      case \"last\":\n        return reduceLast;\n    }\n  }\n  if (typeof reduce !== \"function\") throw new Error(`invalid reduce: ${reduce}`);\n  return reduceArray((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.taker)(reduce));\n}\n\n// Note that the subarray may include NaN in the non-strict case; we expect the\n// function f to handle that itself (e.g., by filtering as needed). The D3\n// reducers (e.g., min, max, mean, median) do, and it’s faster to avoid\n// redundant filtering.\nfunction reduceAccessor(f) {\n  return (k, s, strict) =>\n    strict\n      ? {\n          mapIndex(I, S, T) {\n            const v = (i) => (S[i] == null ? NaN : +S[i]);\n            let nans = 0;\n            for (let i = 0; i < k - 1; ++i) if (isNaN(v(i))) ++nans;\n            for (let i = 0, n = I.length - k + 1; i < n; ++i) {\n              if (isNaN(v(i + k - 1))) ++nans;\n              T[I[i + s]] = nans === 0 ? f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, i, i + k), v) : NaN;\n              if (isNaN(v(i))) --nans;\n            }\n          }\n        }\n      : {\n          mapIndex(I, S, T) {\n            const v = (i) => (S[i] == null ? NaN : +S[i]);\n            for (let i = -s; i < 0; ++i) {\n              T[I[i + s]] = f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, 0, i + k), v);\n            }\n            for (let i = 0, n = I.length - s; i < n; ++i) {\n              T[I[i + s]] = f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, i, i + k), v);\n            }\n          }\n        };\n}\n\nfunction reduceArray(f) {\n  return (k, s, strict) =>\n    strict\n      ? {\n          mapIndex(I, S, T) {\n            let count = 0;\n            for (let i = 0; i < k - 1; ++i) count += (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.defined)(S[I[i]]);\n            for (let i = 0, n = I.length - k + 1; i < n; ++i) {\n              count += (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.defined)(S[I[i + k - 1]]);\n              if (count === k) T[I[i + s]] = f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, i, i + k), S);\n              count -= (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.defined)(S[I[i]]);\n            }\n          }\n        }\n      : {\n          mapIndex(I, S, T) {\n            for (let i = -s; i < 0; ++i) {\n              T[I[i + s]] = f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, 0, i + k), S);\n            }\n            for (let i = 0, n = I.length - s; i < n; ++i) {\n              T[I[i + s]] = f((0,_options_js__WEBPACK_IMPORTED_MODULE_3__.subarray)(I, i, i + k), S);\n            }\n          }\n        };\n}\n\nfunction reduceSum(k, s, strict) {\n  return strict\n    ? {\n        mapIndex(I, S, T) {\n          let nans = 0;\n          let sum = 0;\n          for (let i = 0; i < k - 1; ++i) {\n            const v = S[I[i]];\n            if (v === null || isNaN(v)) ++nans;\n            else sum += +v;\n          }\n          for (let i = 0, n = I.length - k + 1; i < n; ++i) {\n            const a = S[I[i]];\n            const b = S[I[i + k - 1]];\n            if (b === null || isNaN(b)) ++nans;\n            else sum += +b;\n            T[I[i + s]] = nans === 0 ? sum : NaN;\n            if (a === null || isNaN(a)) --nans;\n            else sum -= +a;\n          }\n        }\n      }\n    : {\n        mapIndex(I, S, T) {\n          let sum = 0;\n          const n = I.length;\n          for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {\n            sum += +S[I[i]] || 0;\n          }\n          for (let i = -s, j = n - s; i < j; ++i) {\n            sum += +S[I[i + k - 1]] || 0;\n            T[I[i + s]] = sum;\n            sum -= +S[I[i]] || 0;\n          }\n        }\n      };\n}\n\nfunction reduceMean(k, s, strict) {\n  if (strict) {\n    const sum = reduceSum(k, s, strict);\n    return {\n      mapIndex(I, S, T) {\n        sum.mapIndex(I, S, T);\n        for (let i = 0, n = I.length - k + 1; i < n; ++i) {\n          T[I[i + s]] /= k;\n        }\n      }\n    };\n  } else {\n    return {\n      mapIndex(I, S, T) {\n        let sum = 0;\n        let count = 0;\n        const n = I.length;\n        for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {\n          let v = S[I[i]];\n          if (v !== null && !isNaN((v = +v))) (sum += v), ++count;\n        }\n        for (let i = -s, j = n - s; i < j; ++i) {\n          let a = S[I[i + k - 1]];\n          let b = S[I[i]];\n          if (a !== null && !isNaN((a = +a))) (sum += a), ++count;\n          T[I[i + s]] = sum / count;\n          if (b !== null && !isNaN((b = +b))) (sum -= b), --count;\n        }\n      }\n    };\n  }\n}\n\nfunction firstDefined(S, I, i, k) {\n  for (let j = i + k; i < j; ++i) {\n    const v = S[I[i]];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.defined)(v)) return v;\n  }\n}\n\nfunction lastDefined(S, I, i, k) {\n  for (let j = i + k - 1; j >= i; --j) {\n    const v = S[I[j]];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__.defined)(v)) return v;\n  }\n}\n\nfunction firstNumber(S, I, i, k) {\n  for (let j = i + k; i < j; ++i) {\n    let v = S[I[i]];\n    if (v !== null && !isNaN((v = +v))) return v;\n  }\n}\n\nfunction lastNumber(S, I, i, k) {\n  for (let j = i + k - 1; j >= i; --j) {\n    let v = S[I[j]];\n    if (v !== null && !isNaN((v = +v))) return v;\n  }\n}\n\nfunction reduceDifference(k, s, strict) {\n  return strict\n    ? {\n        mapIndex(I, S, T) {\n          for (let i = 0, n = I.length - k; i < n; ++i) {\n            const a = S[I[i]];\n            const b = S[I[i + k - 1]];\n            T[I[i + s]] = a === null || b === null ? NaN : b - a;\n          }\n        }\n      }\n    : {\n        mapIndex(I, S, T) {\n          for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {\n            T[I[i + s]] = lastNumber(S, I, i, k) - firstNumber(S, I, i, k);\n          }\n        }\n      };\n}\n\nfunction reduceRatio(k, s, strict) {\n  return strict\n    ? {\n        mapIndex(I, S, T) {\n          for (let i = 0, n = I.length - k; i < n; ++i) {\n            const a = S[I[i]];\n            const b = S[I[i + k - 1]];\n            T[I[i + s]] = a === null || b === null ? NaN : b / a;\n          }\n        }\n      }\n    : {\n        mapIndex(I, S, T) {\n          for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {\n            T[I[i + s]] = lastNumber(S, I, i, k) / firstNumber(S, I, i, k);\n          }\n        }\n      };\n}\n\nfunction reduceFirst(k, s, strict) {\n  return strict\n    ? {\n        mapIndex(I, S, T) {\n          for (let i = 0, n = I.length - k; i < n; ++i) {\n            T[I[i + s]] = S[I[i]];\n          }\n        }\n      }\n    : {\n        mapIndex(I, S, T) {\n          for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {\n            T[I[i + s]] = firstDefined(S, I, i, k);\n          }\n        }\n      };\n}\n\nfunction reduceLast(k, s, strict) {\n  return strict\n    ? {\n        mapIndex(I, S, T) {\n          for (let i = 0, n = I.length - k; i < n; ++i) {\n            T[I[i + s]] = S[I[i + k - 1]];\n          }\n        }\n      }\n    : {\n        mapIndex(I, S, T) {\n          for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {\n            T[I[i + s]] = lastDefined(S, I, i, k);\n          }\n        }\n      };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3dpbmRvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErRDtBQUN6QjtBQUNvQjtBQUN0QjtBQUNBOztBQUU3QixtQ0FBbUM7QUFDMUM7QUFDQSxTQUFTLDZDQUFJO0FBQ2I7O0FBRU8sbUNBQW1DO0FBQzFDO0FBQ0EsU0FBUyw2Q0FBSTtBQUNiOztBQUVPLDRCQUE0QjtBQUNuQyw4Q0FBOEM7QUFDOUMsT0FBTyxrQ0FBa0M7QUFDekM7QUFDQTtBQUNBLElBQUksa0RBQUksMkNBQTJDLHFCQUFxQixPQUFPO0FBQy9FO0FBQ0EsZ0VBQWdFLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsRUFBRSx3Q0FBd0MsdURBQVU7QUFDbEU7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBUztBQUN2QztBQUNBLHFDQUFxQyx1Q0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQU07QUFDcEM7QUFDQSxxQ0FBcUMsdUNBQUc7QUFDeEM7QUFDQSxxQ0FBcUMsd0NBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdDQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUUscUJBQXFCLGtEQUFLO0FBQzFCOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0EsMkNBQTJDLHFEQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEMsOEJBQThCLHFEQUFRO0FBQ3RDO0FBQ0EsOENBQThDLE9BQU87QUFDckQsOEJBQThCLHFEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXLGNBQWMsb0RBQU87QUFDNUQsa0RBQWtELE9BQU87QUFDekQsdUJBQXVCLG9EQUFPO0FBQzlCLCtDQUErQyxxREFBUTtBQUN2RCx1QkFBdUIsb0RBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDLDhCQUE4QixxREFBUTtBQUN0QztBQUNBLDhDQUE4QyxPQUFPO0FBQ3JELDhCQUE4QixxREFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsUUFBUSxvREFBTztBQUNmO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy90cmFuc2Zvcm1zL3dpbmRvdy5qcz9mNTEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZGV2aWF0aW9uLCBtYXgsIG1lZGlhbiwgbWluLCBtb2RlLCB2YXJpYW5jZX0gZnJvbSBcImQzXCI7XG5pbXBvcnQge2RlZmluZWR9IGZyb20gXCIuLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQge3BlcmNlbnRpbGUsIHN1YmFycmF5LCB0YWtlcn0gZnJvbSBcIi4uL29wdGlvbnMuanNcIjtcbmltcG9ydCB7d2Fybn0gZnJvbSBcIi4uL3dhcm5pbmdzLmpzXCI7XG5pbXBvcnQge21hcFgsIG1hcFl9IGZyb20gXCIuL21hcC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gd2luZG93WCh3aW5kb3dPcHRpb25zID0ge30sIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIG9wdGlvbnMgPSB3aW5kb3dPcHRpb25zO1xuICByZXR1cm4gbWFwWCh3aW5kb3cod2luZG93T3B0aW9ucyksIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2luZG93WSh3aW5kb3dPcHRpb25zID0ge30sIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIG9wdGlvbnMgPSB3aW5kb3dPcHRpb25zO1xuICByZXR1cm4gbWFwWSh3aW5kb3cod2luZG93T3B0aW9ucyksIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2luZG93KG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIG9wdGlvbnMgPSB7azogb3B0aW9uc307XG4gIGxldCB7aywgcmVkdWNlLCBzaGlmdCwgYW5jaG9yLCBzdHJpY3R9ID0gb3B0aW9ucztcbiAgaWYgKGFuY2hvciA9PT0gdW5kZWZpbmVkICYmIHNoaWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmNob3IgPSBtYXliZVNoaWZ0KHNoaWZ0KTtcbiAgICB3YXJuKGBXYXJuaW5nOiB0aGUgc2hpZnQgb3B0aW9uIGlzIGRlcHJlY2F0ZWQ7IHBsZWFzZSB1c2UgYW5jaG9yIFwiJHthbmNob3J9XCIgaW5zdGVhZC5gKTtcbiAgfVxuICBpZiAoISgoayA9IE1hdGguZmxvb3IoaykpID4gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrOiAke2t9YCk7XG4gIHJldHVybiBtYXliZVJlZHVjZShyZWR1Y2UpKGssIG1heWJlQW5jaG9yKGFuY2hvciwgayksIHN0cmljdCk7XG59XG5cbmZ1bmN0aW9uIG1heWJlQW5jaG9yKGFuY2hvciA9IFwibWlkZGxlXCIsIGspIHtcbiAgc3dpdGNoIChgJHthbmNob3J9YC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgcmV0dXJuIChrIC0gMSkgPj4gMTtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIHJldHVybiBrIC0gMTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yOiAke2FuY2hvcn1gKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVTaGlmdChzaGlmdCkge1xuICBzd2l0Y2ggKGAke3NoaWZ0fWAudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJjZW50ZXJlZFwiOlxuICAgICAgcmV0dXJuIFwibWlkZGxlXCI7XG4gICAgY2FzZSBcImxlYWRpbmdcIjpcbiAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgY2FzZSBcInRyYWlsaW5nXCI6XG4gICAgICByZXR1cm4gXCJlbmRcIjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2hpZnQ6ICR7c2hpZnR9YCk7XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVkdWNlKHJlZHVjZSA9IFwibWVhblwiKSB7XG4gIGlmICh0eXBlb2YgcmVkdWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKC9ecFxcZHsyfSQvaS50ZXN0KHJlZHVjZSkpIHJldHVybiByZWR1Y2VBY2Nlc3NvcihwZXJjZW50aWxlKHJlZHVjZSkpO1xuICAgIHN3aXRjaCAocmVkdWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJkZXZpYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHJlZHVjZUFjY2Vzc29yKGRldmlhdGlvbik7XG4gICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgIHJldHVybiByZWR1Y2VBcnJheSgoSSwgVikgPT4gbWF4KEksIChpKSA9PiBWW2ldKSk7XG4gICAgICBjYXNlIFwibWVhblwiOlxuICAgICAgICByZXR1cm4gcmVkdWNlTWVhbjtcbiAgICAgIGNhc2UgXCJtZWRpYW5cIjpcbiAgICAgICAgcmV0dXJuIHJlZHVjZUFjY2Vzc29yKG1lZGlhbik7XG4gICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIHJldHVybiByZWR1Y2VBcnJheSgoSSwgVikgPT4gbWluKEksIChpKSA9PiBWW2ldKSk7XG4gICAgICBjYXNlIFwibW9kZVwiOlxuICAgICAgICByZXR1cm4gcmVkdWNlQXJyYXkoKEksIFYpID0+IG1vZGUoSSwgKGkpID0+IFZbaV0pKTtcbiAgICAgIGNhc2UgXCJzdW1cIjpcbiAgICAgICAgcmV0dXJuIHJlZHVjZVN1bTtcbiAgICAgIGNhc2UgXCJ2YXJpYW5jZVwiOlxuICAgICAgICByZXR1cm4gcmVkdWNlQWNjZXNzb3IodmFyaWFuY2UpO1xuICAgICAgY2FzZSBcImRpZmZlcmVuY2VcIjpcbiAgICAgICAgcmV0dXJuIHJlZHVjZURpZmZlcmVuY2U7XG4gICAgICBjYXNlIFwicmF0aW9cIjpcbiAgICAgICAgcmV0dXJuIHJlZHVjZVJhdGlvO1xuICAgICAgY2FzZSBcImZpcnN0XCI6XG4gICAgICAgIHJldHVybiByZWR1Y2VGaXJzdDtcbiAgICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICAgIHJldHVybiByZWR1Y2VMYXN0O1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHJlZHVjZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcmVkdWNlOiAke3JlZHVjZX1gKTtcbiAgcmV0dXJuIHJlZHVjZUFycmF5KHRha2VyKHJlZHVjZSkpO1xufVxuXG4vLyBOb3RlIHRoYXQgdGhlIHN1YmFycmF5IG1heSBpbmNsdWRlIE5hTiBpbiB0aGUgbm9uLXN0cmljdCBjYXNlOyB3ZSBleHBlY3QgdGhlXG4vLyBmdW5jdGlvbiBmIHRvIGhhbmRsZSB0aGF0IGl0c2VsZiAoZS5nLiwgYnkgZmlsdGVyaW5nIGFzIG5lZWRlZCkuIFRoZSBEM1xuLy8gcmVkdWNlcnMgKGUuZy4sIG1pbiwgbWF4LCBtZWFuLCBtZWRpYW4pIGRvLCBhbmQgaXTigJlzIGZhc3RlciB0byBhdm9pZFxuLy8gcmVkdW5kYW50IGZpbHRlcmluZy5cbmZ1bmN0aW9uIHJlZHVjZUFjY2Vzc29yKGYpIHtcbiAgcmV0dXJuIChrLCBzLCBzdHJpY3QpID0+XG4gICAgc3RyaWN0XG4gICAgICA/IHtcbiAgICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGkpID0+IChTW2ldID09IG51bGwgPyBOYU4gOiArU1tpXSk7XG4gICAgICAgICAgICBsZXQgbmFucyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGsgLSAxOyArK2kpIGlmIChpc05hTih2KGkpKSkgKytuYW5zO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBJLmxlbmd0aCAtIGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChpc05hTih2KGkgKyBrIC0gMSkpKSArK25hbnM7XG4gICAgICAgICAgICAgIFRbSVtpICsgc11dID0gbmFucyA9PT0gMCA/IGYoc3ViYXJyYXkoSSwgaSwgaSArIGspLCB2KSA6IE5hTjtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKHYoaSkpKSAtLW5hbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGkpID0+IChTW2ldID09IG51bGwgPyBOYU4gOiArU1tpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gLXM7IGkgPCAwOyArK2kpIHtcbiAgICAgICAgICAgICAgVFtJW2kgKyBzXV0gPSBmKHN1YmFycmF5KEksIDAsIGkgKyBrKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IEkubGVuZ3RoIC0gczsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBUW0lbaSArIHNdXSA9IGYoc3ViYXJyYXkoSSwgaSwgaSArIGspLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUFycmF5KGYpIHtcbiAgcmV0dXJuIChrLCBzLCBzdHJpY3QpID0+XG4gICAgc3RyaWN0XG4gICAgICA/IHtcbiAgICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrIC0gMTsgKytpKSBjb3VudCArPSBkZWZpbmVkKFNbSVtpXV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBJLmxlbmd0aCAtIGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGRlZmluZWQoU1tJW2kgKyBrIC0gMV1dKTtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSBrKSBUW0lbaSArIHNdXSA9IGYoc3ViYXJyYXkoSSwgaSwgaSArIGspLCBTKTtcbiAgICAgICAgICAgICAgY291bnQgLT0gZGVmaW5lZChTW0lbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAtczsgaSA8IDA7ICsraSkge1xuICAgICAgICAgICAgICBUW0lbaSArIHNdXSA9IGYoc3ViYXJyYXkoSSwgMCwgaSArIGspLCBTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gSS5sZW5ndGggLSBzOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgIFRbSVtpICsgc11dID0gZihzdWJhcnJheShJLCBpLCBpICsgayksIFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlU3VtKGssIHMsIHN0cmljdCkge1xuICByZXR1cm4gc3RyaWN0XG4gICAgPyB7XG4gICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICBsZXQgbmFucyA9IDA7XG4gICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gU1tJW2ldXTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IGlzTmFOKHYpKSArK25hbnM7XG4gICAgICAgICAgICBlbHNlIHN1bSArPSArdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBJLmxlbmd0aCAtIGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gU1tJW2ldXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBTW0lbaSArIGsgLSAxXV07XG4gICAgICAgICAgICBpZiAoYiA9PT0gbnVsbCB8fCBpc05hTihiKSkgKytuYW5zO1xuICAgICAgICAgICAgZWxzZSBzdW0gKz0gK2I7XG4gICAgICAgICAgICBUW0lbaSArIHNdXSA9IG5hbnMgPT09IDAgPyBzdW0gOiBOYU47XG4gICAgICAgICAgICBpZiAoYSA9PT0gbnVsbCB8fCBpc05hTihhKSkgLS1uYW5zO1xuICAgICAgICAgICAgZWxzZSBzdW0gLT0gK2E7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICBjb25zdCBuID0gSS5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBNYXRoLm1pbihuLCBrIC0gcyAtIDEpOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICBzdW0gKz0gK1NbSVtpXV0gfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IC1zLCBqID0gbiAtIHM7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIHN1bSArPSArU1tJW2kgKyBrIC0gMV1dIHx8IDA7XG4gICAgICAgICAgICBUW0lbaSArIHNdXSA9IHN1bTtcbiAgICAgICAgICAgIHN1bSAtPSArU1tJW2ldXSB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlTWVhbihrLCBzLCBzdHJpY3QpIHtcbiAgaWYgKHN0cmljdCkge1xuICAgIGNvbnN0IHN1bSA9IHJlZHVjZVN1bShrLCBzLCBzdHJpY3QpO1xuICAgIHJldHVybiB7XG4gICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgIHN1bS5tYXBJbmRleChJLCBTLCBUKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBJLmxlbmd0aCAtIGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgVFtJW2kgKyBzXV0gLz0gaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG4gPSBJLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBNYXRoLm1pbihuLCBrIC0gcyAtIDEpOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgbGV0IHYgPSBTW0lbaV1dO1xuICAgICAgICAgIGlmICh2ICE9PSBudWxsICYmICFpc05hTigodiA9ICt2KSkpIChzdW0gKz0gdiksICsrY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IC1zLCBqID0gbiAtIHM7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICBsZXQgYSA9IFNbSVtpICsgayAtIDFdXTtcbiAgICAgICAgICBsZXQgYiA9IFNbSVtpXV07XG4gICAgICAgICAgaWYgKGEgIT09IG51bGwgJiYgIWlzTmFOKChhID0gK2EpKSkgKHN1bSArPSBhKSwgKytjb3VudDtcbiAgICAgICAgICBUW0lbaSArIHNdXSA9IHN1bSAvIGNvdW50O1xuICAgICAgICAgIGlmIChiICE9PSBudWxsICYmICFpc05hTigoYiA9ICtiKSkpIChzdW0gLT0gYiksIC0tY291bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpcnN0RGVmaW5lZChTLCBJLCBpLCBrKSB7XG4gIGZvciAobGV0IGogPSBpICsgazsgaSA8IGo7ICsraSkge1xuICAgIGNvbnN0IHYgPSBTW0lbaV1dO1xuICAgIGlmIChkZWZpbmVkKHYpKSByZXR1cm4gdjtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXN0RGVmaW5lZChTLCBJLCBpLCBrKSB7XG4gIGZvciAobGV0IGogPSBpICsgayAtIDE7IGogPj0gaTsgLS1qKSB7XG4gICAgY29uc3QgdiA9IFNbSVtqXV07XG4gICAgaWYgKGRlZmluZWQodikpIHJldHVybiB2O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpcnN0TnVtYmVyKFMsIEksIGksIGspIHtcbiAgZm9yIChsZXQgaiA9IGkgKyBrOyBpIDwgajsgKytpKSB7XG4gICAgbGV0IHYgPSBTW0lbaV1dO1xuICAgIGlmICh2ICE9PSBudWxsICYmICFpc05hTigodiA9ICt2KSkpIHJldHVybiB2O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3ROdW1iZXIoUywgSSwgaSwgaykge1xuICBmb3IgKGxldCBqID0gaSArIGsgLSAxOyBqID49IGk7IC0taikge1xuICAgIGxldCB2ID0gU1tJW2pdXTtcbiAgICBpZiAodiAhPT0gbnVsbCAmJiAhaXNOYU4oKHYgPSArdikpKSByZXR1cm4gdjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEaWZmZXJlbmNlKGssIHMsIHN0cmljdCkge1xuICByZXR1cm4gc3RyaWN0XG4gICAgPyB7XG4gICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IEkubGVuZ3RoIC0gazsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYSA9IFNbSVtpXV07XG4gICAgICAgICAgICBjb25zdCBiID0gU1tJW2kgKyBrIC0gMV1dO1xuICAgICAgICAgICAgVFtJW2kgKyBzXV0gPSBhID09PSBudWxsIHx8IGIgPT09IG51bGwgPyBOYU4gOiBiIC0gYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgbWFwSW5kZXgoSSwgUywgVCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAtcywgbiA9IEkubGVuZ3RoIC0gayArIHMgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBUW0lbaSArIHNdXSA9IGxhc3ROdW1iZXIoUywgSSwgaSwgaykgLSBmaXJzdE51bWJlcihTLCBJLCBpLCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVJhdGlvKGssIHMsIHN0cmljdCkge1xuICByZXR1cm4gc3RyaWN0XG4gICAgPyB7XG4gICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IEkubGVuZ3RoIC0gazsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYSA9IFNbSVtpXV07XG4gICAgICAgICAgICBjb25zdCBiID0gU1tJW2kgKyBrIC0gMV1dO1xuICAgICAgICAgICAgVFtJW2kgKyBzXV0gPSBhID09PSBudWxsIHx8IGIgPT09IG51bGwgPyBOYU4gOiBiIC8gYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgbWFwSW5kZXgoSSwgUywgVCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAtcywgbiA9IEkubGVuZ3RoIC0gayArIHMgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBUW0lbaSArIHNdXSA9IGxhc3ROdW1iZXIoUywgSSwgaSwgaykgLyBmaXJzdE51bWJlcihTLCBJLCBpLCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUZpcnN0KGssIHMsIHN0cmljdCkge1xuICByZXR1cm4gc3RyaWN0XG4gICAgPyB7XG4gICAgICAgIG1hcEluZGV4KEksIFMsIFQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IEkubGVuZ3RoIC0gazsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgVFtJW2kgKyBzXV0gPSBTW0lbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IC1zLCBuID0gSS5sZW5ndGggLSBrICsgcyArIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIFRbSVtpICsgc11dID0gZmlyc3REZWZpbmVkKFMsIEksIGksIGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlTGFzdChrLCBzLCBzdHJpY3QpIHtcbiAgcmV0dXJuIHN0cmljdFxuICAgID8ge1xuICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBJLmxlbmd0aCAtIGs7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIFRbSVtpICsgc11dID0gU1tJW2kgKyBrIC0gMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBtYXBJbmRleChJLCBTLCBUKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IC1zLCBuID0gSS5sZW5ndGggLSBrICsgcyArIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIFRbSVtpICsgc11dID0gbGFzdERlZmluZWQoUywgSSwgaSwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/transforms/window.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@observablehq/plot/src/warnings.js":
/*!*********************************************************!*\
  !*** ./node_modules/@observablehq/plot/src/warnings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeWarnings: () => (/* binding */ consumeWarnings),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\nlet warnings = 0;\nlet lastMessage;\n\nfunction consumeWarnings() {\n  const w = warnings;\n  warnings = 0;\n  lastMessage = undefined;\n  return w;\n}\n\nfunction warn(message) {\n  if (message === lastMessage) return;\n  lastMessage = message;\n  console.warn(message);\n  ++warnings;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9ic2VydmFibGVocS9wbG90L3NyYy93YXJuaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWZmaWMtZm9yZWNhc3RpbmctZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BvYnNlcnZhYmxlaHEvcGxvdC9zcmMvd2FybmluZ3MuanM/YWE2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd2FybmluZ3MgPSAwO1xubGV0IGxhc3RNZXNzYWdlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3VtZVdhcm5pbmdzKCkge1xuICBjb25zdCB3ID0gd2FybmluZ3M7XG4gIHdhcm5pbmdzID0gMDtcbiAgbGFzdE1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gIHJldHVybiB3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlID09PSBsYXN0TWVzc2FnZSkgcmV0dXJuO1xuICBsYXN0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgKyt3YXJuaW5ncztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@observablehq/plot/src/warnings.js\n");

/***/ })

};
;