"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/es/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/fast-equals/dist/es/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty } = Object.prototype;\n/**\n * Combine two comparators into a single comparators.\n */\nfunction combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nfunction createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n            return areItemsEqual(a, b, state);\n        }\n        const { cache } = state;\n        const cachedA = cache.get(a);\n        const cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        const result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */\nfunction getShortTag(value) {\n    return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nfunction getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */\nconst hasOwn = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nObject.hasOwn || ((object, property) => hasOwnProperty.call(object, property));\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nfunction sameValueZeroEqual(a, b) {\n    return a === b || (!a && !b && a !== a && b !== b);\n}\n\nconst PREACT_VNODE = '__v';\nconst PREACT_OWNER = '__o';\nconst REACT_OWNER = '_owner';\nconst { getOwnPropertyDescriptor, keys } = Object;\n/**\n * Whether the array buffers are equal in value.\n */\nfunction areArrayBuffersEqual(a, b) {\n    return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n/**\n * Whether the arrays are equal in value.\n */\nfunction areArraysEqual(a, b, state) {\n    let index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dataviews are equal in value.\n */\nfunction areDataViewsEqual(a, b) {\n    return (a.byteLength === b.byteLength\n        && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)));\n}\n/**\n * Whether the dates passed are equal in value.\n */\nfunction areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */\nfunction areErrorsEqual(a, b) {\n    return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */\nfunction areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */\nfunction areMapsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.entries();\n    let aResult;\n    let bResult;\n    let index = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.entries();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            const aEntry = aResult.value;\n            const bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state)\n                && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */\nconst areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */\nfunction areObjectsEqual(a, b, state) {\n    const properties = keys(a);\n    let index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nfunction areObjectsEqualStrict(a, b, state) {\n    const properties = getStrictProperties(a);\n    let index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    let property;\n    let descriptorA;\n    let descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB)\n            && (!descriptorA\n                || !descriptorB\n                || descriptorA.configurable !== descriptorB.configurable\n                || descriptorA.enumerable !== descriptorB.enumerable\n                || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nfunction arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */\nfunction areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */\nfunction areSetsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.values();\n    let aResult;\n    let bResult;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.values();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex]\n                && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */\nfunction areTypedArraysEqual(a, b) {\n    let index = a.byteLength;\n    if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */\nfunction areUrlsEqual(a, b) {\n    return (a.hostname === b.hostname\n        && a.pathname === b.pathname\n        && a.protocol === b.protocol\n        && a.port === b.port\n        && a.hash === b.hash\n        && a.username === b.username\n        && a.password === b.password);\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE)\n        && (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\n\nconst ARRAY_BUFFER_TAG = '[object ArrayBuffer]';\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATA_VIEW_TAG = '[object DataView]';\nconst DATE_TAG = '[object Date]';\nconst ERROR_TAG = '[object Error]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\nconst TYPED_ARRAY_TAGS = {\n    '[object Int8Array]': true,\n    '[object Uint8Array]': true,\n    '[object Uint8ClampedArray]': true,\n    '[object Int16Array]': true,\n    '[object Uint16Array]': true,\n    '[object Int32Array]': true,\n    '[object Uint32Array]': true,\n    '[object Float16Array]': true,\n    '[object Float32Array]': true,\n    '[object Float64Array]': true,\n    '[object BigInt64Array]': true,\n    '[object BigUint64Array]': true,\n};\nconst URL_TAG = '[object URL]';\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nfunction createEqualityComparator({ areArrayBuffersEqual, areArraysEqual, areDataViewsEqual, areDatesEqual, areErrorsEqual, areFunctionsEqual, areMapsEqual, areNumbersEqual, areObjectsEqual, arePrimitiveWrappersEqual, areRegExpsEqual, areSetsEqual, areTypedArraysEqual, areUrlsEqual, unknownTagComparators, }) {\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */\n    return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        const type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== 'object') {\n            if (type === 'number') {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === 'function') {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        const constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (Array.isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        const tag = toString.call(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        if (TYPED_ARRAY_TAGS[tag]) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        if (tag === ARRAY_BUFFER_TAG) {\n            return areArrayBuffersEqual(a, b, state);\n        }\n        if (tag === DATA_VIEW_TAG) {\n            return areDataViewsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        if (unknownTagComparators) {\n            let unknownTagComparator = unknownTagComparators[tag];\n            if (!unknownTagComparator) {\n                const shortTag = getShortTag(a);\n                if (shortTag) {\n                    unknownTagComparator = unknownTagComparators[shortTag];\n                }\n            }\n            // If the custom config has an unknown tag comparator that matches the captured tag or the\n            // @@toStringTag, it is the source of truth for whether the values are equal.\n            if (unknownTagComparator) {\n                return unknownTagComparator(a, b, state);\n            }\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */\nfunction createEqualityComparatorConfig({ circular, createCustomConfig, strict, }) {\n    let config = {\n        areArrayBuffersEqual,\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDataViewsEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict\n            ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict)\n            : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n        unknownTagComparators: undefined,\n    };\n    if (createCustomConfig) {\n        config = Object.assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        const areArraysEqual = createIsCircular(config.areArraysEqual);\n        const areMapsEqual = createIsCircular(config.areMapsEqual);\n        const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n        const areSetsEqual = createIsCircular(config.areSetsEqual);\n        config = Object.assign({}, config, {\n            areArraysEqual,\n            areMapsEqual,\n            areObjectsEqual,\n            areSetsEqual,\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nfunction createInternalEqualityComparator(compare) {\n    return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nfunction createIsEqual({ circular, comparator, createState, equals, strict }) {\n    if (createState) {\n        return function isEqual(a, b) {\n            const { cache = circular ? new WeakMap() : undefined, meta } = createState();\n            return comparator(a, b, {\n                cache,\n                equals,\n                meta,\n                strict,\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals,\n                meta: undefined,\n                strict,\n            });\n        };\n    }\n    const state = {\n        cache: undefined,\n        equals,\n        meta: undefined,\n        strict,\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nconst deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nconst strictDeepEqual = createCustomEqual({ strict: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nconst circularDeepEqual = createCustomEqual({ circular: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nconst strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true,\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nconst shallowEqual = createCustomEqual({\n    createInternalComparator: () => sameValueZeroEqual,\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nconst strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: () => sameValueZeroEqual,\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nconst circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: () => sameValueZeroEqual,\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nconst strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: () => sameValueZeroEqual,\n    strict: true,\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nfunction createCustomEqual(options = {}) {\n    const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false, } = options;\n    const config = createEqualityComparatorConfig(options);\n    const comparator = createEqualityComparator(config);\n    const equals = createCustomInternalComparator\n        ? createCustomInternalComparator(comparator)\n        : createInternalEqualityComparator(comparator);\n    return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lcy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLFFBQVEsNkNBQTZDO0FBQ3JEO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnUkFBZ1I7QUFDcFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFtRDtBQUM1RTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFxRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsWUFBWSwyR0FBMkc7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBbUQ7QUFDOUU7O0FBRTZNO0FBQzdNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZmZpYy1mb3JlY2FzdGluZy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lcy9pbmRleC5tanM/M2NmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scyB9ID0gT2JqZWN0O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8qKlxuICogQ29tYmluZSB0d28gY29tcGFyYXRvcnMgaW50byBhIHNpbmdsZSBjb21wYXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY29tYmluZUNvbXBhcmF0b3JzKGNvbXBhcmF0b3JBLCBjb21wYXJhdG9yQikge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yQShhLCBiLCBzdGF0ZSkgJiYgY29tcGFyYXRvckIoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG4vKipcbiAqIFdyYXAgdGhlIHByb3ZpZGVkIGBhcmVJdGVtc0VxdWFsYCBtZXRob2QgdG8gbWFuYWdlIHRoZSBjaXJjdWxhciBzdGF0ZSwgYWxsb3dpbmdcbiAqIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIGJlIHNhZmVseSBpbmNsdWRlZCBpbiB0aGUgY29tcGFyaXNvbiB3aXRob3V0IGNyZWF0aW5nXG4gKiBzdGFjayBvdmVyZmxvd3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzQ2lyY3VsYXIoYXJlSXRlbXNFcXVhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0NpcmN1bGFyKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlSXRlbXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IGNhY2hlZEEgPSBjYWNoZS5nZXQoYSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZEIgPSBjYWNoZS5nZXQoYik7XG4gICAgICAgIGlmIChjYWNoZWRBICYmIGNhY2hlZEIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBID09PSBiICYmIGNhY2hlZEIgPT09IGE7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KGEsIGIpO1xuICAgICAgICBjYWNoZS5zZXQoYiwgYSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICBjYWNoZS5kZWxldGUoYSk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGBAQHRvU3RyaW5nVGFnYCBvZiB0aGUgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2hvcnRUYWcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEdldCB0aGUgcHJvcGVydGllcyB0byBzdHJpY3RseSBleGFtaW5lLCB3aGljaCBpbmNsdWRlIGJvdGggb3duIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIG5vdCBlbnVtZXJhYmxlIGFuZCBzeW1ib2wgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdCBjb250YWlucyB0aGUgcHJvcGVydHkgcGFzc2VkIGFzIGFuIG93biBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuT2JqZWN0Lmhhc093biB8fCAoKG9iamVjdCwgcHJvcGVydHkpID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBzdHJpY3RseSBlcXVhbCBvciBib3RoIE5hTi5cbiAqL1xuZnVuY3Rpb24gc2FtZVZhbHVlWmVyb0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCAoIWEgJiYgIWIgJiYgYSAhPT0gYSAmJiBiICE9PSBiKTtcbn1cblxuY29uc3QgUFJFQUNUX1ZOT0RFID0gJ19fdic7XG5jb25zdCBQUkVBQ1RfT1dORVIgPSAnX19vJztcbmNvbnN0IFJFQUNUX09XTkVSID0gJ19vd25lcic7XG5jb25zdCB7IGdldE93blByb3BlcnR5RGVzY3JpcHRvciwga2V5cyB9ID0gT2JqZWN0O1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheSBidWZmZXJzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlQXJyYXlCdWZmZXJzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhLmJ5dGVMZW5ndGggPT09IGIuYnl0ZUxlbmd0aCAmJiBhcmVUeXBlZEFycmF5c0VxdWFsKG5ldyBVaW50OEFycmF5KGEpLCBuZXcgVWludDhBcnJheShiKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgbGV0IGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoIXN0YXRlLmVxdWFscyhhW2luZGV4XSwgYltpbmRleF0sIGluZGV4LCBpbmRleCwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGRhdGF2aWV3cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZURhdGFWaWV3c0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuYnl0ZUxlbmd0aCA9PT0gYi5ieXRlTGVuZ3RoXG4gICAgICAgICYmIGFyZVR5cGVkQXJyYXlzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBkYXRlcyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVEYXRlc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGVycm9ycyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVFcnJvcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlICYmIGEuY2F1c2UgPT09IGIuY2F1c2UgJiYgYS5zdGFjayA9PT0gYi5zdGFjaztcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZnVuY3Rpb25zIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUZ1bmN0aW9uc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgYE1hcGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGEuc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkSW5kaWNlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICBjb25zdCBhSXRlcmFibGUgPSBhLmVudHJpZXMoKTtcbiAgICBsZXQgYVJlc3VsdDtcbiAgICBsZXQgYlJlc3VsdDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgd2hpbGUgKChhUmVzdWx0ID0gYUl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgaWYgKGFSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYkl0ZXJhYmxlID0gYi5lbnRyaWVzKCk7XG4gICAgICAgIGxldCBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICgoYlJlc3VsdCA9IGJJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgICAgICBpZiAoYlJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBtYXRjaEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhRW50cnkgPSBhUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgYkVudHJ5ID0gYlJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lcXVhbHMoYUVudHJ5WzBdLCBiRW50cnlbMF0sIGluZGV4LCBtYXRjaEluZGV4LCBhLCBiLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAmJiBzdGF0ZS5lcXVhbHMoYUVudHJ5WzFdLCBiRW50cnlbMV0sIGFFbnRyeVswXSwgYkVudHJ5WzBdLCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG51bWJlcnMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5jb25zdCBhcmVOdW1iZXJzRXF1YWwgPSBzYW1lVmFsdWVaZXJvRXF1YWw7XG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ga2V5cyhhKTtcbiAgICBsZXQgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAoa2V5cyhiKS5sZW5ndGggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcbiAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIGlmICghaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0aWVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUgd2l0aCBzdHJpY3QgcHJvcGVydHkgY2hlY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbFN0cmljdChhLCBiLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBnZXRTdHJpY3RQcm9wZXJ0aWVzKGEpO1xuICAgIGxldCBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChnZXRTdHJpY3RQcm9wZXJ0aWVzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcHJvcGVydHk7XG4gICAgbGV0IGRlc2NyaXB0b3JBO1xuICAgIGxldCBkZXNjcmlwdG9yQjtcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3JBID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIHByb3BlcnR5KTtcbiAgICAgICAgZGVzY3JpcHRvckIgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoKGRlc2NyaXB0b3JBIHx8IGRlc2NyaXB0b3JCKVxuICAgICAgICAgICAgJiYgKCFkZXNjcmlwdG9yQVxuICAgICAgICAgICAgICAgIHx8ICFkZXNjcmlwdG9yQlxuICAgICAgICAgICAgICAgIHx8IGRlc2NyaXB0b3JBLmNvbmZpZ3VyYWJsZSAhPT0gZGVzY3JpcHRvckIuY29uZmlndXJhYmxlXG4gICAgICAgICAgICAgICAgfHwgZGVzY3JpcHRvckEuZW51bWVyYWJsZSAhPT0gZGVzY3JpcHRvckIuZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgIHx8IGRlc2NyaXB0b3JBLndyaXRhYmxlICE9PSBkZXNjcmlwdG9yQi53cml0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgcHJpbWl0aXZlIHdyYXBwZXJzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgcmVnZXhwcyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVSZWdFeHBzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbn1cbi8qKlxuICogV2hldGhlciB0aGUgYFNldGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlU2V0c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGEuc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkSW5kaWNlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICBjb25zdCBhSXRlcmFibGUgPSBhLnZhbHVlcygpO1xuICAgIGxldCBhUmVzdWx0O1xuICAgIGxldCBiUmVzdWx0O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgd2hpbGUgKChhUmVzdWx0ID0gYUl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgaWYgKGFSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYkl0ZXJhYmxlID0gYi52YWx1ZXMoKTtcbiAgICAgICAgbGV0IGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaEluZGV4ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKChiUmVzdWx0ID0gYkl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgICAgIGlmIChiUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF1cbiAgICAgICAgICAgICAgICAmJiBzdGF0ZS5lcXVhbHMoYVJlc3VsdC52YWx1ZSwgYlJlc3VsdC52YWx1ZSwgYVJlc3VsdC52YWx1ZSwgYlJlc3VsdC52YWx1ZSwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBUeXBlZEFycmF5IGluc3RhbmNlcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVR5cGVkQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGxldCBpbmRleCA9IGEuYnl0ZUxlbmd0aDtcbiAgICBpZiAoYi5ieXRlTGVuZ3RoICE9PSBpbmRleCB8fCBhLmJ5dGVPZmZzZXQgIT09IGIuYnl0ZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoYVtpbmRleF0gIT09IGJbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFVSTCBpbnN0YW5jZXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVVcmxzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoYS5ob3N0bmFtZSA9PT0gYi5ob3N0bmFtZVxuICAgICAgICAmJiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lXG4gICAgICAgICYmIGEucHJvdG9jb2wgPT09IGIucHJvdG9jb2xcbiAgICAgICAgJiYgYS5wb3J0ID09PSBiLnBvcnRcbiAgICAgICAgJiYgYS5oYXNoID09PSBiLmhhc2hcbiAgICAgICAgJiYgYS51c2VybmFtZSA9PT0gYi51c2VybmFtZVxuICAgICAgICAmJiBhLnBhc3N3b3JkID09PSBiLnBhc3N3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlFcXVhbChhLCBiLCBzdGF0ZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoKHByb3BlcnR5ID09PSBSRUFDVF9PV05FUiB8fCBwcm9wZXJ0eSA9PT0gUFJFQUNUX09XTkVSIHx8IHByb3BlcnR5ID09PSBQUkVBQ1RfVk5PREUpXG4gICAgICAgICYmIChhLiQkdHlwZW9mIHx8IGIuJCR0eXBlb2YpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzT3duKGIsIHByb3BlcnR5KSAmJiBzdGF0ZS5lcXVhbHMoYVtwcm9wZXJ0eV0sIGJbcHJvcGVydHldLCBwcm9wZXJ0eSwgcHJvcGVydHksIGEsIGIsIHN0YXRlKTtcbn1cblxuY29uc3QgQVJSQVlfQlVGRkVSX1RBRyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5jb25zdCBBUkdVTUVOVFNfVEFHID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5jb25zdCBCT09MRUFOX1RBRyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbmNvbnN0IERBVEFfVklFV19UQUcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuY29uc3QgREFURV9UQUcgPSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBFUlJPUl9UQUcgPSAnW29iamVjdCBFcnJvcl0nO1xuY29uc3QgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xuY29uc3QgTlVNQkVSX1RBRyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuY29uc3QgT0JKRUNUX1RBRyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuY29uc3QgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcbmNvbnN0IFNFVF9UQUcgPSAnW29iamVjdCBTZXRdJztcbmNvbnN0IFNUUklOR19UQUcgPSAnW29iamVjdCBTdHJpbmddJztcbmNvbnN0IFRZUEVEX0FSUkFZX1RBR1MgPSB7XG4gICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgRmxvYXQxNkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgQmlnSW50NjRBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XSc6IHRydWUsXG59O1xuY29uc3QgVVJMX1RBRyA9ICdbb2JqZWN0IFVSTF0nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuLyoqXG4gKiBDcmVhdGUgYSBjb21wYXJhdG9yIG1ldGhvZCBiYXNlZCBvbiB0aGUgdHlwZS1zcGVjaWZpYyBlcXVhbGl0eSBjb21wYXJhdG9ycyBwYXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvcih7IGFyZUFycmF5QnVmZmVyc0VxdWFsLCBhcmVBcnJheXNFcXVhbCwgYXJlRGF0YVZpZXdzRXF1YWwsIGFyZURhdGVzRXF1YWwsIGFyZUVycm9yc0VxdWFsLCBhcmVGdW5jdGlvbnNFcXVhbCwgYXJlTWFwc0VxdWFsLCBhcmVOdW1iZXJzRXF1YWwsIGFyZU9iamVjdHNFcXVhbCwgYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCwgYXJlUmVnRXhwc0VxdWFsLCBhcmVTZXRzRXF1YWwsIGFyZVR5cGVkQXJyYXlzRXF1YWwsIGFyZVVybHNFcXVhbCwgdW5rbm93blRhZ0NvbXBhcmF0b3JzLCB9KSB7XG4gICAgLyoqXG4gICAgICogY29tcGFyZSB0aGUgdmFsdWUgb2YgdGhlIHR3byBvYmplY3RzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHZhbHVlc1xuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgc3RyaWN0bHkgZXF1YWwsIG5vIG5lZWQgdG8gZG8gYSB2YWx1ZSBjb21wYXJpc29uLlxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBpdGVtcyBhcmUgbnVsbGlzaCBhbmQgZmFpbCB0aGUgc3RyaWN0bHkgZXF1YWwgY2hlY2tcbiAgICAgICAgLy8gYWJvdmUsIHRoZW4gdGhleSBtdXN0IGJlIHVuZXF1YWwuXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVOdW1iZXJzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlRnVuY3Rpb25zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBwcmltaXRpdmUgdmFsdWUgdGhhdCBpcyBub3Qgc3RyaWN0bHkgZXF1YWwsIGl0IG11c3QgYmUgdW5lcXVhbC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGEuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIENoZWNrcyBhcmUgbGlzdGVkIGluIG9yZGVyIG9mIGNvbW1vbmFsaXR5IG9mIHVzZS1jYXNlOlxuICAgICAgICAvLyAgIDEuIENvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAocGxhaW4gb2JqZWN0LCBhcnJheSlcbiAgICAgICAgLy8gICAyLiBDb21tb24gZGF0YSB2YWx1ZXMgKGRhdGUsIHJlZ2V4cClcbiAgICAgICAgLy8gICAzLiBMZXNzLWNvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAobWFwLCBzZXQpXG4gICAgICAgIC8vICAgNC4gTGVzcy1jb21tb24gZGF0YSB2YWx1ZXMgKHByb21pc2UsIHByaW1pdGl2ZSB3cmFwcGVycylcbiAgICAgICAgLy8gSW5oZXJlbnRseSB0aGlzIGlzIGJvdGggc3ViamVjdGl2ZSBhbmQgYXNzdW1wdGl2ZSwgaG93ZXZlclxuICAgICAgICAvLyB3aGVuIHJldmlld2luZyBjb21wYXJhYmxlIGxpYnJhcmllcyBpbiB0aGUgd2lsZCB0aGlzIG9yZGVyXG4gICAgICAgIC8vIGFwcGVhcnMgdG8gYmUgZ2VuZXJhbGx5IGNvbnNpc3RlbnQuXG4gICAgICAgIC8vIENvbnN0cnVjdG9ycyBzaG91bGQgbWF0Y2gsIG90aGVyd2lzZSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgICAvLyBiZXR3ZWVuIGNsYXNzIGFuZCBzdWJjbGFzcyBvciBjdXN0b20gb2JqZWN0IGFuZCBQT0pPLlxuICAgICAgICBpZiAoY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgaXNQbGFpbk9iamVjdGAgb25seSBjaGVja3MgYWdhaW5zdCB0aGUgb2JqZWN0J3Mgb3duIHJlYWxtLiBDcm9zcy1yZWFsbVxuICAgICAgICAvLyBjb21wYXJpc29ucyBhcmUgcmFyZSwgYW5kIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgdWx0aW1hdGUgZmFsbGJhY2ssIHNvXG4gICAgICAgIC8vIHdlIGNhbiBhdm9pZCBjYXB0dXJpbmcgdGhlIHN0cmluZyB0YWcuXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgaXNBcnJheSgpYCB3b3JrcyBvbiBzdWJjbGFzc2VzIGFuZCBpcyBjcm9zcy1yZWFsbSwgc28gd2UgY2FuIGF2b2lkIGNhcHR1cmluZ1xuICAgICAgICAvLyB0aGUgc3RyaW5nIHRhZyBvciBkb2luZyBhbiBgaW5zdGFuY2VvZmAgY2hlY2suXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlQXJyYXlzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBmYXN0LXBhdGggZXF1YWxpdHkgY2hlY2tzIGZvciBvdGhlciBjb21wbGV4IG9iamVjdCB0eXBlcyBpbiB0aGVcbiAgICAgICAgLy8gc2FtZSByZWFsbSB0byBhdm9pZCBjYXB0dXJpbmcgdGhlIHN0cmluZyB0YWcuIFN0cmljdCBlcXVhbGl0eSBpcyB1c2VkXG4gICAgICAgIC8vIGluc3RlYWQgb2YgYGluc3RhbmNlb2ZgIGJlY2F1c2UgaXQgaXMgbW9yZSBwZXJmb3JtYW50IGZvciB0aGUgY29tbW9uXG4gICAgICAgIC8vIHVzZS1jYXNlLiBJZiBzb21lb25lIGlzIHN1YmNsYXNzaW5nIGEgbmF0aXZlIGNsYXNzLCBpdCB3aWxsIGJlIGhhbmRsZWRcbiAgICAgICAgLy8gd2l0aCB0aGUgc3RyaW5nIHRhZyBjb21wYXJpc29uLlxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVNYXBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlU2V0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgY3VzdG9tIG9iamVjdCwgY2FwdHVyZSB0aGUgc3RyaW5nIHRhZyB0byBkZXRlcm1pbmcgaXRzIHR5cGUuXG4gICAgICAgIC8vIFRoaXMgaXMgcmVhc29uYWJseSBwZXJmb3JtYW50IGluIG1vZGVybiBlbnZpcm9ubWVudHMgbGlrZSB2OCBhbmQgU3BpZGVyTW9ua2V5LlxuICAgICAgICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgICAgICBpZiAodGFnID09PSBEQVRFX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZURhdGVzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBSZWdFeHAsIHRoZSBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZSwgYW5kIHRoZXJlZm9yZSB3aWxsIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGlmXG4gICAgICAgIC8vIHRlc3RlZCBsaWtlIGEgc3RhbmRhcmQgb2JqZWN0LlxuICAgICAgICBpZiAodGFnID09PSBSRUdfRVhQX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gTUFQX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gU0VUX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gT0JKRUNUX1RBRykge1xuICAgICAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBmb3IgdmFsdWUgY29tcGFyaXNvbiBpcyBjdXN0b20gYFByb21pc2VgLWxpa2UgY2xhc3MgaW5zdGFuY2VzLiBUaGVzZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgc3RhbmRhcmQgYFByb21pc2VgIG9iamVjdHMsIHdoaWNoIG1lYW5zIHN0cmljdCBlcXVhbGl0eSwgYW5kIGlmXG4gICAgICAgICAgICAvLyBpdCByZWFjaGVzIHRoaXMgcG9pbnQgdGhlbiB0aGF0IHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29uIGhhcyBhbHJlYWR5IGZhaWxlZC5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYS50aGVuICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiLnRoZW4gIT09ICdmdW5jdGlvbicgJiYgYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIFVSTCB0YWcsIGl0IHNob3VsZCBiZSB0ZXN0ZWQgZXhwbGljaXRseS4gTGlrZSBSZWdFeHAsIHRoZSBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgICAgICAgLy8gZW51bWVyYWJsZSwgYW5kIHRoZXJlZm9yZSB3aWxsIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGlmIHRlc3RlZCBsaWtlIGEgc3RhbmRhcmQgb2JqZWN0LlxuICAgICAgICBpZiAodGFnID09PSBVUkxfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlVXJsc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBlcnJvciB0YWcsIGl0IHNob3VsZCBiZSB0ZXN0ZWQgZXhwbGljaXRseS4gTGlrZSBSZWdFeHAsIHRoZSBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgICAgICAgLy8gZW51bWVyYWJsZSwgYW5kIHRoZXJlZm9yZSB3aWxsIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGlmIHRlc3RlZCBsaWtlIGEgc3RhbmRhcmQgb2JqZWN0LlxuICAgICAgICBpZiAodGFnID09PSBFUlJPUl9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVFcnJvcnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gYXJndW1lbnRzIHRhZywgaXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IEFSR1VNRU5UU19UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWV9UQUdTW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBBUlJBWV9CVUZGRVJfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlQXJyYXlCdWZmZXJzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IERBVEFfVklFV19UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRhVmlld3NFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgdGhlIHBlbnVsdGltYXRlIGZhbGxiYWNrLCBjaGVjayBpZiB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgcHJpbWl0aXZlIHdyYXBwZXJzLiBUaGlzXG4gICAgICAgIC8vIGlzIHZlcnkgcmFyZSBpbiBtb2Rlcm4gSlMsIHdoaWNoIGlzIHdoeSBpdCBpcyBkZXByaW9yaXRpemVkIGNvbXBhcmVkIHRvIGFsbCBvdGhlciBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMuXG4gICAgICAgIGlmICh0YWcgPT09IEJPT0xFQU5fVEFHIHx8IHRhZyA9PT0gTlVNQkVSX1RBRyB8fCB0YWcgPT09IFNUUklOR19UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5rbm93blRhZ0NvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBsZXQgdW5rbm93blRhZ0NvbXBhcmF0b3IgPSB1bmtub3duVGFnQ29tcGFyYXRvcnNbdGFnXTtcbiAgICAgICAgICAgIGlmICghdW5rbm93blRhZ0NvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG9ydFRhZyA9IGdldFNob3J0VGFnKGEpO1xuICAgICAgICAgICAgICAgIGlmIChzaG9ydFRhZykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duVGFnQ29tcGFyYXRvciA9IHVua25vd25UYWdDb21wYXJhdG9yc1tzaG9ydFRhZ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1c3RvbSBjb25maWcgaGFzIGFuIHVua25vd24gdGFnIGNvbXBhcmF0b3IgdGhhdCBtYXRjaGVzIHRoZSBjYXB0dXJlZCB0YWcgb3IgdGhlXG4gICAgICAgICAgICAvLyBAQHRvU3RyaW5nVGFnLCBpdCBpcyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB3aGV0aGVyIHRoZSB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgaWYgKHVua25vd25UYWdDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVua25vd25UYWdDb21wYXJhdG9yKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgbWF0Y2hpbmcgYW55IHRhZ3MgdGhhdCByZXF1aXJlIGEgc3BlY2lmaWMgdHlwZSBvZiBjb21wYXJpc29uLCB0aGVuIHdlIGhhcmQtY29kZSBmYWxzZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIHJlbWFpbmluZyBpcyBzdHJpY3QgZXF1YWxpdHksIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gY29tcGFyZWQuIFRoaXMgaXMgZm9yIGEgZmV3IHJlYXNvbnM6XG4gICAgICAgIC8vICAgLSBDZXJ0YWluIHR5cGVzIHRoYXQgY2Fubm90IGJlIGludHJvc3BlY3RlZCAoZS5nLiwgYFdlYWtNYXBgKS4gRm9yIHRoZXNlIHR5cGVzLCB0aGlzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vICAgICBjb21wYXJpc29uIHRoYXQgY2FuIGJlIG1hZGUuXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkLCBidXQgcmFyZWx5IGhhdmUgcmVxdWlyZW1lbnRzIHRvIGJlIGNvbXBhcmVkXG4gICAgICAgIC8vICAgICAoYEFycmF5QnVmZmVyYCwgYERhdGFWaWV3YCwgZXRjLiksIHRoZSBjb3N0IGlzIGF2b2lkZWQgdG8gcHJpb3JpdGl6ZSB0aGUgY29tbW9uXG4gICAgICAgIC8vICAgICB1c2UtY2FzZXMgKG1heSBiZSBpbmNsdWRlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLCBpZiByZXF1ZXN0ZWQgZW5vdWdoKS5cbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQgYnV0IGRvIG5vdCBoYXZlIGFuIG9iamVjdGl2ZSBkZWZpbml0aW9uIG9mIHdoYXRcbiAgICAgICAgLy8gICAgIGVxdWFsaXR5IGlzIChgRXJyb3JgLCBldGMuKSwgdGhlIHN1YmplY3RpdmUgZGVjaXNpb24gaXMgdG8gYmUgY29uc2VydmF0aXZlIGFuZCBzdHJpY3RseSBjb21wYXJlLlxuICAgICAgICAvLyBJbiBhbGwgY2FzZXMsIHRoZXNlIGRlY2lzaW9ucyBzaG91bGQgYmUgcmVldmFsdWF0ZWQgYmFzZWQgb24gY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2UgYW5kXG4gICAgICAgIC8vIGNvbW1vbiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHVzZWQgZm9yIGJ1aWxkaW5nIGNvbXBhcmF0b3JzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWcoeyBjaXJjdWxhciwgY3JlYXRlQ3VzdG9tQ29uZmlnLCBzdHJpY3QsIH0pIHtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICBhcmVBcnJheUJ1ZmZlcnNFcXVhbCxcbiAgICAgICAgYXJlQXJyYXlzRXF1YWw6IHN0cmljdCA/IGFyZU9iamVjdHNFcXVhbFN0cmljdCA6IGFyZUFycmF5c0VxdWFsLFxuICAgICAgICBhcmVEYXRhVmlld3NFcXVhbCxcbiAgICAgICAgYXJlRGF0ZXNFcXVhbDogYXJlRGF0ZXNFcXVhbCxcbiAgICAgICAgYXJlRXJyb3JzRXF1YWw6IGFyZUVycm9yc0VxdWFsLFxuICAgICAgICBhcmVGdW5jdGlvbnNFcXVhbDogYXJlRnVuY3Rpb25zRXF1YWwsXG4gICAgICAgIGFyZU1hcHNFcXVhbDogc3RyaWN0ID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZU1hcHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KSA6IGFyZU1hcHNFcXVhbCxcbiAgICAgICAgYXJlTnVtYmVyc0VxdWFsOiBhcmVOdW1iZXJzRXF1YWwsXG4gICAgICAgIGFyZU9iamVjdHNFcXVhbDogc3RyaWN0ID8gYXJlT2JqZWN0c0VxdWFsU3RyaWN0IDogYXJlT2JqZWN0c0VxdWFsLFxuICAgICAgICBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsOiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLFxuICAgICAgICBhcmVSZWdFeHBzRXF1YWw6IGFyZVJlZ0V4cHNFcXVhbCxcbiAgICAgICAgYXJlU2V0c0VxdWFsOiBzdHJpY3QgPyBjb21iaW5lQ29tcGFyYXRvcnMoYXJlU2V0c0VxdWFsLCBhcmVPYmplY3RzRXF1YWxTdHJpY3QpIDogYXJlU2V0c0VxdWFsLFxuICAgICAgICBhcmVUeXBlZEFycmF5c0VxdWFsOiBzdHJpY3RcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZVR5cGVkQXJyYXlzRXF1YWwsIGFyZU9iamVjdHNFcXVhbFN0cmljdClcbiAgICAgICAgICAgIDogYXJlVHlwZWRBcnJheXNFcXVhbCxcbiAgICAgICAgYXJlVXJsc0VxdWFsOiBhcmVVcmxzRXF1YWwsXG4gICAgICAgIHVua25vd25UYWdDb21wYXJhdG9yczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgaWYgKGNyZWF0ZUN1c3RvbUNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIGNyZWF0ZUN1c3RvbUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIGNvbnN0IGFyZUFycmF5c0VxdWFsID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlQXJyYXlzRXF1YWwpO1xuICAgICAgICBjb25zdCBhcmVNYXBzRXF1YWwgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVNYXBzRXF1YWwpO1xuICAgICAgICBjb25zdCBhcmVPYmplY3RzRXF1YWwgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVPYmplY3RzRXF1YWwpO1xuICAgICAgICBjb25zdCBhcmVTZXRzRXF1YWwgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVTZXRzRXF1YWwpO1xuICAgICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHtcbiAgICAgICAgICAgIGFyZUFycmF5c0VxdWFsLFxuICAgICAgICAgICAgYXJlTWFwc0VxdWFsLFxuICAgICAgICAgICAgYXJlT2JqZWN0c0VxdWFsLFxuICAgICAgICAgICAgYXJlU2V0c0VxdWFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbi8qKlxuICogRGVmYXVsdCBlcXVhbGl0eSBjb21wYXJhdG9yIHBhc3MtdGhyb3VnaCwgdXNlZCBhcyB0aGUgc3RhbmRhcmQgYGlzRXF1YWxgIGNyZWF0b3IgZm9yXG4gKiB1c2UgaW5zaWRlIHRoZSBidWlsdCBjb21wYXJhdG9yLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvcihjb21wYXJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBfaW5kZXhPcktleUEsIF9pbmRleE9yS2V5QiwgX3BhcmVudEEsIF9wYXJlbnRCLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZShhLCBiLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBgaXNFcXVhbGAgZnVuY3Rpb24gdXNlZCBieSB0aGUgY29uc3VtaW5nIGFwcGxpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJc0VxdWFsKHsgY2lyY3VsYXIsIGNvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlLCBlcXVhbHMsIHN0cmljdCB9KSB7XG4gICAgaWYgKGNyZWF0ZVN0YXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgPSBjaXJjdWxhciA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQsIG1ldGEgfSA9IGNyZWF0ZVN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgZXF1YWxzLFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICAgICAgZXF1YWxzLFxuICAgICAgICAgICAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGNhY2hlOiB1bmRlZmluZWQsXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgICBzdHJpY3QsXG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLlxuICovXG5jb25zdCBkZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCgpO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xuY29uc3Qgc3RyaWN0RGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoeyBzdHJpY3Q6IHRydWUgfSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqL1xuY29uc3QgY2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7IGNpcmN1bGFyOiB0cnVlIH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xuY29uc3Qgc3RyaWN0Q2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgc3RyaWN0OiB0cnVlLFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLlxuICovXG5jb25zdCBzaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiAoKSA9PiBzYW1lVmFsdWVaZXJvRXF1YWwsXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUgYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb25cbiAqL1xuY29uc3Qgc3RyaWN0U2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIHN0cmljdDogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6ICgpID0+IHNhbWVWYWx1ZVplcm9FcXVhbCxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKi9cbmNvbnN0IGNpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogKCkgPT4gc2FtZVZhbHVlWmVyb0VxdWFsLFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG5jb25zdCBzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6ICgpID0+IHNhbWVWYWx1ZVplcm9FcXVhbCxcbiAgICBzdHJpY3Q6IHRydWUsXG59KTtcbi8qKlxuICogQ3JlYXRlIGEgY3VzdG9tIGVxdWFsaXR5IGNvbXBhcmlzb24gbWV0aG9kLlxuICpcbiAqIFRoaXMgY2FuIGJlIGRvbmUgdG8gY3JlYXRlIHZlcnkgdGFyZ2V0ZWQgY29tcGFyaXNvbnMgaW4gZXh0cmVtZSBob3QtcGF0aCBzY2VuYXJpb3NcbiAqIHdoZXJlIHRoZSBzdGFuZGFyZCBtZXRob2RzIGFyZSBub3QgcGVyZm9ybWFudCBlbm91Z2gsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGVcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBleHBlY3RlZCBmZWF0dXJlcyBsaWtlXG4gKiBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2Agb3V0IG9mIHRoZSBib3guXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUVxdWFsKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2lyY3VsYXIgPSBmYWxzZSwgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlLCBzdHJpY3QgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yQ29uZmlnKG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IoY29uZmlnKTtcbiAgICBjb25zdCBlcXVhbHMgPSBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3JcbiAgICAgICAgPyBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IoY29tcGFyYXRvcilcbiAgICAgICAgOiBjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICByZXR1cm4gY3JlYXRlSXNFcXVhbCh7IGNpcmN1bGFyLCBjb21wYXJhdG9yLCBjcmVhdGVTdGF0ZSwgZXF1YWxzLCBzdHJpY3QgfSk7XG59XG5cbmV4cG9ydCB7IGNpcmN1bGFyRGVlcEVxdWFsLCBjaXJjdWxhclNoYWxsb3dFcXVhbCwgY3JlYXRlQ3VzdG9tRXF1YWwsIGRlZXBFcXVhbCwgc2FtZVZhbHVlWmVyb0VxdWFsLCBzaGFsbG93RXF1YWwsIHN0cmljdENpcmN1bGFyRGVlcEVxdWFsLCBzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCwgc3RyaWN0RGVlcEVxdWFsLCBzdHJpY3RTaGFsbG93RXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/es/index.mjs\n");

/***/ })

};
;