"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_route-planner-map_tsx",{

/***/ "(app-pages-browser)/./src/components/route-planner-map.tsx":
/*!**********************************************!*\
  !*** ./src/components/route-planner-map.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RoutePlannerMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction haversineMeters(a, b) {\n    const R = 6371000;\n    const toRad = (v)=>v * Math.PI / 180;\n    const dLat = toRad(b.lat - a.lat);\n    const dLng = toRad(b.lng - a.lng);\n    const lat1 = toRad(a.lat);\n    const lat2 = toRad(b.lat);\n    const sinLat = Math.sin(dLat / 2);\n    const sinLng = Math.sin(dLng / 2);\n    const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;\n    return 2 * R * Math.asin(Math.sqrt(h));\n}\n/**\r\n * Snap route to real roads via OSRM (free, no API key).\r\n * Only sends start, end, and up to 3 evenly-spaced guide points\r\n * to avoid over-constraining the route.\r\n */ async function fetchRoadGeometry(pts) {\n    if (pts.length < 2) return pts;\n    try {\n        var _data_routes__geometry, _data_routes_, _data_routes;\n        // Pick start, end, and up to 3 guide waypoints in between\n        const key = [\n            pts[0]\n        ];\n        if (pts.length > 6) {\n            const step = (pts.length - 1) / 4;\n            key.push(pts[Math.round(step)]);\n            key.push(pts[Math.round(step * 2)]);\n            key.push(pts[Math.round(step * 3)]);\n        } else if (pts.length > 3) {\n            key.push(pts[Math.round((pts.length - 1) / 2)]);\n        }\n        key.push(pts[pts.length - 1]);\n        // OSRM expects lng,lat order\n        const coords = key.map((p)=>\"\".concat(p[1], \",\").concat(p[0])).join(\";\");\n        const url = \"https://router.project-osrm.org/route/v1/driving/\".concat(coords, \"?overview=full&geometries=geojson\");\n        const res = await fetch(url);\n        if (!res.ok) return pts;\n        const data = await res.json();\n        if (data.code !== \"Ok\" || !((_data_routes = data.routes) === null || _data_routes === void 0 ? void 0 : (_data_routes_ = _data_routes[0]) === null || _data_routes_ === void 0 ? void 0 : (_data_routes__geometry = _data_routes_.geometry) === null || _data_routes__geometry === void 0 ? void 0 : _data_routes__geometry.coordinates)) return pts;\n        // GeoJSON coordinates are [lng, lat] → convert to [lat, lng]\n        return data.routes[0].geometry.coordinates.map((c)=>[\n                c[1],\n                c[0]\n            ]);\n    } catch (e) {\n        return pts;\n    }\n}\nfunction RoutePlannerMap(param) {\n    let { sensors, startSensor, endSensor, routeLatLngs, onSelectSensor, height = \"560px\" } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sensorLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const endMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const onSelectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(onSelectSensor);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        onSelectRef.current = onSelectSensor;\n    }, [\n        onSelectSensor\n    ]);\n    const bounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!sensors.length) return null;\n        const latLngs = sensors.map((s)=>leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n        return leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLngBounds(latLngs).pad(0.2);\n    }, [\n        sensors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapRef.current || mapInstanceRef.current) return;\n        if (!sensors.length || !bounds) return;\n        const map = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map(mapRef.current, {\n            center: bounds.getCenter(),\n            zoom: 12,\n            zoomControl: false,\n            scrollWheelZoom: false,\n            touchZoom: false,\n            doubleClickZoom: false,\n            boxZoom: false,\n            keyboard: false,\n            preferCanvas: false,\n            minZoom: 12,\n            maxZoom: 12,\n            maxBounds: bounds,\n            maxBoundsViscosity: 1.0\n        });\n        leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer(\"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\", {\n            attribution: '&copy; <a href=\"https://carto.com/\">CARTO</a>',\n            maxZoom: 19\n        }).addTo(map);\n        map.setView(bounds.getCenter(), 12, {\n            animate: false\n        });\n        const sensorLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup();\n        sensors.forEach((s)=>{\n            leaflet__WEBPACK_IMPORTED_MODULE_2___default().circleMarker([\n                s.lat,\n                s.lng\n            ], {\n                radius: 3,\n                fillColor: \"#94a3b8\",\n                color: \"rgba(0,0,0,0.2)\",\n                weight: 1,\n                fillOpacity: 0.7\n            }).bindTooltip(\"Sensor \".concat(s.id), {\n                direction: \"top\"\n            }).addTo(sensorLayer);\n        });\n        sensorLayer.addTo(map);\n        sensorLayerRef.current = sensorLayer;\n        map.on(\"click\", (e)=>{\n            if (!sensors.length) return;\n            const click = leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(e.latlng.lat, e.latlng.lng);\n            let best = null;\n            let bestMeters = Number.POSITIVE_INFINITY;\n            for (const s of sensors){\n                const d = haversineMeters(click, leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n                if (d < bestMeters) {\n                    bestMeters = d;\n                    best = s;\n                }\n            }\n            if (!best || bestMeters > 1500) return;\n            onSelectRef.current(best);\n        });\n        mapInstanceRef.current = map;\n        return ()=>{\n            if (animationRef.current) cancelAnimationFrame(animationRef.current);\n            map.remove();\n            mapInstanceRef.current = null;\n        };\n    }, [\n        sensors,\n        bounds\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (startMarkerRef.current) startMarkerRef.current.remove();\n        if (endMarkerRef.current) endMarkerRef.current.remove();\n        if (startSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--start\",\n                html: \"S\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            const marker = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                startSensor.lat,\n                startSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            marker.bindTooltip(\"Start\", {\n                direction: \"top\"\n            });\n            startMarkerRef.current = marker;\n        }\n        if (endSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--end\",\n                html: \"E\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            const marker = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                endSensor.lat,\n                endSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            marker.bindTooltip(\"End\", {\n                direction: \"top\"\n            });\n            endMarkerRef.current = marker;\n        }\n    }, [\n        startSensor,\n        endSensor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (routeLayerRef.current) routeLayerRef.current.remove();\n        if (animationRef.current) cancelAnimationFrame(animationRef.current);\n        if (!routeLatLngs.length) return;\n        let cancelled = false;\n        fetchRoadGeometry(routeLatLngs).then((roadPts)=>{\n            if (cancelled || !mapInstanceRef.current) return;\n            const routeLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup().addTo(map);\n            /* layer 1 – soft glow base */ leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#38bdf8\",\n                weight: 7,\n                opacity: 0.18,\n                lineCap: \"round\"\n            }).addTo(routeLayer);\n            /* layer 2 – fast escalator dashes */ const escalator1 = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#38bdf8\",\n                weight: 3,\n                opacity: 0.9,\n                dashArray: \"6 14\",\n                lineCap: \"butt\"\n            }).addTo(routeLayer);\n            /* layer 3 – offset counter-dashes for density */ const escalator2 = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#60a5fa\",\n                weight: 2,\n                opacity: 0.55,\n                dashArray: \"4 18\",\n                lineCap: \"butt\"\n            }).addTo(routeLayer);\n            routeLayerRef.current = routeLayer;\n            let offset1 = 0;\n            let offset2 = 0;\n            const step = ()=>{\n                offset1 = (offset1 - 16) % 2000;\n                offset2 = (offset2 + 12) % 2000;\n                escalator1.setStyle({\n                    dashOffset: \"\".concat(offset1)\n                });\n                escalator2.setStyle({\n                    dashOffset: \"\".concat(offset2)\n                });\n                animationRef.current = requestAnimationFrame(step);\n            };\n            animationRef.current = requestAnimationFrame(step);\n        });\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        routeLatLngs\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapRef,\n        style: {\n            height,\n            width: \"100%\",\n            borderRadius: \"var(--radius)\"\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\OnTime\\\\frontend-nextjs\\\\src\\\\components\\\\route-planner-map.tsx\",\n        lineNumber: 263,\n        columnNumber: 10\n    }, this);\n}\n_s(RoutePlannerMap, \"Xm+sm5SntUDQN0N+kBI08UC2Hi8=\");\n_c = RoutePlannerMap;\nvar _c;\n$RefreshReg$(_c, \"RoutePlannerMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JvdXRlLXBsYW5uZXItbWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDM0I7QUFDVTtBQXFCbEMsU0FBU0ksZ0JBQWdCQyxDQUFXLEVBQUVDLENBQVc7SUFDL0MsTUFBTUMsSUFBSTtJQUNWLE1BQU1DLFFBQVEsQ0FBQ0MsSUFBYyxJQUFLQyxLQUFLQyxFQUFFLEdBQUk7SUFDN0MsTUFBTUMsT0FBT0osTUFBTUYsRUFBRU8sR0FBRyxHQUFHUixFQUFFUSxHQUFHO0lBQ2hDLE1BQU1DLE9BQU9OLE1BQU1GLEVBQUVTLEdBQUcsR0FBR1YsRUFBRVUsR0FBRztJQUNoQyxNQUFNQyxPQUFPUixNQUFNSCxFQUFFUSxHQUFHO0lBQ3hCLE1BQU1JLE9BQU9ULE1BQU1GLEVBQUVPLEdBQUc7SUFDeEIsTUFBTUssU0FBU1IsS0FBS1MsR0FBRyxDQUFDUCxPQUFPO0lBQy9CLE1BQU1RLFNBQVNWLEtBQUtTLEdBQUcsQ0FBQ0wsT0FBTztJQUMvQixNQUFNTyxJQUFJSCxTQUFTQSxTQUFTUixLQUFLWSxHQUFHLENBQUNOLFFBQVFOLEtBQUtZLEdBQUcsQ0FBQ0wsUUFBUUcsU0FBU0E7SUFDdkUsT0FBTyxJQUFJYixJQUFJRyxLQUFLYSxJQUFJLENBQUNiLEtBQUtjLElBQUksQ0FBQ0g7QUFDckM7QUFFQTs7OztDQUlDLEdBQ0QsZUFBZUksa0JBQ2JDLEdBQXVCO0lBRXZCLElBQUlBLElBQUlDLE1BQU0sR0FBRyxHQUFHLE9BQU9EO0lBQzNCLElBQUk7WUFtQnlCRSx3QkFBQUEsZUFBQUE7UUFsQjNCLDBEQUEwRDtRQUMxRCxNQUFNQyxNQUEwQjtZQUFDSCxHQUFHLENBQUMsRUFBRTtTQUFDO1FBQ3hDLElBQUlBLElBQUlDLE1BQU0sR0FBRyxHQUFHO1lBQ2xCLE1BQU1HLE9BQU8sQ0FBQ0osSUFBSUMsTUFBTSxHQUFHLEtBQUs7WUFDaENFLElBQUlFLElBQUksQ0FBQ0wsR0FBRyxDQUFDaEIsS0FBS3NCLEtBQUssQ0FBQ0YsTUFBTTtZQUM5QkQsSUFBSUUsSUFBSSxDQUFDTCxHQUFHLENBQUNoQixLQUFLc0IsS0FBSyxDQUFDRixPQUFPLEdBQUc7WUFDbENELElBQUlFLElBQUksQ0FBQ0wsR0FBRyxDQUFDaEIsS0FBS3NCLEtBQUssQ0FBQ0YsT0FBTyxHQUFHO1FBQ3BDLE9BQU8sSUFBSUosSUFBSUMsTUFBTSxHQUFHLEdBQUc7WUFDekJFLElBQUlFLElBQUksQ0FBQ0wsR0FBRyxDQUFDaEIsS0FBS3NCLEtBQUssQ0FBQyxDQUFDTixJQUFJQyxNQUFNLEdBQUcsS0FBSyxHQUFHO1FBQ2hEO1FBQ0FFLElBQUlFLElBQUksQ0FBQ0wsR0FBRyxDQUFDQSxJQUFJQyxNQUFNLEdBQUcsRUFBRTtRQUU1Qiw2QkFBNkI7UUFDN0IsTUFBTU0sU0FBU0osSUFBSUssR0FBRyxDQUFDLENBQUNDLElBQU0sR0FBV0EsT0FBUkEsQ0FBQyxDQUFDLEVBQUUsRUFBQyxLQUFRLE9BQUxBLENBQUMsQ0FBQyxFQUFFLEdBQUlDLElBQUksQ0FBQztRQUN0RCxNQUFNQyxNQUFNLG9EQUEyRCxPQUFQSixRQUFPO1FBQ3ZFLE1BQU1LLE1BQU0sTUFBTUMsTUFBTUY7UUFDeEIsSUFBSSxDQUFDQyxJQUFJRSxFQUFFLEVBQUUsT0FBT2Q7UUFDcEIsTUFBTUUsT0FBTyxNQUFNVSxJQUFJRyxJQUFJO1FBQzNCLElBQUliLEtBQUtjLElBQUksS0FBSyxRQUFRLEdBQUNkLGVBQUFBLEtBQUtlLE1BQU0sY0FBWGYsb0NBQUFBLGdCQUFBQSxZQUFhLENBQUMsRUFBRSxjQUFoQkEscUNBQUFBLHlCQUFBQSxjQUFrQmdCLFFBQVEsY0FBMUJoQiw2Q0FBQUEsdUJBQTRCaUIsV0FBVyxHQUFFLE9BQU9uQjtRQUMzRSw2REFBNkQ7UUFDN0QsT0FBT0UsS0FBS2UsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDQyxXQUFXLENBQUNYLEdBQUcsQ0FDNUMsQ0FBQ1ksSUFBd0I7Z0JBQUNBLENBQUMsQ0FBQyxFQUFFO2dCQUFFQSxDQUFDLENBQUMsRUFBRTthQUFDO0lBRXpDLEVBQUUsVUFBTTtRQUNOLE9BQU9wQjtJQUNUO0FBQ0Y7QUFFZSxTQUFTcUIsZ0JBQWdCLEtBT2pCO1FBUGlCLEVBQ3RDQyxPQUFPLEVBQ1BDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLGNBQWMsRUFDZEMsU0FBUyxPQUFPLEVBQ0ssR0FQaUI7O0lBUXRDLE1BQU1DLFNBQVNwRCw2Q0FBTUEsQ0FBaUI7SUFDdEMsTUFBTXFELGlCQUFpQnJELDZDQUFNQSxDQUFlO0lBQzVDLE1BQU1zRCxpQkFBaUJ0RCw2Q0FBTUEsQ0FBc0I7SUFDbkQsTUFBTXVELGdCQUFnQnZELDZDQUFNQSxDQUFzQjtJQUNsRCxNQUFNd0QsaUJBQWlCeEQsNkNBQU1BLENBQWtCO0lBQy9DLE1BQU15RCxlQUFlekQsNkNBQU1BLENBQWtCO0lBQzdDLE1BQU0wRCxlQUFlMUQsNkNBQU1BLENBQWdCO0lBQzNDLE1BQU0yRCxjQUFjM0QsNkNBQU1BLENBQUNrRDtJQUUzQnBELGdEQUFTQSxDQUFDO1FBQ1I2RCxZQUFZQyxPQUFPLEdBQUdWO0lBQ3hCLEdBQUc7UUFBQ0E7S0FBZTtJQUVuQixNQUFNVyxTQUFTOUQsOENBQU9BLENBQUM7UUFDckIsSUFBSSxDQUFDK0MsUUFBUXJCLE1BQU0sRUFBRSxPQUFPO1FBQzVCLE1BQU1xQyxVQUFVaEIsUUFBUWQsR0FBRyxDQUFDLENBQUMrQixJQUFNOUQscURBQVEsQ0FBQzhELEVBQUVwRCxHQUFHLEVBQUVvRCxFQUFFbEQsR0FBRztRQUN4RCxPQUFPWiwyREFBYyxDQUFDNkQsU0FBU0ksR0FBRyxDQUFDO0lBQ3JDLEdBQUc7UUFBQ3BCO0tBQVE7SUFFWmhELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDc0QsT0FBT1EsT0FBTyxJQUFJUCxlQUFlTyxPQUFPLEVBQUU7UUFDL0MsSUFBSSxDQUFDZCxRQUFRckIsTUFBTSxJQUFJLENBQUNvQyxRQUFRO1FBRWhDLE1BQU03QixNQUFNL0Isa0RBQUssQ0FBQ21ELE9BQU9RLE9BQU8sRUFBRTtZQUNoQ08sUUFBUU4sT0FBT08sU0FBUztZQUN4QkMsTUFBTTtZQUNOQyxhQUFhO1lBQ2JDLGlCQUFpQjtZQUNqQkMsV0FBVztZQUNYQyxpQkFBaUI7WUFDakJDLFNBQVM7WUFDVEMsVUFBVTtZQUNWQyxjQUFjO1lBQ2RDLFNBQVM7WUFDVEMsU0FBUztZQUNUQyxXQUFXbEI7WUFDWG1CLG9CQUFvQjtRQUN0QjtRQUVBL0Usd0RBQVcsQ0FBQyxpRUFBaUU7WUFDM0VpRixhQUFhO1lBQ2JKLFNBQVM7UUFDWCxHQUFHSyxLQUFLLENBQUNuRDtRQUVUQSxJQUFJb0QsT0FBTyxDQUFDdkIsT0FBT08sU0FBUyxJQUFJLElBQUk7WUFBRWlCLFNBQVM7UUFBTTtRQUVyRCxNQUFNQyxjQUFjckYseURBQVk7UUFDaEM2QyxRQUFRMEMsT0FBTyxDQUFDLENBQUN6QjtZQUNmOUQsMkRBQWMsQ0FBQztnQkFBQzhELEVBQUVwRCxHQUFHO2dCQUFFb0QsRUFBRWxELEdBQUc7YUFBQyxFQUFFO2dCQUM3QjZFLFFBQVE7Z0JBQ1JDLFdBQVc7Z0JBQ1hDLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JDLGFBQWE7WUFDZixHQUNHQyxXQUFXLENBQUMsVUFBZSxPQUFMaEMsRUFBRWlDLEVBQUUsR0FBSTtnQkFBRUMsV0FBVztZQUFNLEdBQ2pEZCxLQUFLLENBQUNHO1FBQ1g7UUFDQUEsWUFBWUgsS0FBSyxDQUFDbkQ7UUFDbEJzQixlQUFlTSxPQUFPLEdBQUcwQjtRQUV6QnRELElBQUlrRSxFQUFFLENBQUMsU0FBUyxDQUFDQztZQUNmLElBQUksQ0FBQ3JELFFBQVFyQixNQUFNLEVBQUU7WUFDckIsTUFBTTJFLFFBQVFuRyxxREFBUSxDQUFDa0csRUFBRUUsTUFBTSxDQUFDMUYsR0FBRyxFQUFFd0YsRUFBRUUsTUFBTSxDQUFDeEYsR0FBRztZQUNqRCxJQUFJeUYsT0FBc0I7WUFDMUIsSUFBSUMsYUFBYUMsT0FBT0MsaUJBQWlCO1lBQ3pDLEtBQUssTUFBTTFDLEtBQUtqQixRQUFTO2dCQUN2QixNQUFNNEQsSUFBSXhHLGdCQUFnQmtHLE9BQU9uRyxxREFBUSxDQUFDOEQsRUFBRXBELEdBQUcsRUFBRW9ELEVBQUVsRCxHQUFHO2dCQUN0RCxJQUFJNkYsSUFBSUgsWUFBWTtvQkFDbEJBLGFBQWFHO29CQUNiSixPQUFPdkM7Z0JBQ1Q7WUFDRjtZQUNBLElBQUksQ0FBQ3VDLFFBQVFDLGFBQWEsTUFBTTtZQUNoQzVDLFlBQVlDLE9BQU8sQ0FBQzBDO1FBQ3RCO1FBRUFqRCxlQUFlTyxPQUFPLEdBQUc1QjtRQUN6QixPQUFPO1lBQ0wsSUFBSTBCLGFBQWFFLE9BQU8sRUFBRStDLHFCQUFxQmpELGFBQWFFLE9BQU87WUFDbkU1QixJQUFJNEUsTUFBTTtZQUNWdkQsZUFBZU8sT0FBTyxHQUFHO1FBQzNCO0lBQ0YsR0FBRztRQUFDZDtRQUFTZTtLQUFPO0lBRXBCL0QsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0MsTUFBTXFCLGVBQWVPLE9BQU87UUFDbEMsSUFBSSxDQUFDNUIsS0FBSztRQUVWLElBQUl3QixlQUFlSSxPQUFPLEVBQUVKLGVBQWVJLE9BQU8sQ0FBQ2dELE1BQU07UUFDekQsSUFBSW5ELGFBQWFHLE9BQU8sRUFBRUgsYUFBYUcsT0FBTyxDQUFDZ0QsTUFBTTtRQUVyRCxJQUFJN0QsYUFBYTtZQUNmLE1BQU04RCxPQUFPNUcsc0RBQVMsQ0FBQztnQkFDckI4RyxXQUFXO2dCQUNYQyxNQUFNO2dCQUNOQyxVQUFVO29CQUFDO29CQUFJO2lCQUFHO2dCQUNsQkMsWUFBWTtvQkFBQztvQkFBSTtpQkFBRztZQUN0QjtZQUNBLE1BQU1DLFNBQVNsSCxxREFBUSxDQUFDO2dCQUFDOEMsWUFBWXBDLEdBQUc7Z0JBQUVvQyxZQUFZbEMsR0FBRzthQUFDLEVBQUU7Z0JBQUVnRztZQUFLLEdBQUcxQixLQUFLLENBQUNuRDtZQUM1RW1GLE9BQU9wQixXQUFXLENBQUMsU0FBUztnQkFBRUUsV0FBVztZQUFNO1lBQy9DekMsZUFBZUksT0FBTyxHQUFHdUQ7UUFDM0I7UUFFQSxJQUFJbkUsV0FBVztZQUNiLE1BQU02RCxPQUFPNUcsc0RBQVMsQ0FBQztnQkFDckI4RyxXQUFXO2dCQUNYQyxNQUFNO2dCQUNOQyxVQUFVO29CQUFDO29CQUFJO2lCQUFHO2dCQUNsQkMsWUFBWTtvQkFBQztvQkFBSTtpQkFBRztZQUN0QjtZQUNBLE1BQU1DLFNBQVNsSCxxREFBUSxDQUFDO2dCQUFDK0MsVUFBVXJDLEdBQUc7Z0JBQUVxQyxVQUFVbkMsR0FBRzthQUFDLEVBQUU7Z0JBQUVnRztZQUFLLEdBQUcxQixLQUFLLENBQUNuRDtZQUN4RW1GLE9BQU9wQixXQUFXLENBQUMsT0FBTztnQkFBRUUsV0FBVztZQUFNO1lBQzdDeEMsYUFBYUcsT0FBTyxHQUFHdUQ7UUFDekI7SUFDRixHQUFHO1FBQUNwRTtRQUFhQztLQUFVO0lBRTNCbEQsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0MsTUFBTXFCLGVBQWVPLE9BQU87UUFDbEMsSUFBSSxDQUFDNUIsS0FBSztRQUVWLElBQUl1QixjQUFjSyxPQUFPLEVBQUVMLGNBQWNLLE9BQU8sQ0FBQ2dELE1BQU07UUFDdkQsSUFBSWxELGFBQWFFLE9BQU8sRUFBRStDLHFCQUFxQmpELGFBQWFFLE9BQU87UUFFbkUsSUFBSSxDQUFDWCxhQUFheEIsTUFBTSxFQUFFO1FBRTFCLElBQUkyRixZQUFZO1FBRWhCN0Ysa0JBQWtCMEIsY0FBY29FLElBQUksQ0FBQyxDQUFDQztZQUNwQyxJQUFJRixhQUFhLENBQUMvRCxlQUFlTyxPQUFPLEVBQUU7WUFFMUMsTUFBTTJELGFBQWF0SCx5REFBWSxHQUFHa0YsS0FBSyxDQUFDbkQ7WUFFeEMsNEJBQTRCLEdBQzVCL0IsdURBQVUsQ0FBQ3FILFNBQVM7Z0JBQ2xCMUIsT0FBTztnQkFDUEMsUUFBUTtnQkFDUjRCLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWCxHQUFHdkMsS0FBSyxDQUFDb0M7WUFFVCxtQ0FBbUMsR0FDbkMsTUFBTUksYUFBYTFILHVEQUFVLENBQUNxSCxTQUFTO2dCQUNyQzFCLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1I0QixTQUFTO2dCQUNURyxXQUFXO2dCQUNYRixTQUFTO1lBQ1gsR0FBR3ZDLEtBQUssQ0FBQ29DO1lBRVQsK0NBQStDLEdBQy9DLE1BQU1NLGFBQWE1SCx1REFBVSxDQUFDcUgsU0FBUztnQkFDckMxQixPQUFPO2dCQUNQQyxRQUFRO2dCQUNSNEIsU0FBUztnQkFDVEcsV0FBVztnQkFDWEYsU0FBUztZQUNYLEdBQUd2QyxLQUFLLENBQUNvQztZQUVUaEUsY0FBY0ssT0FBTyxHQUFHMkQ7WUFFeEIsSUFBSU8sVUFBVTtZQUNkLElBQUlDLFVBQVU7WUFFZCxNQUFNbkcsT0FBTztnQkFDWGtHLFVBQVUsQ0FBQ0EsVUFBVSxFQUFDLElBQUs7Z0JBQzNCQyxVQUFVLENBQUNBLFVBQVUsRUFBQyxJQUFLO2dCQUMzQkosV0FBV0ssUUFBUSxDQUFDO29CQUFFQyxZQUFZLEdBQVcsT0FBUkg7Z0JBQVU7Z0JBQy9DRCxXQUFXRyxRQUFRLENBQUM7b0JBQUVDLFlBQVksR0FBVyxPQUFSRjtnQkFBVTtnQkFDL0NyRSxhQUFhRSxPQUFPLEdBQUdzRSxzQkFBc0J0RztZQUMvQztZQUVBOEIsYUFBYUUsT0FBTyxHQUFHc0Usc0JBQXNCdEc7UUFDL0M7UUFFQSxPQUFPO1lBQVF3RixZQUFZO1FBQU07SUFDbkMsR0FBRztRQUFDbkU7S0FBYTtJQUVqQixxQkFBTyw4REFBQ2tGO1FBQUlDLEtBQUtoRjtRQUFRaUYsT0FBTztZQUFFbEY7WUFBUW1GLE9BQU87WUFBUUMsY0FBYztRQUFnQjs7Ozs7O0FBQ3pGO0dBM0x3QjFGO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3JvdXRlLXBsYW5uZXItbWFwLnRzeD85NWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IEwgZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0IFwibGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzXCI7XHJcblxyXG5pbnRlcmZhY2UgU2Vuc29yIHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHNlbnNvcl9pZD86IHN0cmluZztcclxuICBsYXQ6IG51bWJlcjtcclxuICBsbmc6IG51bWJlcjtcclxuICBhdmdfc3BlZWQ6IG51bWJlcjtcclxuICBjb25nZXN0aW9uOiBudW1iZXI7XHJcbiAgY29sb3I6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFJvdXRlUGxhbm5lck1hcFByb3BzIHtcclxuICBzZW5zb3JzOiBTZW5zb3JbXTtcclxuICBzdGFydFNlbnNvcjogU2Vuc29yIHwgbnVsbDtcclxuICBlbmRTZW5zb3I6IFNlbnNvciB8IG51bGw7XHJcbiAgcm91dGVMYXRMbmdzOiBbbnVtYmVyLCBudW1iZXJdW107XHJcbiAgb25TZWxlY3RTZW5zb3I6IChzZW5zb3I6IFNlbnNvcikgPT4gdm9pZDtcclxuICBoZWlnaHQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhdmVyc2luZU1ldGVycyhhOiBMLkxhdExuZywgYjogTC5MYXRMbmcpOiBudW1iZXIge1xyXG4gIGNvbnN0IFIgPSA2MzcxMDAwO1xyXG4gIGNvbnN0IHRvUmFkID0gKHY6IG51bWJlcikgPT4gKHYgKiBNYXRoLlBJKSAvIDE4MDtcclxuICBjb25zdCBkTGF0ID0gdG9SYWQoYi5sYXQgLSBhLmxhdCk7XHJcbiAgY29uc3QgZExuZyA9IHRvUmFkKGIubG5nIC0gYS5sbmcpO1xyXG4gIGNvbnN0IGxhdDEgPSB0b1JhZChhLmxhdCk7XHJcbiAgY29uc3QgbGF0MiA9IHRvUmFkKGIubGF0KTtcclxuICBjb25zdCBzaW5MYXQgPSBNYXRoLnNpbihkTGF0IC8gMik7XHJcbiAgY29uc3Qgc2luTG5nID0gTWF0aC5zaW4oZExuZyAvIDIpO1xyXG4gIGNvbnN0IGggPSBzaW5MYXQgKiBzaW5MYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luTG5nICogc2luTG5nO1xyXG4gIHJldHVybiAyICogUiAqIE1hdGguYXNpbihNYXRoLnNxcnQoaCkpO1xyXG59XHJcblxyXG4vKipcclxuICogU25hcCByb3V0ZSB0byByZWFsIHJvYWRzIHZpYSBPU1JNIChmcmVlLCBubyBBUEkga2V5KS5cclxuICogT25seSBzZW5kcyBzdGFydCwgZW5kLCBhbmQgdXAgdG8gMyBldmVubHktc3BhY2VkIGd1aWRlIHBvaW50c1xyXG4gKiB0byBhdm9pZCBvdmVyLWNvbnN0cmFpbmluZyB0aGUgcm91dGUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFJvYWRHZW9tZXRyeShcclxuICBwdHM6IFtudW1iZXIsIG51bWJlcl1bXVxyXG4pOiBQcm9taXNlPFtudW1iZXIsIG51bWJlcl1bXT4ge1xyXG4gIGlmIChwdHMubGVuZ3RoIDwgMikgcmV0dXJuIHB0cztcclxuICB0cnkge1xyXG4gICAgLy8gUGljayBzdGFydCwgZW5kLCBhbmQgdXAgdG8gMyBndWlkZSB3YXlwb2ludHMgaW4gYmV0d2VlblxyXG4gICAgY29uc3Qga2V5OiBbbnVtYmVyLCBudW1iZXJdW10gPSBbcHRzWzBdXTtcclxuICAgIGlmIChwdHMubGVuZ3RoID4gNikge1xyXG4gICAgICBjb25zdCBzdGVwID0gKHB0cy5sZW5ndGggLSAxKSAvIDQ7XHJcbiAgICAgIGtleS5wdXNoKHB0c1tNYXRoLnJvdW5kKHN0ZXApXSk7XHJcbiAgICAgIGtleS5wdXNoKHB0c1tNYXRoLnJvdW5kKHN0ZXAgKiAyKV0pO1xyXG4gICAgICBrZXkucHVzaChwdHNbTWF0aC5yb3VuZChzdGVwICogMyldKTtcclxuICAgIH0gZWxzZSBpZiAocHRzLmxlbmd0aCA+IDMpIHtcclxuICAgICAga2V5LnB1c2gocHRzW01hdGgucm91bmQoKHB0cy5sZW5ndGggLSAxKSAvIDIpXSk7XHJcbiAgICB9XHJcbiAgICBrZXkucHVzaChwdHNbcHRzLmxlbmd0aCAtIDFdKTtcclxuXHJcbiAgICAvLyBPU1JNIGV4cGVjdHMgbG5nLGxhdCBvcmRlclxyXG4gICAgY29uc3QgY29vcmRzID0ga2V5Lm1hcCgocCkgPT4gYCR7cFsxXX0sJHtwWzBdfWApLmpvaW4oXCI7XCIpO1xyXG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vcm91dGVyLnByb2plY3Qtb3NybS5vcmcvcm91dGUvdjEvZHJpdmluZy8ke2Nvb3Jkc30/b3ZlcnZpZXc9ZnVsbCZnZW9tZXRyaWVzPWdlb2pzb25gO1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIGlmICghcmVzLm9rKSByZXR1cm4gcHRzO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICBpZiAoZGF0YS5jb2RlICE9PSBcIk9rXCIgfHwgIWRhdGEucm91dGVzPy5bMF0/Lmdlb21ldHJ5Py5jb29yZGluYXRlcykgcmV0dXJuIHB0cztcclxuICAgIC8vIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJlIFtsbmcsIGxhdF0g4oaSIGNvbnZlcnQgdG8gW2xhdCwgbG5nXVxyXG4gICAgcmV0dXJuIGRhdGEucm91dGVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcChcclxuICAgICAgKGM6IFtudW1iZXIsIG51bWJlcl0pID0+IFtjWzFdLCBjWzBdXSBhcyBbbnVtYmVyLCBudW1iZXJdXHJcbiAgICApO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIHB0cztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJvdXRlUGxhbm5lck1hcCh7XHJcbiAgc2Vuc29ycyxcclxuICBzdGFydFNlbnNvcixcclxuICBlbmRTZW5zb3IsXHJcbiAgcm91dGVMYXRMbmdzLFxyXG4gIG9uU2VsZWN0U2Vuc29yLFxyXG4gIGhlaWdodCA9IFwiNTYwcHhcIixcclxufTogUm91dGVQbGFubmVyTWFwUHJvcHMpIHtcclxuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IG1hcEluc3RhbmNlUmVmID0gdXNlUmVmPEwuTWFwIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3Qgc2Vuc29yTGF5ZXJSZWYgPSB1c2VSZWY8TC5MYXllckdyb3VwIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3Qgcm91dGVMYXllclJlZiA9IHVzZVJlZjxMLkxheWVyR3JvdXAgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBzdGFydE1hcmtlclJlZiA9IHVzZVJlZjxMLk1hcmtlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGVuZE1hcmtlclJlZiA9IHVzZVJlZjxMLk1hcmtlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBvblNlbGVjdFJlZiA9IHVzZVJlZihvblNlbGVjdFNlbnNvcik7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBvblNlbGVjdFJlZi5jdXJyZW50ID0gb25TZWxlY3RTZW5zb3I7XHJcbiAgfSwgW29uU2VsZWN0U2Vuc29yXSk7XHJcblxyXG4gIGNvbnN0IGJvdW5kcyA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgaWYgKCFzZW5zb3JzLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBsYXRMbmdzID0gc2Vuc29ycy5tYXAoKHMpID0+IEwubGF0TG5nKHMubGF0LCBzLmxuZykpO1xyXG4gICAgcmV0dXJuIEwubGF0TG5nQm91bmRzKGxhdExuZ3MpLnBhZCgwLjIpO1xyXG4gIH0sIFtzZW5zb3JzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGlmICghc2Vuc29ycy5sZW5ndGggfHwgIWJvdW5kcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IG1hcCA9IEwubWFwKG1hcFJlZi5jdXJyZW50LCB7XHJcbiAgICAgIGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG4gICAgICB6b29tOiAxMixcclxuICAgICAgem9vbUNvbnRyb2w6IGZhbHNlLFxyXG4gICAgICBzY3JvbGxXaGVlbFpvb206IGZhbHNlLFxyXG4gICAgICB0b3VjaFpvb206IGZhbHNlLFxyXG4gICAgICBkb3VibGVDbGlja1pvb206IGZhbHNlLFxyXG4gICAgICBib3hab29tOiBmYWxzZSxcclxuICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxyXG4gICAgICBwcmVmZXJDYW52YXM6IGZhbHNlLFxyXG4gICAgICBtaW5ab29tOiAxMixcclxuICAgICAgbWF4Wm9vbTogMTIsXHJcbiAgICAgIG1heEJvdW5kczogYm91bmRzLFxyXG4gICAgICBtYXhCb3VuZHNWaXNjb3NpdHk6IDEuMCxcclxuICAgIH0pO1xyXG5cclxuICAgIEwudGlsZUxheWVyKFwiaHR0cHM6Ly97c30uYmFzZW1hcHMuY2FydG9jZG4uY29tL2RhcmtfYWxsL3t6fS97eH0ve3l9e3J9LnBuZ1wiLCB7XHJcbiAgICAgIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL2NhcnRvLmNvbS9cIj5DQVJUTzwvYT4nLFxyXG4gICAgICBtYXhab29tOiAxOSxcclxuICAgIH0pLmFkZFRvKG1hcCk7XHJcblxyXG4gICAgbWFwLnNldFZpZXcoYm91bmRzLmdldENlbnRlcigpLCAxMiwgeyBhbmltYXRlOiBmYWxzZSB9KTtcclxuXHJcbiAgICBjb25zdCBzZW5zb3JMYXllciA9IEwubGF5ZXJHcm91cCgpO1xyXG4gICAgc2Vuc29ycy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIEwuY2lyY2xlTWFya2VyKFtzLmxhdCwgcy5sbmddLCB7XHJcbiAgICAgICAgcmFkaXVzOiAzLFxyXG4gICAgICAgIGZpbGxDb2xvcjogXCIjOTRhM2I4XCIsXHJcbiAgICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjIpXCIsXHJcbiAgICAgICAgd2VpZ2h0OiAxLFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjcsXHJcbiAgICAgIH0pXHJcbiAgICAgICAgLmJpbmRUb29sdGlwKGBTZW5zb3IgJHtzLmlkfWAsIHsgZGlyZWN0aW9uOiBcInRvcFwiIH0pXHJcbiAgICAgICAgLmFkZFRvKHNlbnNvckxheWVyKTtcclxuICAgIH0pO1xyXG4gICAgc2Vuc29yTGF5ZXIuYWRkVG8obWFwKTtcclxuICAgIHNlbnNvckxheWVyUmVmLmN1cnJlbnQgPSBzZW5zb3JMYXllcjtcclxuXHJcbiAgICBtYXAub24oXCJjbGlja1wiLCAoZSkgPT4ge1xyXG4gICAgICBpZiAoIXNlbnNvcnMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgIGNvbnN0IGNsaWNrID0gTC5sYXRMbmcoZS5sYXRsbmcubGF0LCBlLmxhdGxuZy5sbmcpO1xyXG4gICAgICBsZXQgYmVzdDogU2Vuc29yIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIGxldCBiZXN0TWV0ZXJzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICBmb3IgKGNvbnN0IHMgb2Ygc2Vuc29ycykge1xyXG4gICAgICAgIGNvbnN0IGQgPSBoYXZlcnNpbmVNZXRlcnMoY2xpY2ssIEwubGF0TG5nKHMubGF0LCBzLmxuZykpO1xyXG4gICAgICAgIGlmIChkIDwgYmVzdE1ldGVycykge1xyXG4gICAgICAgICAgYmVzdE1ldGVycyA9IGQ7XHJcbiAgICAgICAgICBiZXN0ID0gcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFiZXN0IHx8IGJlc3RNZXRlcnMgPiAxNTAwKSByZXR1cm47XHJcbiAgICAgIG9uU2VsZWN0UmVmLmN1cnJlbnQoYmVzdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtYXBJbnN0YW5jZVJlZi5jdXJyZW50ID0gbWFwO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50KSBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XHJcbiAgICAgIG1hcC5yZW1vdmUoKTtcclxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH0sIFtzZW5zb3JzLCBib3VuZHNdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IG1hcCA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChzdGFydE1hcmtlclJlZi5jdXJyZW50KSBzdGFydE1hcmtlclJlZi5jdXJyZW50LnJlbW92ZSgpO1xyXG4gICAgaWYgKGVuZE1hcmtlclJlZi5jdXJyZW50KSBlbmRNYXJrZXJSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuXHJcbiAgICBpZiAoc3RhcnRTZW5zb3IpIHtcclxuICAgICAgY29uc3QgaWNvbiA9IEwuZGl2SWNvbih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJvdXRlLW1hcmtlciByb3V0ZS1tYXJrZXItLXN0YXJ0XCIsXHJcbiAgICAgICAgaHRtbDogXCJTXCIsXHJcbiAgICAgICAgaWNvblNpemU6IFsyNiwgMjZdLFxyXG4gICAgICAgIGljb25BbmNob3I6IFsxMywgMTNdLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgbWFya2VyID0gTC5tYXJrZXIoW3N0YXJ0U2Vuc29yLmxhdCwgc3RhcnRTZW5zb3IubG5nXSwgeyBpY29uIH0pLmFkZFRvKG1hcCk7XHJcbiAgICAgIG1hcmtlci5iaW5kVG9vbHRpcChcIlN0YXJ0XCIsIHsgZGlyZWN0aW9uOiBcInRvcFwiIH0pO1xyXG4gICAgICBzdGFydE1hcmtlclJlZi5jdXJyZW50ID0gbWFya2VyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmRTZW5zb3IpIHtcclxuICAgICAgY29uc3QgaWNvbiA9IEwuZGl2SWNvbih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJvdXRlLW1hcmtlciByb3V0ZS1tYXJrZXItLWVuZFwiLFxyXG4gICAgICAgIGh0bWw6IFwiRVwiLFxyXG4gICAgICAgIGljb25TaXplOiBbMjYsIDI2XSxcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTMsIDEzXSxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IG1hcmtlciA9IEwubWFya2VyKFtlbmRTZW5zb3IubGF0LCBlbmRTZW5zb3IubG5nXSwgeyBpY29uIH0pLmFkZFRvKG1hcCk7XHJcbiAgICAgIG1hcmtlci5iaW5kVG9vbHRpcChcIkVuZFwiLCB7IGRpcmVjdGlvbjogXCJ0b3BcIiB9KTtcclxuICAgICAgZW5kTWFya2VyUmVmLmN1cnJlbnQgPSBtYXJrZXI7XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0U2Vuc29yLCBlbmRTZW5zb3JdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IG1hcCA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChyb3V0ZUxheWVyUmVmLmN1cnJlbnQpIHJvdXRlTGF5ZXJSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGlmICghcm91dGVMYXRMbmdzLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcclxuXHJcbiAgICBmZXRjaFJvYWRHZW9tZXRyeShyb3V0ZUxhdExuZ3MpLnRoZW4oKHJvYWRQdHMpID0+IHtcclxuICAgICAgaWYgKGNhbmNlbGxlZCB8fCAhbWFwSW5zdGFuY2VSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3Qgcm91dGVMYXllciA9IEwubGF5ZXJHcm91cCgpLmFkZFRvKG1hcCk7XHJcblxyXG4gICAgICAvKiBsYXllciAxIOKAkyBzb2Z0IGdsb3cgYmFzZSAqL1xyXG4gICAgICBMLnBvbHlsaW5lKHJvYWRQdHMsIHtcclxuICAgICAgICBjb2xvcjogXCIjMzhiZGY4XCIsXHJcbiAgICAgICAgd2VpZ2h0OiA3LFxyXG4gICAgICAgIG9wYWNpdHk6IDAuMTgsXHJcbiAgICAgICAgbGluZUNhcDogXCJyb3VuZFwiLFxyXG4gICAgICB9KS5hZGRUbyhyb3V0ZUxheWVyKTtcclxuXHJcbiAgICAgIC8qIGxheWVyIDIg4oCTIGZhc3QgZXNjYWxhdG9yIGRhc2hlcyAqL1xyXG4gICAgICBjb25zdCBlc2NhbGF0b3IxID0gTC5wb2x5bGluZShyb2FkUHRzLCB7XHJcbiAgICAgICAgY29sb3I6IFwiIzM4YmRmOFwiLFxyXG4gICAgICAgIHdlaWdodDogMyxcclxuICAgICAgICBvcGFjaXR5OiAwLjksXHJcbiAgICAgICAgZGFzaEFycmF5OiBcIjYgMTRcIixcclxuICAgICAgICBsaW5lQ2FwOiBcImJ1dHRcIixcclxuICAgICAgfSkuYWRkVG8ocm91dGVMYXllcik7XHJcblxyXG4gICAgICAvKiBsYXllciAzIOKAkyBvZmZzZXQgY291bnRlci1kYXNoZXMgZm9yIGRlbnNpdHkgKi9cclxuICAgICAgY29uc3QgZXNjYWxhdG9yMiA9IEwucG9seWxpbmUocm9hZFB0cywge1xyXG4gICAgICAgIGNvbG9yOiBcIiM2MGE1ZmFcIixcclxuICAgICAgICB3ZWlnaHQ6IDIsXHJcbiAgICAgICAgb3BhY2l0eTogMC41NSxcclxuICAgICAgICBkYXNoQXJyYXk6IFwiNCAxOFwiLFxyXG4gICAgICAgIGxpbmVDYXA6IFwiYnV0dFwiLFxyXG4gICAgICB9KS5hZGRUbyhyb3V0ZUxheWVyKTtcclxuXHJcbiAgICAgIHJvdXRlTGF5ZXJSZWYuY3VycmVudCA9IHJvdXRlTGF5ZXI7XHJcblxyXG4gICAgICBsZXQgb2Zmc2V0MSA9IDA7XHJcbiAgICAgIGxldCBvZmZzZXQyID0gMDtcclxuXHJcbiAgICAgIGNvbnN0IHN0ZXAgPSAoKSA9PiB7XHJcbiAgICAgICAgb2Zmc2V0MSA9IChvZmZzZXQxIC0gMTYpICUgMjAwMDtcclxuICAgICAgICBvZmZzZXQyID0gKG9mZnNldDIgKyAxMikgJSAyMDAwO1xyXG4gICAgICAgIGVzY2FsYXRvcjEuc2V0U3R5bGUoeyBkYXNoT2Zmc2V0OiBgJHtvZmZzZXQxfWAgfSk7XHJcbiAgICAgICAgZXNjYWxhdG9yMi5zZXRTdHlsZSh7IGRhc2hPZmZzZXQ6IGAke29mZnNldDJ9YCB9KTtcclxuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHsgY2FuY2VsbGVkID0gdHJ1ZTsgfTtcclxuICB9LCBbcm91dGVMYXRMbmdzXSk7XHJcblxyXG4gIHJldHVybiA8ZGl2IHJlZj17bWFwUmVmfSBzdHlsZT17eyBoZWlnaHQsIHdpZHRoOiBcIjEwMCVcIiwgYm9yZGVyUmFkaXVzOiBcInZhcigtLXJhZGl1cylcIiB9fSAvPjtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsIkwiLCJoYXZlcnNpbmVNZXRlcnMiLCJhIiwiYiIsIlIiLCJ0b1JhZCIsInYiLCJNYXRoIiwiUEkiLCJkTGF0IiwibGF0IiwiZExuZyIsImxuZyIsImxhdDEiLCJsYXQyIiwic2luTGF0Iiwic2luIiwic2luTG5nIiwiaCIsImNvcyIsImFzaW4iLCJzcXJ0IiwiZmV0Y2hSb2FkR2VvbWV0cnkiLCJwdHMiLCJsZW5ndGgiLCJkYXRhIiwia2V5Iiwic3RlcCIsInB1c2giLCJyb3VuZCIsImNvb3JkcyIsIm1hcCIsInAiLCJqb2luIiwidXJsIiwicmVzIiwiZmV0Y2giLCJvayIsImpzb24iLCJjb2RlIiwicm91dGVzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImMiLCJSb3V0ZVBsYW5uZXJNYXAiLCJzZW5zb3JzIiwic3RhcnRTZW5zb3IiLCJlbmRTZW5zb3IiLCJyb3V0ZUxhdExuZ3MiLCJvblNlbGVjdFNlbnNvciIsImhlaWdodCIsIm1hcFJlZiIsIm1hcEluc3RhbmNlUmVmIiwic2Vuc29yTGF5ZXJSZWYiLCJyb3V0ZUxheWVyUmVmIiwic3RhcnRNYXJrZXJSZWYiLCJlbmRNYXJrZXJSZWYiLCJhbmltYXRpb25SZWYiLCJvblNlbGVjdFJlZiIsImN1cnJlbnQiLCJib3VuZHMiLCJsYXRMbmdzIiwicyIsImxhdExuZyIsImxhdExuZ0JvdW5kcyIsInBhZCIsImNlbnRlciIsImdldENlbnRlciIsInpvb20iLCJ6b29tQ29udHJvbCIsInNjcm9sbFdoZWVsWm9vbSIsInRvdWNoWm9vbSIsImRvdWJsZUNsaWNrWm9vbSIsImJveFpvb20iLCJrZXlib2FyZCIsInByZWZlckNhbnZhcyIsIm1pblpvb20iLCJtYXhab29tIiwibWF4Qm91bmRzIiwibWF4Qm91bmRzVmlzY29zaXR5IiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJhZGRUbyIsInNldFZpZXciLCJhbmltYXRlIiwic2Vuc29yTGF5ZXIiLCJsYXllckdyb3VwIiwiZm9yRWFjaCIsImNpcmNsZU1hcmtlciIsInJhZGl1cyIsImZpbGxDb2xvciIsImNvbG9yIiwid2VpZ2h0IiwiZmlsbE9wYWNpdHkiLCJiaW5kVG9vbHRpcCIsImlkIiwiZGlyZWN0aW9uIiwib24iLCJlIiwiY2xpY2siLCJsYXRsbmciLCJiZXN0IiwiYmVzdE1ldGVycyIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlIiwiaWNvbiIsImRpdkljb24iLCJjbGFzc05hbWUiLCJodG1sIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwibWFya2VyIiwiY2FuY2VsbGVkIiwidGhlbiIsInJvYWRQdHMiLCJyb3V0ZUxheWVyIiwicG9seWxpbmUiLCJvcGFjaXR5IiwibGluZUNhcCIsImVzY2FsYXRvcjEiLCJkYXNoQXJyYXkiLCJlc2NhbGF0b3IyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJzZXRTdHlsZSIsImRhc2hPZmZzZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiYm9yZGVyUmFkaXVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/route-planner-map.tsx\n"));

/***/ })

});