"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_route-planner-map_tsx",{

/***/ "(app-pages-browser)/./src/components/route-planner-map.tsx":
/*!**********************************************!*\
  !*** ./src/components/route-planner-map.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RoutePlannerMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction haversineMeters(a, b) {\n    const R = 6371000;\n    const toRad = (v)=>v * Math.PI / 180;\n    const dLat = toRad(b.lat - a.lat);\n    const dLng = toRad(b.lng - a.lng);\n    const lat1 = toRad(a.lat);\n    const lat2 = toRad(b.lat);\n    const sinLat = Math.sin(dLat / 2);\n    const sinLng = Math.sin(dLng / 2);\n    const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;\n    return 2 * R * Math.asin(Math.sqrt(h));\n}\n/**\r\n * Snap route to real roads via OSRM (free, no API key).\r\n * Fetches road geometry for each consecutive sensor pair,\r\n * then stitches all segments together. This ensures the route\r\n * follows the sensor graph order while staying on actual roads.\r\n */ async function fetchRoadGeometry(pts) {\n    if (pts.length < 2) return pts;\n    // Build pairwise OSRM requests for each consecutive sensor pair\n    const pairPromises = [];\n    for(let i = 0; i < pts.length - 1; i++){\n        const a = pts[i];\n        const b = pts[i + 1];\n        pairPromises.push(fetch(\"https://router.project-osrm.org/route/v1/driving/\".concat(a[1], \",\").concat(a[0], \";\").concat(b[1], \",\").concat(b[0], \"?overview=full&geometries=geojson\")).then((r)=>r.ok ? r.json() : null).then((data)=>{\n            var _data_routes__geometry, _data_routes_, _data_routes;\n            if ((data === null || data === void 0 ? void 0 : data.code) === \"Ok\" && ((_data_routes = data.routes) === null || _data_routes === void 0 ? void 0 : (_data_routes_ = _data_routes[0]) === null || _data_routes_ === void 0 ? void 0 : (_data_routes__geometry = _data_routes_.geometry) === null || _data_routes__geometry === void 0 ? void 0 : _data_routes__geometry.coordinates)) {\n                return data.routes[0].geometry.coordinates.map((c)=>[\n                        c[1],\n                        c[0]\n                    ]);\n            }\n            return [\n                a,\n                b\n            ]; // fallback to straight line\n        }).catch(()=>[\n                a,\n                b\n            ]));\n    }\n    const segments = await Promise.all(pairPromises);\n    // Stitch segments, skipping duplicate junction points\n    const result = [];\n    for (const seg of segments){\n        const start = result.length ? 1 : 0; // skip first point of subsequent segments (duplicate)\n        for(let i = start; i < seg.length; i++){\n            result.push(seg[i]);\n        }\n    }\n    return result;\n}\nfunction RoutePlannerMap(param) {\n    let { sensors, startSensor, endSensor, routeLatLngs, onSelectSensor, height = \"560px\" } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sensorLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const endMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const onSelectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(onSelectSensor);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        onSelectRef.current = onSelectSensor;\n    }, [\n        onSelectSensor\n    ]);\n    const bounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!sensors.length) return null;\n        const latLngs = sensors.map((s)=>leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n        return leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLngBounds(latLngs).pad(0.2);\n    }, [\n        sensors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapRef.current || mapInstanceRef.current) return;\n        if (!sensors.length || !bounds) return;\n        const map = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map(mapRef.current, {\n            center: bounds.getCenter(),\n            zoom: 12,\n            zoomControl: false,\n            scrollWheelZoom: false,\n            touchZoom: false,\n            doubleClickZoom: false,\n            boxZoom: false,\n            keyboard: false,\n            preferCanvas: false,\n            minZoom: 12,\n            maxZoom: 12,\n            maxBounds: bounds,\n            maxBoundsViscosity: 1.0\n        });\n        leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer(\"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\", {\n            attribution: '&copy; <a href=\"https://carto.com/\">CARTO</a>',\n            maxZoom: 19\n        }).addTo(map);\n        map.setView(bounds.getCenter(), 12, {\n            animate: false\n        });\n        const sensorLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup();\n        sensors.forEach((s)=>{\n            leaflet__WEBPACK_IMPORTED_MODULE_2___default().circleMarker([\n                s.lat,\n                s.lng\n            ], {\n                radius: 3,\n                fillColor: \"#94a3b8\",\n                color: \"rgba(0,0,0,0.2)\",\n                weight: 1,\n                fillOpacity: 0.7\n            }).bindTooltip(\"Sensor \".concat(s.id), {\n                direction: \"top\"\n            }).addTo(sensorLayer);\n        });\n        sensorLayer.addTo(map);\n        sensorLayerRef.current = sensorLayer;\n        map.on(\"click\", (e)=>{\n            if (!sensors.length) return;\n            const click = leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(e.latlng.lat, e.latlng.lng);\n            let best = null;\n            let bestMeters = Number.POSITIVE_INFINITY;\n            for (const s of sensors){\n                const d = haversineMeters(click, leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n                if (d < bestMeters) {\n                    bestMeters = d;\n                    best = s;\n                }\n            }\n            if (!best || bestMeters > 1500) return;\n            onSelectRef.current(best);\n        });\n        mapInstanceRef.current = map;\n        return ()=>{\n            if (animationRef.current) cancelAnimationFrame(animationRef.current);\n            map.remove();\n            mapInstanceRef.current = null;\n        };\n    }, [\n        sensors,\n        bounds\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (startMarkerRef.current) startMarkerRef.current.remove();\n        if (endMarkerRef.current) endMarkerRef.current.remove();\n        if (startSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--start\",\n                html: \"S\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            const marker = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                startSensor.lat,\n                startSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            marker.bindTooltip(\"Start\", {\n                direction: \"top\"\n            });\n            startMarkerRef.current = marker;\n        }\n        if (endSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--end\",\n                html: \"E\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            const marker = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                endSensor.lat,\n                endSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            marker.bindTooltip(\"End\", {\n                direction: \"top\"\n            });\n            endMarkerRef.current = marker;\n        }\n    }, [\n        startSensor,\n        endSensor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (routeLayerRef.current) routeLayerRef.current.remove();\n        if (animationRef.current) cancelAnimationFrame(animationRef.current);\n        if (!routeLatLngs.length) return;\n        let cancelled = false;\n        fetchRoadGeometry(routeLatLngs).then((roadPts)=>{\n            if (cancelled || !mapInstanceRef.current) return;\n            const routeLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup().addTo(map);\n            /* layer 1 – soft glow base */ leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#38bdf8\",\n                weight: 7,\n                opacity: 0.18,\n                lineCap: \"round\"\n            }).addTo(routeLayer);\n            /* layer 2 – fast escalator dashes */ const escalator1 = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#38bdf8\",\n                weight: 3,\n                opacity: 0.9,\n                dashArray: \"6 14\",\n                lineCap: \"butt\"\n            }).addTo(routeLayer);\n            /* layer 3 – offset counter-dashes for density */ const escalator2 = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(roadPts, {\n                color: \"#60a5fa\",\n                weight: 2,\n                opacity: 0.55,\n                dashArray: \"4 18\",\n                lineCap: \"butt\"\n            }).addTo(routeLayer);\n            routeLayerRef.current = routeLayer;\n            let offset1 = 0;\n            let offset2 = 0;\n            const step = ()=>{\n                offset1 = (offset1 - 16) % 2000;\n                offset2 = (offset2 + 12) % 2000;\n                escalator1.setStyle({\n                    dashOffset: \"\".concat(offset1)\n                });\n                escalator2.setStyle({\n                    dashOffset: \"\".concat(offset2)\n                });\n                animationRef.current = requestAnimationFrame(step);\n            };\n            animationRef.current = requestAnimationFrame(step);\n        });\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        routeLatLngs\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapRef,\n        style: {\n            height,\n            width: \"100%\",\n            borderRadius: \"var(--radius)\"\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\OnTime\\\\frontend-nextjs\\\\src\\\\components\\\\route-planner-map.tsx\",\n        lineNumber: 271,\n        columnNumber: 10\n    }, this);\n}\n_s(RoutePlannerMap, \"Xm+sm5SntUDQN0N+kBI08UC2Hi8=\");\n_c = RoutePlannerMap;\nvar _c;\n$RefreshReg$(_c, \"RoutePlannerMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JvdXRlLXBsYW5uZXItbWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDM0I7QUFDVTtBQXFCbEMsU0FBU0ksZ0JBQWdCQyxDQUFXLEVBQUVDLENBQVc7SUFDL0MsTUFBTUMsSUFBSTtJQUNWLE1BQU1DLFFBQVEsQ0FBQ0MsSUFBYyxJQUFLQyxLQUFLQyxFQUFFLEdBQUk7SUFDN0MsTUFBTUMsT0FBT0osTUFBTUYsRUFBRU8sR0FBRyxHQUFHUixFQUFFUSxHQUFHO0lBQ2hDLE1BQU1DLE9BQU9OLE1BQU1GLEVBQUVTLEdBQUcsR0FBR1YsRUFBRVUsR0FBRztJQUNoQyxNQUFNQyxPQUFPUixNQUFNSCxFQUFFUSxHQUFHO0lBQ3hCLE1BQU1JLE9BQU9ULE1BQU1GLEVBQUVPLEdBQUc7SUFDeEIsTUFBTUssU0FBU1IsS0FBS1MsR0FBRyxDQUFDUCxPQUFPO0lBQy9CLE1BQU1RLFNBQVNWLEtBQUtTLEdBQUcsQ0FBQ0wsT0FBTztJQUMvQixNQUFNTyxJQUFJSCxTQUFTQSxTQUFTUixLQUFLWSxHQUFHLENBQUNOLFFBQVFOLEtBQUtZLEdBQUcsQ0FBQ0wsUUFBUUcsU0FBU0E7SUFDdkUsT0FBTyxJQUFJYixJQUFJRyxLQUFLYSxJQUFJLENBQUNiLEtBQUtjLElBQUksQ0FBQ0g7QUFDckM7QUFFQTs7Ozs7Q0FLQyxHQUNELGVBQWVJLGtCQUNiQyxHQUF1QjtJQUV2QixJQUFJQSxJQUFJQyxNQUFNLEdBQUcsR0FBRyxPQUFPRDtJQUUzQixnRUFBZ0U7SUFDaEUsTUFBTUUsZUFBOEMsRUFBRTtJQUN0RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsSUFBSUMsTUFBTSxHQUFHLEdBQUdFLElBQUs7UUFDdkMsTUFBTXhCLElBQUlxQixHQUFHLENBQUNHLEVBQUU7UUFDaEIsTUFBTXZCLElBQUlvQixHQUFHLENBQUNHLElBQUksRUFBRTtRQUNwQkQsYUFBYUUsSUFBSSxDQUNmQyxN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WUFFVCwrQ0FBK0MsR0FDL0MsTUFBTU0sYUFBYTlILHVEQUFVLENBQUN1SCxTQUFTO2dCQUNyQ3pCLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1IyQixTQUFTO2dCQUNURyxXQUFXO2dCQUNYRixTQUFTO1lBQ1gsR0FBR3RDLEtBQUssQ0FBQ21DO1lBRVQvRCxjQUFjSyxPQUFPLEdBQUcwRDtZQUV4QixJQUFJTyxVQUFVO1lBQ2QsSUFBSUMsVUFBVTtZQUVkLE1BQU1DLE9BQU87Z0JBQ1hGLFVBQVUsQ0FBQ0EsVUFBVSxFQUFDLElBQUs7Z0JBQzNCQyxVQUFVLENBQUNBLFVBQVUsRUFBQyxJQUFLO2dCQUMzQkosV0FBV00sUUFBUSxDQUFDO29CQUFFQyxZQUFZLEdBQVcsT0FBUko7Z0JBQVU7Z0JBQy9DRCxXQUFXSSxRQUFRLENBQUM7b0JBQUVDLFlBQVksR0FBVyxPQUFSSDtnQkFBVTtnQkFDL0NwRSxhQUFhRSxPQUFPLEdBQUdzRSxzQkFBc0JIO1lBQy9DO1lBRUFyRSxhQUFhRSxPQUFPLEdBQUdzRSxzQkFBc0JIO1FBQy9DO1FBRUEsT0FBTztZQUFRWCxZQUFZO1FBQU07SUFDbkMsR0FBRztRQUFDbkU7S0FBYTtJQUVqQixxQkFBTyw4REFBQ2tGO1FBQUlDLEtBQUtoRjtRQUFRaUYsT0FBTztZQUFFbEY7WUFBUW1GLE9BQU87WUFBUUMsY0FBYztRQUFnQjs7Ozs7O0FBQ3pGO0dBM0x3QjFGO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3JvdXRlLXBsYW5uZXItbWFwLnRzeD85NWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IEwgZnJvbSBcImxlYWZsZXRcIjtcclxuaW1wb3J0IFwibGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzXCI7XHJcblxyXG5pbnRlcmZhY2UgU2Vuc29yIHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHNlbnNvcl9pZD86IHN0cmluZztcclxuICBsYXQ6IG51bWJlcjtcclxuICBsbmc6IG51bWJlcjtcclxuICBhdmdfc3BlZWQ6IG51bWJlcjtcclxuICBjb25nZXN0aW9uOiBudW1iZXI7XHJcbiAgY29sb3I6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIFJvdXRlUGxhbm5lck1hcFByb3BzIHtcclxuICBzZW5zb3JzOiBTZW5zb3JbXTtcclxuICBzdGFydFNlbnNvcjogU2Vuc29yIHwgbnVsbDtcclxuICBlbmRTZW5zb3I6IFNlbnNvciB8IG51bGw7XHJcbiAgcm91dGVMYXRMbmdzOiBbbnVtYmVyLCBudW1iZXJdW107XHJcbiAgb25TZWxlY3RTZW5zb3I6IChzZW5zb3I6IFNlbnNvcikgPT4gdm9pZDtcclxuICBoZWlnaHQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhdmVyc2luZU1ldGVycyhhOiBMLkxhdExuZywgYjogTC5MYXRMbmcpOiBudW1iZXIge1xyXG4gIGNvbnN0IFIgPSA2MzcxMDAwO1xyXG4gIGNvbnN0IHRvUmFkID0gKHY6IG51bWJlcikgPT4gKHYgKiBNYXRoLlBJKSAvIDE4MDtcclxuICBjb25zdCBkTGF0ID0gdG9SYWQoYi5sYXQgLSBhLmxhdCk7XHJcbiAgY29uc3QgZExuZyA9IHRvUmFkKGIubG5nIC0gYS5sbmcpO1xyXG4gIGNvbnN0IGxhdDEgPSB0b1JhZChhLmxhdCk7XHJcbiAgY29uc3QgbGF0MiA9IHRvUmFkKGIubGF0KTtcclxuICBjb25zdCBzaW5MYXQgPSBNYXRoLnNpbihkTGF0IC8gMik7XHJcbiAgY29uc3Qgc2luTG5nID0gTWF0aC5zaW4oZExuZyAvIDIpO1xyXG4gIGNvbnN0IGggPSBzaW5MYXQgKiBzaW5MYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luTG5nICogc2luTG5nO1xyXG4gIHJldHVybiAyICogUiAqIE1hdGguYXNpbihNYXRoLnNxcnQoaCkpO1xyXG59XHJcblxyXG4vKipcclxuICogU25hcCByb3V0ZSB0byByZWFsIHJvYWRzIHZpYSBPU1JNIChmcmVlLCBubyBBUEkga2V5KS5cclxuICogRmV0Y2hlcyByb2FkIGdlb21ldHJ5IGZvciBlYWNoIGNvbnNlY3V0aXZlIHNlbnNvciBwYWlyLFxyXG4gKiB0aGVuIHN0aXRjaGVzIGFsbCBzZWdtZW50cyB0b2dldGhlci4gVGhpcyBlbnN1cmVzIHRoZSByb3V0ZVxyXG4gKiBmb2xsb3dzIHRoZSBzZW5zb3IgZ3JhcGggb3JkZXIgd2hpbGUgc3RheWluZyBvbiBhY3R1YWwgcm9hZHMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFJvYWRHZW9tZXRyeShcclxuICBwdHM6IFtudW1iZXIsIG51bWJlcl1bXVxyXG4pOiBQcm9taXNlPFtudW1iZXIsIG51bWJlcl1bXT4ge1xyXG4gIGlmIChwdHMubGVuZ3RoIDwgMikgcmV0dXJuIHB0cztcclxuXHJcbiAgLy8gQnVpbGQgcGFpcndpc2UgT1NSTSByZXF1ZXN0cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSBzZW5zb3IgcGFpclxyXG4gIGNvbnN0IHBhaXJQcm9taXNlczogUHJvbWlzZTxbbnVtYmVyLCBudW1iZXJdW10+W10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHB0cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgIGNvbnN0IGEgPSBwdHNbaV07XHJcbiAgICBjb25zdCBiID0gcHRzW2kgKyAxXTtcclxuICAgIHBhaXJQcm9taXNlcy5wdXNoKFxyXG4gICAgICBmZXRjaChcclxuICAgICAgICBgaHR0cHM6Ly9yb3V0ZXIucHJvamVjdC1vc3JtLm9yZy9yb3V0ZS92MS9kcml2aW5nLyR7YVsxXX0sJHthWzBdfTske2JbMV19LCR7YlswXX0/b3ZlcnZpZXc9ZnVsbCZnZW9tZXRyaWVzPWdlb2pzb25gXHJcbiAgICAgIClcclxuICAgICAgICAudGhlbigocikgPT4gKHIub2sgPyByLmpzb24oKSA6IG51bGwpKVxyXG4gICAgICAgIC50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZGF0YT8uY29kZSA9PT0gXCJPa1wiICYmIGRhdGEucm91dGVzPy5bMF0/Lmdlb21ldHJ5Py5jb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5yb3V0ZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKFxyXG4gICAgICAgICAgICAgIChjOiBbbnVtYmVyLCBudW1iZXJdKSA9PiBbY1sxXSwgY1swXV0gYXMgW251bWJlciwgbnVtYmVyXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIFthLCBiXTsgLy8gZmFsbGJhY2sgdG8gc3RyYWlnaHQgbGluZVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKCgpID0+IFthLCBiXSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzZWdtZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKHBhaXJQcm9taXNlcyk7XHJcblxyXG4gIC8vIFN0aXRjaCBzZWdtZW50cywgc2tpcHBpbmcgZHVwbGljYXRlIGp1bmN0aW9uIHBvaW50c1xyXG4gIGNvbnN0IHJlc3VsdDogW251bWJlciwgbnVtYmVyXVtdID0gW107XHJcbiAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gcmVzdWx0Lmxlbmd0aCA/IDEgOiAwOyAvLyBza2lwIGZpcnN0IHBvaW50IG9mIHN1YnNlcXVlbnQgc2VnbWVudHMgKGR1cGxpY2F0ZSlcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHNlZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICByZXN1bHQucHVzaChzZWdbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSb3V0ZVBsYW5uZXJNYXAoe1xyXG4gIHNlbnNvcnMsXHJcbiAgc3RhcnRTZW5zb3IsXHJcbiAgZW5kU2Vuc29yLFxyXG4gIHJvdXRlTGF0TG5ncyxcclxuICBvblNlbGVjdFNlbnNvcixcclxuICBoZWlnaHQgPSBcIjU2MHB4XCIsXHJcbn06IFJvdXRlUGxhbm5lck1hcFByb3BzKSB7XHJcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBtYXBJbnN0YW5jZVJlZiA9IHVzZVJlZjxMLk1hcCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHNlbnNvckxheWVyUmVmID0gdXNlUmVmPEwuTGF5ZXJHcm91cCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHJvdXRlTGF5ZXJSZWYgPSB1c2VSZWY8TC5MYXllckdyb3VwIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3Qgc3RhcnRNYXJrZXJSZWYgPSB1c2VSZWY8TC5NYXJrZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBlbmRNYXJrZXJSZWYgPSB1c2VSZWY8TC5NYXJrZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBhbmltYXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3Qgb25TZWxlY3RSZWYgPSB1c2VSZWYob25TZWxlY3RTZW5zb3IpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgb25TZWxlY3RSZWYuY3VycmVudCA9IG9uU2VsZWN0U2Vuc29yO1xyXG4gIH0sIFtvblNlbGVjdFNlbnNvcl0pO1xyXG5cclxuICBjb25zdCBib3VuZHMgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGlmICghc2Vuc29ycy5sZW5ndGgpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgbGF0TG5ncyA9IHNlbnNvcnMubWFwKChzKSA9PiBMLmxhdExuZyhzLmxhdCwgcy5sbmcpKTtcclxuICAgIHJldHVybiBMLmxhdExuZ0JvdW5kcyhsYXRMbmdzKS5wYWQoMC4yKTtcclxuICB9LCBbc2Vuc29yc10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCBtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBpZiAoIXNlbnNvcnMubGVuZ3RoIHx8ICFib3VuZHMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBtYXAgPSBMLm1hcChtYXBSZWYuY3VycmVudCwge1xyXG4gICAgICBjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICAgICAgem9vbTogMTIsXHJcbiAgICAgIHpvb21Db250cm9sOiBmYWxzZSxcclxuICAgICAgc2Nyb2xsV2hlZWxab29tOiBmYWxzZSxcclxuICAgICAgdG91Y2hab29tOiBmYWxzZSxcclxuICAgICAgZG91YmxlQ2xpY2tab29tOiBmYWxzZSxcclxuICAgICAgYm94Wm9vbTogZmFsc2UsXHJcbiAgICAgIGtleWJvYXJkOiBmYWxzZSxcclxuICAgICAgcHJlZmVyQ2FudmFzOiBmYWxzZSxcclxuICAgICAgbWluWm9vbTogMTIsXHJcbiAgICAgIG1heFpvb206IDEyLFxyXG4gICAgICBtYXhCb3VuZHM6IGJvdW5kcyxcclxuICAgICAgbWF4Qm91bmRzVmlzY29zaXR5OiAxLjAsXHJcbiAgICB9KTtcclxuXHJcbiAgICBMLnRpbGVMYXllcihcImh0dHBzOi8ve3N9LmJhc2VtYXBzLmNhcnRvY2RuLmNvbS9kYXJrX2FsbC97en0ve3h9L3t5fXtyfS5wbmdcIiwge1xyXG4gICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly9jYXJ0by5jb20vXCI+Q0FSVE88L2E+JyxcclxuICAgICAgbWF4Wm9vbTogMTksXHJcbiAgICB9KS5hZGRUbyhtYXApO1xyXG5cclxuICAgIG1hcC5zZXRWaWV3KGJvdW5kcy5nZXRDZW50ZXIoKSwgMTIsIHsgYW5pbWF0ZTogZmFsc2UgfSk7XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yTGF5ZXIgPSBMLmxheWVyR3JvdXAoKTtcclxuICAgIHNlbnNvcnMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBMLmNpcmNsZU1hcmtlcihbcy5sYXQsIHMubG5nXSwge1xyXG4gICAgICAgIHJhZGl1czogMyxcclxuICAgICAgICBmaWxsQ29sb3I6IFwiIzk0YTNiOFwiLFxyXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC4yKVwiLFxyXG4gICAgICAgIHdlaWdodDogMSxcclxuICAgICAgICBmaWxsT3BhY2l0eTogMC43LFxyXG4gICAgICB9KVxyXG4gICAgICAgIC5iaW5kVG9vbHRpcChgU2Vuc29yICR7cy5pZH1gLCB7IGRpcmVjdGlvbjogXCJ0b3BcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhzZW5zb3JMYXllcik7XHJcbiAgICB9KTtcclxuICAgIHNlbnNvckxheWVyLmFkZFRvKG1hcCk7XHJcbiAgICBzZW5zb3JMYXllclJlZi5jdXJyZW50ID0gc2Vuc29yTGF5ZXI7XHJcblxyXG4gICAgbWFwLm9uKFwiY2xpY2tcIiwgKGUpID0+IHtcclxuICAgICAgaWYgKCFzZW5zb3JzLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjbGljayA9IEwubGF0TG5nKGUubGF0bG5nLmxhdCwgZS5sYXRsbmcubG5nKTtcclxuICAgICAgbGV0IGJlc3Q6IFNlbnNvciB8IG51bGwgPSBudWxsO1xyXG4gICAgICBsZXQgYmVzdE1ldGVycyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgZm9yIChjb25zdCBzIG9mIHNlbnNvcnMpIHtcclxuICAgICAgICBjb25zdCBkID0gaGF2ZXJzaW5lTWV0ZXJzKGNsaWNrLCBMLmxhdExuZyhzLmxhdCwgcy5sbmcpKTtcclxuICAgICAgICBpZiAoZCA8IGJlc3RNZXRlcnMpIHtcclxuICAgICAgICAgIGJlc3RNZXRlcnMgPSBkO1xyXG4gICAgICAgICAgYmVzdCA9IHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghYmVzdCB8fCBiZXN0TWV0ZXJzID4gMTUwMCkgcmV0dXJuO1xyXG4gICAgICBvblNlbGVjdFJlZi5jdXJyZW50KGJlc3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG1hcDtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICBtYXAucmVtb3ZlKCk7XHJcbiAgICAgIG1hcEluc3RhbmNlUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfTtcclxuICB9LCBbc2Vuc29ycywgYm91bmRzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBtYXAgPSBtYXBJbnN0YW5jZVJlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFtYXApIHJldHVybjtcclxuXHJcbiAgICBpZiAoc3RhcnRNYXJrZXJSZWYuY3VycmVudCkgc3RhcnRNYXJrZXJSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgIGlmIChlbmRNYXJrZXJSZWYuY3VycmVudCkgZW5kTWFya2VyUmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcblxyXG4gICAgaWYgKHN0YXJ0U2Vuc29yKSB7XHJcbiAgICAgIGNvbnN0IGljb24gPSBMLmRpdkljb24oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyb3V0ZS1tYXJrZXIgcm91dGUtbWFya2VyLS1zdGFydFwiLFxyXG4gICAgICAgIGh0bWw6IFwiU1wiLFxyXG4gICAgICAgIGljb25TaXplOiBbMjYsIDI2XSxcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTMsIDEzXSxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IG1hcmtlciA9IEwubWFya2VyKFtzdGFydFNlbnNvci5sYXQsIHN0YXJ0U2Vuc29yLmxuZ10sIHsgaWNvbiB9KS5hZGRUbyhtYXApO1xyXG4gICAgICBtYXJrZXIuYmluZFRvb2x0aXAoXCJTdGFydFwiLCB7IGRpcmVjdGlvbjogXCJ0b3BcIiB9KTtcclxuICAgICAgc3RhcnRNYXJrZXJSZWYuY3VycmVudCA9IG1hcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kU2Vuc29yKSB7XHJcbiAgICAgIGNvbnN0IGljb24gPSBMLmRpdkljb24oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyb3V0ZS1tYXJrZXIgcm91dGUtbWFya2VyLS1lbmRcIixcclxuICAgICAgICBodG1sOiBcIkVcIixcclxuICAgICAgICBpY29uU2l6ZTogWzI2LCAyNl0sXHJcbiAgICAgICAgaWNvbkFuY2hvcjogWzEzLCAxM10sXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBtYXJrZXIgPSBMLm1hcmtlcihbZW5kU2Vuc29yLmxhdCwgZW5kU2Vuc29yLmxuZ10sIHsgaWNvbiB9KS5hZGRUbyhtYXApO1xyXG4gICAgICBtYXJrZXIuYmluZFRvb2x0aXAoXCJFbmRcIiwgeyBkaXJlY3Rpb246IFwidG9wXCIgfSk7XHJcbiAgICAgIGVuZE1hcmtlclJlZi5jdXJyZW50ID0gbWFya2VyO1xyXG4gICAgfVxyXG4gIH0sIFtzdGFydFNlbnNvciwgZW5kU2Vuc29yXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBtYXAgPSBtYXBJbnN0YW5jZVJlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFtYXApIHJldHVybjtcclxuXHJcbiAgICBpZiAocm91dGVMYXllclJlZi5jdXJyZW50KSByb3V0ZUxheWVyUmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcclxuXHJcbiAgICBpZiAoIXJvdXRlTGF0TG5ncy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XHJcblxyXG4gICAgZmV0Y2hSb2FkR2VvbWV0cnkocm91dGVMYXRMbmdzKS50aGVuKChyb2FkUHRzKSA9PiB7XHJcbiAgICAgIGlmIChjYW5jZWxsZWQgfHwgIW1hcEluc3RhbmNlUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IHJvdXRlTGF5ZXIgPSBMLmxheWVyR3JvdXAoKS5hZGRUbyhtYXApO1xyXG5cclxuICAgICAgLyogbGF5ZXIgMSDigJMgc29mdCBnbG93IGJhc2UgKi9cclxuICAgICAgTC5wb2x5bGluZShyb2FkUHRzLCB7XHJcbiAgICAgICAgY29sb3I6IFwiIzM4YmRmOFwiLFxyXG4gICAgICAgIHdlaWdodDogNyxcclxuICAgICAgICBvcGFjaXR5OiAwLjE4LFxyXG4gICAgICAgIGxpbmVDYXA6IFwicm91bmRcIixcclxuICAgICAgfSkuYWRkVG8ocm91dGVMYXllcik7XHJcblxyXG4gICAgICAvKiBsYXllciAyIOKAkyBmYXN0IGVzY2FsYXRvciBkYXNoZXMgKi9cclxuICAgICAgY29uc3QgZXNjYWxhdG9yMSA9IEwucG9seWxpbmUocm9hZFB0cywge1xyXG4gICAgICAgIGNvbG9yOiBcIiMzOGJkZjhcIixcclxuICAgICAgICB3ZWlnaHQ6IDMsXHJcbiAgICAgICAgb3BhY2l0eTogMC45LFxyXG4gICAgICAgIGRhc2hBcnJheTogXCI2IDE0XCIsXHJcbiAgICAgICAgbGluZUNhcDogXCJidXR0XCIsXHJcbiAgICAgIH0pLmFkZFRvKHJvdXRlTGF5ZXIpO1xyXG5cclxuICAgICAgLyogbGF5ZXIgMyDigJMgb2Zmc2V0IGNvdW50ZXItZGFzaGVzIGZvciBkZW5zaXR5ICovXHJcbiAgICAgIGNvbnN0IGVzY2FsYXRvcjIgPSBMLnBvbHlsaW5lKHJvYWRQdHMsIHtcclxuICAgICAgICBjb2xvcjogXCIjNjBhNWZhXCIsXHJcbiAgICAgICAgd2VpZ2h0OiAyLFxyXG4gICAgICAgIG9wYWNpdHk6IDAuNTUsXHJcbiAgICAgICAgZGFzaEFycmF5OiBcIjQgMThcIixcclxuICAgICAgICBsaW5lQ2FwOiBcImJ1dHRcIixcclxuICAgICAgfSkuYWRkVG8ocm91dGVMYXllcik7XHJcblxyXG4gICAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQgPSByb3V0ZUxheWVyO1xyXG5cclxuICAgICAgbGV0IG9mZnNldDEgPSAwO1xyXG4gICAgICBsZXQgb2Zmc2V0MiA9IDA7XHJcblxyXG4gICAgICBjb25zdCBzdGVwID0gKCkgPT4ge1xyXG4gICAgICAgIG9mZnNldDEgPSAob2Zmc2V0MSAtIDE2KSAlIDIwMDA7XHJcbiAgICAgICAgb2Zmc2V0MiA9IChvZmZzZXQyICsgMTIpICUgMjAwMDtcclxuICAgICAgICBlc2NhbGF0b3IxLnNldFN0eWxlKHsgZGFzaE9mZnNldDogYCR7b2Zmc2V0MX1gIH0pO1xyXG4gICAgICAgIGVzY2FsYXRvcjIuc2V0U3R5bGUoeyBkYXNoT2Zmc2V0OiBgJHtvZmZzZXQyfWAgfSk7XHJcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7IGNhbmNlbGxlZCA9IHRydWU7IH07XHJcbiAgfSwgW3JvdXRlTGF0TG5nc10pO1xyXG5cclxuICByZXR1cm4gPGRpdiByZWY9e21hcFJlZn0gc3R5bGU9e3sgaGVpZ2h0LCB3aWR0aDogXCIxMDAlXCIsIGJvcmRlclJhZGl1czogXCJ2YXIoLS1yYWRpdXMpXCIgfX0gLz47XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJMIiwiaGF2ZXJzaW5lTWV0ZXJzIiwiYSIsImIiLCJSIiwidG9SYWQiLCJ2IiwiTWF0aCIsIlBJIiwiZExhdCIsImxhdCIsImRMbmciLCJsbmciLCJsYXQxIiwibGF0MiIsInNpbkxhdCIsInNpbiIsInNpbkxuZyIsImgiLCJjb3MiLCJhc2luIiwic3FydCIsImZldGNoUm9hZEdlb21ldHJ5IiwicHRzIiwibGVuZ3RoIiwicGFpclByb21pc2VzIiwiaSIsInB1c2giLCJmZXRjaCIsInRoZW4iLCJyIiwib2siLCJqc29uIiwiZGF0YSIsImNvZGUiLCJyb3V0ZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwibWFwIiwiYyIsImNhdGNoIiwic2VnbWVudHMiLCJQcm9taXNlIiwiYWxsIiwicmVzdWx0Iiwic2VnIiwic3RhcnQiLCJSb3V0ZVBsYW5uZXJNYXAiLCJzZW5zb3JzIiwic3RhcnRTZW5zb3IiLCJlbmRTZW5zb3IiLCJyb3V0ZUxhdExuZ3MiLCJvblNlbGVjdFNlbnNvciIsImhlaWdodCIsIm1hcFJlZiIsIm1hcEluc3RhbmNlUmVmIiwic2Vuc29yTGF5ZXJSZWYiLCJyb3V0ZUxheWVyUmVmIiwic3RhcnRNYXJrZXJSZWYiLCJlbmRNYXJrZXJSZWYiLCJhbmltYXRpb25SZWYiLCJvblNlbGVjdFJlZiIsImN1cnJlbnQiLCJib3VuZHMiLCJsYXRMbmdzIiwicyIsImxhdExuZyIsImxhdExuZ0JvdW5kcyIsInBhZCIsImNlbnRlciIsImdldENlbnRlciIsInpvb20iLCJ6b29tQ29udHJvbCIsInNjcm9sbFdoZWVsWm9vbSIsInRvdWNoWm9vbSIsImRvdWJsZUNsaWNrWm9vbSIsImJveFpvb20iLCJrZXlib2FyZCIsInByZWZlckNhbnZhcyIsIm1pblpvb20iLCJtYXhab29tIiwibWF4Qm91bmRzIiwibWF4Qm91bmRzVmlzY29zaXR5IiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJhZGRUbyIsInNldFZpZXciLCJhbmltYXRlIiwic2Vuc29yTGF5ZXIiLCJsYXllckdyb3VwIiwiZm9yRWFjaCIsImNpcmNsZU1hcmtlciIsInJhZGl1cyIsImZpbGxDb2xvciIsImNvbG9yIiwid2VpZ2h0IiwiZmlsbE9wYWNpdHkiLCJiaW5kVG9vbHRpcCIsImlkIiwiZGlyZWN0aW9uIiwib24iLCJlIiwiY2xpY2siLCJsYXRsbmciLCJiZXN0IiwiYmVzdE1ldGVycyIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlIiwiaWNvbiIsImRpdkljb24iLCJjbGFzc05hbWUiLCJodG1sIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwibWFya2VyIiwiY2FuY2VsbGVkIiwicm9hZFB0cyIsInJvdXRlTGF5ZXIiLCJwb2x5bGluZSIsIm9wYWNpdHkiLCJsaW5lQ2FwIiwiZXNjYWxhdG9yMSIsImRhc2hBcnJheSIsImVzY2FsYXRvcjIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsInN0ZXAiLCJzZXRTdHlsZSIsImRhc2hPZmZzZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiYm9yZGVyUmFkaXVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/route-planner-map.tsx\n"));

/***/ })

});