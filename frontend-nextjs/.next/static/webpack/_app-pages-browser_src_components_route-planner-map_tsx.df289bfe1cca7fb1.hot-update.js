"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_route-planner-map_tsx",{

/***/ "(app-pages-browser)/./src/components/route-planner-map.tsx":
/*!**********************************************!*\
  !*** ./src/components/route-planner-map.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RoutePlannerMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction haversineMeters(a, b) {\n    const R = 6371000;\n    const toRad = (v)=>v * Math.PI / 180;\n    const dLat = toRad(b.lat - a.lat);\n    const dLng = toRad(b.lng - a.lng);\n    const lat1 = toRad(a.lat);\n    const lat2 = toRad(b.lat);\n    const sinLat = Math.sin(dLat / 2);\n    const sinLng = Math.sin(dLng / 2);\n    const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;\n    return 2 * R * Math.asin(Math.sqrt(h));\n}\nfunction RoutePlannerMap(param) {\n    let { sensors, startSensor, endSensor, routeLatLngs, onSelectSensor, height = \"560px\" } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sensorLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const endMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const movingMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const dashOffsetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const bounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!sensors.length) return null;\n        const latLngs = sensors.map((s)=>leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n        return leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLngBounds(latLngs).pad(0.2);\n    }, [\n        sensors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapRef.current || mapInstanceRef.current) return;\n        if (!sensors.length || !bounds) return;\n        const map = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map(mapRef.current, {\n            center: bounds.getCenter(),\n            zoom: 12,\n            zoomControl: false,\n            scrollWheelZoom: false,\n            touchZoom: false,\n            doubleClickZoom: false,\n            boxZoom: false,\n            keyboard: false,\n            preferCanvas: true,\n            minZoom: 12,\n            maxZoom: 12,\n            maxBounds: bounds,\n            maxBoundsViscosity: 1.0\n        });\n        leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer(\"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\", {\n            attribution: '&copy; <a href=\"https://carto.com/\">CARTO</a>',\n            maxZoom: 19\n        }).addTo(map);\n        map.setView(bounds.getCenter(), 12, {\n            animate: false\n        });\n        const sensorLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup();\n        sensors.forEach((s)=>{\n            var _s_sensor_id;\n            leaflet__WEBPACK_IMPORTED_MODULE_2___default().circleMarker([\n                s.lat,\n                s.lng\n            ], {\n                radius: 3,\n                fillColor: \"#94a3b8\",\n                color: \"rgba(0,0,0,0.2)\",\n                weight: 1,\n                fillOpacity: 0.7\n            }).bindTooltip(\"Sensor \".concat((_s_sensor_id = s.sensor_id) !== null && _s_sensor_id !== void 0 ? _s_sensor_id : s.id), {\n                direction: \"top\"\n            }).addTo(sensorLayer);\n        });\n        sensorLayer.addTo(map);\n        sensorLayerRef.current = sensorLayer;\n        map.on(\"click\", (e)=>{\n            if (!sensors.length) return;\n            const click = leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(e.latlng.lat, e.latlng.lng);\n            let best = null;\n            let bestMeters = Number.POSITIVE_INFINITY;\n            for (const s of sensors){\n                const d = haversineMeters(click, leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(s.lat, s.lng));\n                if (d < bestMeters) {\n                    bestMeters = d;\n                    best = s;\n                }\n            }\n            if (!best || bestMeters > 1500) return;\n            onSelectSensor(best);\n        });\n        mapInstanceRef.current = map;\n        return ()=>{\n            if (animationRef.current) cancelAnimationFrame(animationRef.current);\n            map.remove();\n            mapInstanceRef.current = null;\n        };\n    }, [\n        sensors,\n        bounds,\n        onSelectSensor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (startMarkerRef.current) startMarkerRef.current.remove();\n        if (endMarkerRef.current) endMarkerRef.current.remove();\n        if (startSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--start\",\n                html: \"S\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            startMarkerRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                startSensor.lat,\n                startSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            startMarkerRef.current.bindTooltip(\"Start\", {\n                direction: \"top\"\n            });\n        }\n        if (endSensor) {\n            const icon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().divIcon({\n                className: \"route-marker route-marker--end\",\n                html: \"E\",\n                iconSize: [\n                    26,\n                    26\n                ],\n                iconAnchor: [\n                    13,\n                    13\n                ]\n            });\n            endMarkerRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker([\n                endSensor.lat,\n                endSensor.lng\n            ], {\n                icon\n            }).addTo(map);\n            endMarkerRef.current.bindTooltip(\"End\", {\n                direction: \"top\"\n            });\n        }\n    }, [\n        startSensor,\n        endSensor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const map = mapInstanceRef.current;\n        if (!map) return;\n        if (routeLayerRef.current) routeLayerRef.current.remove();\n        if (movingMarkerRef.current) movingMarkerRef.current.remove();\n        if (animationRef.current) cancelAnimationFrame(animationRef.current);\n        if (!routeLatLngs.length) return;\n        const poly = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polyline(routeLatLngs, {\n            color: \"#38bdf8\",\n            weight: 4,\n            opacity: 0.9,\n            dashArray: \"8 10\"\n        }).addTo(map);\n        routeLayerRef.current = poly;\n        const routePoints = routeLatLngs.map((p)=>leaflet__WEBPACK_IMPORTED_MODULE_2___default().latLng(p[0], p[1]));\n        if (routePoints.length < 2) return;\n        const segLengths = [];\n        let total = 0;\n        for(let i = 0; i < routePoints.length - 1; i += 1){\n            const d = map.distance(routePoints[i], routePoints[i + 1]);\n            segLengths.push(d);\n            total += d;\n        }\n        movingMarkerRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().circleMarker(routePoints[0], {\n            radius: 5,\n            fillColor: \"#f8fafc\",\n            color: \"#38bdf8\",\n            weight: 2,\n            fillOpacity: 1\n        }).addTo(map);\n        const speedMps = 55;\n        const startTime = performance.now();\n        const step = (now)=>{\n            var _movingMarkerRef_current;\n            const elapsed = (now - startTime) / 1000;\n            const dist = elapsed * speedMps % total;\n            let acc = 0;\n            let idx = 0;\n            while(idx < segLengths.length && acc + segLengths[idx] < dist){\n                acc += segLengths[idx];\n                idx += 1;\n            }\n            const segDist = segLengths[Math.min(idx, segLengths.length - 1)] || 1;\n            const t = Math.min(1, Math.max(0, (dist - acc) / segDist));\n            const from = routePoints[Math.min(idx, routePoints.length - 2)];\n            const to = routePoints[Math.min(idx + 1, routePoints.length - 1)];\n            const lat = from.lat + (to.lat - from.lat) * t;\n            const lng = from.lng + (to.lng - from.lng) * t;\n            (_movingMarkerRef_current = movingMarkerRef.current) === null || _movingMarkerRef_current === void 0 ? void 0 : _movingMarkerRef_current.setLatLng([\n                lat,\n                lng\n            ]);\n            dashOffsetRef.current = (dashOffsetRef.current - 1.5) % 1000;\n            poly.setStyle({\n                dashOffset: \"\".concat(dashOffsetRef.current)\n            });\n            animationRef.current = requestAnimationFrame(step);\n        };\n        animationRef.current = requestAnimationFrame(step);\n        map.setView(map.getCenter(), map.getZoom(), {\n            animate: false\n        });\n    }, [\n        routeLatLngs\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapRef,\n        style: {\n            height,\n            width: \"100%\",\n            borderRadius: \"var(--radius)\"\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\OnTime\\\\frontend-nextjs\\\\src\\\\components\\\\route-planner-map.tsx\",\n        lineNumber: 228,\n        columnNumber: 10\n    }, this);\n}\n_s(RoutePlannerMap, \"wPDDhcf9LbU8uQiLXXcF4ZUTyXU=\");\n_c = RoutePlannerMap;\nvar _c;\n$RefreshReg$(_c, \"RoutePlannerMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3JvdXRlLXBsYW5uZXItbWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDM0I7QUFDVTtBQXFCbEMsU0FBU0ksZ0JBQWdCQyxDQUFXLEVBQUVDLENBQVc7SUFDL0MsTUFBTUMsSUFBSTtJQUNWLE1BQU1DLFFBQVEsQ0FBQ0MsSUFBYyxJQUFLQyxLQUFLQyxFQUFFLEdBQUk7SUFDN0MsTUFBTUMsT0FBT0osTUFBTUYsRUFBRU8sR0FBRyxHQUFHUixFQUFFUSxHQUFHO0lBQ2hDLE1BQU1DLE9BQU9OLE1BQU1GLEVBQUVTLEdBQUcsR0FBR1YsRUFBRVUsR0FBRztJQUNoQyxNQUFNQyxPQUFPUixNQUFNSCxFQUFFUSxHQUFHO0lBQ3hCLE1BQU1JLE9BQU9ULE1BQU1GLEVBQUVPLEdBQUc7SUFDeEIsTUFBTUssU0FBU1IsS0FBS1MsR0FBRyxDQUFDUCxPQUFPO0lBQy9CLE1BQU1RLFNBQVNWLEtBQUtTLEdBQUcsQ0FBQ0wsT0FBTztJQUMvQixNQUFNTyxJQUFJSCxTQUFTQSxTQUFTUixLQUFLWSxHQUFHLENBQUNOLFFBQVFOLEtBQUtZLEdBQUcsQ0FBQ0wsUUFBUUcsU0FBU0E7SUFDdkUsT0FBTyxJQUFJYixJQUFJRyxLQUFLYSxJQUFJLENBQUNiLEtBQUtjLElBQUksQ0FBQ0g7QUFDckM7QUFFZSxTQUFTSSxnQkFBZ0IsS0FPakI7UUFQaUIsRUFDdENDLE9BQU8sRUFDUEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsY0FBYyxFQUNkQyxTQUFTLE9BQU8sRUFDSyxHQVBpQjs7SUFRdEMsTUFBTUMsU0FBUzlCLDZDQUFNQSxDQUFpQjtJQUN0QyxNQUFNK0IsaUJBQWlCL0IsNkNBQU1BLENBQWU7SUFDNUMsTUFBTWdDLGlCQUFpQmhDLDZDQUFNQSxDQUFzQjtJQUNuRCxNQUFNaUMsZ0JBQWdCakMsNkNBQU1BLENBQW9CO0lBQ2hELE1BQU1rQyxpQkFBaUJsQyw2Q0FB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QUs7WUFDeERtRCxLQUFLMkIsUUFBUSxDQUFDO2dCQUFFQyxZQUFZLEdBQXlCLE9BQXRCeEYsY0FBY1MsT0FBTztZQUFHO1lBRXZEVixhQUFhVSxPQUFPLEdBQUdnRixzQkFBc0JkO1FBQy9DO1FBRUE1RSxhQUFhVSxPQUFPLEdBQUdnRixzQkFBc0JkO1FBRTdDdkUsSUFBSXVCLE9BQU8sQ0FBQ3ZCLElBQUlPLFNBQVMsSUFBSVAsSUFBSXNGLE9BQU8sSUFBSTtZQUFFOUQsU0FBUztRQUFNO0lBQy9ELEdBQUc7UUFBQ3ZDO0tBQWE7SUFFakIscUJBQU8sOERBQUNzRztRQUFJQyxLQUFLcEc7UUFBUXFHLE9BQU87WUFBRXRHO1lBQVF1RyxPQUFPO1lBQVFDLGNBQWM7UUFBZ0I7Ozs7OztBQUN6RjtHQTlMd0I5RztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9yb3V0ZS1wbGFubmVyLW1hcC50c3g/OTVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBMIGZyb20gXCJsZWFmbGV0XCI7XHJcbmltcG9ydCBcImxlYWZsZXQvZGlzdC9sZWFmbGV0LmNzc1wiO1xyXG5cclxuaW50ZXJmYWNlIFNlbnNvciB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICBzZW5zb3JfaWQ/OiBzdHJpbmc7XHJcbiAgbGF0OiBudW1iZXI7XHJcbiAgbG5nOiBudW1iZXI7XHJcbiAgYXZnX3NwZWVkOiBudW1iZXI7XHJcbiAgY29uZ2VzdGlvbjogbnVtYmVyO1xyXG4gIGNvbG9yOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBSb3V0ZVBsYW5uZXJNYXBQcm9wcyB7XHJcbiAgc2Vuc29yczogU2Vuc29yW107XHJcbiAgc3RhcnRTZW5zb3I6IFNlbnNvciB8IG51bGw7XHJcbiAgZW5kU2Vuc29yOiBTZW5zb3IgfCBudWxsO1xyXG4gIHJvdXRlTGF0TG5nczogW251bWJlciwgbnVtYmVyXVtdO1xyXG4gIG9uU2VsZWN0U2Vuc29yOiAoc2Vuc29yOiBTZW5zb3IpID0+IHZvaWQ7XHJcbiAgaGVpZ2h0Pzogc3RyaW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXZlcnNpbmVNZXRlcnMoYTogTC5MYXRMbmcsIGI6IEwuTGF0TG5nKTogbnVtYmVyIHtcclxuICBjb25zdCBSID0gNjM3MTAwMDtcclxuICBjb25zdCB0b1JhZCA9ICh2OiBudW1iZXIpID0+ICh2ICogTWF0aC5QSSkgLyAxODA7XHJcbiAgY29uc3QgZExhdCA9IHRvUmFkKGIubGF0IC0gYS5sYXQpO1xyXG4gIGNvbnN0IGRMbmcgPSB0b1JhZChiLmxuZyAtIGEubG5nKTtcclxuICBjb25zdCBsYXQxID0gdG9SYWQoYS5sYXQpO1xyXG4gIGNvbnN0IGxhdDIgPSB0b1JhZChiLmxhdCk7XHJcbiAgY29uc3Qgc2luTGF0ID0gTWF0aC5zaW4oZExhdCAvIDIpO1xyXG4gIGNvbnN0IHNpbkxuZyA9IE1hdGguc2luKGRMbmcgLyAyKTtcclxuICBjb25zdCBoID0gc2luTGF0ICogc2luTGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkxuZyAqIHNpbkxuZztcclxuICByZXR1cm4gMiAqIFIgKiBNYXRoLmFzaW4oTWF0aC5zcXJ0KGgpKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUm91dGVQbGFubmVyTWFwKHtcclxuICBzZW5zb3JzLFxyXG4gIHN0YXJ0U2Vuc29yLFxyXG4gIGVuZFNlbnNvcixcclxuICByb3V0ZUxhdExuZ3MsXHJcbiAgb25TZWxlY3RTZW5zb3IsXHJcbiAgaGVpZ2h0ID0gXCI1NjBweFwiLFxyXG59OiBSb3V0ZVBsYW5uZXJNYXBQcm9wcykge1xyXG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgbWFwSW5zdGFuY2VSZWYgPSB1c2VSZWY8TC5NYXAgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBzZW5zb3JMYXllclJlZiA9IHVzZVJlZjxMLkxheWVyR3JvdXAgfCBudWxsPihudWxsKTtcclxuICBjb25zdCByb3V0ZUxheWVyUmVmID0gdXNlUmVmPEwuUG9seWxpbmUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBzdGFydE1hcmtlclJlZiA9IHVzZVJlZjxMLkNpcmNsZU1hcmtlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGVuZE1hcmtlclJlZiA9IHVzZVJlZjxMLkNpcmNsZU1hcmtlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IG1vdmluZ01hcmtlclJlZiA9IHVzZVJlZjxMLkNpcmNsZU1hcmtlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBkYXNoT2Zmc2V0UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIGNvbnN0IGJvdW5kcyA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgaWYgKCFzZW5zb3JzLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBsYXRMbmdzID0gc2Vuc29ycy5tYXAoKHMpID0+IEwubGF0TG5nKHMubGF0LCBzLmxuZykpO1xyXG4gICAgcmV0dXJuIEwubGF0TG5nQm91bmRzKGxhdExuZ3MpLnBhZCgwLjIpO1xyXG4gIH0sIFtzZW5zb3JzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGlmICghc2Vuc29ycy5sZW5ndGggfHwgIWJvdW5kcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IG1hcCA9IEwubWFwKG1hcFJlZi5jdXJyZW50LCB7XHJcbiAgICAgIGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG4gICAgICB6b29tOiAxMixcclxuICAgICAgem9vbUNvbnRyb2w6IGZhbHNlLFxyXG4gICAgICBzY3JvbGxXaGVlbFpvb206IGZhbHNlLFxyXG4gICAgICB0b3VjaFpvb206IGZhbHNlLFxyXG4gICAgICBkb3VibGVDbGlja1pvb206IGZhbHNlLFxyXG4gICAgICBib3hab29tOiBmYWxzZSxcclxuICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxyXG4gICAgICBwcmVmZXJDYW52YXM6IHRydWUsXHJcbiAgICAgIG1pblpvb206IDEyLFxyXG4gICAgICBtYXhab29tOiAxMixcclxuICAgICAgbWF4Qm91bmRzOiBib3VuZHMsXHJcbiAgICAgIG1heEJvdW5kc1Zpc2Nvc2l0eTogMS4wLFxyXG4gICAgfSk7XHJcblxyXG4gICAgTC50aWxlTGF5ZXIoXCJodHRwczovL3tzfS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vZGFya19hbGwve3p9L3t4fS97eX17cn0ucG5nXCIsIHtcclxuICAgICAgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vY2FydG8uY29tL1wiPkNBUlRPPC9hPicsXHJcbiAgICAgIG1heFpvb206IDE5LFxyXG4gICAgfSkuYWRkVG8obWFwKTtcclxuXHJcbiAgICBtYXAuc2V0Vmlldyhib3VuZHMuZ2V0Q2VudGVyKCksIDEyLCB7IGFuaW1hdGU6IGZhbHNlIH0pO1xyXG5cclxuICAgIGNvbnN0IHNlbnNvckxheWVyID0gTC5sYXllckdyb3VwKCk7XHJcbiAgICBzZW5zb3JzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgTC5jaXJjbGVNYXJrZXIoW3MubGF0LCBzLmxuZ10sIHtcclxuICAgICAgICByYWRpdXM6IDMsXHJcbiAgICAgICAgZmlsbENvbG9yOiBcIiM5NGEzYjhcIixcclxuICAgICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuMilcIixcclxuICAgICAgICB3ZWlnaHQ6IDEsXHJcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuNyxcclxuICAgICAgfSlcclxuICAgICAgICAuYmluZFRvb2x0aXAoYFNlbnNvciAke3Muc2Vuc29yX2lkID8/IHMuaWR9YCwgeyBkaXJlY3Rpb246IFwidG9wXCIgfSlcclxuICAgICAgICAuYWRkVG8oc2Vuc29yTGF5ZXIpO1xyXG4gICAgfSk7XHJcbiAgICBzZW5zb3JMYXllci5hZGRUbyhtYXApO1xyXG4gICAgc2Vuc29yTGF5ZXJSZWYuY3VycmVudCA9IHNlbnNvckxheWVyO1xyXG5cclxuICAgIG1hcC5vbihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgIGlmICghc2Vuc29ycy5sZW5ndGgpIHJldHVybjtcclxuICAgICAgY29uc3QgY2xpY2sgPSBMLmxhdExuZyhlLmxhdGxuZy5sYXQsIGUubGF0bG5nLmxuZyk7XHJcbiAgICAgIGxldCBiZXN0OiBTZW5zb3IgfCBudWxsID0gbnVsbDtcclxuICAgICAgbGV0IGJlc3RNZXRlcnMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzZW5zb3JzKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IGhhdmVyc2luZU1ldGVycyhjbGljaywgTC5sYXRMbmcocy5sYXQsIHMubG5nKSk7XHJcbiAgICAgICAgaWYgKGQgPCBiZXN0TWV0ZXJzKSB7XHJcbiAgICAgICAgICBiZXN0TWV0ZXJzID0gZDtcclxuICAgICAgICAgIGJlc3QgPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWJlc3QgfHwgYmVzdE1ldGVycyA+IDE1MDApIHJldHVybjtcclxuICAgICAgb25TZWxlY3RTZW5zb3IoYmVzdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtYXBJbnN0YW5jZVJlZi5jdXJyZW50ID0gbWFwO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50KSBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XHJcbiAgICAgIG1hcC5yZW1vdmUoKTtcclxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH0sIFtzZW5zb3JzLCBib3VuZHMsIG9uU2VsZWN0U2Vuc29yXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBtYXAgPSBtYXBJbnN0YW5jZVJlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFtYXApIHJldHVybjtcclxuXHJcbiAgICBpZiAoc3RhcnRNYXJrZXJSZWYuY3VycmVudCkgc3RhcnRNYXJrZXJSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgIGlmIChlbmRNYXJrZXJSZWYuY3VycmVudCkgZW5kTWFya2VyUmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcblxyXG4gICAgaWYgKHN0YXJ0U2Vuc29yKSB7XHJcbiAgICAgIGNvbnN0IGljb24gPSBMLmRpdkljb24oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJyb3V0ZS1tYXJrZXIgcm91dGUtbWFya2VyLS1zdGFydFwiLFxyXG4gICAgICAgIGh0bWw6IFwiU1wiLFxyXG4gICAgICAgIGljb25TaXplOiBbMjYsIDI2XSxcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTMsIDEzXSxcclxuICAgICAgfSk7XHJcbiAgICAgIHN0YXJ0TWFya2VyUmVmLmN1cnJlbnQgPSBMLm1hcmtlcihbc3RhcnRTZW5zb3IubGF0LCBzdGFydFNlbnNvci5sbmddLCB7IGljb24gfSkuYWRkVG8obWFwKTtcclxuICAgICAgc3RhcnRNYXJrZXJSZWYuY3VycmVudC5iaW5kVG9vbHRpcChcIlN0YXJ0XCIsIHsgZGlyZWN0aW9uOiBcInRvcFwiIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmRTZW5zb3IpIHtcclxuICAgICAgY29uc3QgaWNvbiA9IEwuZGl2SWNvbih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJvdXRlLW1hcmtlciByb3V0ZS1tYXJrZXItLWVuZFwiLFxyXG4gICAgICAgIGh0bWw6IFwiRVwiLFxyXG4gICAgICAgIGljb25TaXplOiBbMjYsIDI2XSxcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTMsIDEzXSxcclxuICAgICAgfSk7XHJcbiAgICAgIGVuZE1hcmtlclJlZi5jdXJyZW50ID0gTC5tYXJrZXIoW2VuZFNlbnNvci5sYXQsIGVuZFNlbnNvci5sbmddLCB7IGljb24gfSkuYWRkVG8obWFwKTtcclxuICAgICAgZW5kTWFya2VyUmVmLmN1cnJlbnQuYmluZFRvb2x0aXAoXCJFbmRcIiwgeyBkaXJlY3Rpb246IFwidG9wXCIgfSk7XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0U2Vuc29yLCBlbmRTZW5zb3JdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IG1hcCA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChyb3V0ZUxheWVyUmVmLmN1cnJlbnQpIHJvdXRlTGF5ZXJSZWYuY3VycmVudC5yZW1vdmUoKTtcclxuICAgIGlmIChtb3ZpbmdNYXJrZXJSZWYuY3VycmVudCkgbW92aW5nTWFya2VyUmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcclxuXHJcbiAgICBpZiAoIXJvdXRlTGF0TG5ncy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBwb2x5ID0gTC5wb2x5bGluZShyb3V0ZUxhdExuZ3MsIHtcclxuICAgICAgY29sb3I6IFwiIzM4YmRmOFwiLFxyXG4gICAgICB3ZWlnaHQ6IDQsXHJcbiAgICAgIG9wYWNpdHk6IDAuOSxcclxuICAgICAgZGFzaEFycmF5OiBcIjggMTBcIixcclxuICAgIH0pLmFkZFRvKG1hcCk7XHJcbiAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQgPSBwb2x5O1xyXG5cclxuICAgIGNvbnN0IHJvdXRlUG9pbnRzID0gcm91dGVMYXRMbmdzLm1hcCgocCkgPT4gTC5sYXRMbmcocFswXSwgcFsxXSkpO1xyXG4gICAgaWYgKHJvdXRlUG9pbnRzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBzZWdMZW5ndGhzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgbGV0IHRvdGFsID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVQb2ludHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XHJcbiAgICAgIGNvbnN0IGQgPSBtYXAuZGlzdGFuY2Uocm91dGVQb2ludHNbaV0sIHJvdXRlUG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgIHNlZ0xlbmd0aHMucHVzaChkKTtcclxuICAgICAgdG90YWwgKz0gZDtcclxuICAgIH1cclxuXHJcbiAgICBtb3ZpbmdNYXJrZXJSZWYuY3VycmVudCA9IEwuY2lyY2xlTWFya2VyKHJvdXRlUG9pbnRzWzBdLCB7XHJcbiAgICAgIHJhZGl1czogNSxcclxuICAgICAgZmlsbENvbG9yOiBcIiNmOGZhZmNcIixcclxuICAgICAgY29sb3I6IFwiIzM4YmRmOFwiLFxyXG4gICAgICB3ZWlnaHQ6IDIsXHJcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxyXG4gICAgfSkuYWRkVG8obWFwKTtcclxuXHJcbiAgICBjb25zdCBzcGVlZE1wcyA9IDU1O1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgY29uc3Qgc3RlcCA9IChub3c6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBlbGFwc2VkID0gKG5vdyAtIHN0YXJ0VGltZSkgLyAxMDAwO1xyXG4gICAgICBjb25zdCBkaXN0ID0gKGVsYXBzZWQgKiBzcGVlZE1wcykgJSB0b3RhbDtcclxuXHJcbiAgICAgIGxldCBhY2MgPSAwO1xyXG4gICAgICBsZXQgaWR4ID0gMDtcclxuICAgICAgd2hpbGUgKGlkeCA8IHNlZ0xlbmd0aHMubGVuZ3RoICYmIGFjYyArIHNlZ0xlbmd0aHNbaWR4XSA8IGRpc3QpIHtcclxuICAgICAgICBhY2MgKz0gc2VnTGVuZ3Roc1tpZHhdO1xyXG4gICAgICAgIGlkeCArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNlZ0Rpc3QgPSBzZWdMZW5ndGhzW01hdGgubWluKGlkeCwgc2VnTGVuZ3Rocy5sZW5ndGggLSAxKV0gfHwgMTtcclxuICAgICAgY29uc3QgdCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIChkaXN0IC0gYWNjKSAvIHNlZ0Rpc3QpKTtcclxuICAgICAgY29uc3QgZnJvbSA9IHJvdXRlUG9pbnRzW01hdGgubWluKGlkeCwgcm91dGVQb2ludHMubGVuZ3RoIC0gMildO1xyXG4gICAgICBjb25zdCB0byA9IHJvdXRlUG9pbnRzW01hdGgubWluKGlkeCArIDEsIHJvdXRlUG9pbnRzLmxlbmd0aCAtIDEpXTtcclxuICAgICAgY29uc3QgbGF0ID0gZnJvbS5sYXQgKyAodG8ubGF0IC0gZnJvbS5sYXQpICogdDtcclxuICAgICAgY29uc3QgbG5nID0gZnJvbS5sbmcgKyAodG8ubG5nIC0gZnJvbS5sbmcpICogdDtcclxuICAgICAgbW92aW5nTWFya2VyUmVmLmN1cnJlbnQ/LnNldExhdExuZyhbbGF0LCBsbmddKTtcclxuXHJcbiAgICAgIGRhc2hPZmZzZXRSZWYuY3VycmVudCA9IChkYXNoT2Zmc2V0UmVmLmN1cnJlbnQgLSAxLjUpICUgMTAwMDtcclxuICAgICAgcG9seS5zZXRTdHlsZSh7IGRhc2hPZmZzZXQ6IGAke2Rhc2hPZmZzZXRSZWYuY3VycmVudH1gIH0pO1xyXG5cclxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG5cclxuICAgIG1hcC5zZXRWaWV3KG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSwgeyBhbmltYXRlOiBmYWxzZSB9KTtcclxuICB9LCBbcm91dGVMYXRMbmdzXSk7XHJcblxyXG4gIHJldHVybiA8ZGl2IHJlZj17bWFwUmVmfSBzdHlsZT17eyBoZWlnaHQsIHdpZHRoOiBcIjEwMCVcIiwgYm9yZGVyUmFkaXVzOiBcInZhcigtLXJhZGl1cylcIiB9fSAvPjtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsIkwiLCJoYXZlcnNpbmVNZXRlcnMiLCJhIiwiYiIsIlIiLCJ0b1JhZCIsInYiLCJNYXRoIiwiUEkiLCJkTGF0IiwibGF0IiwiZExuZyIsImxuZyIsImxhdDEiLCJsYXQyIiwic2luTGF0Iiwic2luIiwic2luTG5nIiwiaCIsImNvcyIsImFzaW4iLCJzcXJ0IiwiUm91dGVQbGFubmVyTWFwIiwic2Vuc29ycyIsInN0YXJ0U2Vuc29yIiwiZW5kU2Vuc29yIiwicm91dGVMYXRMbmdzIiwib25TZWxlY3RTZW5zb3IiLCJoZWlnaHQiLCJtYXBSZWYiLCJtYXBJbnN0YW5jZVJlZiIsInNlbnNvckxheWVyUmVmIiwicm91dGVMYXllclJlZiIsInN0YXJ0TWFya2VyUmVmIiwiZW5kTWFya2VyUmVmIiwibW92aW5nTWFya2VyUmVmIiwiYW5pbWF0aW9uUmVmIiwiZGFzaE9mZnNldFJlZiIsImJvdW5kcyIsImxlbmd0aCIsImxhdExuZ3MiLCJtYXAiLCJzIiwibGF0TG5nIiwibGF0TG5nQm91bmRzIiwicGFkIiwiY3VycmVudCIsImNlbnRlciIsImdldENlbnRlciIsInpvb20iLCJ6b29tQ29udHJvbCIsInNjcm9sbFdoZWVsWm9vbSIsInRvdWNoWm9vbSIsImRvdWJsZUNsaWNrWm9vbSIsImJveFpvb20iLCJrZXlib2FyZCIsInByZWZlckNhbnZhcyIsIm1pblpvb20iLCJtYXhab29tIiwibWF4Qm91bmRzIiwibWF4Qm91bmRzVmlzY29zaXR5IiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJhZGRUbyIsInNldFZpZXciLCJhbmltYXRlIiwic2Vuc29yTGF5ZXIiLCJsYXllckdyb3VwIiwiZm9yRWFjaCIsImNpcmNsZU1hcmtlciIsInJhZGl1cyIsImZpbGxDb2xvciIsImNvbG9yIiwid2VpZ2h0IiwiZmlsbE9wYWNpdHkiLCJiaW5kVG9vbHRpcCIsInNlbnNvcl9pZCIsImlkIiwiZGlyZWN0aW9uIiwib24iLCJlIiwiY2xpY2siLCJsYXRsbmciLCJiZXN0IiwiYmVzdE1ldGVycyIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlIiwiaWNvbiIsImRpdkljb24iLCJjbGFzc05hbWUiLCJodG1sIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwibWFya2VyIiwicG9seSIsInBvbHlsaW5lIiwib3BhY2l0eSIsImRhc2hBcnJheSIsInJvdXRlUG9pbnRzIiwicCIsInNlZ0xlbmd0aHMiLCJ0b3RhbCIsImkiLCJkaXN0YW5jZSIsInB1c2giLCJzcGVlZE1wcyIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93Iiwic3RlcCIsImVsYXBzZWQiLCJkaXN0IiwiYWNjIiwiaWR4Iiwic2VnRGlzdCIsIm1pbiIsInQiLCJtYXgiLCJmcm9tIiwidG8iLCJzZXRMYXRMbmciLCJzZXRTdHlsZSIsImRhc2hPZmZzZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnZXRab29tIiwiZGl2IiwicmVmIiwic3R5bGUiLCJ3aWR0aCIsImJvcmRlclJhZGl1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/route-planner-map.tsx\n"));

/***/ })

});